<html>
<head>
<title> Types, Values, and Variables</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="lexical.doc.html">Prev</a> | <a href="conversions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="44329"></a>
<p><strong>
CHAPTER
 4 </strong></p>
<a name="48440"></a>
<h1>Types, Values, and Variables</h1>
<hr><p>
<a name="97679"></a>
The Java programming language is a <em>strongly typed</em> language, which means that every variable and every expression has a type that is known at compile time. Types limit the values that a variable <a href="typesValues.doc.html#18470">(&#167;4.5)</a> can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations. Strong typing helps detect errors at compile time.<p>
<a name="50743"></a>
The types of the Java programming language are divided into two categories: primitive types and reference types. The primitive types <a href="typesValues.doc.html#85587">(&#167;4.2)</a> are the <code>boolean</code> type and the numeric types. The numeric types are the integral types <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>char</code>, and the floating-point types <code>float</code> and <code>double</code>. The reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a> are class types, interface types, and array types. There is also a special null type. An object <a href="typesValues.doc.html#12028">(&#167;4.3.1)</a> is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class <code>Object</code> <a href="typesValues.doc.html#11055">(&#167;4.3.2)</a>. String literals are represented by <code>String</code> objects <a href="typesValues.doc.html#26992">(&#167;4.3.3)</a>.<p>
<a name="50838"></a>
Names of types are used <a href="typesValues.doc.html#25948">(&#167;4.4)</a> in declarations, casts, class instance creation expressions, array creation expressions, class literals, and <code>instanceof</code> operator expressions. <p>
<a name="50800"></a>
A variable <a href="typesValues.doc.html#18470">(&#167;4.5)</a> is a storage location. A variable of a primitive type always holds a value of that exact type. A variable of a class type <i>T</i> can hold a null reference or a reference to an instance of class <i>T</i> or of any class that is a subclass of <i>T</i>. A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface. If <i>T</i> is a primitive type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>T</i>"; if <i>T</i> is a reference type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>S</i>" such that type <i>S</i> is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to type <i>T</i>. A variable of type <code>Object</code> can hold a null reference or a reference to any object, whether class interface or array.<p>
<a name="11128"></a>
<h2>4.1    The Kinds of Types and Values</h2>
<a name="10737"></a>
There are two kinds of <em>types</em> in the Java programming language: primitive types <a href="typesValues.doc.html#85587">(&#167;4.2)</a> and reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a>. There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values <a href="typesValues.doc.html#85587">(&#167;4.2)</a> and reference values <a href="typesValues.doc.html#9317">(&#167;4.3)</a>.<p>
<ul><pre>
<i>Type:
<code>	</code>PrimitiveType
	ReferenceType
</i></pre></ul><a name="23953"></a>
There is also a special <em>null type</em>, the type of the expression <code>null</code>, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the programmer can ignore the null type and just pretend that <code>null</code> is merely a special literal that can be of any reference type.<p>
<a name="85587"></a>
<h2>4.2    Primitive Types and Values</h2>
<a name="9122"></a>
A <em>primitive type</em> is predefined by the Java programming language and named by its reserved keyword <a href="lexical.doc.html#229308">(&#167;3.9)</a>:<p>
<ul><pre>
<i>PrimitiveType:
	NumericType
</i>	<code>boolean
</code>
<i>NumericType:
	IntegralType
	FloatingPointType

IntegralType: one of</i>
	<code>byte short int long char
</code>
<i>FloatingPointType: one of</i>
<code>	float double
</code></pre></ul><a name="50919"></a>
Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that same type. The value of a variable of primitive type can be changed only by assignment operations on that variable.<p>
<a name="9137"></a>
The <em>numeric types</em> are the integral types and the floating-point types. <p>
<a name="88061"></a>
The <em>integral types</em> are <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and <code>char</code>, whose values are 16-bit unsigned integers representing Unicode characters.<p>
<a name="88062"></a>
The <em>floating-point types</em> are <code>float</code>, whose values include the 32-bit IEEE 754 floating-point numbers, and <code>double</code>, whose values include the 64-bit IEEE 754 floating-point numbers.<p>
<a name="50913"></a>
The <code>boolean</code> type has exactly two values: <code>true</code> and <code>false.</code><p>
<a name="9151"></a>
<h3>4.2.1    Integral Types and Values</h3>
<a name="50950"></a>
The values of the integral types are integers in the following ranges:<p>
<ul><a name="9163"></a>
<li>For <code>byte</code>, from -128 to 127, inclusive
<a name="9164"></a>
<li>For <code>short</code>, from -32768 to 32767, inclusive
<a name="9165"></a>
<li>For <code>int</code>, from -2147483648 to 2147483647, inclusive
<a name="9166"></a>
<li>For <code>long</code>, from -9223372036854775808 to 9223372036854775807, inclusive
<a name="51034"></a>
<li>For <code>char</code>, from <code>'\u0000'</code> to <code>'\uffff'</code> inclusive, that is, from 0 to 65535
</ul><a name="51035"></a>
<h3>4.2.2    Integer Operations</h3>
<a name="29775"></a>
The Java programming language provides a number of operators that act on integral values:<p>
<ul><a name="10358"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="9181"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>
<a name="17601"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="10365"></a>
<li>The numerical operators, which result in a value of type <code>int</code> or <code>long</code>:
<ul>
<a name="18334"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.doc.html#24924">&#167;15.15.3</a>, <a href="expressions.doc.html#236345">&#167;15.15.4</a>)
<a name="17539"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.doc.html#239829">(&#167;15.17)</a>
<a name="19482"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.doc.html#13510">(&#167;15.18.2)</a>
<a name="24026"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.doc.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.doc.html#39438">(&#167;15.14.1)</a>
<a name="24036"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.doc.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.doc.html#4987">(&#167;15.14.2)</a>
<a name="19496"></a>
<li>The signed and unsigned shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> <a href="expressions.doc.html#5121">(&#167;15.19)</a>
<a name="51061"></a>
<li>The bitwise complement operator <code>~</code> <a href="expressions.doc.html#5017">(&#167;15.15.5)</a>
<a name="17770"></a>
<li>The integer bitwise operators <code>&amp;</code>, <code>|</code>, and <code>^</code> <a href="expressions.doc.html#5233">(&#167;15.22.1)</a>
</ul>
<a name="19469"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="18373"></a>
<li>The cast operator, which can convert from an integral value to a value of any specified numeric type (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="17774"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and an integral operand, will convert the integral operand to a <code>String</code> representing its value in decimal form, and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="51025"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, and <code>Character</code>.<p>
<a name="28057"></a>
If an integer operator other than a shift operator has at least one operand of type <code>long</code>, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type <code>long</code>. If the other operand is not <code>long</code>, it is first widened <a href="conversions.doc.html#25215">(&#167;5.1.4)</a> to type <code>long</code> by numeric promotion <a href="conversions.doc.html#26917">(&#167;5.6)</a>. Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type <code>int</code>. If either operand is not an <code>int</code>, it is first widened to type <code>int</code> by numeric promotion.<p>
<a name="9194"></a>
The built-in integer operators do not indicate overflow or underflow in any way. The only numeric operators that can throw an exception <a href="exceptions.doc.html#44043">(&#167;11)</a> are the integer divide operator <code>/</code> <a href="expressions.doc.html#5047">(&#167;15.17.2)</a> and the integer remainder operator <code>%</code> <a href="expressions.doc.html#24956">(&#167;15.17.3)</a>, which throw an <code>ArithmeticException</code> if the right-hand operand is zero. <p>
<a name="86654"></a>
The example:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int i = 1000000;
		System.out.println(i * i);
		long l = i;
		System.out.println(l * l);
		System.out.println(20296 / (l - i));
	}
}
</pre></blockquote><a name="51131"></a>
produces the output:<p>
<blockquote><pre>-727379968
1000000000000
</pre></blockquote><a name="51199"></a>
and then encounters an <code>ArithmeticException</code> in the division by <code>l</code> <code>-</code> <code>i</code>, because <code>l</code> <code>-</code> <code>i</code> is zero. The first multiplication is performed in 32-bit precision, whereas the second multiplication is a <code>long</code> multiplication. The value <code>-727379968</code> is the decimal value of the low 32 bits of the mathematical result, <code>1000000000000</code>, which is a value too large for type <code>int</code>.<p>
<a name="51203"></a>
Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type <code>boolean</code>.<p>
<a name="9208"></a>
<h3>4.2.3    Floating-Point Types, Formats, and Values</h3>
<a name="87606"></a>
The floating-point types are <code>float</code> and <code>double</code>, which are conceptually associated with the single-precision 32-bit and double-precision 64-bit format IEEE 754 values and operations as specified in <em>IEEE Standard for Binary Floating-Point Arithmetic</em>, ANSI/IEEE Standard 754-1985 (IEEE, New York).<p>
<a name="88071"></a>
The IEEE 754 standard includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative <em>infinities</em>, and special <em>Not-a-Number </em>values (hereafter abbreviated NaN). A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero. NaN constants of both <code>float</code> and <code>double</code> type are predefined as <code>Float.NaN</code> and <code>Double.NaN</code>.<p>
<a name="96776"></a>
Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the <em>float value set</em> and the <em>double value set</em>. In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point value sets, called the<em> float-extended-exponent value set</em> and the<em> double-extended-exponent value set</em>. These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of expressions of type <code>float</code> or <code>double</code> (<a href="conversions.doc.html#184225">&#167;5.1.8</a>, <a href="expressions.doc.html#249198">&#167;15.4</a>).<p>
<a name="96777"></a>
The finite nonzero values of any floating-point value set can all be expressed in the form <img src="typesValues.doc.anc.gif">, where <em>s</em> is +1 or -1, <em>m</em> is a positive integer less than <img src="typesValues.doc.anc1.gif">, and <em>e</em> is an integer between <img src="typesValues.doc.anc2.gif"> and <img src="typesValues.doc.anc3.gif">, inclusive, and where <em>N</em> and <em>K</em> are parameters that depend on the value set. Some values can be represented in this form in more than one way; for example, supposing that a value <em>v</em> in a value set might be represented in this form using certain values for <em>s</em>, <em>m</em>, and <em>e</em>, then if it happened that <em>m</em> were even and <em>e</em> were less than <img src="typesValues.doc.anc4.gif">, one could halve <em>m</em> and increase <em>e</em> by 1 to produce a second representation for the same value <em>v</em>. A representation in this form is called <em>normalized</em> if <img src="typesValues.doc.anc5.gif">; otherwise the representation is said to be <em>denormalized</em>. If a value in a value set cannot be represented in such a way that <img src="typesValues.doc.anc7.gif">, then the value is said to be a <em>denormalized value</em>, because it has no normalized representation.<p>
<a name="96680"></a>
The constraints on the parameters <em>N</em> and <em>K</em> (and on the derived parameters <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>) for the two required and two optional floating-point value sets are summarized in <a href="typesValues.doc.html#96802">Table 4.1</a>. 
<p>
<Table Border="3">
<caption><a name="96802"></a>
<i>Floating-point value set parameters</i>
</caption>
<tr><th><a name="96683"></a>
<b> Parameter</b>
<th><a name="96685"></a>
<strong>float</strong>
<th><a name="96687"></a>
<strong>float-extended-exponent</strong>
<th><a name="96689"></a>
<b> double</b>
<th><a name="96691"></a>
<b> double-extended-exponent<b>

<tr><td><a name="96693"></a>
 N<p>
<td><a name="96695"></a>
 24<p>
<td><a name="96697"></a>
 24<p>
<td><a name="96699"></a>
 53<p>
<td><a name="96701"></a>
 53<p>

<tr><td><a name="96703"></a>
 K<p>
<td><a name="96705"></a>
 8<p>
<td><a name="96707"></a>
 <img src="chars/gtequal.gif"> 11<p>
<td><a name="96709"></a>
 11<p>
<td><a name="96711"></a>
 <img src="chars/gtequal.gif"> 15<p>

<tr><td><a name="96713"></a>
 E<sub><i>max</i></sub><p>
<td><a name="96715"></a>
 +127<p>
<td><a name="96717"></a>
 <img src="chars/gtequal.gif"> +1023<p>
<td><a name="96719"></a>
 +1023<p>
<td><a name="96721"></a>
 <img src="chars/gtequal.gif"> +16383<p>

<tr><td><a name="96723"></a>
 E<sub><i>min</i></sub><p>
<td><a name="96725"></a>
 -126<p>
<td><a name="96727"></a>
 <img src="chars/lt_equal.gif"> -1022<p>
<td><a name="96729"></a>
 -1022<p>
<td><a name="96731"></a>
<img src="chars/lt_equal.gif"> -16382<p>


</Table>

<Table>
<tr><td>
</Table>
<p>
<a name="106189"></a>
Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant <em>K</em>, whose value is constrained by <a href="typesValues.doc.html#96802">Table 4.1</a>; this value <em>K</em> in turn dictates the values for <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>.<p>
<a name="96735"></a>
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.<p>
<a name="96736"></a>
Note that the constraints in <a href="typesValues.doc.html#96802">Table 4.1</a> are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set. Likewise, each element of the double value set is necessarily also an element of the double-extended-exponent value set. Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.<p>
<a name="96737"></a>
The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard. The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard. Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do <em>not</em> correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.<p>
<a name="96744"></a>
The float, float-extended-exponent, double, and double-extended-exponent value sets are not types. It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value of type <code>float</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the float-extended-exponent value set instead. Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type <code>double</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the double-extended-exponent value set instead.<p>
<a name="106159"></a>
Except for NaN, floating-point values are <em>ordered</em>; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.<p>
<a name="106160"></a>
IEEE 754 allows multiple distinct NaN values for each of its single and double floating-point formats. While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information. <p>
<a name="106258"></a>
For the most part, the Java platform treats NaN values of a given type as though collapsed into a single canonical value (and hence this specification normally refers to an arbitrary NaN as though to a canonical value). However, version 1.3 the Java platform introduced methods enabling the programmer to distinguish between NaN values: the <code>Float.floatToRawIntBits</code> and <code>Double.doubleToRawLongBits</code> methods. The interested reader is referred to the specifications for the <code>Float</code> and <code>Double</code> classes for more information.<p>
<a name="86666"></a>
Positive zero and negative zero compare equal; thus the result of the expression <code>0.0==-0.0</code> is <code>true</code> and the result of <code>0.0&gt;-0.0</code> is <code>false</code>. But other operations can distinguish positive and negative zero; for example, <code>1.0/0.0</code> has the value positive infinity, while the value of <code>1.0/-0.0</code> is negative infinity.<p>
<a name="16083"></a>
NaN is <em>unordered</em>, so the numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> return <code>false</code> if either or both operands are NaN <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>. The equality operator <code>==</code> returns <code>false</code> if either operand is NaN, and the inequality operator <code>!=</code> returns <code>true</code> if either operand is NaN <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>. In particular, <code>x!=x</code> is <code>true</code> if and only if <code>x</code> is NaN, and <code>(x&lt;y)</code> <code>==</code> <code>!(x&gt;=y)</code> will be <code>false</code> if <code>x</code> or <code>y</code> is NaN.<p>
<a name="16093"></a>
Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type <code>boolean</code>.<p>
<a name="9249"></a>
<h3>4.2.4    Floating-Point Operations</h3>
<a name="9981"></a>
The Java programming language provides a number of operators that act on floating-point values:<p>
<ul><a name="52058"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="52062"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.doc.html#153654">(&#167;15.20.1)</a>
<a name="52066"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="52069"></a>
<li>The numerical operators, which result in a value of type <code>float</code> or <code>double</code>:
<ul>
<a name="52076"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.doc.html#24924">&#167;15.15.3</a>, <a href="expressions.doc.html#236345">&#167;15.15.4</a>)
<a name="24115"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.doc.html#239829">(&#167;15.17)</a>
<a name="24119"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.doc.html#13510">(&#167;15.18.2)</a>
<a name="24126"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.doc.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.doc.html#39438">(&#167;15.14.1)</a>
<a name="24107"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.doc.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.doc.html#4987">(&#167;15.14.2)</a>
</ul>
<a name="19446"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="11998"></a>
<li>The cast operator, which can convert from a floating-point value to a value of any specified numeric type (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="21842"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a floating-point operand, will convert the floating-point operand to a <code>String</code> representing its value in decimal form (without information loss), and then produce a newly created <code>String</code> by concatenating the two strings
</ul><a name="12009"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Float</code>, <code>Double</code>, and <code>Math</code>.<p>
<a name="12005"></a>
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.<p>
<a name="51262"></a>
If at least one of the operands to a numerical operator is of type <code>double</code>, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>double</code>. (If the other operand is not a <code>double</code>, it is first widened to type <code>double</code> by numeric promotion <a href="conversions.doc.html#26917">(&#167;5.6)</a>.) Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>float. </code>If the other operand is not a <code>float</code>, it is first widened to type <code>float</code> by numeric promotion.<p>
<a name="9265"></a>
Operators on floating-point numbers behave as specified by IEEE 754 (with the exception of the remainder operator <a href="expressions.doc.html#24956">(&#167;15.17.3)</a>). In particular, the Java programming language requires support of IEEE 754 <em>denormalized</em> floating-point numbers and <em>gradual underflow</em>, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations do not "flush to zero" if the calculated result is a denormalized number.<p>
<a name="9274"></a>
The Java programming language requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. <em>Inexact</em> results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as <em>round to nearest</em>.<p>
<a name="10346"></a>
The language uses <em>round toward zero</em> when converting a floating value to an integer <a href="conversions.doc.html#25363">(&#167;5.1.3)</a>, which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.<p>
<a name="9290"></a>
Floating-point operators produce no exceptions <a href="exceptions.doc.html#44043">(&#167;11)</a>. An operation that overflows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. As has already been described, NaN is unordered, so a numeric comparison operation involving one or two NaNs returns <code>false</code> and any <code>!=</code> comparison involving NaN returns <code>true</code>, including <code>x!=x</code> when <code>x</code> is NaN.<p>
<a name="9291"></a>
The example program:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		// An example of overflow:
		double d = 1e308;
		System.out.print("overflow produces infinity: ");
		System.out.println(d + "*10==" + d*10);
		// An example of gradual underflow:
		d = 1e-305 * Math.PI;
		System.out.print("gradual underflow: " + d + "\n &#32; &#32; &#32;");
		for (int i = 0; i &lt; 4; i++)
			System.out.print(" " + (d /= 100000));
		System.out.println();
		// An example of NaN:
		System.out.print("0.0/0.0 is Not-a-Number: ");
		d = 0.0/0.0;
		System.out.println(d);
		// An example of inexact results and rounding:
		System.out.print("inexact results with float:");
		for (int i = 0; i &lt; 100; i++) {
			float z = 1.0f / i;
			if (z * i != 1.0f)
				System.out.print(" " + i);
		}
		System.out.println();
		// Another example of inexact results and rounding:
		System.out.print("inexact results with double:");
		for (int i = 0; i &lt; 100; i++) {
			double z = 1.0 / i;
			if (z * i != 1.0)
				System.out.print(" " + i);
		}
		System.out.println();
		// An example of cast to integer rounding:
		System.out.print("cast to int rounds toward 0: ");
		d = 12345.6;
		System.out.println((int)d + " " + (int)(-d));
	}
}
</pre></blockquote><a name="23297"></a>
produces the output:<p>
<blockquote><pre>overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305
	3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345
</pre></blockquote>
<a name="22309"></a>
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.
<a name="11717"></a>
The results when <code>i</code> is <code>0</code> involve division by zero, so that <code>z</code> becomes positive infinity, and <code>z</code> <code>*</code> <code>0</code> is NaN, which is not equal to <code>1.0</code>.
</pre></blockquote><a name="11527"></a>
<h3>4.2.5    The <code>boolean</code> Type and <code>boolean</code> Values</h3>
<a name="9295"></a>
The <code>boolean</code> type represents a logical quantity with two possible values, indicated by the literals <code>true</code> and <code>false</code> <a href="lexical.doc.html#49652">(&#167;3.10.3)</a>. The boolean operators are:<p>
<ul><a name="17733"></a>
<li>The relational operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#54508">(&#167;15.21.2)</a>
<a name="17734"></a>
<li>The logical-complement operator <code>!</code> <a href="expressions.doc.html#13350">(&#167;15.15.6)</a>
<a name="17736"></a>
<li>The logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> <a href="expressions.doc.html#5242">(&#167;15.22.2)</a>
<a name="17737"></a>
<li>The conditional-and and conditional-or operators <code>&amp;&amp;</code> <a href="expressions.doc.html#5247">(&#167;15.23)</a> and <code>||</code> <a href="expressions.doc.html#54532">(&#167;15.24)</a>
<a name="19467"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>
<a name="21871"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a boolean operand, will convert the boolean operand to a <code>String</code> (either <code>"true"</code> or <code>"false"</code>), and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="17738"></a>
Boolean expressions determine the control flow in several kinds of statements:<p>
<ul><a name="17742"></a>
<li>The <code>if</code> statement <a href="statements.doc.html#5991">(&#167;14.9)</a>
<a name="17743"></a>
<li>The <code>while</code> statement <a href="statements.doc.html#237277">(&#167;14.11)</a>
<a name="17745"></a>
<li>The <code>do</code> statement <a href="statements.doc.html#6045">(&#167;14.12)</a>
<a name="17747"></a>
<li>The <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>
</ul><a name="48454"></a>
A <code>boolean</code> expression also determines which subexpression is evaluated in the conditional <code>?&#32;:</code> operator <a href="expressions.doc.html#290293">(&#167;15.25)</a>.<p>
<a name="48458"></a>
Only <code>boolean</code> expressions can be used in control flow statements and as the first operand of the conditional operator <code>?&#32;:</code>. An integer <code>x</code> can be converted to a <code>boolean</code>, following the C language convention that any nonzero value is <code>true</code>, by the expression <code>x!=0</code>. An object reference <code>obj</code> can be converted to a <code>boolean</code>, following &#32;the C language convention that any reference other than <code>null</code> is <code>true</code>, by the expression <code>obj!=null</code>.<p>
<a name="9299"></a>
A cast of a <code>boolean</code> value to type <code>boolean</code> is allowed <a href="conversions.doc.html#25209">(&#167;5.1.1)</a>; no other casts on type <code>boolean</code> are allowed. A <code>boolean</code> can be converted to a string by string conversion <a href="conversions.doc.html#186035">(&#167;5.4)</a>.<p>
<a name="9317"></a>
<h2>4.3    Reference Types and Values</h2>
<a name="9664"></a>
There are three kinds of <em>reference types</em>: class types <a href="classes.doc.html#3857">(&#167;8)</a>, interface types <a href="interfaces.doc.html#238678">(&#167;9)</a>, and array types <a href="arrays.doc.html#27803">(&#167;10)</a>.<p>
<ul><pre>
<i>ReferenceType:
	ClassOrInterfaceType
	ArrayType

ClassOrInterfaceType:
	ClassType
	InterfaceType

ClassType:
	TypeName

InterfaceType:
	TypeName

ArrayType:
	Type<code> [ ]
	</i>
</code></pre></ul><a name="9678"></a>
Names are described in <a href="names.doc.html#48086">&#167;6</a>; type names in <a href="names.doc.html#106941">&#167;6.5</a> and, specifically, <a href="names.doc.html#73064">&#167;6.5.5</a>.<p>
<a name="87599"></a>
The sample code:
<blockquote><pre>class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
</pre></blockquote><a name="11032"></a>
declares a class type <code>Point</code>, an interface type <code>Move</code>, and uses an array type <code>int[]</code> (an array of <code>int</code>) to declare the field <code>metrics</code> of the class <code>Point</code>.<p>
<a name="12028"></a>
<h3>4.3.1    Objects</h3>
<a name="86707"></a>
An <em>object</em> is a <em>class</em> <em>instance</em> or an array.<p>
<a name="106237"></a>
The reference values (often just <em>references</em>) are <em>pointers </em>to these objects, and a special null reference, which refers to no object.<p>
<a name="49853"></a>
A class instance is explicitly created by a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>. An array is explicitly created by an array creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="49899"></a>
A new class instance is implicitly created when the string concatenation operator + <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> is used in an expression, resulting in a new object of type <code>String</code> (<a href="typesValues.doc.html#26992">&#167;4.3.3</a>). A new array object is implicitly created when an array initializer expression <a href="arrays.doc.html#11358">(&#167;10.6)</a> is evaluated; this can occur when a class or interface is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>, when a new instance of a class is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>, or when a local variable declaration statement is executed <a href="statements.doc.html#5920">(&#167;14.4)</a>.<p>
<a name="49960"></a>
Many of these cases are illustrated in the following example:
<blockquote><pre>class Point {
	int x, y;
	Point() { System.out.println("default"); }
	Point(int x, int y) { this.x = x; this.y = y; }
	// A Point instance is explicitly created at class initialization time:
	static Point origin = new Point(0,0);
	// A String can be implicitly created by a + operator:
	public String toString() {
		return "(" + x + "," + y + ")";
	}
}
class Test {
	public static void main(String[] args) {
		// A Point is explicitly created using newInstance:
		Point p = null;
		try {
			p = (Point)Class.forName("Point").newInstance();
		} catch (Exception e) {
			System.out.println(e);
		}
		// An array is implicitly created by an array constructor:
		Point a[] = { new Point(0,0), new Point(1,1) };
		// Strings are implicitly created by + operators:
		System.out.println("p: " + p);
		System.out.println("a: { " + a[0] + ", "
										  &#32;+ a[1] + " }");
		// An array is explicitly created by an array creation expression:
		String sa[] = new String[2];
		sa[0] = "he"; sa[1] = "llo";
		System.out.println(sa[0] + sa[1]);
	}
}
</pre></blockquote><a name="87328"></a>
which produces the output:<p>
<blockquote><pre>default
p: (0,0)
a: { (0,0), (1,1) }
hello
</pre></blockquote><a name="49965"></a>
The operators on references to objects are:<p>
<ul><a name="31321"></a>
<li>Field access, using either a qualified name <a href="names.doc.html#104285">(&#167;6.6)</a> or a field access expression <a href="expressions.doc.html#41267">(&#167;15.11)</a>
<a name="31328"></a>
<li>Method invocation <a href="expressions.doc.html#20448">(&#167;15.12)</a>
<a name="31378"></a>
<li>The cast operator (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>)
<a name="31345"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a reference, will convert the reference to a <code>String</code> by invoking the <code>toString</code> method of the referenced object (using <code>"null"</code> if either the reference or the result of <code>toString</code> is a null reference), and then will produce a newly created <code>String</code> that is the concatenation of the two strings
<a name="31399"></a>
<li>The <code>instanceof</code> operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>
<a name="31306"></a>
<li>The reference equality operators <code>==</code> and <code>!=</code> <a href="expressions.doc.html#236163">(&#167;15.21.3)</a>
<a name="19595"></a>
<li>The conditional operator <code>?&#32;:</code> <a href="expressions.doc.html#290293">(&#167;15.25)</a>.
</ul><a name="28239"></a>
There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.<p>
<a name="87600"></a>
The example program:
<blockquote><pre>class Value { int val; }
class Test {
	public static void main(String[] args) {
		int i1 = 3;
		int i2 = i1;
		i2 = 4;
		System.out.print("i1==" + i1);
		System.out.println(" but i2==" + i2);
		Value v1 = new Value();
		v1.val = 5;
		Value v2 = v1;
		v2.val = 6;
		System.out.print("v1.val==" + v1.val);
		System.out.println(" and v2.val==" + v2.val);
	}
}
</pre></blockquote><a name="11050"></a>
produces the output:<p>
<blockquote><pre>i1==3 but i2==4
v1.val==6 and v2.val==6
</pre></blockquote><a name="11053"></a>
because <code>v1.val</code> and <code>v2.val</code> reference the same instance variable <a href="typesValues.doc.html#28536">(&#167;4.5.3)</a> in the one <code>Value</code> object created by the only <code>new</code> expression, while <code>i1</code> and <code>i2</code> are different variables.<p>
<a name="17783"></a>
See <a href="arrays.doc.html#27803">&#167;10</a> and <a href="expressions.doc.html#46168">&#167;15.10</a> for examples of the creation and use of arrays.
<a name="17053"></a>
Each object has an associated lock <a href="memory.doc.html#28460">(&#167;17.13)</a>, which is used by <code>synchronized</code> methods <a href="classes.doc.html#78188">(&#167;8.4.3)</a> and the <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a> to provide control over concurrent access to state by multiple threads (<a href="memory.doc.html#28457">&#167;17.12</a>).<p>
<a name="11055"></a>
<h3>4.3.2    The Class Object</h3>
<a name="26999"></a>
The class <code>Object</code> is a superclass <a href="classes.doc.html#15372">(&#167;8.1)</a> of all other classes. A variable of type <code>Object</code> can hold a reference to any object, whether it is an instance of a class or an array <a href="arrays.doc.html#27803">(&#167;10)</a>. All class and array types inherit the methods of class <code>Object</code>, which are summarized here:<p>
<blockquote><pre>package java.lang;
<a name="45609"></a>
public class Object {
<a name="51634"></a>	public final Class getClass() { . . . }
<a name="51635"></a>	public String toString() { . . . }
<a name="51636"></a>	public boolean equals(Object obj) { . . . }
<a name="51637"></a>	public int hashCode() { . . . }
<a name="51638"></a>	protected Object clone()
<a name="86088"></a>		throws CloneNotSupportedException { . . . }
<a name="87378"></a>	public final void wait()
		throws IllegalMonitorStateException,
			InterruptedException { . . . }
<a name="51641"></a>	public final void wait(long millis)
<a name="87381"></a>		throws IllegalMonitorStateException,
<a name="87383"></a>			InterruptedException { . . . }
<a name="51642"></a>	public final void wait(long millis, int nanos) { . . . }
<a name="87385"></a>		throws IllegalMonitorStateException,
<a name="87386"></a>			InterruptedException { . . . }
<a name="87373"></a>	public final void notify() { . . . }
<a name="87374"></a>		throws IllegalMonitorStateException
<a name="87387"></a>	public final void notifyAll() { . . . }
<a name="87389"></a>		throws IllegalMonitorStateException
<a name="51644"></a>	protected void finalize()
<a name="86090"></a>		throws Throwable { . . . }
<a name="51645"></a>}
</pre></blockquote><a name="45610"></a>
The members of <code>Object</code> are as follows:<p>
<ul><a name="12048"></a>
<li>The method <code>getClass</code> returns the <code>Class</code> object that represents the class of the object. A <code>Class</code> object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements. A class method that is declared <code>synchronized</code> <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a> synchronizes on the lock associated with the <code>Class</code> object of the class.
<a name="12066"></a>
<li>The method <code>toString</code> returns a <code>String</code> representation of the object.
<a name="12104"></a>
<li>The methods <code>equals</code> and <code>hashCode</code> are very useful in hashtables such as <code>java.util.Hashtable</code>. The method <code>equals</code> defines a notion of object equality, which is based on value, not reference, comparison.
<a name="12115"></a>
<li>The method <code>clone</code> is used to make a duplicate of an object.
<a name="12116"></a>
<li>The methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> are used in concurrent programming using threads, as described in <a href="memory.doc.html#26250">&#167;17</a>.
<a name="12117"></a>
<li>The method <code>finalize</code> is run just before an object is destroyed and is described in <a href="execution.doc.html#44748">&#167;12.6</a>.
</ul><a name="26992"></a>
<h3>4.3.3    The Class String</h3>
<a name="27000"></a>
Instances of class <code>String</code> represent sequences of Unicode characters. A &#32;<code>String</code> object has a constant (unchanging) value. String literals <a href="lexical.doc.html#101083">(&#167;3.10.5)</a> are references to instances of class <code>String</code>.<p>
<a name="52188"></a>
The string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> implicitly creates a new <code>String</code> object.<p>
<a name="97058"></a>
<h3>4.3.4    When Reference Types Are the Same</h3>
<a name="96897"></a>
Two reference types are the <em>same compile-time type</em> if they have the same binary name <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>, in which case they are sometimes said to be the <em>same class</em> or the <em>same interface</em>.<p>
<a name="97070"></a>
At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders. These types may or may not represent the same type declaration. Even if two such types do represent the same type declaration, they are considered distinct.<p>
<a name="96917"></a>
Two reference types are the <em>same run-time type</em> if:<p>
<ul><a name="86567"></a>
<li>They are both class or both interface types, are loaded by the same class loader, and have the same binary name <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>, in which case they are sometimes said to be the <em>same run-time class</em> or the <em>same run-time interface</em>.
<a name="86576"></a>
<li>They are both array types, and their component types are the same run-time type<a href="arrays.doc.html#27803">(&#167;10)</a>.
</ul><a name="25948"></a>
<h2>4.4    Where Types Are Used</h2>
<a name="52309"></a>
Types are used when they appear in declarations or in certain expressions.<p>
<a name="85893"></a>
The following code fragment contains one or more instances of most kinds of usage of a type:
<blockquote><pre>import java.util.Random;
class MiscMath {
	int divisor;
	MiscMath(int divisor) {
		this.divisor = divisor;
	}
	float ratio(long l) {
		try {
			l /= divisor;
		} catch (Exception e) {
			if (e instanceof ArithmeticException)
				l = Long.MAX_VALUE;
			else
				l = 0;
		}
		return (float)l;
	}
	double gausser() {
		Random r = new Random();
		double[] val = new double[2];
		val[0] = r.nextGaussian();
		val[1] = r.nextGaussian();
		return (val[0] + val[1]) / 2;
	}
}
</pre></blockquote><a name="53860"></a>
In this example, types are used in declarations of the following:<p>
<ul><a name="53864"></a>
<li>Imported types <a href="packages.doc.html#70209">(&#167;7.5)</a>; here the type <code>Random</code>, imported from the type<code> java.util.Random</code> of the package <code>java.util</code>, is declared
<a name="49983"></a>
<li>Fields, which are the class variables and instance variables of classes <a href="classes.doc.html#40898">(&#167;8.3)</a>, and constants of interfaces <a href="interfaces.doc.html#78642">(&#167;9.3)</a>; here the field <code>divisor</code> in the class <code>MiscMath</code> &#32;is declared to be of type <code>int</code>
<a name="49990"></a>
<li>Method parameters <a href="classes.doc.html#38698">(&#167;8.4.1)</a>; here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code>
<a name="52378"></a>
<li>Method results <a href="classes.doc.html#40420">(&#167;8.4)</a>; here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code>
<a name="38145"></a>
<li>Constructor parameters <a href="classes.doc.html#29488">(&#167;8.8.1)</a>; here the parameter of the constructor for<code> MiscMath</code> is declared to be of type <code>int</code>
<a name="12250"></a>
<li>Local variables (<a href="statements.doc.html#5920">&#167;14.4</a>, <a href="statements.doc.html#24588">&#167;14.13</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)
<a name="52411"></a>
<li>Exception handler parameters <a href="statements.doc.html#79311">(&#167;14.19)</a>; here the exception handler parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code>
</ul><a name="25979"></a>
and in expressions of the following kinds:<p>
<ul><a name="52468"></a>
<li>Class instance creations <a href="expressions.doc.html#41147">(&#167;15.9)</a>; here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random </code>
<a name="96936"></a>
<li>Array creations <a href="expressions.doc.html#46168">(&#167;15.10)</a>; here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2
<a name="52427"></a>
<li>Casts <a href="expressions.doc.html#238146">(&#167;15.16)</a>; here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast
<a name="25987"></a>
<li>The <code>instanceof</code> operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>; here the <code>instanceof</code> operator tests whether <code>e</code> is assignment compatible with the type <code>ArithmeticException</code>
</ul><a name="18470"></a>
<h2>4.5    Variables</h2>
<a name="10872"></a>
A variable is a storage location and has an associated type, sometimes called its <em>compile-time type</em>, that is either a primitive type <a href="typesValues.doc.html#85587">(&#167;4.2)</a> or a reference type <a href="typesValues.doc.html#9317">(&#167;4.3)</a>. A variable always contains a value that is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with its type. A variable's value is changed by an assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a> or by a prefix or postfix <code>++</code> (increment) or <code>--</code> (decrement) operator (<a href="expressions.doc.html#39438">&#167;15.14.1</a>, <a href="expressions.doc.html#4987">&#167;15.14.2</a>, <a href="expressions.doc.html#39547">&#167;15.15.1</a>, <a href="expressions.doc.html#239136">&#167;15.15.2</a>).<p>
<a name="24555"></a>
Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language. Default values are compatible <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> and all assignments to a variable are checked for assignment compatibility <a href="conversions.doc.html#184206">(&#167;5.2)</a>, usually at compile time, but, in a single case involving arrays, a run-time check is made <a href="arrays.doc.html#11430">(&#167;10.10)</a>.<p>
<a name="28344"></a>
<h3>4.5.1    Variables of Primitive Type</h3>
<a name="17088"></a>
A variable of a primitive type always holds a value of that exact primitive type.<p>
<a name="28345"></a>
<h3>4.5.2    Variables of Reference Type</h3>
<a name="10877"></a>
A variable of reference type can hold either of the following:<p>
<ul><a name="52494"></a>
<li>A null reference
<a name="52496"></a>
<li>A reference to any object <a href="typesValues.doc.html#9317">(&#167;4.3)</a> whose class <a href="typesValues.doc.html#24887">(&#167;4.5.6)</a> is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the type of the variable
</ul><a name="28536"></a>
<h3>4.5.3    Kinds of Variables</h3>
<a name="10883"></a>
There are seven kinds of variables:<p>
<ol>
<a name="10884"></a>
<li>A <em>class variable</em> is a field declared using the keyword <code>static</code> within a class declaration <a href="classes.doc.html#37544">(&#167;8.3.1.1)</a>, or with or without the keyword <code>static</code> within an interface declaration <a href="interfaces.doc.html#78642">(&#167;9.3)</a>. A class variable is created when its class or interface is prepared <a href="execution.doc.html#47979">(&#167;12.3.2)</a> and is initialized to a default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>. The class variable effectively ceases to exist when its class or interface is unloaded <a href="execution.doc.html#74294">(&#167;12.7)</a>.
<a name="51516"></a>
<li>An <em>instance variable</em> is a field declared within a class declaration without using the keyword <code>static</code> <a href="classes.doc.html#37544">(&#167;8.3.1.1)</a>. If a class <i>T</i> has a field <i>a</i> that is an instance variable, then a new instance variable <i>a</i> is created and initialized to a default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> as part of each newly created object of class <i>T</i> or of any class that is a subclass of <i>T</i> <a href="classes.doc.html#262560">(&#167;8.1.3)</a>. The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object <a href="execution.doc.html#44748">(&#167;12.6)</a> has been completed.
<a name="10895"></a>
<li><em>Array components</em> are unnamed variables that are created and initialized to default values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a> whenever a new object that is an array is created <a href="expressions.doc.html#46168">(&#167;15.10)</a>. The array components effectively cease to exist when the array is no longer referenced. See <a href="arrays.doc.html#27803">&#167;10</a> for a description of arrays.
<a name="24632"></a>
<li><em>Method parameters</em> <a href="classes.doc.html#38698">(&#167;8.4.1)</a> name argument values passed to a method. For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.
<a name="24657"></a>
<li><em>Constructor parameters</em> <a href="classes.doc.html#29488">(&#167;8.8.1)</a> name argument values passed to a constructor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a> invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
<a name="10903"></a>
<li>An <em>exception-handler parameter</em> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a>. The new variable is initialized with the actual object associated with the exception (<a href="exceptions.doc.html#44153">&#167;11.3</a>, <a href="statements.doc.html#237350">&#167;14.17</a>). The exception-handler parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.
<a name="24801"></a>
<li><em>Local variables</em> are declared by local variable declaration statements <a href="statements.doc.html#5920">(&#167;14.4)</a>. Whenever the flow of control enters a block <a href="statements.doc.html#246838">(&#167;14.2)</a> or <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>, a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement. A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment <a href="defAssign.doc.html#25979">(&#167;16)</a> prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or <code>for</code> statement is complete.
</ol>
Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement <a href="statements.doc.html#35518">(&#167;14.10)</a>, where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment <a href="defAssign.doc.html#">(&#167;16)</a>, however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression <a href="expressions.doc.html#5281">(&#167;15.26)</a>. 
<a name="24836"></a>
The following example contains several different kinds of variables:
<blockquote><pre>
class Point {
	static int numPoints;		// numPoints is a class variable
	int x, y;			// x and y are instance variables
	int[] w = new int[10];		// w[0] is an array component
	int setX(int x) {		// x is a method parameter
		int oldx = this.x;	// oldx is a local variable
		this.x = x;
		return oldx;
	}
}
</pre></blockquote><a name="10931"></a>
<h3>4.5.4    final Variables</h3>
<a name="96639"></a>
A variable can be declared <code>final</code>. A final variable may only be assigned to once. It is a compile time error if a final variable is assigned to unless it is definitely unassigned <a href="defAssign.doc.html#25979">(&#167;16)</a> immediately prior to the assignment.<p>
<a name="96971"></a>
A <em>blank final</em> is a final variable whose declaration lacks an initializer. <p>
<a name="96975"></a>
Once a <code>final</code> variable has been assigned, it always contains the same value. If a <code>final</code> variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.<p>
<a name="103462"></a>
Declaring a variable <code>final</code> can serve as useful documentation that its value will not change and can help avoid programming errors.
<a name="96976"></a>
<p>In the example:
<blockquote><pre>class Point {
	int x, y;
	int useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
</pre></blockquote><a name="96596"></a>
the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable holds a reference to an object that is an instance of class <code>Point</code> whose coordinates are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always refers to the same <code>Point</code> object, the one created by its initializer. However, an operation on this <code>Point</code> object might change its state-for example, modifying its <code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.<p>
<a name="96595"></a>
<h3>4.5.5    Initial Values of Variables</h3>
<a name="10935"></a>
Every variable in a program must have a value before its value is used:<p>
<ul><a name="10946"></a>
<li>Each class variable, instance variable, or array component is initialized with a <em>default value</em> when it is created (<a href="expressions.doc.html#41147">&#167;15.9</a>, <a href="expressions.doc.html#46168">&#167;15.10</a>):
<ul>
<a name="10947"></a>
<li>For type <code>byte</code>, the default value is zero, that is, the value of <code>(byte)0</code>.
<a name="10948"></a>
<li>For type <code>short</code>, the default value is zero, that is, the value of <code>(short)0</code>.
<a name="10949"></a>
<li>For type <code>int</code>, the default value is zero, that is, <code>0</code>.
<a name="10950"></a>
<li>For type <code>long</code>, the default value is zero, that is, <code>0L</code>.
<a name="10951"></a>
<li>For type <code>float</code>, the default value is positive zero, that is, <code>0.0f</code>.
<a name="46977"></a>
<li>For type <code>double</code>, the default value is positive zero, that is, <code>0.0d</code>.
<a name="46978"></a>
<li>For type <code>char</code>, the default value is the null character, that is, <code>'\u0000'</code>.
<a name="46979"></a>
<li>For type <code>boolean</code>, the default value is <code>false</code>.
<a name="10955"></a>
<li>For all reference types <a href="typesValues.doc.html#9317">(&#167;4.3)</a>, the default value is <code>null</code>.
</ul>
<a name="11353"></a>
<li>Each method parameter <a href="classes.doc.html#38698">(&#167;8.4.1)</a> is initialized to the corresponding argument value provided by the invoker of the method <a href="expressions.doc.html#20448">(&#167;15.12)</a>.
<a name="38160"></a>
<li>Each constructor parameter <a href="classes.doc.html#29488">(&#167;8.8.1)</a> is initialized to the corresponding argument value provided by a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.
<a name="11354"></a>
<li>An exception-handler parameter <a href="statements.doc.html#79311">(&#167;14.19)</a> is initialized to the thrown object representing the exception (<a href="exceptions.doc.html#44153">&#167;11.3</a>, <a href="statements.doc.html#237350">&#167;14.17</a>). 
<a name="11569"></a>
<li>A local variable (<a href="statements.doc.html#5920">&#167;14.4</a>, <a href="statements.doc.html#24588">&#167;14.13</a>) must be explicitly given a value before it is used, by either initialization <a href="statements.doc.html#5920">(&#167;14.4)</a> or assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a>, in a way that can be verified by the compiler using the rules for definite assignment <a href="defAssign.doc.html#25979">(&#167;16)</a>.
</ul><a name="30962"></a>
The example program:<p>
<blockquote><pre>class Point {
	static int npoints;
	int x, y;
	Point root;
}
class Test {
	public static void main(String[] args) {
		System.out.println("npoints=" + Point.npoints);
		Point p = new Point();
		System.out.println("p.x=" + p.x + ", p.y=" + p.y);
		System.out.println("p.root=" + p.root);
	}
}
</pre></blockquote><a name="12324"></a>
prints:<p>
<blockquote><pre>npoints=0
p.x=0, p.y=0
p.root=null
</pre></blockquote><a name="24882"></a>
illustrating the default initialization of <code>npoints</code>, which occurs when the class <code>Point</code> is prepared <a href="execution.doc.html#47979">(&#167;12.3.2)</a>, and the default initialization of <code>x</code>, <code>y</code>, and <code>root</code>, which occurs when a new <code>Point</code> is instantiated. See <a href="execution.doc.html#44410">&#167;12</a> for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.<p>
<a name="24887"></a>
<h3>4.5.6    Types, Classes, and Interfaces</h3>
<a name="24888"></a>
In the Java programming language, every variable and every expression has a type that can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference types are introduced by type declarations, which include class declarations <a href="classes.doc.html#15372">(&#167;8.1)</a> and interface declarations <a href="interfaces.doc.html#35470">(&#167;9.1)</a>. We often use the term <em>type</em> to refer to either a class or an interface.<p>
<a name="97724"></a>
Every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object, the class whose <code>Class</code> object was used to invoke a reflective method to produce the object, or the <code>String</code> class for objects implicitly created by the string concatenation operator <code>+</code> <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>. This class is called the <em>class of the object</em>. (Arrays also have a class, as described at the end of this section.) An object is said to be an instance of its class and of all superclasses of its class.<p>
<a name="96875"></a>
Sometimes a variable or expression is said to have a "run-time type". This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not <code>null</code>. <p>
<a name="96880"></a>
The compile time type of a variable is always declared, and the compile time type of an expression can be deduced at compile time. The compile time type limits the possible values that the variable can hold or the expression can produce at run time. If a run-time value is a reference that is not <code>null</code>, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.<p>
<a name="24895"></a>
Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements <a href="classes.doc.html#34031">(&#167;8.1.4)</a> that interface.<p>
<a name="24918"></a>
Here is an example of creating new objects and of the distinction between the type of a variable and the class of an object:
<blockquote><pre>public interface Colorable {
	void setColor(byte r, byte g, byte b);
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	byte r, g, b;
	public void setColor(byte rv, byte gv, byte bv) {
		r = rv; g = gv; b = bv;
	}
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		ColoredPoint cp = new ColoredPoint();
		p = cp;
		Colorable c = cp;
	}
}
</pre></blockquote><a name="52612"></a>
In this example:<p>
<ul><a name="52613"></a>
<li>The local variable <code>p</code> of the method <code>main</code> of class <code>Test</code> has type <code>Point</code> and is initially assigned a reference to a new instance of class <code>Point</code>.
<a name="52614"></a>
<li>The local variable <code>cp</code> similarly has as its type <code>ColoredPoint</code>, and is initially assigned a reference to a new instance of class <code>ColoredPoint</code>.
<a name="52615"></a>
<li>The assignment of the value of <code>cp</code> to the variable <code>p</code> causes <code>p</code> to hold a reference to a <code>ColoredPoint</code> object. This is permitted because <code>ColoredPoint</code> is a subclass of <code>Point</code>, so the class <code>ColoredPoint</code> is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the type <code>Point</code>. A <code>ColoredPoint</code> object includes support for all the methods of a <code>Point</code>. In addition to its particular fields <code>r</code>, <code>g</code>, and <code>b</code>, it has the fields of class <code>Point</code>, namely <code>x</code> and <code>y</code>.
<a name="52586"></a>
<li>The local variable <code>c</code> has as its type the interface type <code>Colorable</code>, so it can hold a reference to any object whose class implements <code>Colorable</code>; specifically, it can hold a reference to a <code>ColoredPoint</code>.
<a name="24972"></a>
<li>Note that an expression such as "<code>new Colorable()</code>" is not valid because it is not possible to create an instance of an interface, only of a class.
</ul><a name="24976"></a>
Every array also has a class; the method <code>getClass</code>, when invoked for an array object, will return a class object (of class <code>Class</code>) that represents the class of the array. <p>
<a name="103397"></a>
The classes for arrays have strange names that are not valid identifiers; for example, the class for an array of <code>int</code> components has the name "<code>[I</code>" and so the value of the expression:
<blockquote><pre>new int[10].getClass().getName()
</pre></blockquote><a name="103415"></a>
is the string <code>"[I"</code>; see the specification of <code>Class.getName</code> for details.<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="lexical.doc.html">Prev</a> | <a href="conversions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Names</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="conversions.doc.html">Prev</a> | <a href="packages.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="48086"></a>
<p><strong>
CHAPTER
 6 </strong></p>
<a name="44352"></a>
<h1>Names</h1>
<hr><p>
<a name="10551"></a>
Names are used to refer to entities declared in a program. A declared entity <a href="names.doc.html#33757">(&#167;6.1)</a> is a package, class type, interface type, member (class, interface, field, or method) of a reference type, parameter (to a method, constructor, or exception handler), or local variable.<p>
<a name="56343"></a>
Names in programs are either simple, consisting of a single identifier, or qualified, &#32;consisting of a sequence of identifiers separated by "<code>.</code>" tokens <a href="names.doc.html#31692">(&#167;6.2)</a>.<p>
<a name="56234"></a>
Every declaration that introduces a name has a <em>scope</em> <a href="names.doc.html#103228">(&#167;6.3)</a>, which is the part of the program text within which the declared entity can be referred to by a simple name.<p>
<a name="56241"></a>
Packages and reference types (that is, class types, interface types, and array types) have members <a href="names.doc.html#106443">(&#167;6.4)</a>. A member can be referred to using a qualified name <i>N</i><code>.</code><i>x</i>, where <i>N</i> is a simple or qualified name and <i>x</i> is an identifier. If <i>N</i> names a package, then <i>x</i> is a member of that package, which is either a class or interface type or a subpackage. If <i>N</i> names a reference type or a variable of a reference type, then <i>x</i> names a member of that type, which is either a class, an interface, a field, or a method.<p>
<a name="34249"></a>
In determining the meaning of a name <a href="names.doc.html#106941">(&#167;6.5)</a>, the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.<p>
<a name="56266"></a>
Access control <a href="names.doc.html#104285">(&#167;6.6)</a> can be specified in a class, interface, method, or field declaration to control when <em>access</em> to a member is allowed. Access is a different concept from scope; access specifies the part of the program text within which the declared entity can be referred to by a qualified name, a field access expression <a href="expressions.doc.html#41267">(&#167;15.11)</a>, or a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> in which the method is not specified by a simple name. The default access is that a member can be accessed anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.<p>
<a name="27329"></a>
Fully qualified and canonical names <a href="names.doc.html#25430">(&#167;6.7)</a> and naming conventions <a href="names.doc.html#73307">(&#167;6.8)</a> are also discussed in this chapter.<p>
<a name="31249"></a>
The name of a field, parameter, or local variable may be used as an expression <a href="expressions.doc.html#39438">(&#167;15.14.1)</a>. The name of a method may appear in an expression only as part of a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The name of a class or interface type may appear in an expression only as part of a class literal <a href="expressions.doc.html#251530">(&#167;15.8.2)</a>, a qualified this expression <a href="expressions.doc.html#251603">(&#167;15.8.4)</a>, a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>, an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>, a cast expression <a href="expressions.doc.html#238146">(&#167;15.16)</a>, or an <code>instanceof</code> expression <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>, or as part of a qualified name for a field or method. The name of a package may appear in an expression only as part of a qualified name for a class or interface type.<p>
<a name="33757"></a>
<h2>6.1    Declarations</h2>
<a name="33759"></a>
A <i>declaration</i> introduces an entity into a program and includes an identifier <a href="lexical.doc.html#40625">(&#167;3.8)</a> that can be used in a name to refer to this entity. A declared entity is one of the following:<p>
<ul><a name="60314"></a>
<li>A package, declared in a <code>package</code> declaration <a href="packages.doc.html#26619">(&#167;7.4)</a>
<a name="60319"></a>
<li>An imported type, declared in a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a>
<a name="27103"></a>
<li>A class, declared in a class type declaration <a href="classes.doc.html#15372">(&#167;8.1)</a>
<a name="27107"></a>
<li>An interface, declared in an interface type declaration <a href="interfaces.doc.html#35470">(&#167;9.1)</a>
<a name="103106"></a>
<li>A member of a reference type (<a href="classes.doc.html#21831">&#167;8.2</a>, <a href="interfaces.doc.html#32392">&#167;9.2</a>, <a href="arrays.doc.html#64347">&#167;10.7</a>), one of the following:
<ul>
<a name="103114"></a>
<li>A member class (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>).
<a name="103122"></a>
<li>A member interface (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>).
<a name="71624"></a>
<li>A field, one of the following:
<ul>
<a name="20168"></a>
<li>A field declared in a class type <a href="classes.doc.html#40898">(&#167;8.3)</a>
<a name="20172"></a>
<li>A constant field declared in an interface type <a href="interfaces.doc.html#78642">(&#167;9.3)</a>
<a name="20173"></a>
<li>The field <code>length</code>, which is implicitly a member of every array type <a href="arrays.doc.html#64347">(&#167;10.7)</a>
</ul>
<a name="33764"></a>
<li>A method, one of the following:
<ul>
<a name="38090"></a>
<li>A method (<code>abstract</code> or otherwise) declared in a class type <a href="classes.doc.html#40420">(&#167;8.4)</a>
<a name="33944"></a>
<li>A method (always <code>abstract</code>) declared in an interface type <a href="interfaces.doc.html#78651">(&#167;9.4)</a>
</ul>
</ul>
<a name="31380"></a>
<li>A parameter, one of the following:
<ul>
<a name="33773"></a>
<li>A parameter of a method or constructor of a class (<a href="classes.doc.html#38698">&#167;8.4.1</a>, <a href="classes.doc.html#29488">&#167;8.8.1</a>)
<a name="33775"></a>
<li>A parameter of an <code>abstract</code> method of an interface <a href="interfaces.doc.html#78651">(&#167;9.4)</a>
<a name="31398"></a>
<li>A parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a>
</ul>
<a name="31392"></a>
<li>A local variable, one of the following:
<ul>
<a name="33776"></a>
<li>A local variable declared in a block <a href="statements.doc.html#5920">(&#167;14.4)</a>
<a name="33777"></a>
<li>A local variable declared in a <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>
</ul>
</ul><a name="56358"></a>
Constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.<p>
<a name="31692"></a>
<h2>6.2    Names and Identifiers</h2>
<a name="61760"></a>
A <em>name</em> is used to refer to an entity declared in a program.<p>
<a name="61763"></a>
There are two forms of names: simple names and qualified names. A <em>simple name</em> is a single identifier. A <em>qualified name</em> consists of a name, a "<code>.</code>" token, and an identifier.<p>
<a name="21637"></a>
In determining the meaning of a name <a href="names.doc.html#106941">(&#167;6.5)</a>, the context in which the name appears is taken into account. The rules of <a href="names.doc.html#106941">&#167;6.5</a> distinguish among contexts where a name must denote (refer to) a package <a href="names.doc.html#22349">(&#167;6.5.3)</a>, a type <a href="names.doc.html#73064">(&#167;6.5.5)</a>, a variable or value in an expression <a href="names.doc.html#21650">(&#167;6.5.6)</a>, or a method <a href="names.doc.html#21652">(&#167;6.5.7)</a>.<p>
<a name="33483"></a>
Not all identifiers in programs are a part of a name. Identifiers are also used in the following situations:<p>
<ul><a name="33485"></a>
<li>In declarations <a href="names.doc.html#33757">(&#167;6.1)</a>, where an identifier may occur to specify the name by which the declared entity will be known
<a name="33490"></a>
<li>In field access expressions <a href="expressions.doc.html#41267">(&#167;15.11)</a>, where an identifier occurs after a "<code>.</code>" token to indicate a member of an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="33491"></a>
<li>In some method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>, where an identifier may occur after a "<code>.</code>" token and before a "<code>(</code>" token to indicate a method to be invoked for an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="76093"></a>
<li>In qualified class instance creation expressions <a href="expressions.doc.html#41147">(&#167;15.9)</a>, where an identifier occurs immediately to the right of the leftmost new token to indicate a type that must be a member of the compile-time type of the primary expression preceding the "." preceding the leftmost new token.
<a name="33492"></a>
<li>As labels in labeled statements <a href="statements.doc.html#78993">(&#167;14.7)</a> and in <code>break</code> <a href="statements.doc.html#6842">(&#167;14.14)</a> and <code>continue</code> <a href="statements.doc.html#6122">(&#167;14.15)</a> statements that refer to statement labels.
</ul><a name="79896"></a>
In the example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		Class c = System.out.getClass();
		System.out.println(c.toString().length() +
					args[0].length() + args.length);
	}
}
</pre></blockquote><a name="61602"></a>
the identifiers <code>Test</code>, <code>main</code>, and the first occurrences of <code>args</code> and <code>c</code> are not names; rather, they are used in declarations to specify the names of the declared entities. The names <code>String</code>, <code>Class</code>, <code>System.out.getClass</code>, <code>System.out.println</code>, <code>c.toString</code>, <code>args</code>, and <code>args.length</code> appear in the example. The first occurrence of <code>length</code> is not a name, but rather an identifier appearing in a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The second occurrence of <code>length</code> is not a name, but rather an identifier appearing in a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a>.<p>
<a name="61609"></a>
The identifiers used in labeled statements and their associated <code>break</code> and <code>continue</code> statements are completely separate from those used in declarations. Thus, the following code is valid:
<blockquote><pre>class TestString {
	char[] value;
	int offset, count;
	int indexOf(TestString str, int fromIndex) {
		char[] v1 = value, v2 = str.value;
		int max = offset + (count - str.count);
		int start = offset + ((fromIndex &lt; 0) ? 0 : fromIndex);
	i:
		for (int i = start; i &lt;= max; i++)
		{
			int n = str.count, j = i, k = str.offset;
			while (n-- != 0) {
				if (v1[j++] != v2[k++])
					continue i;
			} 
			return i - offset;
		}
		return -1;
	}
}
</pre></blockquote><a name="103223"></a>
This code was taken from a version of the class <code>String</code> and its method <code>indexOf</code>, where the label was originally called <code>test</code>. Changing the label to have the same name as the local variable <code>i</code> does not obscure <a href="names.doc.html#104058">(&#167;6.3.2)</a> the label in the scope of the declaration of <code>i</code>. The identifier <code>max</code> could also have been used as the statement label; the label would not obscure the local variable <code>max</code> within the labeled statement.<p>
<a name="103228"></a>
<h2>6.3    Scope of a Declaration</h2>
<a name="103232"></a>
The <em>scope</em> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name (provided it is visible <a href="names.doc.html#34133">(&#167;6.3.1)</a>). A declaration is said to be <em>in scope</em> at a particular point in a program if and only if the declaration's scope includes that point. <p>
<a name="103908"></a>
The scoping rules for various constructs are given in the sections that describe those constructs. For convenience, the rules are repeated here:<p>
<a name="108808"></a>
 The scope of the declaration of an observable <a href="packages.doc.html#13180">(&#167;7.4.3)</a> top level package is all observable compilation units <a href="packages.doc.html#40031">(&#167;7.3)</a>. The declaration of a package that is not observable is never in scope. Subpackage declarations are never in scope.<p>
<a name="108865"></a>
The scope of a type imported by a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> or type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="packages.doc.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="108901"></a>
The scope of a top level type is all type declarations in the package in which the top level type is declared.<p>
<a name="109152"></a>
The scope of a label declared by a labeled statement is the statement immediately enclosed by the labeled statement.<p>
<a name="109195"></a>
The scope of a declaration of a member m declared in or inherited by a class type C is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="109234"></a>
The scope of the declaration of a member m declared in or inherited by an interface type I is the entire body of <i>I</i>, including any nested type declarations.<p>
<a name="108452"></a>
The scope of a parameter of a method <a href="classes.doc.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.doc.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="108957"></a>
The scope of a local variable declaration in a block <a href="statements.doc.html#32644">(&#167;14.4.2)</a> is the rest of the block in which the declaration appears, starting with its own initializer <a href="statements.doc.html#5920">(&#167;14.4)</a> and including any further declarators to the right in the local variable declaration statement. <p>
<a name="108996"></a>
The scope of a local class declared in a block is the rest of the immediately enclosing block, including its own class declaration.<p>
<a name="109032"></a>
The scope of a local variable declared in the <em>ForInit</em> part of a <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a> includes all of the following:<p>
<ul><a name="109037"></a>
<li>Its own initializer
<a name="109040"></a>
<li>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement
<a name="109041"></a>
<li>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement
<a name="109042"></a>
<li>The contained <em>Statement</em>
</ul><a name="109075"></a>
The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a> is the entire block associated with the <code>catch</code>.<p>
<a name="107230"></a>
These rules imply that declarations of class and interface types need not appear before uses of the types.<p>
<a name="20278"></a>
In the example:
<blockquote><pre>package points;
class Point {
	int x, y;
	PointList list;
	Point next;
}
class PointList {
	Point first;
}
</pre></blockquote><a name="34047"></a>
the use of <code>PointList</code> in class <code>Point</code> is correct, because the scope of the class declaration <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any other type declarations in other compilation units of package <code>points</code>.<p>
<a name="34133"></a>
<h3>6.3.1    Shadowing Declarations</h3>
<a name="34051"></a>
Some declarations may be <em>shadowed</em> in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.<p>
<a name="84195"></a>
A declaration <i>d</i> of a type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="84205"></a>
A declaration <i>d</i> of a field, local variable, method parameter, constructor parameter or exception handler parameter named <i>n</i> shadows the declarations of any other fields, local variables, method parameters, constructor parameters or exception handler parameters named <i>n</i> that are in scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="84220"></a>
A declaration <i>d</i> of a label named <i>n</i> shadows the declarations of any other labels named <i>n</i> that are in scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="84229"></a>
A declaration <i>d</i> of a method named <i>n</i> shadows the declarations of any other methods named <i>n</i> that are in an enclosing scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="103966"></a>
A package declaration never shadows any other declaration. <p>
<a name="109278"></a>
A single-type-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="109280"></a>
<li>any top level type named <i>n</i> declared in another compilation unit of <i>p</i>.
<a name="109281"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration in <i>c</i>.
</ul><a name="109282"></a>
throughout <i>c.</i><p>
<a name="109313"></a>
A type-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="108437"></a>
A declaration <i>d</i> is said to be <em>visible at point </em><i>p</i><em> in a program</em> if the scope of <i>d</i> includes <i>p</i>, and <i>d</i> is not shadowed by any other declaration at <i>p</i>. When the program point we are discussing is clear from context, we will often simply say that a declaration is <em>visible</em>.<p>
<a name="104510"></a>
Note that shadowing is distinct from hiding (<a href="classes.doc.html#40898">&#167;8.3</a>, <a href="classes.doc.html#227928">&#167;8.4.6.2</a>, <a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#78642">&#167;9.3</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). Hiding, in the technical sense defined in this specification, applies only to members which would otherwise be inherited but are not because of a declaration in a subclass. Shadowing is also distinct from obscuring <a href="names.doc.html#104058">(&#167;6.3.2)</a>.
<p>
<a name="62323"></a>
Here is an example of shadowing of a field declaration by a local variable declaration:
<blockquote><pre>class Test {
	static int x = 1;
	public static void main(String[] args) {
		int x = 0;
		System.out.print("x=" + x);
		System.out.println(", Test.x=" + Test.x);
	}
}
</pre></blockquote><a name="34060"></a>
produces the output:<p>
<blockquote><pre>x=0, Test.x=1
</pre></blockquote><a name="34062"></a>
This example declares:<p>
<ul><a name="62327"></a>
<li>a class <code>Test</code>
<a name="62331"></a>
<li>a class (<code>static</code>) variable <code>x</code> that is a member of the class <code>Test</code>
<a name="62332"></a>
<li>a class method <code>main</code> that is a member of the class <code>Test</code>
<a name="62333"></a>
<li>a parameter <code>args</code> of the <code>main</code> method
<a name="62334"></a>
<li>a local variable <code>x</code> of the <code>main</code> method
<a name="34066"></a>
</ul>
Since the scope of a class variable includes the entire body of the class <a href="classes.doc.html#21831">(&#167;8.2)</a> the class variable <code>x</code> would normally be available throughout the entire body of the method <code>main</code>. In this example, however, the class variable <code>x</code> is shadowed within the body of the method <code>main</code> by the declaration of the local variable <code>x</code>.
<p>
<a name="62312"></a>
A local variable has as its scope the rest of the block in which it is declared <a href="statements.doc.html#32644">(&#167;14.4.2)</a>; in this case this is the rest of the body of the <code>main</code> method, namely its initializer "<code>0</code>" and the invocations of <code>print</code> and <code>println</code>.
<a name="62314"></a>
<p>
This means that:
<a name="62313"></a>
<ul>
<li>The expression "<code>x</code>" in the invocation of <code>print</code> refers to (denotes) the value of the local variable <code>x</code>.
<a name="62320"></a>
<li>The invocation of <code>println</code> uses a qualified name <a href="names.doc.html#104285">(&#167;6.6)</a> <code>Test.x</code>, which uses the class type name <code>Test</code> to access the class variable <code>x</code>, because the declaration of <code>Test.x</code> is shadowed at this point and cannot be referred to by its simple name.
<a name="104040"></a>
</ul>
The following example illustrates the shadowing of one type declaration by another:
</ul><blockquote><pre>import java.util.*;
class Vector {
	int val[] = { 1 , 2 };
<a name="104044"></a>
}<p>
class Test {
	public static void main(String[] args) {
		Vector v = new Vector();
		System.out.println(v.val[0]);
	}
}
</pre></blockquote><a name="104051"></a>
compiles and prints:<p>
<blockquote><pre>1
</pre></blockquote><a name="104053"></a>
using the class <code>Vector</code> declared here in preference to class <code>java.util.Vector</code> that might be imported on demand.<p>
<a name="104058"></a>
<h3>6.3.2    Obscured Declarations</h3>
<a name="62307"></a>
A simple name may occur in contexts where it may potentially be interpreted as the name of a variable, a type or a package. In these situations, the rules of <a href="names.doc.html#106941">&#167;6.5</a> specify that a variable will be chosen in preference to a type, and that a type will be chosen in preference to a package. Thus, it is may sometimes be impossible to refer to a visible type or package declaration via its simple name. We say that such a declaration is <em>obscured</em>. <p>
<a name="106440"></a>
Obscuring is distinct from shadowing <a href="names.doc.html#34133">(&#167;6.3.1)</a> and hiding (<a href="classes.doc.html#40898">&#167;8.3</a>, <a href="classes.doc.html#227928">&#167;8.4.6.2</a>, <a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#78642">&#167;9.3</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). The naming conventions of <a href="names.doc.html#73307">&#167;6.8</a> help reduce obscuring.
<p>
<a name="106443"></a>
<h2>6.4    Members and Inheritance</h2>
<a name="86672"></a>
Packages and reference types have <em>members</em>. <p>
<a name="56531"></a>
This section provides an overview of the members of packages and reference types here, as background for the discussion of qualified names and the determination of the meaning of names. For a complete description of membership, see <a href="packages.doc.html#26535">&#167;7.1</a>, <a href="classes.doc.html#21831">&#167;8.2</a>, <a href="interfaces.doc.html#32392">&#167;9.2</a>, and <a href="arrays.doc.html#64347">&#167;10.7</a>. 
<p>
<a name="34993"></a>
<h3>6.4.1    The Members of a Package</h3>
<a name="104077"></a>
The members of a package <a href="packages.doc.html#34412">(&#167;7)</a> are specified in <a href="packages.doc.html#26535">&#167;7.1</a>. For convenience, we repeat that specification here:<p>
<a name="108769"></a>
The members of a package are subpackages and all the top level <a href="packages.doc.html#26783">(&#167;7.6)</a> class <a href="classes.doc.html#3857">(&#167;8)</a> and top level interface <a href="interfaces.doc.html#238678">(&#167;9)</a> types declared in all the compilation units <a href="packages.doc.html#40031">(&#167;7.3)</a> of the package.<p>
<a name="98547"></a>
In general, the subpackages of a package are determined by the host system <a href="packages.doc.html#37758">(&#167;7.2)</a>. However, the package <code>java</code> always includes the subpackages <code>lang</code> and <code>io</code> and may include other subpackages. No two distinct members of the same package may have the same simple name <a href="packages.doc.html#26535">(&#167;7.1)</a>, but members of different packages may have the same simple name. <p>
<a name="107146"></a>
For example, it is possible to declare a package:
<blockquote><pre>package vector;
public class Vector { Object[] vec; }
</pre></blockquote><a name="34986"></a>
that has as a member a <code>public</code> class named <code>Vector</code>, even though the package <code>java.util</code> also declares a class named <code>Vector</code>. These two class types are different, reflected by the fact that they have different fully qualified names <a href="names.doc.html#25430">(&#167;6.7)</a>. The fully qualified name of this example <code>Vector</code> is <code>vector.Vector</code>, whereas <code>java.util.Vector</code> is the fully qualified name of the standard <code>Vector</code> class. Because the package <code>vector</code> contains a class named <code>Vector</code>, it cannot also have a subpackage named <code>Vector</code>.<p>
<a name="34757"></a>
<h3>6.4.2    The Members of a Class Type</h3>
<a name="104101"></a>
The members of a class type <a href="classes.doc.html#21831">(&#167;8.2)</a> are classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), interfaces (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), fields (<a href="classes.doc.html#40898">&#167;8.3</a>, <a href="interfaces.doc.html#78642">&#167;9.3</a>, <a href="arrays.doc.html#64347">&#167;10.7</a>), and methods (<a href="classes.doc.html#40420">&#167;8.4</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>). Members are either declared in the type, or <i>inherited </i>because they are accessible members of a superclass or superinterface which are neither private nor hidden nor overridden <a href="classes.doc.html#228745">(&#167;8.4.6)</a>.<p>
<a name="34765"></a>
The members of a class type are all of the following:
<ul><a name="34768"></a>
<li>Members inherited from its direct superclass <a href="classes.doc.html#262560">(&#167;8.1.3)</a>, if it has one (the class <code>Object</code> has no direct superclass)
<a name="34777"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.doc.html#34031">(&#167;8.1.4)</a>
<a name="34778"></a>
<li>Members declared in the body of the class <a href="classes.doc.html#18988">(&#167;8.1.5)</a>
</ul><a name="62337"></a>
Constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> are not members.<p>
<a name="31685"></a>
There is no restriction against a field and a method of a class type having the same simple name. Likewise, there is no restriction against a member class or member interface of a class type having the same simple name as a field or method of that class type.
<a name="56650"></a>
<p>
A class may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any of the fields by its simple name results in a compile-time error (<a href="names.doc.html#54547">&#167;6.5.7.2</a>, <a href="classes.doc.html#21831">&#167;8.2</a>).
<a name="31689"></a>
<p>
In the example:
<blockquote><pre>interface Colors {
	int WHITE = 0, BLACK = 1;
}
interface Separates {
	int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
}
class Test implements Colors, Separates {
	public static void main(String[] args) {
		System.out.println(BLACK); // compile-time error: ambiguous
	}
}
</pre></blockquote><a name="25294"></a>
the name <code>BLACK</code> in the method <code>main</code> is ambiguous, because class <code>Test</code> has two members named <code>BLACK</code>, one inherited from <code>Colors</code> and one from <code>Separates</code>.<p>
<a name="23306"></a>
A class type may have two or more methods with the same simple name if the methods have different signatures <a href="classes.doc.html#38649">(&#167;8.4.2)</a>, that is, if they have different numbers of parameters or different parameter types in at least one parameter position. Such a method member name is said to be <em>overloaded</em>.
<p>
<a name="31700"></a>
A class type may contain a declaration for a method with the same name and the same signature as a method that would otherwise be inherited from a superclass or superinterface. In this case, the method of the superclass or superinterface is not inherited. If the method not inherited is <code>abstract</code>, then the new declaration is said to <em>implement</em> it; if the method not inherited is not <code>abstract</code>, then the new declaration is said to <em>override</em> it.<p>
<a name="31699"></a>
In the example:
<blockquote><pre>class Point {
	float x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
	void move(float dx, float dy) { x += dx; y += dy; }
	public String toString() { return "("+x+","+y+")"; }
}
</pre></blockquote><a name="31707"></a>
the class <code>Point</code> has two members that are methods with the same name, <code>move</code>. The overloaded <code>move</code> method of class <code>Point</code> chosen for any particular method invocation is determined at compile time by the overloading resolution procedure given in <a href="expressions.doc.html#20448">&#167;15.12</a>.<p>
<a name="62345"></a>
In this example, the members of the class <code>Point</code> are the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>Point</code>, the two declared <code>move</code> methods, the declared <code>toString</code> method, and the members that <code>Point</code> inherits from its implicit direct superclass <code>Object</code> <a href="typesValues.doc.html#11055">(&#167;4.3.2)</a>, such as the method <code>hashCode</code>. Note that <code>Point</code> does not inherit the <code>toString</code> method of class <code>Object</code> because that method is overridden by the declaration of the <code>toString</code> method in class <code>Point</code>.
<p>
<a name="34849"></a>
<h3>6.4.3    The Members of an Interface Type</h3>
<a name="109115"></a>
The members of an interface type <a href="interfaces.doc.html#32392">(&#167;9.2)</a> may be classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), interfaces (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), fields (<a href="classes.doc.html#40898">&#167;8.3</a>, <a href="interfaces.doc.html#78642">&#167;9.3</a>, <a href="arrays.doc.html#64347">&#167;10.7</a>), and methods (<a href="classes.doc.html#40420">&#167;8.4</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>).The members of an interface are:<p>
<ul><a name="109116"></a>
<li>Those members declared in the interface.
<a name="109119"></a>
<li>Those members inherited from direct superinterfaces.
<a name="109120"></a>
<li>If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method <i>m</i> with signature <i>s</i>, return type <i>r</i>, and <code>throws</code> clause <i>t</i> corresponding to each public instance method <i>m</i> with signature <i>s</i>, return type <i>r</i>, and <code>throws</code> clause <i>t</i> declared in <code>Object</code>, unless a method with the same signature, same return type, and a compatible <code>throws</code> clause is explicitly declared by the interface.
</ul><a name="108393"></a>
An interface may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any such field by its simple name results in a compile-time error (<a href="names.doc.html#22022">&#167;6.5.6.1</a>, <a href="interfaces.doc.html#32392">&#167;9.2</a>).<p>
<a name="61795"></a>
In the example:
<blockquote><pre>interface Colors {
	int WHITE = 0, BLACK = 1;
}
interface Separates {
	int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
}
interface ColorsAndSeparates extends Colors, Separates {
	int DEFAULT = BLACK;								 	// compile-time error: ambiguous
}
</pre></blockquote><a name="35254"></a>
the members of the interface <code>ColorsAndSeparates</code> include those members inherited from <code>Colors</code> and those inherited from <code>Separates</code>, namely <code>WHITE</code>, <code>BLACK</code> (first of two), <code>CYAN</code>, <code>MAGENTA</code>, <code>YELLOW</code>, and <code>BLACK</code> (second of two). The member name <code>BLACK</code> is ambiguous in the interface <code>ColorsAndSeparates</code>.<p>
<a name="27725"></a>
<h3>6.4.4    The Members of an Array Type</h3>
<a name="86520"></a>
The members of an array type are specified in <a href="arrays.doc.html#64347">&#167;10.7</a>. For convenience, we repeat that specification here.<p>
<a name="108751"></a>
The members of an array type are all of the following:<p>
<ul><a name="108753"></a>
<li>The <code>public</code> <code>final</code> field <code>length</code>, which contains the number of components of the array (<code>length</code> may be positive or zero)
<a name="108755"></a>
<li>The <code>public</code> method <code>clone</code>, which overrides the method of the same name in class <code>Object</code> and throws no checked exceptions
<a name="108757"></a>
<li>All the members inherited from class <code>Object</code>; the only method of <code>Object</code> that is not inherited is its <code>clone</code> method
</ul><a name="27727"></a>
<p>
<a name="98552"></a>
The example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[] ia = new int[3];
		int[] ib = new int[6];
		System.out.println(ia.getClass() == ib.getClass());
		System.out.println("ia has length=" + ia.length);
	}
}
</pre></blockquote><a name="27736"></a>
produces the output:<p>
<blockquote><pre>true
ia has length=3
</pre></blockquote><a name="106936"></a>
This example uses the method <code>getClass</code> inherited from class <code>Object</code> and the field <code>length</code>. The result of the comparison of the <code>Class</code> objects in the first <code>println</code> demonstrates that all arrays whose components are of type <code>int</code> are instances of the same array type, which is <code>int[]</code>.<p>
<a name="106941"></a>
<h2>6.5    Determining the Meaning of a Name</h2>
<a name="106943"></a>
The meaning of a name depends on the context in which it is used. The determination of the meaning of a name requires three steps. First, context causes a name syntactically to fall into one of six categories: <em>PackageName</em>, <em>TypeName</em>, <em>ExpressionName</em>, <em>MethodName</em>, <em>PackageOrTypeName, </em>or <em>AmbiguousName</em>. Second, a name that is initially classified by its context as an <em>AmbiguousName</em> or as a <em>Package-OrTypeName</em> is then reclassified to be a <em>PackageName</em>, <em>TypeName</em>, or <em>ExpressionName</em>. Third, the resulting category then dictates the final determination of the meaning of the name (or a compilation error if the name has no meaning).<p>
<ul><pre><i>
PackageName:
	Identifier
	PackageName . Identifier

TypeName:
	Identifier
	PackageOrTypeName . Identifier

ExpressionName:
	Identifier
	AmbiguousName . Identifier

MethodName:
	Identifier
	AmbiguousName . Identifier

PackageOrTypeName:
	Identifier
	PackageOrTypeName . Identifier

AmbiguousName:
	Identifier
	AmbiguousName . Identifier
	</i></pre></ul>
<a name="32744"></a>
The use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in <a href="names.doc.html#73307">&#167;6.8</a> are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.
</pre></ul><a name="32740"></a>
<h3>6.5.1    Syntactic Classification of a Name According to Context</h3>
<a name="32741"></a>
A name is syntactically classified as a <em>PackageName</em> in these contexts:<p>
<ul><a name="32159"></a>
<li>In a package declaration <a href="packages.doc.html#26619">(&#167;7.4)</a>
<a name="32492"></a>
<li>To the left of the "<code>.</code>" in a qualified <em>PackageName</em>
</ul><a name="32149"></a>
A name is syntactically classified as a <em>TypeName</em> in these contexts:<p>
<ul><a name="32174"></a>
<li>In a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a>
<a name="32178"></a>
<li>In an <code>extends</code> clause in a class declaration <a href="classes.doc.html#262560">(&#167;8.1.3)</a>
<a name="32182"></a>
<li>In an <code>implements</code> clause in a class declaration <a href="classes.doc.html#34031">(&#167;8.1.4)</a>
<a name="34302"></a>
<li>In an <code>extends</code> clause in an interface declaration <a href="interfaces.doc.html#78598">(&#167;9.1.2)</a>
<a name="32290"></a>
<li>As a <em>Type</em> (or the part of a <em>Type</em> that remains after all brackets are deleted) in any of the following contexts:
<ul>
<a name="32310"></a>
<li>In a field declaration (<a href="classes.doc.html#40898">&#167;8.3</a>, <a href="interfaces.doc.html#78642">&#167;9.3</a>)
<a name="32322"></a>
<li>As the result type of a method (<a href="classes.doc.html#40420">&#167;8.4</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>)
<a name="32355"></a>
<li>As the type of a formal parameter of a method or constructor (<a href="classes.doc.html#38698">&#167;8.4.1</a>, <a href="classes.doc.html#29488">&#167;8.8.1</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>)
<a name="32266"></a>
<li>As the type of an exception that can be thrown by a method or constructor (<a href="classes.doc.html#78323">&#167;8.4.4</a>, <a href="classes.doc.html#244611">&#167;8.8.4</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>)
<a name="32224"></a>
<li>As the type of a local variable <a href="statements.doc.html#5920">(&#167;14.4)</a>
<a name="72827"></a>
<li>As the type of an exception parameter in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a>
<a name="72840"></a>
<li>As the type in a class literal <a href="expressions.doc.html#251530">(&#167;15.8.2)</a>
<a name="104184"></a>
<li>As the qualifying type of a qualified <code>this</code> expression <a href="expressions.doc.html#251603">(&#167;15.8.4)</a>.
<a name="72842"></a>
<li>As the class type which is to be instantiated in an unqualified class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>
<a name="83309"></a>
<li>As the direct superclass or direct superinterface of an anonymous class <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> which is to be instantiated in an unqualified class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>
<a name="32240"></a>
<li>As the element type of an array to be created in an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>
<a name="104188"></a>
<li>As the qualifying type of field access using the keyword <code>super</code> <a href="expressions.doc.html#20860">(&#167;15.11.2)</a>
<a name="104192"></a>
<li>As the qualifying type of a method invocation using the keyword <code>super</code> <a href="expressions.doc.html#20448">(&#167;15.12)</a>
<a name="32244"></a>
<li>As the type mentioned in the cast operator of a cast expression <a href="expressions.doc.html#238146">(&#167;15.16)</a>
<a name="32248"></a>
<li>As the type that follows the <code>instanceof</code> relational operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>
</ul>
</ul><a name="32435"></a>
A name is syntactically classified as an <em>ExpressionName</em> in these contexts:<p>
<ul><a name="32464"></a>
<li>As the qualifying expression in a qualified superclass constructor invocation <a href="classes.doc.html#229267">(&#167;8.8.5.1)</a>
<a name="104200"></a>
<li>As the qualifying expression in a qualified class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>
<a name="104201"></a>
<li>As the array reference expression in an array access expression <a href="expressions.doc.html#239587">(&#167;15.13)</a>
<a name="32459"></a>
<li>As a <em>PostfixExpression</em> <a href="expressions.doc.html#36254">(&#167;15.14)</a>
<a name="32477"></a>
<li>As the left-hand operand of an assignment operator <a href="expressions.doc.html#5281">(&#167;15.26)</a>
</ul><a name="32437"></a>
A name is syntactically classified as a <em>MethodName</em> in this context:<p>
<ul><a name="32480"></a>
<li>Before the "<code>(</code>" in a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a>
</ul><a name="72939"></a>
A name is syntactically classified as a <em>PackageOrTypeName</em> in these contexts:<p>
<ul><a name="72943"></a>
<li>To the left of the "." in a qualified TypeName
<a name="73268"></a>
<li>In a type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a>
</ul><a name="32439"></a>
A name is syntactically classified as an <em>AmbiguousName</em> in these contexts:<p>
<ul><a name="32496"></a>
<li>To the left of the "<code>.</code>" in a qualified <em>ExpressionName</em>
<a name="32499"></a>
<li>To the left of the "<code>.</code>" in a qualified <em>MethodName</em>
<a name="72113"></a>
<li>To the left of the "<code>.</code>" in a qualified <em>AmbiguousName</em>
</ul><a name="32725"></a>
<h3>6.5.2    Reclassification of Contextually Ambiguous Names</h3>
<a name="32133"></a>
An <em>AmbiguousName</em> is then reclassified as follows:<p>
<ul><a name="32505"></a>
<li>If the <em>AmbiguousName</em> is a simple name, consisting of a single <em>Identifier</em>:
<ul>
<a name="32544"></a>
<li>If the <em>Identifier</em> appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a local variable declaration <a href="statements.doc.html#5920">(&#167;14.4)</a> or parameter declaration (<a href="classes.doc.html#38698">&#167;8.4.1</a>, <a href="classes.doc.html#29488">&#167;8.8.1</a>, <a href="statements.doc.html#79311">&#167;14.19</a>) or field declaration <a href="classes.doc.html#40898">(&#167;8.3)</a> with that name, then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.
<a name="32843"></a>
<li>Otherwise, if the <em>Identifier</em> appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a local class declaration <a href="statements.doc.html#247766">(&#167;14.3)</a> or member type declaration (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>) with that name, then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.
<a name="71975"></a>
<li>Otherwise, if a type of that name is declared in the compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> containing the <em>Identifier</em>, either by a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> or by a top level class <a href="classes.doc.html#3857">(&#167;8)</a> or interface type declaration <a href="interfaces.doc.html#238678">(&#167;9)</a>, then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.
<a name="32853"></a>
<li>Otherwise, if a type of that name is declared in another compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> of the package <a href="packages.doc.html#26535">(&#167;7.1)</a> of the compilation unit containing the <em>Identifier</em>, &#32;then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>. 
<a name="32860"></a>
<li>Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> of the compilation unit containing the <em>Identifier</em>, &#32;then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.
<a name="32864"></a>
<li>Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit containing the <em>Identifier</em>, then a compile-time error results.
<a name="32535"></a>
<li>Otherwise, the <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.
</ul>
<a name="32506"></a>
<li>If the <em>AmbiguousName</em> is a qualified name, consisting of a name, a "<code>.</code>", and an <em>Identifier</em>, then the name to the left of the "<code>.</code>" is first reclassified, for it is itself an <em>AmbiguousName</em>. There is then a choice:
<ul>
<a name="32509"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <em>PackageName</em>, then if there is a package whose name is the name to the left of the "<code>.</code>" and that package contains a declaration of a type whose name is the same as the <em>Identifier</em>, then this <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>. Otherwise, this <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.
<a name="72049"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <em>TypeName</em>, then if the Identifier is the name of a method or field of the class or interface denoted by TypeName, this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName. </em>Otherwise, if the Identifier is the name of a member type of the class or interface denoted by TypeName, this AmbiguousName is reclassified as a TypeName. Otherwise, a compile-time error results.
<a name="79937"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as an <em>ExpressionName</em>, then let T be the type of the expression denoted by ExpressionName. If the Identifier is the name of a method or field of the class or interface denoted by T, this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>. Otherwise, if the Identifier is the name of a member type (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>) of the class or interface denoted by T, then this AmbiguousName is reclassified as a TypeName. Otherwise, a compile-time error results.
<a name="60456"></a>
</ul>
<p>
As an example, consider the following contrived "library code":
</ul><blockquote><pre>package org.rpgpoet;
import java.util.Random;
interface Music { Random[] wizards = new Random[4]; }
</pre></blockquote><a name="60464"></a>
and then consider this example code in another package:<p>
<blockquote><pre>package bazola;
class Gabriel {
	static int n = org.rpgpoet.Music.wizards.length;
}
</pre></blockquote><a name="60483"></a>
First of all, the name <code>org.rpgpoet.Music.wizards.length</code> is classified as an <em>ExpressionName</em> because it functions as a <i>PostfixExpression</i>. Therefore, each of the names:<p>
<a name="107486"></a>
<blockquote><pre>org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org 
</pre></blockquote><a name="86574"></a>
is initially classified as an <em>AmbiguousName</em>. These are then reclassified:<p>
<ul><a name="60526"></a>
<li>The simple name <code>org</code> is reclassified as a <em>PackageName</em> (since there is no variable or type named <code>org</code> in scope). 
<a name="60530"></a>
<li>Next, assuming that there is no class or interface named <code>rpgpoet</code> in any compilation unit of package <code>org</code> (and we know that there is no such class or interface because package <code>org</code> has a subpackage named <code>rpgpoet</code>), the qualified name <code>org.rpgpoet</code> is reclassified as a <em>PackageName</em>.
<a name="60542"></a>
<li>Next, because package <code>org.rpgpoet</code> has an interface type named <code>Music</code>, the qualified name <code>org.rpgpoet.Music</code> is reclassified as a <em>TypeName</em>.
<a name="80032"></a>
<li>Finally, because the name <code>org.rpgpoet.Music</code> is a <em>TypeName</em>, the qualified name <code>org.rpgpoet.Music.wizards</code> is reclassified as an <em>ExpressionName</em>. 
</ul><a name="22349"></a>
<h3>6.5.3    Meaning of Package Names</h3>
<a name="32757"></a>
The meaning of a name classified as a <em>PackageName</em> is determined as follows.<p>
<a name="22481"></a>
<h4>6.5.3.1    Simple Package Names</h4>
<a name="21719"></a>
If a package name consists of a single <em>Identifier</em>, then this identifier denotes a top level package named by that identifier. If no top level package of that name is in scope <a href="packages.doc.html#70172">(&#167;7.4.4)</a>, then a compile-time error occurs.<p>
<a name="22482"></a>
<h4>6.5.3.2    Qualified Package Names</h4>
<a name="21727"></a>
If a package name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must also be a package name. The package name <i>Q</i><code>.</code><i>Id</i> names a package that is the member named <i>Id</i> within the package named by <i>Q</i>. If <i>Q</i> does not name an observable package <a href="packages.doc.html#13180">(&#167;7.4.3)</a>, or <i>Id</i> is not the simple name an observable subpackage of that package, then a compile-time error occurs.<p>
<a name="21721"></a>
<h3>6.5.4    Meaning of <i>PackageOrTypeNames</i></h3>
<a name="73065"></a>
<h4>6.5.4.1    Simple <i>PackageOrTypeNames</i></h4>
<a name="73113"></a>
If the <i>PackageOrTypeName</i>, <i>Q</i>, occurs in the scope of a type named <i>Q</i>, then the <i>PackageOrTypeName</i> is reclassified as a <i>TypeName</i>. <p>
<a name="107160"></a>
Otherwise, the <i>PackageOrTypeName</i> is reclassified as a <i>PackageName</i>. The meaning of the <i>PackageOrTypeName</i> is the meaning of the reclassified name.<p>
<a name="73067"></a>
<h4>6.5.4.2    Qualified <i>PackageOrTypeNames</i></h4>
<a name="73097"></a>
Given a qualified <i>PackageOrTypeName</i> of the form <i>Q.Id</i>, if the type or package denoted by <i>Q</i> has a member type named <i>Id</i>, then the qualified <i>PackageOrTypeName</i> name is reclassified as a <i>TypeName</i>. <p>
<a name="107161"></a>
Otherwise, it is reclassified as a <i>PackageName</i>. The meaning of the qualified <i>PackageOrTypeName</i> is the meaning of the reclassified name.<p>
<a name="73064"></a>
<h3>6.5.5    Meaning of Type Names</h3>
<a name="32763"></a>
The meaning of a name classified as a <em>TypeName</em> is determined as follows.<p>
<a name="21810"></a>
<h4>6.5.5.1    Simple Type Names</h4>
<a name="32799"></a>
If a type name consists of a single <em>Identifier</em>, then the identifier must occur in the scope of a declaration of a type with this name, or a compile-time error occurs. <p>
<a name="107164"></a>
It is possible that the identifier occurs within the scope of more than one type with that name, in which case the type denoted by the name is determined as follows:<p>
<ul><a name="21741"></a>
<li>If the simple type name occurs within the scope of a visible local class declaration <a href="statements.doc.html#247766">(&#167;14.3)</a> with that name, then the simple type name denotes that local class type.
<a name="72329"></a>
<li>Otherwise, if the simple type name occurs within the scope of exactly one visible member type (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), then the simple type name denotes that member type.
<a name="72330"></a>
<li>Otherwise, if the simple type name occurs within the scope of more than one visible member type, then the name is ambiguous as a type name; a compile-time error occurs.
<a name="72322"></a>
<li>Otherwise, if a type with that name is declared in the current compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a>, either by a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> or by a declaration of a class or interface &#32;type <a href="packages.doc.html#26783">(&#167;7.6)</a>, then the simple type name denotes that type. 
<a name="21751"></a>
<li>Otherwise, if a type with that name is declared in another compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> of the package <a href="packages.doc.html#26535">(&#167;7.1)</a> containing the identifier, then the identifier denotes that type.
<a name="21758"></a>
<li>Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> of the compilation unit containing the identifier, then the simple type name denotes that type.
<a name="32932"></a>
<li>Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit, then the name is ambiguous as a type name; a compile-time error occurs.
<a name="79949"></a>
<li>Otherwise, the name is undefined as a type name; a compile-time error occurs.
</ul><a name="32934"></a>
This order for considering type declarations is designed to choose the most explicit of two or more applicable type declarations.<p>
<a name="21811"></a>
<h4>6.5.5.2    Qualified Type Names</h4>
<a name="72865"></a>
If a type name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must be either a type name or a package name. If <i>Id</i> names exactly one type that is a member of the type or package denoted by <i>Q</i>, then the qualified type name denotes that type. If <i>Id</i> does not name a member type (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>) within <i>Q</i>, or the member type named <i>Id</i> within <i>Q</i> is not accessible <a href="names.doc.html#104285">(&#167;6.6)</a>, or <i>Id</i> names more than one member type within <i>Q</i>, then a compile-time error occurs. <p>
<a name="32816"></a>
The example:
<blockquote><pre>package wnj.test;
class Test {
	public static void main(String[] args) {
		java.util.Date date =
			new java.util.Date(System.currentTimeMillis());
		System.out.println(date.toLocaleString());
	}
}
</pre></blockquote><a name="21797"></a>
produced the following output the first time it was run:<p>
<blockquote><pre>Sun Jan 21 22:56:29 1996
</pre></blockquote><a name="21799"></a>
In this example the name <code>java.util.Date</code> must denote a type, so we first use the procedure recursively to determine if <code>java.util</code> is an accessible type or a package, which it is, and then look to see if the type <code>Date</code> is accessible in this package.<p>
<a name="21650"></a>
<h3>6.5.6    Meaning of Expression Names</h3>
<a name="32767"></a>
The meaning of a name classified as an <em>ExpressionName</em> is determined as follows.<p>
<a name="22022"></a>
<h4>6.5.6.1    Simple Expression Names</h4>
<a name="22023"></a>
If an expression name consists of a single <em>Identifier</em>, then:<p>
<ul><a name="22030"></a>
<li>If the <em>Identifier</em> appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a visible local variable declaration <a href="statements.doc.html#5920">(&#167;14.4)</a> or visible parameter declaration (<a href="classes.doc.html#38698">&#167;8.4.1</a>, <a href="classes.doc.html#29488">&#167;8.8.1</a>, <a href="statements.doc.html#79311">&#167;14.19</a>) with that name, then the expression name denotes a variable, that is, that local variable or parameter. There is necessarily at most one such local variable or parameter. The type of the expression name is the declared type of the local variable or parameter.
<a name="22052"></a>
<li>Otherwise, if the <em>Identifier</em> appears within a class declaration <a href="classes.doc.html#3857">(&#167;8)</a>:
<ul>
<a name="22062"></a>
<li>If the Identifier appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a visible field declaration with that name, then there must be a lexically enclosing type declaration of which that field is a member. Let T be the innermost such declaration. If there is not exactly one member of T that is a field with that name, then a compile-time error results. 
<a name="22063"></a>
<li>Otherwise, if the single member field with that name is declared <code>final</code> <a href="classes.doc.html#35962">(&#167;8.3.1.2)</a>, then the expression name denotes the value of the field. The type of the expression name is the declared type of the field. If the <i>Identifier</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22077"></a>
<li>Otherwise, the expression name denotes a variable, the single member field with that name. The type of the expression name is the field's declared type.
</ul>
</ul>
<ul>If the field is an instance variable <a href="classes.doc.html#37544">(&#167;8.3.1.1)</a>, the expression name must appear within the declaration of an instance method <a href="classes.doc.html#40420">(&#167;8.4)</a>, constructor <a href="classes.doc.html#41652">(&#167;8.8)</a>, or instance variable initializer <a href="classes.doc.html#38013">(&#167;8.3.2.2)</a>. If it appears within a <code>static</code> method <a href="classes.doc.html#229128">(&#167;8.4.3.2)</a>, static initializer <a href="classes.doc.html#39245">(&#167;8.7)</a>, or initializer for a <code>static</code> variable (<a href="classes.doc.html#37544">&#167;8.3.1.1</a>, <a href="execution.doc.html#44630">&#167;12.4.2</a>), then a compile-time error occurs.
</ul><ul><a name="60376"></a>
<li>Otherwise, the identifier appears within an interface declaration <a href="interfaces.doc.html#238678">(&#167;9)</a>:
<ul>
<a name="60380"></a>
<li>If the Identifier appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a visible field declaration with that name, then there must be an enclosing type declaration T of which that field is a member. If there is not exactly one member of T that is a field with that name, then a compile-time error results.
<a name="32963"></a>
<li>Otherwise, the expression name denotes the value of the single member field of that name. The type of the expression name is the declared type of the field. If the <i>Identifier</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
</ul>
</ul><a name="79966"></a>
In the example:<p>
<blockquote><pre>class Test {
	static int v;
	static final int f = 3;
	public static void main(String[] args) {
		int i;
		i = 1;
		v = 2;
		f = 33;										// compile-time error
		System.out.println(i + " " + v + " " + f);
	}
}
</pre></blockquote><a name="22130"></a>
the names used as the left-hand-sides in the assignments to <code>i</code>, <code>v</code>, and <code>f</code> denote the local variable <code>i</code>, the field <code>v</code>, and the value of <code>f</code> (not the variable <code>f</code>, because <code>f</code> is a <code>final</code> variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:<p>
<blockquote><pre>1 2 3
</pre></blockquote><a name="22133"></a>
<h4>6.5.6.2    Qualified Expression Names</h4>
<a name="33085"></a>
If an expression name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a package name, a type name, or an expression name:<p>
<ul><a name="22747"></a>
<li>If <i>Q</i> is a package name, then a compile-time error occurs.
<a name="22294"></a>
<li>If <i>Q</i> is a type name that names a class type <a href="classes.doc.html#3857">(&#167;8)</a>, then:
<ul>
<a name="22298"></a>
<li>If there is not exactly one accessible <a href="names.doc.html#104285">(&#167;6.6)</a> member of the class type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22299"></a>
<li>Otherwise, if the single accessible member field is not a class variable (that is, it is not declared <code>static</code>), then a compile-time error occurs.
<a name="41289"></a>
<li>Otherwise, if the class variable is declared <code>final</code>, then <i>Q</i><code>.</code><i>Id</i> denotes the value of the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22303"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable.
</ul>
<a name="22145"></a>
<li>If <i>Q</i> is a type name that names an interface type <a href="interfaces.doc.html#238678">(&#167;9)</a>, then:
<ul>
<a name="33167"></a>
<li>If there is not exactly one accessible <a href="names.doc.html#104285">(&#167;6.6)</a> member of the interface type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="33169"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
</ul>
<a name="22165"></a>
<li>If <i>Q</i> is an expression name, let <i>T</i> be the type of the expression <i>Q</i>:
<ul>
<a name="22169"></a>
<li>If <i>T</i> is not a reference type, a compile-time error occurs.
<a name="33185"></a>
<li>If there is not exactly one accessible <a href="names.doc.html#104285">(&#167;6.6)</a> member of the type <i>T</i> that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22170"></a>
<li>Otherwise, if this field is any of the following:
<ul>
<a name="33204"></a>
<li>A field of an interface type
<a name="33205"></a>
<li>A <code>final</code> field of a class type (which may be either a class variable or an instance variable)
<a name="33208"></a>
<li>The <code>final</code> field <code>length</code> of an array type
<br>then <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<br>
</ul>
<a name="22173"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes a variable, the field <i>Id</i> of class <i>T</i>, which may be either a class variable or an instance variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field
<a name="98602"></a>
<p>The example:
</ul>
</ul><blockquote><pre>class Point {
	int x, y;
	static int nPoints;
}
class Test {
	public static void main(String[] args) {
		int i = 0;
		i.x++;			// compile-time error
		Point p = new Point();
		p.nPoints();	// compile-time error
	}
}
</pre></blockquote><a name="22187"></a>
encounters two compile-time errors, because the <code>int</code> variable <code>i</code> has no members, and because <code>nPoints</code> is not a method of class <code>Point</code>.<p>
<a name="21652"></a>
<h3>6.5.7    Meaning of Method Names</h3>
<a name="32771"></a>
A <em>MethodName</em> can appear only in a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The meaning of a name classified as a <em>MethodName</em> is determined as follows.<p>
<a name="54512"></a>
<h4>6.5.7.1    Simple Method Names</h4>
<a name="104325"></a>
If a method name consists of a single <em>Identifier</em>, then <em>Identifier</em> is the method name to be used for method invocation. The <em>Identifier</em> must name at least one method of a class or interface within whose declaration the <em>Identifier</em> appears. See <a href="expressions.doc.html#20448">&#167;15.12</a> for further discussion of the interpretation of simple method names in method invocation expressions.<p>
<a name="54547"></a>
<h4>6.5.7.2    Qualified Method Names</h4>
<a name="104276"></a>
If a method name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a package name, a type name, or an expression name. If <i>Q</i> is a package name, then a compile-time error occurs. Otherwise, <i>Id</i> is the method name to be used for method invocation. If <i>Q</i> is a type name, then <i>Id</i> must name at least one <code>static</code> method of the type <i>Q</i>. If <i>Q</i> is an expression name, then let <i>T</i> be the type of the expression <i>Q</i>; <i>Id</i> must name at least one method of the type <i>T</i>. See <a href="expressions.doc.html#20448">&#167;15.12</a> for further discussion of the interpretation of qualified method names in method invocation expressions.<p>
<a name="104285"></a>
<h2>6.6    Access Control</h2>
<a name="33924"></a>
The Java programming language provides mechanisms for <em>access control</em>, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. If access is permitted, then the accessed entity is said to be <em>accessible</em>.<p>
<a name="104333"></a>
Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers. Qualified names are a means of access to members of packages and reference types; related means of access include field access expressions <a href="expressions.doc.html#41267">(&#167;15.11)</a> and method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>. All three are syntactically similar in that a "<code>.</code>" token appears, preceded by some indication of a package, type, or expression having a type and followed by an <em>Identifier</em> that names a member of the package or type. These are collectively known as constructs for <em>qualified access</em>.<p>
<a name="104350"></a>
Access control applies to qualified access and to the invocation of constructors by class instance creation expressions <a href="expressions.doc.html#41147">(&#167;15.9)</a> and explicit constructor invocations <a href="classes.doc.html#78435">(&#167;8.8.5)</a>. Accessibility also affects inheritance of class members <a href="classes.doc.html#21831">(&#167;8.2)</a>, including hiding and method overriding <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a>.<p>
<a name="102765"></a>
<h3>6.6.1    Determining Accessibility</h3>
<ul><a name="102769"></a>
<li>A package is always <em>accessible</em>.
<a name="102776"></a>
<li>If a class or interface type is declared <code>public</code>, then it may be accessed by any code, provided that the compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> in which it is declared is observable. If a top level class or interface type is not declared <code>public</code>, then it may be accessed only from within the package in which it is declared.
<a name="106781"></a>
<li>An array type is accessible if and only if its element type is accessible.
<a name="62410"></a>
<li>A member (class, interface, field, or method) of a reference (class, interface, or array) type or a constructor of a class type is accessible only if the type is accessible and the member or constructor is declared to permit access:
<ul>
<a name="62795"></a>
<li>If the member or constructor is declared <code>public</code>, then access is permitted. All members of interfaces are implicitly <code>public</code>.
<a name="62561"></a>
<li>Otherwise, if the member or constructor is declared <code>protected</code>, then access is permitted only when one of the following is true:
<ul><ul>
<a name="62562"></a>
<li>Access to the member or constructor occurs from within the package containing the class in which the <code>protected</code> member or constructor is declared.
<a name="62452"></a>
<li>Access is correct as described in <a href="names.doc.html#62587">&#167;6.6.2</a>.
</ul>
</ul><a name="62857"></a>
<li>Otherwise, if the member or constructor is declared <code>private</code>, then access is permitted if and only if it occurs within the body of the top level class <a href="packages.doc.html#26783">(&#167;7.6)</a> that encloses the declaration of the member. 
<a name="62586"></a>
<li>Otherwise, we say there is default access, which is permitted only when the access occurs from within the package in which the type is declared.
</ul>
</ul><a name="62587"></a>
<h3>6.6.2    Details on <code>protected Access</code></h3>
<a name="62638"></a>
A <code>protected</code> member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object. <p>
<a name="60602"></a>
<h4>6.6.2.1    Access to a <code>protected</code> Member</h4>
<a name="104383"></a>
Let <i>C</i> be the class in which a <code>protected</code> member m is declared. Access is permitted only within the body of a subclass <i>S </i>of <i>C</i>. In addition, if <i>Id</i> denotes an instance field or instance method, then:<p>
<ul><a name="33946"></a>
<li>If the access is by a qualified name <i>Q</i><code>.</code><i>Id</i>, where <i>Q</i> is an <em>ExpressionName</em>, then the access is permitted if and only if the type of the expression <i>Q</i> is <i>S</i> or a subclass of <i>S</i>.
<a name="72727"></a>
<li>If the access is by a field access expression <i>E</i><code>.</code><i>Id</i>, where <i>E</i> is a <em>Primary</em> expression, or by a method invocation expression <i>E</i><code>.</code><i>Id</i><code>(</code>. . .<code>)</code>, where <i>E</i> is a <em>Primary</em> expression, then the access is permitted if and only if the type of <i>E</i> is <i>S</i> or a subclass of <i>S</i>.
</ul><a name="72728"></a>
<h4>6.6.2.2    Qualified Access to a <code>protected</code> Constructor</h4>
<a name="72596"></a>
Let <i>C</i> be the class in which a <code>protected</code> constructor is declared and let <i>S</i> be the innermost class in whose declaration the use of the <code>protected</code> constructor occurs. Then:<p>
<ul><a name="73445"></a>
<li>If the access is by a superclass constructor invocation <code>super(</code>. . .<code>)</code> or by a qualified superclass constructor invocation of the form <i>E</i><code>.super(. . .)</code>, where <i>E</i> is a <i>Primary</i> expression,<i> </i>then the access is permitted.
<a name="95698"></a>
<li>If the access is by an anonymous class instance creation expression of the form <code>new</code><i> C</i><code>(. . .){...}</code> or by a qualified class instance creation expression of the form <i>E</i><code>.new C(. . .){...}</code>, where <i>E</i> is a <i>Primary</i> expression, then the access is permitted.
<a name="95700"></a>
<li>Otherwise, if the access is by a simple class instance creation expression of the form <code>new</code> <i>C</i><code>(</code>. . .<code>)</code> or by a qualified class instance creation expression of the form <i>E</i><code>.new C(. . .)</code>, where <i>E</i> is a <i>Primary</i> expression, then the access is not permitted. A <code>protected</code> constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) only from within the package in which it is defined.
</ul><a name="62666"></a>
<h3>6.6.3    An Example of Access Control</h3>
<a name="62647"></a>
For examples of access control, consider the two compilation units:<p>
<blockquote><pre>package points;
class PointVec { Point[] vec; }
</pre></blockquote><a name="33960"></a>
and:<p>
<blockquote><pre>package points;
public class Point {
	protected int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
	public int getX() { return x; }
	public int getY() { return y; }
}
</pre></blockquote><a name="33968"></a>
which declare two class types in the package <code>points</code>:<p>
<ul><a name="33969"></a>
<li>The class type <code>PointVec</code> is not <code>public</code> and not part of the <code>public</code> interface of the package <code>points</code>, but rather can be used only by other classes in the package.
<a name="33970"></a>
<li>The class type <code>Point</code> is declared <code>public</code> and is available to other packages. It is part of the <code>public</code> interface of the package <code>points</code>.
<a name="33971"></a>
<li>The methods <code>move</code>, <code>getX</code>, and <code>getY</code> of the class <code>Point</code> are declared <code>public</code> and so are available to any code that uses an object of type <code>Point</code>.
<a name="33972"></a>
<li>The fields <code>x</code> and <code>y</code> are declared <code>protected</code> and are accessible outside the package <code>points</code> only in subclasses of class <code>Point,</code> and only when they are fields of objects that are being implemented by the code that is accessing them.
</ul><a name="33976"></a>
See <a href="names.doc.html#36191">&#167;6.6.7</a> for an example of how the <code>protected</code> access modifier limits access. <p>
<a name="36060"></a>
<h3>6.6.4    Example: Access to <code>public</code> and <code>Non-public</code> Classes</h3>
<a name="36063"></a>
If a class lacks the <code>public</code> modifier, access to the class declaration is limited to the package in which it is declared <a href="names.doc.html#104285">(&#167;6.6)</a>. In the example:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
}
class PointList {
	Point next, prev;
}
</pre></blockquote><a name="36084"></a>
two classes are declared in the compilation unit. The class <code>Point</code> is available outside the package <code>points</code>, while the class <code>PointList</code> is available for access only within the package. <p>
<a name="107165"></a>
Thus a compilation unit in another package can access <code>points.Point</code>, either by using its fully qualified name:
<blockquote><pre>package pointsUser;
class Test {
	public static void main(String[] args) {
		points.Point p = new points.Point();
		System.out.println(p.x + " " + p.y);
	}
}
</pre></blockquote><a name="36092"></a>
or by using a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> that mentions the fully qualified name, so that the simple name may be used thereafter:<p>
<blockquote><pre>package pointsUser;
import points.Point;
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println(p.x + " " + p.y);
	}
}
</pre></blockquote><a name="36104"></a>
However, this compilation unit cannot use or import <code>points.PointList</code>, which is not declared <code>public</code> and is therefore inaccessible outside package <code>points</code>.<p>
<a name="36154"></a>
<h3>6.6.5    Example: Default-Access Fields, Methods, and Constructors</h3>
<a name="36155"></a>
If none of the access modifiers <code>public</code>, <code>protected</code>, or <code>private</code> are specified, a class member or constructor is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package. <p>
<a name="107169"></a>
If a <code>public</code> class has a method or constructor with default access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.
<a name="60607"></a>
<p>
For example, if we have:
<blockquote><pre>package points;
public class Point {
	public int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
	public void moveAlso(int dx, int dy) { move(dx, dy); }
}
</pre></blockquote><a name="36161"></a>
then a subclass in another package may declare an unrelated <code>move</code> method, with the same signature <a href="classes.doc.html#24510">(&#167;8.3.2)</a> and return type. Because the original <code>move</code> method is not accessible from package <code>morepoints</code>, <code>super</code> may not be used:<p>
<blockquote><pre>package morepoints;
public class PlusPoint extends points.Point {
	public void move(int dx, int dy) {
		super.move(dx, dy);								// compile-time error
		moveAlso(dx, dy);
	}
}
</pre></blockquote><a name="61629"></a>
Because move of <code>Point</code> is not overridden by <code>move</code> in <code>PlusPoint</code>, the method <code>moveAlso</code> in <code>Point</code> never calls the method move in <code>PlusPoint</code>.<p>
<a name="61639"></a>
Thus if you delete the <code>super.move</code> call from <code>PlusPoint</code> and execute the test program:
<blockquote><pre>import points.Point;
import morepoints.PlusPoint;
class Test {
    public static void main(String[] args) {
        PlusPoint pp = new PlusPoint();
        pp.move(1, 1);
	}
}
</pre></blockquote><a name="61640"></a>
it terminates normally. If move of <code>Point</code> were overridden by <code>move</code> in <code>PlusPoint</code>, then this program would recurse infinitely, until a <code>StackoverflowError</code> occurred.<p>
<a name="36250"></a>
<h3>6.6.6    Example: <code>public</code> Fields, Methods, and Constructors</h3>
<a name="36251"></a>
A <code>public</code> class member or constructor is accessible throughout the package where it is declared and from any other package, provided the package in which it is declared is observable <a href="packages.doc.html#13180">(&#167;7.4.3)</a>. For example, in the compilation unit:<p>
<blockquote><pre>package points;
public class Point {
	int x, y;
	public void move(int dx, int dy) {
		x += dx; y += dy;
		moves++;
	}
	public static int moves = 0;
}
</pre></blockquote><a name="36189"></a>
the <code>public</code> class <code>Point</code> has as <code>public</code> members the <code>move</code> method and the <code>moves</code> field. These <code>public</code> members are accessible to any other package that has access to package <code>points</code>. The fields <code>x</code> and <code>y</code> are not <code>public</code> and therefore are accessible only from within the package <code>points</code>.<p>
<a name="36191"></a>
<h3>6.6.7    Example: <code>protected</code> Fields, Methods, and Constructors</h3>
<a name="36201"></a>
Consider this example, where the <code>points</code> package declares:<p>
<blockquote><pre>package points;
public class Point {
	protected int x, y;
	void warp(threePoint.Point3d a) {
		if (a.z &gt; 0)		// compile-time error: cannot access a.z
			a.delta(this);
	}
}
</pre></blockquote><a name="36204"></a>
and the <code>threePoint</code> package declares:<p>
<blockquote><pre>package threePoint;
import points.Point;
public class Point3d extends Point {
	protected int z;
	public void delta(Point p) {
		p.x += this.x;		// compile-time error: cannot access p.x
		p.y += this.y;		// compile-time error: cannot access p.y
	}
	public void delta3d(Point3d q) {
		q.x += this.x;
		q.y += this.y;
		q.z += this.z;
	}
}
</pre></blockquote><a name="36210"></a>
which defines a class <code>Point3d</code>. A compile-time error occurs in the method <code>delta </code>here: it cannot access the protected members <code>x</code> and <code>y</code> of its parameter <code>p</code>, because while <code>Point3d</code> (the class in which the references to fields <code>x</code> and <code>y</code> occur) is a subclass of <code>Point</code> (the class in which <code>x</code> and <code>y</code> are declared), it is not involved in the implementation of a <code>Point</code> (the type of the parameter <code>p</code>). The method <code>delta3d</code> can access the protected members of its parameter <code>q</code>, because the class <code>Point3d</code> is a subclass of <code>Point</code> and is involved in the implementation of a <code>Point3d</code>.<p>
<a name="36214"></a>
The method <code>delta</code> could try to cast (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>) its parameter to be a <code>Point3d</code>, but this cast would fail, causing an exception, if the class of <code>p</code> at run time were not <code>Point3d</code>.
<a name="61715"></a>
<p>A compile-time error also occurs in the method warp: it cannot access the protected member <code>z</code> of its parameter <code>a</code>, because while the class <code>Point</code> (the class in which the reference to field <code>z</code> occurs) is involved in the implementation of a <code>Point3d</code> (the type of the parameter <code>a</code>), it is not a subclass of <code>Point3d</code> (the class in which <code>z</code> is declared). 
<a name="36233"></a>
<h3>6.6.8    Example: <code>private</code> Fields, Methods, and Constructors</h3>
<a name="36235"></a>
A <code>private</code> class member or constructor is accessible only within the class body in which the member is declared and is not inherited by subclasses. In the example:<p>
<blockquote><pre>class Point {
	Point() { setMasterID(); }
	int x, y;
	private int ID;
	private static int masterID = 0;
	private void setMasterID() { ID = masterID++; }
}
</pre></blockquote><a name="36243"></a>
the <code>private</code> members <code>ID,</code> <code>masterID</code>, and <code>setMasterID</code> may be used only within the body of class <code>Point</code>. They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of <code>Point</code>.<p>
<a name="62528"></a>
See <a href="classes.doc.html#16830">&#167;8.8.8</a> for an example that uses a <code>private</code> constructor.
<a name="25430"></a>
<h2>6.7    Fully Qualified Names and Canonical Names</h2>
<a name="24074"></a>
Every package, top level class, top level interface, and primitive type has a <em>fully qualified name</em>. An array type has a fully qualified name if and only if its element type has a fully qualified name.<p>
<ul><a name="9478"></a>
<li>The fully qualified name of a primitive type is the keyword for that primitive type, namely <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>.
<a name="33330"></a>
<li>The fully qualified name of a named package that is not a subpackage of a named package is its simple name.
<a name="33332"></a>
<li>The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by "<code>.</code>", followed by the simple (member) name of the subpackage.
<a name="28912"></a>
<li>The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.
<a name="33340"></a>
<li>The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by "<code>.</code>", followed by the simple name of the class or interface.
<a name="71701"></a>
<li>A member class or member interface <i>M</i> of another class <i>C</i> has a fully qualified name if and only if <i>C</i> has a fully qualified name. In that case, the fully qualified name of <i>M</i> consists of the fully qualified name of <i>C</i>, followed by ".", followed by the simple name of <i>M</i>.
<a name="79979"></a>
<li>The fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "<code>[]</code>".
</ul><a name="79984"></a>
Examples:<p>
<ul><a name="79981"></a>
<li>The fully qualified name of the type <code>long</code> is "<code>long</code>".
<a name="12351"></a>
<li>The fully qualified name of the package <code>java.lang</code> is "<code>java.lang</code>" because it is subpackage <code>lang</code> of package <code>java</code>.
<a name="33392"></a>
<li>The fully qualified name of the class <code>Object</code>, which is defined in the package <code>java.lang</code>, is "<code>java.lang.Object</code>".
<a name="33394"></a>
<li>The fully qualified name of the interface <code>Enumeration</code>, which is defined in the package <code>java.util</code>, is "<code>java.util.Enumeration</code>".
<a name="33378"></a>
<li>The fully qualified name of the type "array of <code>double</code>" is "<code>double[]</code>".
<a name="33380"></a>
<li>The fully qualified name of the type "array of array of array of array of <code>String</code>" is "<code>java.lang.String[][][][]</code>".
</ul><a name="12352"></a>
In the example:<p>
<blockquote><pre>package points;
class Point { int x, y; }
class PointVec {
	Point[] vec;
}
</pre></blockquote><a name="73301"></a>
the fully qualified name of the type <code>Point</code> is "<code>points.Point</code>"; the fully qualified name of the type <code>PointVec</code> is "<code>points.PointVec</code>"; and the fully qualified name of the type of the field <code>vec</code> of class <code>PointVec</code> is "<code>points.Point[]</code>".<p>
<a name="73354"></a>
Every package, top level class, top level interface, and primitive type has a canonical name. An array type has a canonical name if and only if its element type has a canonical name. A member class or member interface <i>M</i> declared in another class <i>C</i> has a canonical name if and only if <i>C</i> has a canonical name. In that case, the canonical name of <i>M</i> consists of the canonical name of <i>C</i>, followed by ".", followed by the simple name of <i>M</i>. For every package, top level class, top level interface and primitive type, the canonical name is the same as the fully qualified name. The canonical name of an array type is defined only when the component type of the array has a canonical name. In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by "<code>[]</code>".<p>
<a name="81303"></a>
The difference between a fully qualified name and a canonical name can be seen in examples such as:
<blockquote><pre>package p;
class O1 { class I{}}
class O2 extends O1{};

</pre></blockquote><a name="81324"></a>
In this example both <code>p.O1.I</code> and <code>p.O2.I</code> are fully qualified names that denote the same class, but only <code>p.O1.I</code> is its canonical name.<p>
<a name="73307"></a>
<h2>6.8    Naming Conventions</h2>
<a name="9218"></a>
The class libraries of the Java platform attempt to use, whenever possible, names chosen according to the conventions presented here. These conventions help to make code more readable and avoid certain kinds of name conflicts.<p>
<a name="34468"></a>
We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the <code>sin</code> and <code>cos</code> methods of the class <code>java.lang.Math</code> have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.
<a name="9184"></a>
<h3>6.8.1    Package Names</h3>
<a name="9253"></a>
Names of packages that are to be made widely available should be formed as described in <a href="packages.doc.html#40169">&#167;7.7</a>. Such names are always qualified names whose first identifier consists of two or three lowercase letters that name an Internet domain, such as <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, <code>org</code>, or a two-letter ISO country code such as <code>uk</code> or <code>jp</code>. Here are examples of hypothetical unique names that might be formed under this convention:<p>
<blockquote><pre>com.JavaSoft.jag.Oak
org.npr.pledge.driver
uk.ac.city.rugby.game
<a name="32841"></a>
</pre></blockquote>
Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier <code>java</code>; package names that start with the identifier <code>java</code> are reserved by Sun for naming Java platform packages.
<a name="81419"></a>
<p>
When package names occur in expressions:
<ul><a name="81420"></a>
<li>If a package name is obscured by a field declaration, then <code>import</code> declarations <a href="packages.doc.html#70209">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="34379"></a>
<li>If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
<a name="34365"></a>
<p>
The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter. (The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.)
</ul><a name="29466"></a>
<h3>6.8.2    Class and Interface Type Names</h3>
<a name="32824"></a>
Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized. For example:<p>
<blockquote><pre><code>ClassLoader
</code><code>SecurityManager
</code><code>Thread
</code><code>Dictionary
</code>BufferedInputStream
</pre></blockquote>
<a name="9111"></a>
Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces <code>java.io.DataInput</code> and <code>java.io.DataOutput</code>; or it may be an adjective describing a behavior, as for the interfaces <code>Runnable</code> and <code>Cloneable</code>.
<a name="12992"></a>
<p>
Obscuring involving class and interface type names is rare. Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.
</pre></blockquote><a name="9322"></a>
<h3>6.8.3    Method Names</h3>
<a name="34563"></a>
Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized. Here are some additional specific conventions for method names:<p>
<ul><a name="34587"></a>
<li>Methods to <code>get</code> and <code>set</code> an attribute that might be thought of as a variable <i>V</i> should be named <code>get</code>V and <code>set</code>V. An example is the methods <code>getPriority</code> and <code>setPriority</code> of class <code>Thread</code>.
<a name="34594"></a>
<li>A method that returns the length of something should be named <code>length</code>, as in class <code>String</code>.
<a name="9341"></a>
<li>A method that tests a <code>boolean</code> condition <i>V</i> about an object should be named <code>is</code>V. An example is the method <code>isInterrupted</code> of class <code>Thread</code>.
<a name="34650"></a>
<li>A method that converts its object to a particular format <em>F</em> should be named <code>to</code>F. Examples are the method <code>toString</code> of class <code>Object</code> and the methods <code>toLocaleString</code> and <code>toGMTString</code> of class <code>java.util.Date</code>.
</ul><a name="34660"></a>
Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java Application Programming Interface classes, will make it easier to use.<p>
<a name="9384"></a>
Method names cannot obscure or be obscured by other names <a href="names.doc.html#21652">(&#167;6.5.7)</a>.
<a name="9351"></a>
<h3>6.8.4    Field Names</h3>
<a name="32831"></a>
Names of fields that are not <code>final</code> should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. Note that well-designed classes have very few <code>public</code> or <code>protected</code> fields, except for fields that are constants (<code>final</code> <code>static</code> fields) <a href="names.doc.html#9367">(&#167;6.8.5)</a>.<p>
<a name="56830"></a>
Fields should have names that are nouns, noun phrases, or abbreviations for nouns. Examples of this convention are the fields <code>buf</code>, <code>pos</code>, and <code>count</code> of the class <code>java.io.ByteArrayInputStream</code> and the field <code>bytesTransferred</code> of the class <code>java.io.InterruptedIOException</code>.
<a name="13055"></a>
<p>Obscuring involving field names is rare.
<ul><a name="29526"></a>
<li>If a field name obscures a package name, then an <code>import</code> declaration <a href="packages.doc.html#70209">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="13069"></a>
<li>If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class <a href="statements.doc.html#247766">(&#167;14.3)</a>.
<a name="29539"></a>
<li>Field names cannot obscure method names.
<a name="9539"></a>
<li>If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
</ul><a name="9367"></a>
<h3>6.8.5    Constant Names</h3>
<a name="9368"></a>
The names of constants in interface types should be, and <code>final</code> variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore "<code>_</code>" characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech. Examples of names for constants include <code>MIN_VALUE</code>, <code>MAX_VALUE</code>, <code>MIN_RADIX</code>, and <code>MAX_RADIX</code> of the class <code>Character</code>.<p>
<a name="9563"></a>
A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix, as in:
<blockquote><pre>interface ProcessStates {
	int PS_RUNNING = 0;
	int PS_SUSPENDED = 1;
}
</pre></blockquote><a name="13087"></a>
Obscuring involving constant names is rare:<p>
<ul><a name="62840"></a>
<li>Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter.
<a name="62841"></a>
<li>Constant names cannot obscure method names, because they are distinguished syntactically.
</ul><a name="62552"></a>
<h3>6.8.6    Local Variable and Parameter Names</h3>
<a name="81404"></a>
Local variable and parameter names should be short, yet meaningful. They are often short sequences of lowercase letters that are not words. For example:<p>
<ul><a name="81405"></a>
<li>Acronyms, that is the first letter of a series of words, as in <code>cp</code> for a variable holding a reference to a <code>ColoredPoint</code>
<a name="12410"></a>
<li>Abbreviations, as in <code>buf</code> holding a pointer to a <code>buffer</code> of some kind
<a name="12434"></a>
<li>Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example:
<ul>
<a name="12435"></a>
<li><code>in</code> and <code>out</code>, whenever some kind of input and output are involved, patterned after the fields of <code>System</code>
<a name="12436"></a>
<li><code>off</code> and <code>len</code>, whenever an offset and length are involved, patterned after the parameters to the <code>read</code> and <code>write</code> methods of the interfaces <code>DataInput</code> and <code>DataOutput</code> of <code>java.io</code>
<a name="12367"></a>
</ul>
</ul>
<p>One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are:
<a name="9148"></a>
<ul>
<li><code>b</code> for a <code>byte</code>
<a name="9149"></a>
<li><code>c</code> for a <code>char</code>
<a name="12485"></a>
<li><code>d</code> for a <code>double</code>
<a name="9150"></a>
<li><code>e</code> for an <code>Exception</code>
<a name="12479"></a>
<li><code>f</code> for a <code>float</code>
<a name="9151"></a>
<li><code>i</code>, <code>j</code>, and <code>k</code> for integers
<a name="12846"></a>
<li><code>l</code> for a <code>long</code>
<a name="9155"></a>
<li><code>o</code> for an <code>Object</code>
<a name="12475"></a>
<li><code>s</code> for a <code>String</code>
<a name="12474"></a>
<li><code>v</code> for an arbitrary value of some type
<a name="34406"></a>
</ul>
Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names <a href="packages.doc.html#40169">(&#167;7.7)</a>.
</ul><a name="65318"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="conversions.doc.html">Prev</a> | <a href="packages.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Packages</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="names.doc.html">Prev</a> | <a href="classes.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="34412"></a>
<p><strong>
CHAPTER
 7 </strong></p>
<a name="60384"></a>
<h1>Packages</h1>
<hr><p>
<a name="61541"></a>
Programs are organized as sets of packages. Each package has its own set of names for types, which helps to prevent name conflicts. A top level type is accessible <a href="names.doc.html#104285">(&#167;6.6)</a> outside the package that declares it only if the type is declared <code>public</code>.<p>
<a name="26517"></a>
The naming structure for packages is hierarchical <a href="packages.doc.html#26535">(&#167;7.1)</a>. The members of a package are class and interface types <a href="packages.doc.html#26783">(&#167;7.6)</a>, which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own.<p>
<a name="40294"></a>
A package can be stored in a file system <a href="packages.doc.html#37546">(&#167;7.2.1)</a> or in a database <a href="packages.doc.html#37739">(&#167;7.2.2)</a>. Packages that are stored in a file system have certain constraints on the organization of their compilation units to allow a simple implementation to find classes easily.<p>
<a name="26522"></a>
A package consists of a number of compilation units <a href="packages.doc.html#40031">(&#167;7.3)</a>. A compilation unit automatically has access to all types declared in its package and also automatically imports<em> </em>all of the public types declared in the predefined package<em> </em><code>java.lang</code>.<p>
<a name="26526"></a>
For small programs and casual development, a package can be unnamed <a href="packages.doc.html#26639">(&#167;7.4.2)</a> or have a simple name, but if code is to be widely distributed, unique package names should be chosen <a href="packages.doc.html#40169">(&#167;7.7)</a>. This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.
<a name="26535"></a>
<h2>7.1    Package Members</h2>
<a name="91953"></a>
The members of a package are subpackages and all the top level <a href="packages.doc.html#26783">(&#167;7.6)</a> class <a href="classes.doc.html#3857">(&#167;8)</a> and top level interface <a href="interfaces.doc.html#238678">(&#167;9)</a> types declared in all the compilation units <a href="packages.doc.html#40031">(&#167;7.3)</a> of the package.<p>
<a name="85252"></a>
For example, in the Java Application Programming Interface:<p>
<ul><a name="37559"></a>
<li>The package <code>java</code> has subpackages <code>awt</code>, <code>applet</code>, <code>io</code>, <code>lang</code>, <code>net</code>, and <code>util</code>, but no compilation units.
<a name="37560"></a>
<li>The package <code>java.awt</code> has a subpackage named <code>image</code>, as well as a number of compilation units containing declarations of class and interface types.
</ul><a name="13127"></a>
If the fully qualified name <a href="names.doc.html#25430">(&#167;6.7)</a> of a package is <i>P</i>, and <i>Q</i> is a subpackage of <i>P</i>, then <i>P</i><code>.</code><i>Q</i> is the fully qualified name of the subpackage.<p>
<a name="77109"></a>
A package may not contain two members of the same name, or a compile-time error results. <p>
<a name="77111"></a>
Here are some examples:
<ul><a name="37575"></a>
<li>Because the package <code>java.awt</code> has a subpackage <code>image</code>, it cannot (and does not) contain a declaration of a class or interface type named <code>image</code>.
<a name="73657"></a>
<li>If there is a package named <code>mouse</code> and a member type <code>Button</code> in that package (which then might be referred to as <code>mouse.Button</code>), then there cannot be any package with the fully qualified name <code>mouse.Button</code> or <code>mouse.Button.Click</code>.
<a name="73658"></a>
<li>If <code>com.sun.java.jag</code> is the fully qualified name of a type, then there cannot be any package whose fully qualified name is either <code>com.sun.java.jag</code> or <code>com.sun.java.jag.scrabble</code>.
<a name="73659"></a>
</ul>
The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level type <a href="packages.doc.html#26783">(&#167;7.6)</a> declared in that package. There is no special access relationship between a package named <code>oliver</code> and another package named <code>oliver.twist</code>, or between packages named <code>evelyn.wood</code> and <code>evelyn.waugh</code>. For example, the code in a package named <code>oliver.twist</code> has no better access to the types declared within package <code>oliver</code> than code in any other package.
<a name="37758"></a>
<h2>7.2    Host Support for Packages</h2>
<a name="37780"></a>
Each host determines how packages, compilation units, and subpackages are created and stored, and which compilation units are observable <a href="packages.doc.html#40031">(&#167;7.3)</a> in a particular compilation. <p>
<a name="89673"></a>
The observability of compilation units in turn determines which packages are observable, and which packages are in scope.
<a name="73467"></a>
<p>The packages may be stored in a local file system in simple implementations of the Java platform. Other implementations may use a distributed file system or some form of database to store source and/or binary code.
<a name="37546"></a>
<h3>7.2.1    Storing Packages in a File System</h3>
<a name="37463"></a>
As an extremely simple example, all the packages and source and binary code on a system might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name. The directory might contain the following immediate subdirectories:<p>
<blockquote><pre>com
gls
jag
java
wnj
</pre></blockquote><a name="37477"></a>
where directory <code>java</code> would contain the Java Application Programming Interface packages; the directories <code>jag</code>, <code>gls</code>, and <code>wnj</code> might contain packages that three of the authors of this specification created for their personal use and to share with each other within this small group; and the directory <code>com</code> would contain packages procured from companies that used the conventions described in <a href="packages.doc.html#40169">&#167;7.7</a> to generate unique names for their packages.<p>
<a name="37480"></a>
Continuing the example, the directory <code>java</code> would contain, among others, the following subdirectories:
<blockquote><pre>applet	
awt
io
lang
net
util
</pre></blockquote><a name="37490"></a>
corresponding to the packages <code>java.applet</code>, <code>java.awt</code>, <code>java.io</code>, <code>java.lang</code>, <code>java.net</code>, and <code>java.util</code> that are defined as part of the Java Application Programming Interface.<p>
<a name="37491"></a>
Still continuing the example, if we were to look inside the directory <code>util</code>, we might see the following files:
<blockquote><pre>
BitSet.java				Observable.java
BitSet.class				Observable.class
Date.java				Observer.java
Date.class				Observer.class
...
</pre></blockquote><a name="37466"></a>
where each of the <code>.java</code> files contains the source for a compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> that contains the definition of a class or interface whose binary compiled form is contained in the corresponding <code>.class</code> file.<p>
<a name="37599"></a>
Under this simple organization of packages, an implementation of the Java platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components. 
<a name="91586"></a>
<p>For example, if this simple organization were used on a UNIX system, where the file name separator is <code>/</code>, the package name:
<blockquote><pre>jag.scrabble.board
</pre></blockquote><a name="37601"></a>
would be transformed into the directory name:<p>
<blockquote><pre>jag/scrabble/board
</pre></blockquote><a name="37603"></a>
and:<p>
<blockquote><pre>com.sun.sunsoft.DOE
</pre></blockquote><a name="37605"></a>
would be transformed to the directory name:<p>
<blockquote><pre><code>com/sun/sunsoft/DOE
</code><a name="77903"></a>
</pre></blockquote>
A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As a convention, the character can be escaped by using, say, the <code>@</code> character followed by four hexadecimal digits giving the numeric value of the character, as in the <code>\u</code><i>xxxx</i> escape <a href="lexical.doc.html#100850">(&#167;3.3)</a>, so that the package name:
<blockquote><pre>
children.activities.crafts.papierM\u00e2ch\u00e9
</pre></blockquote><a name="77910"></a>
which can also be written using full Unicode as:<p>
<blockquote><pre>children.activities.crafts.papierM&acirc;ch&eacute;
</pre></blockquote><a name="37616"></a>
might be mapped to the directory name:<p>
<blockquote><pre>children/activities/crafts/papierM@00e2ch@00e9
</pre></blockquote><a name="37618"></a>
If the <code>@</code> character is not a valid character in a file name for some given host file system, then some other character that is not valid in an identifier could be used instead.<p>
<a name="37739"></a>
<h3>7.2.2    Storing Packages in a Database</h3>
<a name="37740"></a>
A host system may store packages and their compilation units and subpackages in a database.<p>
<a name="85462"></a>
Such a database must not impose the optional restrictions <a href="packages.doc.html#26783">(&#167;7.6)</a> on compilation units in file-based implementations. For example, a system that uses a database to store packages may not enforce a maximum of one <code>public</code> class or interface per compilation unit.
<a name="74243"></a>
<p>
Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.<p>
<a name="40031"></a>
<h2>7.3    Compilation Units</h2>
<a name="26594"></a>
<em>CompilationUnit </em>is the goal symbol <a href="grammars.doc.html#40415">(&#167;2.1)</a> for the syntactic grammar <a href="grammars.doc.html#151185">(&#167;2.3)</a> of Java programs. It is defined by the following productions:<p>
<ul><pre>
<em>CompilationUnit</em>:
<em>	PackageDeclaration</em><sub><i>opt</i></sub><code> </code>ImportDeclarations<sub><i>opt</i></sub><code> </code>TypeDeclarations<sub><i>opt
</i></sub>
<i>ImportDeclarations:
	ImportDeclaration
	ImportDeclarations<code> </code>ImportDeclaration

TypeDeclarations:
	TypeDeclaration
	TypeDeclarations<code> </code>TypeDeclaration
</i></pre></ul><a name="24124"></a>
Types declared in different compilation units can depend on each other, circularly. A Java compiler must arrange to compile all such types at the same time.<p>
<a name="35022"></a>
A <em>compilation unit</em> consists of three parts, each of which is optional:<p>
<ul><a name="35029"></a>
<li>A <code>package</code> declaration <a href="packages.doc.html#26619">(&#167;7.4)</a>, giving the fully qualified name <a href="names.doc.html#25430">(&#167;6.7)</a> of the package to which the compilation unit belongs. A compilation unit that has no package declaration is part of an unnamed package <a href="packages.doc.html#26639">(&#167;7.4.2)</a>.
<a name="35033"></a>
<li><code>import</code> declarations <a href="packages.doc.html#70209">(&#167;7.5)</a> that allow types from other packages to be referred to using their simple names
<a name="35037"></a>
<li>Top level type declarations <a href="packages.doc.html#26783">(&#167;7.6)</a> of class and interface types
</ul><a name="70276"></a>
Which compilation units are <em>observable</em> is determined by the host system. However, all the compilation units of the package <code>java</code> and its subpackages <code>lang</code> and <code>io</code> must always be observable. The observability of a compilation unit influences the observability of its package <a href="packages.doc.html#13180">(&#167;7.4.3)</a>.<p>
<a name="26614"></a>
Every compilation unit automatically and implicitly imports every <code>public</code> type name declared by the predefined package <code>java.lang</code>, so that the names of all those types are available as simple names, as described in <a href="packages.doc.html#26741">&#167;7.5.3</a>.<p>
<a name="26619"></a>
<h2>7.4    Package Declarations</h2>
<a name="35052"></a>
A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.<p>
<a name="26621"></a>
<h3>7.4.1    Named Packages</h3>
<a name="26626"></a>
A <em>package declaration</em> in a compilation unit specifies the name <a href="names.doc.html#31692">(&#167;6.2)</a> of the package to which the compilation unit belongs.<p>
<ul><pre>
<em>PackageDeclaration:
	</em><code>package </code><em>PackageName</em><code> ;
</code></pre></ul><a name="26629"></a>
The package name mentioned in a package declaration must be the fully qualified name <a href="names.doc.html#25430">(&#167;6.7)</a> of the package.<p>
<a name="26639"></a>
<h3>7.4.2    Unnamed Packages</h3>
<a name="70410"></a>
A compilation unit that has no package declaration is part of an unnamed package. <p>
<a name="73463"></a>
Note that an unnamed package cannot have subpackages, since the syntax of a package declaration always includes a reference to a named top level package.
<p>
<a name="73468"></a>
As an example, the compilation unit:<p>
<blockquote><pre>class FirstCall {
	public static void main(String[] args) {
		System.out.println("Mr. Watson, come here. "
						+ "I want you.");
	}
}
</pre></blockquote><a name="35114"></a>
defines a very simple compilation unit as part of an unnamed package.<p>
<a name="73470"></a>
An implementation of the Java platform must support at least one unnamed package; it may support more than one unnamed package but is not required to do so. Which compilation units are in each unnamed package is determined by the host system.<p>
<a name="73469"></a>
In implementations of the Java platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the "current working directory." The precise meaning of "current working directory" depends on the host system.
<a name="73471"></a>
<p>
Unnamed packages are provided by the Java platform principally for convenience when developing small or temporary applications or when just beginning development.
<a name="13180"></a>
<h3>7.4.3    Observability of a Package</h3>
<a name="70173"></a>
A package is <em>observable</em> if and only if either:<p>
<ul><a name="70174"></a>
<li>A compilation unit containing a declaration of the package is observable.
<a name="70175"></a>
<li>A subpackage of the package is observable.
<a name="89676"></a>
</ul>
One can conclude from the rule above and from the requirements on observable compilation units, that the packages <code>java</code>, <code>java.lang</code>, and <code>java.io</code> are always observable.
<a name="70172"></a>
<h3>7.4.4    Scope of a Package Declaration</h3>
<a name="91970"></a>
The scope of the declaration of an observable <a href="packages.doc.html#13180">(&#167;7.4.3)</a> top level package is all observable compilation units <a href="packages.doc.html#40031">(&#167;7.3)</a>. The declaration of a package that is not observable is never in scope. Subpackage declarations are never in scope.<p>
<a name="87388"></a>
It follows that the package <code>java</code> is always in scope <a href="names.doc.html#103228">(&#167;6.3)</a>.
<p>
<a name="91991"></a>
Package declarations never shadow other declarations.<p>
<a name="70209"></a>
<h2>7.5    Import Declarations</h2>
<a name="26658"></a>
An <em>import declaration</em> allows a named type to be referred to by a simple name <a href="names.doc.html#31692">(&#167;6.2)</a> that consists of a single identifier. Without the use of an appropriate <code>import</code> declaration, the only way to refer to a type declared in another package is to use a fully qualified name <a href="names.doc.html#25430">(&#167;6.7)</a>.<p>
<ul><pre>
<em>ImportDeclaration</em>:
	SingleTypeImportDeclaration
	TypeImportOnDemandDeclaration
</pre></ul><a name="37962"></a>
A single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> imports a single named type, by mentioning its canonical name. A type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> imports all the accessible types of a named type or package as needed.<p>
<a name="92000"></a>
The scope of a type imported by a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> or type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="packages.doc.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="69951"></a>
An <code>import</code> declaration makes types available by their simple names only within the compilation unit that actually contains the <code>import</code> declaration. The scope of the entities(s) it introduces specifically does not include the <code>package</code> statement, other <code>import</code> declarations in the current compilation unit, or other compilation units in the same package. See <a href="packages.doc.html#24151">&#167;7.5.4</a> for an illustrative example.<p>
<a name="26699"></a>
<h3>7.5.1    Single-Type-Import Declaration</h3>
<a name="13275"></a>
A <em>single-type-import declaration </em>imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type import declaration appears.<p>
<ul><pre>
<i>SingleTypeImportDeclaration:</i>
<code>	import </code><i>TypeName</i> ;
</pre></ul><a name="29086"></a>
The <em>TypeName</em> must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible <a href="names.doc.html#104285">(&#167;6.6)</a> or a compile-time error occurs.<p>
<a name="91940"></a>
A single-type-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="91942"></a>
<li>any top level type named <i>n</i> declared in another compilation unit of <i>p</i>.
<a name="91943"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration in <i>c</i>.
</ul><a name="91944"></a>
throughout <i>c.</i><p>
<a name="37971"></a>
The example:
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="45771"></a>
causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the type <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.doc.html#104058">(&#167;6.3.2)</a> by a declaration of a field, parameter, local variable, or nested type declaration with the same name.<p>
<a name="73473"></a>
If two single-type-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored. If another top level type with the same simple name is otherwise declared in the current compilation unit except by a type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a>, then a compile-time error occurs. <p>
<a name="73474"></a>
So the sample program:
<blockquote><pre>import java.util.Vector;
class Vector { Object[] vec; }
</pre></blockquote><a name="29137"></a>
causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:<p>
<blockquote><pre>import java.util.Vector;
import myVector.Vector;
</pre></blockquote><a name="29140"></a>
where <code>myVector</code> is a package containing the compilation unit:<p>
<blockquote><pre>package myVector;
public class Vector { Object[] vec; }
</pre></blockquote><a name="73475"></a>
The compiler keeps track of types by their binary names <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>.<p>
<a name="60471"></a>
Note that an import statement cannot import a subpackage, only a type. For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:
<blockquote><pre>
import java.util;		// incorrect: compile-time error
class Test { util.Random generator; }
</pre></blockquote><a name="26725"></a>
<h3>7.5.2    Type-Import-on-Demand Declaration</h3>
<a name="26727"></a>
A <em>type-import-on-demand declaration</em> allows all accessible <a href="names.doc.html#104285">(&#167;6.6)</a> types declared in the type or package named by a canonical name to be imported as needed.<p>
<ul><pre>
<i>TypeImportOnDemandDeclaration:</i>
<em>	</em><code>import </code><i>PackageOrType<em>Name</i></em><code> . * ;
</code></pre></ul><a name="91257"></a>
It is a compile-time error for a type-import-on-demand declaration to name a type or package that is not accessible. Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package; the effect is as if there were exactly one such declaration. It is not a compile-time error to name the current package or <code>java.lang</code> in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases<p>
<a name="92030"></a>
A type-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="91265"></a>
The example:<p>
<blockquote><pre>import java.util.*;
</pre></blockquote><a name="35216"></a>
causes the simple names of all <code>public</code> types declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the type <code>Vector</code> in the package <code>java.util</code> in all places in the compilation unit where that type declaration is not shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.doc.html#104058">(&#167;6.3.2)</a>. The declaration might be shadowed by a single-type-import declaration of a type whose simple name is <code>Vector</code>; by a type named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces. The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector </code>(It would be unusual for any of these conditions to occur.)<p>
<a name="26741"></a>
<h3>7.5.3    Automatic Imports</h3>
<a name="26743"></a>
Each compilation unit automatically imports all of the<em> </em><code>public</code> type names declared in the predefined package<em> </em><code>java.lang</code>, as if the declaration:<p>
<blockquote><pre>import java.lang.*;
</pre></blockquote><a name="26745"></a>
appeared at the beginning of each compilation unit, immediately following any <code>package</code> statement.<p>
<a name="24151"></a>
<h3>7.5.4    A Strange Example</h3>
<a name="24152"></a>
Package names and type names are usually different under the naming conventions described in <a href="names.doc.html#73307">&#167;6.8</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a <code>public</code> class named <code>Mosquito</code>:<p>
<blockquote><pre>package Vector;
public class Mosquito { int capacity; }
</pre></blockquote><a name="24158"></a>
and then the compilation unit:<p>
<blockquote><pre>package strange.example;
import java.util.Vector;
import Vector.Mosquito;
class Test {
	public static void main(String[] args) {
		System.out.println(new Vector().getClass());
		System.out.println(new Mosquito().getClass());
	}
}
</pre></blockquote><a name="24170"></a>
the single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:<p>
<blockquote><pre>class java.util.Vector
class Vector.Mosquito
</pre></blockquote><a name="26783"></a>
<h2>7.6    Top Level Type Declarations</h2>
<a name="26790"></a>
A top level <em>type declaration</em> declares a top level class type <a href="classes.doc.html#3857">(&#167;8)</a> or a top level interface type <a href="interfaces.doc.html#238678">(&#167;9)</a>:<p>
<ul><pre>
<i>TypeDeclaration:</i>
	ClassDeclaration
	InterfaceDeclaration
	<code>;
</code></pre></ul><a name="70047"></a>
By default, the top level types declared in a package are accessible only within the compilation units of that package, but a type may be declared to be <code>public</code> to grant access to the type from code in other packages (<a href="names.doc.html#104285">&#167;6.6</a>, <a href="classes.doc.html#21613">&#167;8.1.1</a>, <a href="interfaces.doc.html#235947">&#167;9.1.1</a>).<p>
<a name="92016"></a>
The scope of a top level type is all type declarations in the package in which the top level type is declared.<p>
<a name="92021"></a>
If a top level type named <i>T</i> is declared in a compilation unit of a package whose fully qualified name is <i>P</i>, then the fully qualified name of the type is <i>P</i><code>.</code><i>T</i>.<i> </i>If the type is declared in an unnamed package <a href="packages.doc.html#26639">(&#167;7.4.2)</a>, then the type has the fully qualified name <i>T</i>.<p>
<a name="91788"></a>
<i></i>Thus in the example:<p>
<blockquote><pre>package wnj.points;
class Point { int x, y; }
</pre></blockquote><a name="70050"></a>
the fully qualified name of class <code>Point</code> is <code>wnj.points.Point</code>. <p>
<a name="26802"></a>
An implementation of the Java platform must keep track of types within packages by their binary names <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>. Multiple ways of naming a type must be expanded to binary names to make sure that such names are understood as referring to the same type. <p>
<a name="73490"></a>
For example, if a compilation unit contains the single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a>:
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="26807"></a>
then within that compilation unit the simple name <code>Vector</code> and the fully qualified name <code>java.util.Vector</code> refer to the same type.<p>
<a name="73491"></a>
When packages are stored in a file system <a href="packages.doc.html#37546">(&#167;7.2.1)</a>, the host system may choose to enforce the restriction that it is a compile-time error if a type is not found in a file under a name composed of the type name plus an extension (such as <code>.java</code> or <code>.jav</code>) if either of the following is true:<p>
<ul><a name="40155"></a>
<li>The type is referred to by code in other compilation units of the package in which the type is declared.
<a name="40159"></a>
<li>The type is declared <code>public</code> (and therefore is potentially accessible from code in other packages).
</ul><a name="40156"></a>
This restriction implies that there must be at most one such type per compilation unit. This restriction makes it easy for a compiler for the Java programming language or an implementation of the Java virtual machine to find a named class within a package; for example, the source code for a <code>public</code> type <code>wet.sprocket.Toad</code> would be found in a file <code>Toad.java</code> in the directory <code>wet/sprocket</code>, and the corresponding object code would be found in the file <code>Toad.class</code> in the same directory.<p>
<a name="20150"></a>
When packages are stored in a database <a href="packages.doc.html#37739">(&#167;7.2.2)</a>, the host system must not impose such restrictions. <p>
<a name="73495"></a>
In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is <code>public</code> or is referred to by code in other compilation units.
<a name="73496"></a>
A compile-time error occurs if the name of a top level type appears as the name of any other top level class or interface type declared in the same package <a href="packages.doc.html#26783">(&#167;7.6)</a>.<p>
<a name="70145"></a>
A compile-time error occurs if the name of a top level type is also declared as a type by a single-type-import declaration <a href="packages.doc.html#26699">(&#167;7.5.1)</a> in the compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> containing the type declaration.<p>
<a name="69817"></a>
In the example:
<blockquote><pre>class Point { int x, y; }
</pre></blockquote><a name="69819"></a>
the class Point is declared in a compilation unit with no package statement, and thus Point is its fully qualified name, whereas in the example:<p>
<blockquote><pre>package vista;
class Point { int x, y; }
</pre></blockquote><a name="69822"></a>
the fully qualified name of the class Point is <code>vista.Point</code>. (The package name vista is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name <a href="packages.doc.html#40169">(&#167;7.7)</a>.)<p>
<a name="69837"></a>
In the example:
<blockquote><pre>package test;
import java.util.Vector;
class Point {
<a name="69841"></a>	int x, y;
}
interface Point {			// compile-time error #1
	int getR();
	int getTheta();
}
class Vector { Point[] pts; }		// compile-time error #2
</pre></blockquote><a name="69848"></a>
the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an <code>interface</code> in the same package. A second error detected at compile time is the attempt to declare the name Vector both by a class type declaration and by a single-type-import declaration.<p>
<a name="69849"></a>
Note, however, that it is not an error for the name of a class to also to name a type that otherwise might be imported by a type-import-on-demand declaration <a href="packages.doc.html#26725">(&#167;7.5.2)</a> in the compilation unit <a href="packages.doc.html#40031">(&#167;7.3)</a> containing the class declaration. In the example:
<blockquote><pre>package test;
import java.util.*;
class Vector { Point[] pts; }		// not a compile-time error
</pre></blockquote><a name="69859"></a>
the declaration of the class Vector is permitted even though there is also a class java.util.Vector. Within this compilation unit, the simple name Vector refers to the class test.Vector, not to java.util.Vector (which can still be referred to by code within the compilation unit, but only by its fully qualified name).<p>
<a name="69810"></a>
As another example, the compilation unit:
<blockquote><pre>package points;
class Point {
	int x, y;			// coordinates
	PointColor color;		// color of this point
	Point next;			// next point with this color
	static int nPoints;
}
class PointColor {
	Point first;			// first point with this color
	PointColor(int color) {
		this.color = color;
	}
	private int color;		// color components
}
</pre></blockquote><a name="80061"></a>
defines two classes that use each other in the declarations of their class members. Because the class types Point and PointColor have all the type declarations in package points, including all those in the current compilation unit, as their scope, this example compiles correctly-that is, forward reference is not a problem.<p>
<a name="69901"></a>
It is a compile-time error if a top level type declaration contains any one of the following access modifiers: protected, private or static.<p>
<a name="40169"></a>
<h2>7.7    Unique Package Names</h2>
<a name="37792"></a>
Developers should take steps to avoid the possibility of two published packages having the same name by choosing <em>unique package names</em> for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.<p>
<a name="37825"></a>
If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create &#32;a situation that is difficult or impossible for the user or programmer to resolve. The class <code>ClassLoader</code> can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a na&iuml;ve program.
<a name="26818"></a>
<p>You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as <code>sun.com</code>. You then reverse this name, component by component, to obtain, in this example, <code>com.sun</code>, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names.
<a name="77945"></a>
<p>In some cases, the internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations:
<ul><a name="77954"></a>
<li>If the domain name contains a hyphen, or any other special character not allowed in an identifier <a href="lexical.doc.html#40625">(&#167;3.8)</a>, convert it into an underscore.
<a name="77968"></a>
<li>If any of the resulting package name components are keywords <a href="lexical.doc.html#229308">(&#167;3.9)</a> then append underscore to them.
<a name="77982"></a>
<li>If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
<a name="26819"></a>
</ul>
Such a convention might specify that certain directory name components be division, department, project, machine, or login names. Some possible examples:
<blockquote><pre>com.sun.sunsoft.DOE
com.sun.java.jag.scrabble
com.apple.quicktime.v2
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder
</pre></blockquote><a name="91495"></a>
The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, currently <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, <code>org</code>, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166, 1981. For more information, refer to the documents stored at <code>ftp://rs.internic.net/rfc</code>, for example, <code>rfc920.txt</code> and <code>rfc1032.txt</code>.<p>
<a name="91496"></a>
The name of a package is not meant to imply where the package is stored within the Internet; for example, a package named <code>edu.cmu.cs.bovik.cheese</code> is not necessarily obtainable from Internet address <code>cmu.edu</code> or from <code>cs.cmu.edu</code> or from <code>bovik.cs.cmu.edu</code>. The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.
<a name="60426"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="names.doc.html">Prev</a> | <a href="classes.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Classes</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="packages.doc.html">Prev</a> | <a href="interfaces.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="3857"></a>
<p><strong>
CHAPTER
 8 </strong></p>
<a name="44365"></a>
<h1>Classes</h1>
<hr><p>
<a name="228205"></a>
Class declarations define new reference types and describe how they are implemented <a href="classes.doc.html#15372">(&#167;8.1)</a>.<p>
<a name="246201"></a>
A <em>nested class</em> is any class whose declaration occurs within the body of another class or interface. A <em>top level class</em> is a class that is not a nested class.<p>
<a name="246214"></a>
This chapter discusses the common semantics of all classes-top level <a href="packages.doc.html#26783">(&#167;7.6)</a> and nested (including member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), local classes <a href="statements.doc.html#247766">(&#167;14.3)</a> and anonymous classes <a href="expressions.doc.html#252986">(&#167;15.9.5)</a>). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs. <p>
<a name="228209"></a>
A named class may be declared <code>abstract</code> <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a> and must be declared <code>abstract</code> if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a>, in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from other packages.<p>
<a name="35674"></a>
Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class <a href="classes.doc.html#262560">(&#167;8.1.3)</a> and may implement interfaces <a href="classes.doc.html#34031">(&#167;8.1.4)</a>.
<a name="273974"></a>
<p>
The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors <a href="classes.doc.html#18988">(&#167;8.1.5)</a>. The scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a member <a href="classes.doc.html#21831">(&#167;8.2)</a> is the entire declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers <a href="names.doc.html#104285">(&#167;6.6)</a> <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members <a href="classes.doc.html#21831">(&#167;8.2)</a>. Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.<p>
<a name="15807"></a>
Field declarations <a href="classes.doc.html#40898">(&#167;8.3)</a> describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> <a href="classes.doc.html#35962">(&#167;8.3.1.2)</a>, in which case it can be assigned to only once. Any field declaration may include an initializer.<p>
<a name="245981"></a>
Member class declarations <a href="classes.doc.html#246026">(&#167;8.5)</a> describe nested classes that are members of the surrounding class. Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes <a href="classes.doc.html#262890">(&#167;8.1.2)</a>.<p>
<a name="245982"></a>
Member interface declarations <a href="classes.doc.html#246026">(&#167;8.5)</a> describe nested interfaces that are members of the surrounding class.<p>
<a name="35821"></a>
Method declarations <a href="classes.doc.html#40420">(&#167;8.4)</a> describe code that may be invoked by method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>. A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of the class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> <a href="classes.doc.html#11246">(&#167;8.4.3.3)</a>, in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code <a href="classes.doc.html#31125">(&#167;8.4.3.4)</a>. A <code>synchronized</code> method <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a> automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a>, thus allowing its activities to be synchronized with those of other threads <a href="memory.doc.html#26250">(&#167;17)</a>.<p>
<a name="227762"></a>
Method names may be overloaded <a href="classes.doc.html#227768">(&#167;8.4.7)</a>.<p>
<a name="246235"></a>
Instance initializers <a href="classes.doc.html#246032">(&#167;8.6)</a> are blocks of executable code that may be used to help initialize an instance when it is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="35837"></a>
Static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a> are blocks of executable code that may be used to help initialize a class when it is first loaded <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="259034"></a>
Constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded <a href="classes.doc.html#229266">(&#167;8.8.6)</a>.<p>
<a name="15372"></a>
<h2>8.1    Class Declaration</h2>
<a name="23643"></a>
A <em>class declaration</em> specifies a new named reference type:<p>
<ul><pre>
<em>ClassDeclaration:
	ClassModifiers<sub><i>opt</i></sub> </em>class<em> Identifier Super<sub><i>opt</i></sub> Interfaces<sub><i>opt</i></sub> ClassBody</em>
</pre></ul><a name="287266"></a>
The <em>Identifier</em> in a class declaration specifies the name of the class. A compile-time error occurs if a class has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="21613"></a>
<h3>8.1.1    Class Modifiers</h3>
<a name="54718"></a>
A class declaration may include <em>class modifiers</em>.<p>
<ul><pre>
<em>ClassModifiers:
	ClassModifier
	ClassModifiers ClassModifier

ClassModifier: one of</em>
	public&#32;protected&#32;private
	abstract&#32;static&#32;final&#32;strictfp
</pre></ul><a name="258803"></a>
Not all modifiers are applicable to all kinds of class declarations. The access modifier public pertains only to top level classes <a href="packages.doc.html#26783">(&#167;7.6)</a> and to member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), and is discussed in <a href="names.doc.html#104285">&#167;6.6</a>, <a href="classes.doc.html#246026">&#167;8.5</a> and <a href="interfaces.doc.html#252566">&#167;9.5</a>. The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration <a href="classes.doc.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.doc.html#247581">&#167;8.5.1</a>. The access modifier static pertains only to member classes (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in a class declaration. <p>
<a name="259039"></a>
If two or more class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.<p>
<a name="34944"></a>
<h4>8.1.1.1    <code>abstract</code> Classes</h4>
<a name="20269"></a>
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. Only <code>abstract</code> classes may have <code>abstract</code> methods (<a href="classes.doc.html#34484">&#167;8.4.3.1</a>, <a href="interfaces.doc.html#78651">&#167;9.4</a>), that is, methods that are declared but not yet implemented. If a class that is not <code>abstract</code> contains an <code>abstract</code> method, then a compile-time error occurs. A class C has <code>abstract</code> methods if any of the following is true:<p>
<ul><a name="36417"></a>
<li>C explicitly contains a declaration of an <code>abstract</code> method <a href="classes.doc.html#78188">(&#167;8.4.3)</a>.
<a name="250484"></a>
<li>Any of C's superclasses declares an <code>abstract</code> method that has not been implemented <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a> in C or any of its superclasses. 
<a name="14247"></a>
<li>A direct superinterface (<a href="classes.doc.html#34031">&#167;8.1.4</a>) of C declares or inherits a method (which is therefore necessarily <code>abstract</code>) and C neither declares nor inherits a method that implements it.
<a name="259043"></a>
<p>
</ul>
In the example:
<blockquote><pre>abstract class Point {
	int x = 1, y = 1;
	void move(int dx, int dy) {
		x += dx;
		y += dy;
		alert();
	}
	abstract void alert();
}
abstract class ColoredPoint extends Point {
	int color;
}
class SimplePoint extends Point {
	void alert() { }
}
</pre></blockquote><a name="259046"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared <code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides an implementation of <code>alert</code>, so it need not be <code>abstract</code>.<p>
<a name="259051"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>. <p>
<a name="259044"></a>
Thus, continuing the example just shown, the statement:
<blockquote><pre>	Point p = new Point();
</pre></blockquote><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not <code>abstract</code>, so the statement:<p>
<blockquote><pre>	Point p = new SimplePoint();
</pre></blockquote><a name="227782"></a>
would be correct.<p>
<a name="259056"></a>
A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.
<a name="292198"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a> but different return types. <p>
<a name="292194"></a>
As an example, the declarations:
<blockquote><pre>interface Colorable { void setColor(int color); }
abstract class Colored implements Colorable {
	abstract int setColor(int color);
}
</pre></blockquote><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class <code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, because the one in interface <code>Colorable</code> requires the same method to return no value, while the one in class <code>Colored</code> requires the same method to return a value of type <code>int</code> <a href="classes.doc.html#40420">(&#167;8.4)</a>.<p>
<a name="36521"></a>
A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="classes.doc.html#16830">(&#167;8.8.8)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:
<blockquote><pre>public final class Math {
	private Math() { }		// never instantiate this class
<em>	. . . declarations of class variables and methods . . .
</em><a name="259064"></a>
}
</pre></blockquote><a name="54727"></a>
<h4>8.1.1.2    <code>final</code> Classes</h4>
<a name="54729"></a>
A class can be declared <code>final</code> if its definition is complete and no subclasses are desired or required. A compile-time error occurs if the name of a <code>final</code> class appears in the <code>extends</code> clause <a href="classes.doc.html#262560">(&#167;8.1.3)</a> of another <code>class</code> declaration; this implies that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a class could never be completed <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="259069"></a>
Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a>.
<a name="251946"></a>
<h4>8.1.1.3    <code>strictfp</code> Classes</h4>
<a name="251947"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the class declaration be explicitly FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>. This implies that all methods declared in the class, and all nested types declared in the class, are implicitly <code>strictfp</code>. <p>
<a name="270918"></a>
Note also that all <code>float</code> or <code>double </code>expressions within all variable initializers, instance initializers, static initializers and constructors of the class will also be explicitly FP-strict.
<a name="262890"></a>
<h3>8.1.2    Inner Classes and Enclosing Instances</h3>
<a name="246255"></a>
An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a> or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields <a href="expressions.doc.html#5313">(&#167;15.28)</a>.<p>
<a name="263434"></a>
To illustrate these rules, consider the example below:
<blockquote><pre>class HasStatic{
	static int j = 100;
}
class Outer{
	class Inner extends HasStatic{
		static final x = 3;		// ok - compile-time constant
		static int y = 4; 		// compile-time error, an inner class
	}
	static class NestedButNotInner{
		static int z = 5; 		// ok, not an inner class
	}
	interface NeverInner{}		// interfaces are never inner
}
</pre></blockquote><a name="270924"></a>
Inner classes may inherit static members that are not compile-time constants even though they may not declare them. Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language. Member interfaces <a href="classes.doc.html#246026">(&#167;8.5)</a> are always implicitly static so they are never considered to be inner classes. <p>
<a name="255246"></a>
A statement or expression <em>occurs in a static context</em> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.<p>
<a name="247506"></a>
An inner class <i>C</i> is a <em>direct inner class of a class O</em> if <i>O</i> is the immediately lexically enclosing class of <i>C</i> and the declaration of <i>C</i> does not occur in a static context. A class <i>C</i> is an <i>inner class of class O</i> if it is either a direct inner class of <i>O</i> or an inner class of an inner class of <i>O</i>.<p>
<a name="255368"></a>
A class <i>O</i> is the <i>zeroth lexically enclosing class of itself</i>. A class <i>O</i> is the <i>nth lexically enclosing class of a class C</i> if it is the immediately enclosing class of the <i>n</i> - 1st lexically enclosing class of <i>C</i>.<p>
<a name="246965"></a>
An instance <i>i</i> of a direct inner class <i>C</i> of a class <i>O</i> is associated with an instance of <i>O</i>, known as the <i>immediately enclosing instance</i> of <i>i</i>. The immediately enclosing instance of an object, if any, is determined when the object is created <a href="expressions.doc.html#253028">(&#167;15.9.2)</a>.<p>
<a name="255371"></a>
An object <i>o</i> is the <i>zeroth lexically enclosing instance of itself</i>. An object <i>o</i> is the <i>nth lexically enclosing instance of an instance i</i> if it is the immediately enclosing instance of the <i>n</i> - 1st lexically enclosing instance of <i>i</i>.<p>
<a name="247026"></a>
When an inner class refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used. A blank final <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a> field of a lexically enclosing class may not be assigned within an inner class.<p>
<a name="250538"></a>
An instance of an inner class <i>I</i> whose declaration occurs in a static context has no lexically enclosing instances. However, if <i>I</i> is immediately declared within a static method or static initializer then <i>I</i> does have an <i>enclosing block</i>, which is the innermost block statement lexically enclosing the declaration of <i>I</i>.<p>
<a name="254910"></a>
Furthermore, for every superclass <i>S</i> of <i>C</i> which is itself a direct inner class of a class <i>SO</i>, there is an instance of <i>SO</i> associated with <i>i</i>, known as <em>the immediately enclosing instance of i with respect to S</em>. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.<p>
<a name="247496"></a>
Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared <code>final</code>, and must be definitely assigned <a href="defAssign.doc.html#25979">(&#167;16)</a> before the body of the inner class.<p>
<a name="247494"></a>
Inner classes include local <a href="statements.doc.html#247766">(&#167;14.3)</a>, anonymous <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> and non-static member classes <a href="classes.doc.html#246026">(&#167;8.5)</a>. Here are some examples:
<blockquote><pre>class Outer {
	int i = 100;
	static void classMethod() {
		final int l = 200;
		class LocalInStaticContext{
			int k = i; // compile-time error
			int m = l; // ok
		}
	}
	void foo() {
		class Local { // a local class
			int j = i;
		}
	}
}
</pre></blockquote>
<a name="262528"></a>
The declaration of class <code>LocalInStaticContext</code> occurs in a static context-within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are marked <code>final</code>).
<a name="262541"></a>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class. So, for example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:
<blockquote><pre>
class WithDeepNesting{
	boolean toBe;
	WithDeepNesting(boolean b) { toBe = b;}
	class Nested {
		boolean theQuestion;
		class DeeplyNested {
			DeeplyNested(){
				theQuestion = toBe || !toBe;
			}
		}
	}
}
</pre></blockquote><a name="270930"></a>
Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).<p>
<a name="262560"></a>
<h3>8.1.3    Superclasses and Subclasses</h3>
<a name="262569"></a>
The optional <code>extends</code> clause in a class declaration specifies the <em>direct superclass</em> of the current class. A class is said to be a <em>direct subclass</em> of the class it extends. The direct superclass is the class from whose implementation the implementation of the current class is derived. The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, because it is the primordial class and has no direct superclass. If the class declaration for any other class has no <code>extends</code> clause, then the class has the class <code>Object</code> as its implicit direct superclass.<p>
<ul><pre>
<i>Super:</i>
	extends <i>ClassType</i>
</pre></ul><a name="229540"></a>
The following is repeated from <a href="typesValues.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<ul><pre>
<i>ClassType:
	TypeName</i>
</pre></ul><a name="29813"></a>
The <em>ClassType</em> must name an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> class type, or a compile-time error occurs. If the specified <em>ClassType </em>names a class that is <code>final</code> <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a>, then a compile-time error occurs; <code>final</code> classes are not allowed to have subclasses.<p>
<a name="34088"></a>
In the example:
<blockquote><pre>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; } // error
</pre></blockquote><a name="29322"></a>
the relationships are as follows:<p>
<ul><a name="29323"></a>
<li>The class <code>Point</code> is a direct subclass of <code>Object</code>.
<a name="29324"></a>
<li>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.
<a name="35258"></a>
<li>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.
<a name="35261"></a>
<li>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.
</ul><a name="270940"></a>
The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the <code>final</code> class <code>ColoredPoint</code>.<p>
<a name="259080"></a>
The <em>subclass </em>relationship is the transitive closure of the direct subclass relationship. A class <i>A</i> is a subclass of class <i>C</i> if either of the following is true:<p>
<ul><a name="34080"></a>
<li><i>A</i> is the direct subclass of <i>C</i>.
<a name="34081"></a>
<li>There exists a class <i>B</i> such that <i>A</i> is a subclass of <i>B</i>, and <i>B</i> is a subclass of <i>C</i>, applying this definition recursively.
</ul><a name="34082"></a>
Class <i>C</i> is said to be a <em>superclass </em>of class <i>A</i> whenever <i>A</i> is a subclass of <i>C</i>.<p>
<a name="36594"></a>
In the example:
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }
</pre></blockquote><a name="35276"></a>
the relationships are as follows:<p>
<ul><a name="36602"></a>
<li>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.
<a name="36604"></a>
<li>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="36611"></a>
<li>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.
<a name="36613"></a>
<li>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="271013"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.
<a name="271014"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.
</ul><a name="271016"></a>
A class C <em>directly depends</em> on a type T if T is mentioned in the <code>extends</code> or <code>implements</code> clause of C either as a superclass or superinterface, or as a qualifier within a superclass or superinterface name. A class C <em>depends</em> on a reference type T if any of the following conditions hold:<p>
<ul><a name="251985"></a>
<li>C directly depends on T.
<a name="251987"></a>
<li>C directly depends on an interface I that depends <a href="interfaces.doc.html#78598">(&#167;9.1.2)</a> on T.
<a name="251993"></a>
<li>C directly depends on a class D that depends on T (using this definition recursively).
</ul><a name="251995"></a>
It is a compile-time error if a class depends on itself.<p>
<a name="250505"></a>
For example:
<blockquote><pre>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
</pre></blockquote><a name="270956"></a>
causes a compile-time error.<p>
<a name="259094"></a>
If circularly declared classes are detected at run time, as classes are loaded <a href="execution.doc.html#44459">(&#167;12.2)</a>, then a <code>ClassCircularityError</code> is thrown.<p>
<a name="34031"></a>
<h3>8.1.4    Superinterfaces</h3>
<a name="18953"></a>
The optional <code>implements</code> clause in a class declaration lists the names of interfaces that are <em>direct superinterfaces</em> of the class being declared:<p>
<ul><pre>
<i>Interfaces:</i>
	implements <i>InterfaceTypeList

InterfaceTypeList:
	InterfaceType
	InterfaceTypeList , InterfaceType</i>
</pre></ul><a name="229546"></a>
The following is repeated from <a href="typesValues.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<ul><pre>
<i>InterfaceType:
	TypeName</i>
</pre></ul><a name="34112"></a>
Each <em>InterfaceType</em> must name an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> interface type, or a compile-time error occurs. <p>
<a name="36646"></a>
A compile-time error occurs if the same interface is mentioned two or more times in a single <code>implements</code> clause.<p>
<a name="258838"></a>
This is true even if the interface is named in different ways; for example, the code:
<blockquote><pre>class Redundant implements java.lang.Cloneable, Cloneable {
	int x;
}
</pre></blockquote><a name="259097"></a>
results in a compile-time error because the names java.lang.<code>Cloneable</code> and <code>Cloneable</code> refer to the same interface.<p>
<a name="31147"></a>
An interface type <i>I</i> is a <em>superinterface</em> of class type <i>C</i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i> has some direct superinterface <i>J</i> for which <i>I</i> is a superinterface, using the definition of "superinterface of an interface" given in <a href="interfaces.doc.html#78598">&#167;9.1.2</a>.
<a name="34121"></a>
<li><i>I</i> is a superinterface of the direct superclass of <i>C</i>.
</ul><a name="29918"></a>
A class is said to <em>implement</em> all its superinterfaces.<p>
<a name="229105"></a>
In the example:
<blockquote><pre>public interface Colorable {
	void setColor(int color);
	int getColor();
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
	void setFinish(int finish);
	int getFinish();
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	int color;
	public void setColor(int color) { this.color = color; }
	public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable 
{
	int finish;
	public void setFinish(int finish) {
		this.finish = finish;
	}
	public int getFinish() { return finish; }
}
</pre></blockquote><a name="29896"></a>
the relationships are as follows:<p>
<ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="interfaces.doc.html#78598">&#167;9.1.2</a>.
</ul><a name="270974"></a>
A class can have a superinterface in more than one way. In this example, the class <code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>.<p>
<a name="29870"></a>
Unless the class being declared is <code>abstract</code>, the declarations of all the method members of each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="230327"></a>
Thus, the example:
<blockquote><pre>interface Colorable {
	void setColor(int color);
	int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
	int color;
}
</pre></blockquote><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the interface <code>Colorable</code>.<p>
<a name="228059"></a>
It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
	// You can tune a piano, but can you tuna fish?
	int getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return type that matches the method declared in interface <code>Fish</code> and also matches the method declared in interface <code>Piano</code>; it is considered to implement both.<p>
<a name="228080"></a>
On the other hand, in a situation such as this:
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
	// This declaration cannot be correct, no matter what type is used.
	public ??? getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="270984"></a>
It is impossible to declare a method named <code>getNumberOfScales</code> with the same signature and return type as those of both the methods declared in interface <code>Fish</code> and in interface <code>StringBass</code>, because a class can have only one method with a given signature <a href="classes.doc.html#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement both interface <code>Fish</code> and interface <code>StringBass</code> <a href="classes.doc.html#228745">(&#167;8.4.6)</a>.<p>
<a name="18988"></a>
<h3>8.1.5    Class Body and Member Declarations</h3>
<a name="77979"></a>
A <em>class body</em> may contain declarations of members of the class, that is, fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, classes <a href="classes.doc.html#246026">(&#167;8.5)</a>, interfaces <a href="classes.doc.html#246026">(&#167;8.5)</a> and methods <a href="classes.doc.html#40420">(&#167;8.4)</a>. A class body may also contain instance initializers <a href="classes.doc.html#246032">(&#167;8.6)</a>, static initializers <a href="classes.doc.html#39245">(&#167;8.7)</a>, and declarations of constructors <a href="classes.doc.html#41652">(&#167;8.8)</a> for the class.<p>
<ul><pre>
<em>ClassBody:
	{ ClassBodyDeclarations<sub>opt</sub> }

ClassBodyDeclarations:
	ClassBodyDeclaration
	ClassBodyDeclarations ClassBodyDeclaration

ClassBodyDeclaration:
	ClassMemberDeclaration
	InstanceInitializer
	StaticInitializer
	ConstructorDeclaration

ClassMemberDeclaration:
	FieldDeclaration
	MethodDeclaration
	ClassDeclaration						
	InterfaceDeclaration
	;			</em> 
</pre></ul><a name="294464"></a>
The scope of a declaration of a member m declared in or inherited by a class type C is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="250255"></a>
If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) for m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared or inherited in C shadows <a href="names.doc.html#34133">(&#167;6.3.1)</a> the other definitions of m. <p>
<a name="21831"></a>
<h2>8.2    Class Members</h2>
<a name="40942"></a>
The members of a class type are all of the following:<p>
<ul><a name="40946"></a>
<li>Members inherited from its direct superclass <a href="classes.doc.html#262560">(&#167;8.1.3)</a>, except in class <code>Object</code>, which has no direct superclass
<a name="45862"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.doc.html#34031">(&#167;8.1.4)</a>
<a name="45866"></a>
<li>Members declared in the body of the class <a href="classes.doc.html#18988">(&#167;8.1.5)</a>
</ul><a name="30394"></a>
Members of a class that are declared <code>private</code> are not inherited by subclasses of that class. Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.<p>
<a name="230007"></a>
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.<p>
<a name="36731"></a>
The example:
<blockquote><pre>class Point {
	int x, y;
	private Point() { reset(); }
	Point(int x, int y) { this.x = x; this.y = y; }
	private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
	int color;
	void clear() { reset(); }		// error
}
class Test {
	public static void main(String[] args) {
		ColoredPoint c = new ColoredPoint(0, 0);	// error
		c.reset();				// error
	}
}
</pre></blockquote><a name="14620"></a>
causes four compile-time errors:<p>
<ul><a name="16328"></a>
<li>An error occurs because <code>ColoredPoint</code> has no constructor declared with two integer parameters, as requested by the use in <code>main</code>. This illustrates the fact that <code>ColoredPoint</code> does not inherit the constructors of its superclass <code>Point</code>.
<a name="16329"></a>
<li>Another error occurs because <code>ColoredPoint</code> declares no constructors, and therefore a default constructor for it is automatically created <a href="classes.doc.html#16823">(&#167;8.8.7)</a>, and this default constructor is equivalent to:
</ul><blockquote><pre>	ColoredPoint() { super(); }
</pre></blockquote>
<a name="14625"></a>
which invokes the constructor, with no arguments, for the direct superclass of the class <code>ColoredPoint</code>. The error is that the constructor for <code>Point</code> that takes no arguments is <code>private</code>, and therefore is not accessible outside the class <code>Point</code>, even through a superclass constructor invocation <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.
<a name="270990"></a>
Two more errors occur because the method <code>reset</code> of class <code>Point</code> is <code>private</code>, and therefore is not inherited by class <code>ColoredPoint</code>. The method invocations in method <code>clear</code> of class <code>ColoredPoint</code> and in method <code>main</code> of class <code>Test</code> are therefore not correct.<p>
<a name="30229"></a>
<h3>8.2.1    Examples of Inheritance</h3>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.<p>
<a name="40830"></a>
<h4>8.2.1.1    Example: Inheritance with Default Access</h4>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:<p>
<blockquote><pre>package points;
public class Point {
	int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="40836"></a>
and:<p>
<blockquote><pre>package points;
public class Point3d extends Point {
	int z;
	public void move(int dx, int dy, int dz) {
		x += dx; y += dy; z += dz;
	}
}
</pre></blockquote><a name="40844"></a>
and a third compilation unit, in another package, is:<p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		x += dx; y += dy; z += dz; w += dw; // compile-time errors
	}
}
</pre></blockquote><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.<p>
<a name="40853"></a>
A better way to write the third compilation unit would be:
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If <code>Point4d</code> is written in this way it will compile without errors.<p>
<a name="40862"></a>
<h4>8.2.1.2    Inheritance with public and protected</h4>
<a name="40863"></a>
Given the class <code>Point</code>:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	protected int useCount = 0;
	static protected int totalUseCount = 0;
	public void move(int dx, int dy) {
		x += dx; y += dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited in all subclasses of <code>Point</code>. <p>
<a name="292212"></a>
Therefore, this test program, in another package, can be compiled successfully:
<blockquote><pre>class Test extends points.Point {
	public void moveBack(int dx, int dy) {
		x -= dx; y -= dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40879"></a>
<h4>8.2.1.3    Inheritance with private</h4>
<a name="40880"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x, y;
	void move(int dx, int dy) {
		x += dx; y += dy; totalMoves++;
	}
	private static int totalMoves;
	void printMoves() { System.out.println(totalMoves); }
}
class Point3d extends Point {
	int z;
	void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz; totalMoves++;
	}
}
</pre></blockquote><a name="40822"></a>
the class variable <code>totalMoves</code> can be used only within the class <code>Point</code>; it is not inherited by the subclass <code>Point3d</code>. A compile-time error occurs because method <code>move</code> of class <code>Point3d</code> tries to increment <code>totalMoves</code>.<p>
<a name="23530"></a>
<h4>8.2.1.4    Accessing Members of Inaccessible Classes</h4>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be available at run time to code outside the package in which it is declared if it has a <code>public</code> superclass or superinterface. An instance of the class can be assigned to a variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the <code>public</code> superclass or superinterface. (In this situation, the method is necessarily declared <code>public</code>, even though it is declared in a class that is not <code>public</code>.)<p>
<a name="23519"></a>
Consider the compilation unit:
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public void move(int dx, int dy) {
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="36865"></a>
and another compilation unit of another package:<p>
<blockquote><pre>package morePoints;
class Point3d extends points.Point {
	public int z;
	public void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz;
	}
	public void move(int dx, int dy) {
		move(dx, dy, 0);
	}
}
public class OnePoint {
	public static points.Point getOne() { 
		return new Point3d(); 
	}
}
</pre></blockquote><a name="23527"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is not available outside the package <code>morePoints</code>. The two argument version of method <code>move</code> could then be invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is <code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself be <code>public</code>, precisely so that situations such as this will work out correctly). The fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.<p>
<a name="36884"></a>
While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. 
<a name="292218"></a>
<p>The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:
<blockquote><pre>package morePoints;
public class Point4d extends Point3d {
	public int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="270996"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be accessed by code in packages other than <code>morePoints</code>, through variables and expressions of the <code>public</code> type <code>Point4d</code>.<p>
<a name="40898"></a>
<h2>8.3    Field Declarations</h2>
<a name="40823"></a>
The variables of a class type are introduced by <em>field declarations</em>:<p>
<ul><pre>
<em>FieldDeclaration:
	FieldModifiers<sub>opt</sub> Type VariableDeclarators ;

<em></em>VariableDeclarators:
	VariableDeclarator
	VariableDeclarators , VariableDeclarator

VariableDeclarator:
	VariableDeclaratorId
	VariableDeclaratorId = VariableInitializer

VariableDeclaratorId:
	Identifier
	VariableDeclaratorId [ ]

VariableInitializer:
	Expression
	ArrayInitializer
	</em>
</pre></ul><a name="78087"></a>
The <em>FieldModifiers</em> are described in <a href="classes.doc.html#78091">&#167;8.3.1</a>. The <em>Identifier</em> in a <em>FieldDeclarator</em> may be used in a name to refer to the field. Fields are members; the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a field declaration is specified in <a href="classes.doc.html#18988">&#167;8.1.5</a>. More than one field may be declared in a single field declaration by using more than one declarator; the <em>FieldModifiers</em> and <em>Type</em> apply to all the declarators in the declaration. Variable declarations involving array types are discussed in <a href="arrays.doc.html#25891">&#167;10.2</a>.<p>
<a name="29989"></a>
It is a compile-time error for the body of a class declaration to declare two fields with the same name. Methods, types, and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.doc.html#106941">(&#167;6.5)</a>.<p>
<a name="36999"></a>
If the class declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class. The field declaration also shadows <a href="names.doc.html#34133">(&#167;6.3.1)</a> declarations of any accessible fields in enclosing classes or interfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.<p>
<a name="38152"></a>
If a field declaration hides the declaration of another field, the two fields need not have the same type.<p>
<a name="38148"></a>
A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247092"></a>
Note that a private field of a superclass might be accessible to a subclass (for example, if both classes are members of the same class). Nevertheless, a private field is never inherited by a subclass.
<a name="37087"></a>
<p>It is possible for a class to inherit more than one field with the same name <a href="classes.doc.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.
<a name="37038"></a>
<p>There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.
<a name="37037"></a>
<p>A hidden field can be accessed by using a qualified name (if it is <code>static</code>) or by using a field access expression <a href="expressions.doc.html#41267">(&#167;15.11)</a> that contains the keyword <code>super</code> or a cast to a superclass type. See <a href="expressions.doc.html#20860">&#167;15.11.2</a> for discussion and an example.
<a name="259125"></a>
<p>A value stored in a field of type <code>float</code> is always an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, a value stored in a field of type <code>double</code> is always an element of the double value set. It is not permitted for a field of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.
<a name="78091"></a>
<h3>8.3.1    Field Modifiers</h3>
<ul><pre>
<em>FieldModifiers:
	FieldModifier
	FieldModifiers FieldModifier

FieldModifier: one of
</em>	public&#32;protected&#32;private
	static&#32;final&#32;transient&#32;volatile
</pre></ul><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="259130"></a>
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>FieldModifier</em>.
<a name="37544"></a>
<h4>8.3.1.1    <code>static</code> Fields</h4>
<a name="230789"></a>
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A <code>static</code> field, sometimes called a <em>class variable</em>, is incarnated when the class is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <em>instance variable</em>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses. The example program:<p>
<blockquote><pre>class Point {
	int x, y, useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
class Test {
	public static void main(String[] args) {
		Point p = new Point(1,1);
		Point q = new Point(2,2);
		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
		System.out.println("(" + q.x + "," + q.y + ")");
		System.out.println(q.useCount);
		System.out.println(q.origin == Point.origin);
		System.out.println(q.origin.useCount);
	}
}
</pre></blockquote><a name="37584"></a>
prints:<p>
<blockquote><pre>(2,2)
0
true
1
</pre></blockquote><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields of <code>q</code>, because these fields are instance variables in distinct objects. In this example, the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in field access expressions <a href="expressions.doc.html#41267">(&#167;15.11)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways of accessing the <code>origin</code> class variable access the same object, evidenced by the fact that the value of the reference equality expression <a href="expressions.doc.html#236163">(&#167;15.21.3)</a>:<p>
<blockquote><pre><code>q.origin==Point.origin
</code></pre></blockquote><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:<p>
<blockquote><pre>p.origin.useCount++;
</pre></blockquote><a name="259135"></a>
causes the value of <code>q.origin.useCount</code> to be <code>1</code>; this is so because <code>p.origin</code> and <code>q.origin</code> refer to the same variable.<p>
<a name="35962"></a>
<h4>8.3.1.2    <code>final</code> Fields</h4>
<a name="246472"></a>
A field can be declared <code>final</code> <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a>. Both class and instance variables (<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.<p>
<a name="246476"></a>
It is a compile-time error if a blank final <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a> class variable is not definitely assigned <a href="defAssign.doc.html#63310">(&#167;16.7)</a> by a static initializer <a href="classes.doc.html#39245">(&#167;8.7)</a> of the class in which it is declared.<p>
<a name="246496"></a>
A blank final instance variable must be definitely assigned <a href="defAssign.doc.html#56210">(&#167;16.8)</a> at the end of every constructor <a href="classes.doc.html#41652">(&#167;8.8)</a> of the class in which it is declared; otherwise a compile-time error occurs. <p>
<a name="78119"></a>
<h4>8.3.1.3    <code>transient</code> Fields</h4>
<a name="37020"></a>
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent state of an object. <p>
<a name="258868"></a>
If an instance of the class <code>Point</code>:
<blockquote><pre>class Point {
	int x, y;
	transient float rho, theta;
}
</pre></blockquote><a name="259140"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> would be saved. This specification does not specify details of such services; see the specification of java.io.Serializable for an example of such a service.<p>
<a name="36930"></a>
<h4>8.3.1.4    <code>volatile</code> Fields</h4>
<a name="37715"></a>
As described in <a href="memory.doc.html#26250">&#167;17</a>, the Java programming language allows threads that access shared variables to keep private working copies of the variables; this allows a more efficient implementation of multiple threads. These working copies need be reconciled with the master copies in the shared main memory only at prescribed synchronization points, namely when objects are locked or unlocked. As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.<p>
<a name="259149"></a>
The Java programming language provides a second mechanism, volatile fields, that is more convenient for some purposes.
<a name="259153"></a>
<p>
A field may be declared <code>volatile</code>, in which case a thread must reconcile its working copy of the field with the master copy every time it accesses the variable. Moreover, operations on the master copies of one or more volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.<p>
<a name="14790"></a>
If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> times in all), and another thread repeatedly calls the method <code>two</code>:
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the value of <code>i</code>, because the example includes no synchronization and, under the rules explained in <a href="memory.doc.html#26250">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.<p>
<a name="37738"></a>
One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="classes.doc.html#260369">(&#167;8.4.3.6)</a>:
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static synchronized void one() { i++; j++; }
	static synchronized void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.<p>
<a name="37789"></a>
Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:
<blockquote><pre>class Test {
	static volatile int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote>
<a name="259157"></a>
This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for <code>j</code> is never greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the value observed for <code>i</code>, because method <code>one</code> might be executed many times between the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when method <code>two</code> fetches the value of <code>j</code>.
<a name="14791"></a>
See <a href="memory.doc.html#26250">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>
<a name="24510"></a>
<h3>8.3.2    Initialization of Fields</h3>
<a name="41082"></a>
If a field declarator contains a <em>variable initializer</em>, then it has the semantics of an assignment <a href="expressions.doc.html#5281">(&#167;15.26)</a> to the declared variable, and:<p>
<ul><a name="37635"></a>
<li>If the declarator is for a class variable (that is, a <code>static</code> field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>.
<a name="37639"></a>
<li>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created <a href="execution.doc.html#44670">(&#167;12.5)</a>. 
<a name="38002"></a>
The example:
</ul><blockquote><pre>class Point {
	int x = 1, y = 5;
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println(p.x + ", " + p.y);
	}
}
</pre></blockquote><a name="30363"></a>
produces the output:<p>
<blockquote><pre>1, 5
</pre></blockquote><a name="30378"></a>
because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.<p>
<a name="259166"></a>
Variable initializers are also used in local variable declaration statements <a href="statements.doc.html#5920">(&#167;14.4)</a>, where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.<p>
<a name="38006"></a>
It is a compile-time error if the evaluation of a variable initializer for a <code>static</code> field or for an instance variable of a named class (or of an interface) can complete abruptly with a checked exception <a href="exceptions.doc.html#44121">(&#167;11.2)</a>.<p>
<a name="38010"></a>
<h4>8.3.2.1    Initializers for Class Variables</h4>
<a name="37971"></a>
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="37934"></a>
If the keyword <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>) occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="259173"></a>
One subtlety here is that, at run time, <code>static</code> variables that are <code>final</code> and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces <a href="interfaces.doc.html#40720">(&#167;9.3.1)</a>. These variables are "constants" that will never be observed to have their default initial values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>, even by devious programs. See <a href="execution.doc.html#44630">&#167;12.4.2</a> and <a href="binaryComp.doc.html#45139">&#167;13.4.8</a> for more discussion.
<a name="294375"></a>
<em></em>Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="38013"></a>
<h4>8.3.2.2    Initializers for Instance Variables</h4>
<a name="37982"></a>
Initialization expressions for instance variables may use the simple name of any <code>static</code> variable declared in or inherited by the class, even one whose declaration occurs textually later. <p>
<a name="258899"></a>
Thus the example:
<blockquote><pre>class Test {
	float f = j;
	static int j = 1;
}
</pre></blockquote><a name="259183"></a>
compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes <code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.<p>
<a name="40409"></a>
Initialization expressions for instance variables are permitted to refer to the current object <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> and to use the keyword <code>super</code> (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>).<p>
<a name="294509"></a>
<em></em>Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="287406"></a>
<h4>8.3.2.3    Restrictions on the use of Fields during Initialization</h4>
<a name="287409"></a>
The declaration of a member needs to appear before it is used only if the member is an instance (respectively <code>static</code>) field of a class or interface <i>C</i> and all of the following conditions hold:<p>
<ul><a name="287410"></a>
<li>The usage occurs in an instance (respectively <code>static</code>) variable initializer of <i>C</i> or in an instance (respectively <code>static</code>) initializer of <i>C</i>.
<a name="287411"></a>
<li>The usage is not on the left hand side of an assignment.
<a name="287412"></a>
<li><i>C</i> is the innermost class or interface enclosing the usage.
</ul><a name="287413"></a>
A compile-time error occurs if any of the three requirements above are not met.<p>
<a name="287447"></a>
This means that a compile-time error results from the test program:
<blockquote><pre>	class Test {
		int i = j;	// compile-time error: incorrect forward reference
		int j = 1;
	}
</pre></blockquote><a name="287452"></a>
whereas the following example compiles without error:<p>
<blockquote><pre>	class Test {
		Test() { k = 2; }
		int j = 1;
		int i = j;
		int k;
	}
</pre></blockquote><a name="287462"></a>
even though the constructor <a href="classes.doc.html#41652">(&#167;8.8)</a> for <code>Test</code> refers to the field <code>k</code> that is declared three lines later. <p>
<a name="288775"></a>
These restrictions are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:
<blockquote><pre>class Z {
	static int i = j + 2; 
	static int j = 4;
}
</pre></blockquote><a name="288780"></a>
and:<p>
<blockquote><pre>class Z {
	static { i = j + 2; }
	static int i, j;
	static { j = 4; }
}
</pre></blockquote><a name="288786"></a>
result in compile-time errors. Accesses by methods are not checked in this way, so:<p>
<blockquote><pre>class Z {
	static int peek() { return j; }
	static int i = peek();
	static int j = 1;
}
class Test {
	public static void main(String[] args) {
		System.out.println(Z.i);
	}
}
</pre></blockquote><a name="288795"></a>
produces the output:<p>
<blockquote><pre>0
</pre></blockquote><a name="288797"></a>
because the variable initializer for <code>i</code> uses the class method <code>peek</code> to access the value of the variable <code>j</code> before <code>j</code> has been initialized by its variable initializer, at which point it still has its default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>.<p>
<a name="288772"></a>
A more elaborate example is:
<blockquote><pre>class UseBeforeDeclaration {
	static {
		x = 100; // ok - assignment
		int y = x + 1; // error - read before declaration
		int v = x = 3; // ok - x at left hand side of assignment
		int z = UseBeforeDeclaration.x * 2;
	// ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){x++;} // ok - occurs in a different class
			{x++;} // ok - occurs in a different class
    		};
  }
	{
		j = 200; // ok - assignment
		j = j + 1; // error - right hand side reads before declaration
		int k = j = j + 1; 
		int n = j = 300; // ok - j at left hand side of assignment
		int h = j++; // error - read before declaration
		int l = this.j * 3; // ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){j++;} // ok - occurs in a different class
			{ j = j + 1;} // ok - occurs in a different class
		};
	}
	int w = x= 3; // ok - x at left hand side of assignment
	int p = x; // ok - instance initializers may access static fields
	static int u = (new Object(){int bar(){return x;}}).bar();
	// ok - occurs in a different class
	static int x;
	int m = j = 4; // ok - j at left hand side of assignment
	int o = (new Object(){int bar(){return j;}}).bar(); 
	// ok - occurs in a different class
	int j;
}
</pre></blockquote><a name="40425"></a>
<h3>8.3.3    Examples of Field Declarations</h3>
<a name="259192"></a>
The following examples illustrate some (possibly subtle) points about field declarations.<p>
<a name="40428"></a>
<h4>8.3.3.1    Example: Hiding of Class Variables</h4>
<a name="40429"></a>
The example:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	static double x = 4.7;
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40439"></a>
produces the output:<p>
<blockquote><pre>4.7 2
</pre></blockquote><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> (or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. Therefore, the output from this variant program is:<p>
<blockquote><pre>2 2
</pre></blockquote><a name="229119"></a>
<h4>8.3.3.2    Example: Hiding of Instance Variables</h4>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables rather than static variables. The code:<p>
<blockquote><pre>class Point {
	int x = 2;
}
class Test extends Point {
	double x = 4.7;
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " + 
								((Point)sample).x);
	}
}
</pre></blockquote><a name="40468"></a>
produces the output:<p>
<blockquote><pre>4.7 2
4.7 2
</pre></blockquote><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be noted, however, that while the field <code>x</code> of class <code>Point</code> is not <em>inherited</em> by class <code>Test</code>, it is nevertheless <em>implemented</em> by instances of class <code>Test</code>. In other words, every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type <code>float</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> as <code>super.x</code>.<p>
<a name="40472"></a>
Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>float</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.
<a name="40473"></a>
<p>If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " +
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> declared in class <code>Point</code>. The output from this variant program is:<p>
<blockquote><pre>2 2
2 2
</pre></blockquote><a name="40491"></a>
<h4>8.3.3.3    Example: Multiply Inherited Fields</h4>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword <code>super</code> <a href="expressions.doc.html#20860">(&#167;15.11.2)</a> may be used to access such fields unambiguously. In the example:<p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() { System.out.println(v); }
}
</pre></blockquote><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot be determined which <code>v</code> is intended.<p>
<a name="41191"></a>
The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() {
		System.out.println((super.v + Frob.v)/2);
	}
}
</pre></blockquote><a name="40515"></a>
It compiles and prints:<p>
<blockquote><pre>2.5
</pre></blockquote>
<a name="40518"></a>
Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:
<blockquote><pre>
interface Color { int RED=0, GREEN=1, BLUE=2; }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
	public static void main(String[] args) {
		System.out.println(GREEN);			// compile-time error
		System.out.println(RED);		// compile-time error
	}
}
</pre></blockquote><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different values. The point of this example is that the reference to <code>RED</code> is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named <code>RED</code> happen to have the same type and the same unchanging value does not affect this judgment.<p>
<a name="40528"></a>
<h4>8.3.3.4    Example: Re-inheritance of Fields</h4>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code:<p>
<blockquote><pre>public interface Colorable {
	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	. . .
}
class PaintedPoint extends ColoredPoint implements Paintable 
{
	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
}
</pre></blockquote><a name="259196"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both through its direct superclass <code>ColoredPoint</code> and through its direct superinterface <code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in interface <code>Colorable</code>.<p>
<a name="40420"></a>
<h2>8.4    Method Declarations</h2>
<a name="40422"></a>
A <em>method</em> declares executable code that can be invoked, passing a fixed number of values as arguments.<p>
<ul><pre>
<em>MethodDeclaration:
	MethodHeader MethodBody

MethodHeader:
	MethodModifiers<sub>opt</sub> ResultType MethodDeclarator Throws<sub><i>opt
</i></sub>
ResultType:
	Type
</em>	void

<em>MethodDeclarator:
	Identifer ( FormalParameterList<sub><i>opt</i></sub> )
</em></pre></ul><a name="37508"></a>
The <em>MethodModifiers</em> are described in <a href="classes.doc.html#78188">&#167;8.4.3</a>, the <em>Throws</em> clause in <a href="classes.doc.html#78323">&#167;8.4.4</a>, and the <em>MethodBody</em> in <a href="classes.doc.html#37316">&#167;8.4.5</a>. A method declaration either specifies the type of value that the method returns or uses the keyword <code>void</code> to indicate that the method does not return a value.<p>
<a name="30386"></a>
The <em>Identifier</em> in a <em>MethodDeclarator</em> may be used in a name to refer to the method. A class can declare a method with the same name as the class or a field, member class or member interface of the class.<p>
<a name="38703"></a>
For compatibility with older versions of the Java platform, a declaration form for a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the parameter list. This is supported by the obsolescent production:<p>
<ul><pre>
<em>MethodDeclarator:
	MethodDeclarator</em> [ ]
</pre></ul><a name="38705"></a>
but should not be used in new code.<p>
<a name="38056"></a>
It is a compile-time error for the body of a class to have as members two methods with the same signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a> (name, number of parameters, and types of any parameters). Methods and fields may have the same name, since they are used in different contexts and are disambiguated by the different lookup procedures <a href="names.doc.html#106941">(&#167;6.5)</a>.<p>
<a name="38698"></a>
<h3>8.4.1    Formal Parameters</h3>
<a name="37472"></a>
The <em>formal parameters</em> of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the final modifier) and an identifier (optionally followed by brackets) that specifies the name of the parameter:<p>
<ul><pre>
<em>FormalParameterList:
	FormalParameter
	FormalParameterList , FormalParameter

FormalParameter:
</em>	final<em><sub>opt</sub> Type VariableDeclaratorId
</em></pre></ul><a name="291867"></a>
The following is repeated from <a href="classes.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<ul><pre>
<em>VariableDeclaratorId:
	Identifier
	VariableDeclaratorId</em> [ ]
</pre></ul><a name="55499"></a>
If a method or constructor has no parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.<p>
<a name="246504"></a>
If two formal parameters of the same method or constructor are declared to have the same name (that is, their declarations mention the same <em>Identifier</em>), then a compile-time error occurs.<p>
<a name="246509"></a>
It is a compile-time error if a method or constructor parameter that is declared final is assigned to within the body of the method or constructor.<p>
<a name="37477"></a>
When the method or constructor is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>, the values of the actual argument expressions initialize newly created parameter variables, each of the declared <em>Type,</em> before execution of the body of the method or constructor. The <em>Identifier</em> that appears<em> </em>in the <em>DeclaratorId</em> may be used as a simple name in the body of the method or constructor to refer to the formal parameter.<p>
<a name="294443"></a>
The scope of a parameter of a method <a href="classes.doc.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.doc.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="38643"></a>
These parameter names may not be redeclared as local variables of the method, or as exception parameters of catch clauses in a try statement of the method or constructor. However, a parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor. Such a nested class declaration could declare either a local class <a href="statements.doc.html#247766">(&#167;14.3)</a> or an anonymous class <a href="expressions.doc.html#41147">(&#167;15.9)</a>. <p>
<a name="38647"></a>
Formal parameters are referred to only using simple names, never by using qualified names <a href="names.doc.html#104285">(&#167;6.6)</a>.<p>
<a name="246529"></a>
A method or constructor parameter of type <code>float</code> always contains an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, a method or constructor parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a method or constructor parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set. <p>
<a name="246530"></a>
Where an actual argument expression corresponding to a parameter variable is not FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>, evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable the result of such an expression is mapped to the nearest value in the corresponding standard value set by method invocation conversion <a href="conversions.doc.html#12687">(&#167;5.3)</a>.<p>
<a name="38649"></a>
<h3>8.4.2    Method Signature</h3>
<a name="37479"></a>
The <em>signature</em> of a method consists of the name of the method and the number and types of formal parameters to the method. A class may not declare two methods with the same signature, or a compile-time error occurs. <p>
<a name="258904"></a>
The example:
<blockquote><pre>class Point implements Move {
	int x, y;
	abstract void move(int dx, int dy);
	void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="259201"></a>
causes a compile-time error because it declares two <code>move</code> methods with the same signature. This is an error even though one of the declarations is <code>abstract</code>.<p>
<a name="78188"></a>
<h3>8.4.3    Method Modifiers</h3>
<ul><pre>
<em>MethodModifiers:
	MethodModifier
	MethodModifiers MethodModifier

MethodModifier: one of
</em>	public&#32;protected&#32;private&#32;abstract&#32;static
	final&#32;synchronized&#32;native&#32;strictfp
</pre></ul><a name="244675"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a method declaration, or if a method declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a method declaration that contains the keyword <code>abstract</code> also contains any one of the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A compile-time error occurs if a method declaration that contains the keyword <code>native</code> also contains <code>strictfp</code>.<p>
<a name="259206"></a>
If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>MethodModifier</em>.
<a name="34484"></a>
<h4>8.4.3.1    <code>abstract</code> Methods</h4>
<a name="227750"></a>
An <code>abstract</code> method declaration introduces the method as a member, providing its signature (name and number and type of parameters), return type, and <code>throws</code> clause (if any), but does not provide an implementation. The declaration of an <code>abstract</code> method <i>m</i> must appear directly within an <code>abstract</code> class (call it <i>A</i>); otherwise a compile-time error results. Every subclass of <i>A</i> that is not <code>abstract</code> must provide an implementation for <i>m</i>, or a compile-time error occurs as specified in <a href="classes.doc.html#34944">&#167;8.1.1.1</a>. <p>
<a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>.<p>
<a name="259211"></a>
It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not inherited by subclasses; therefore such a method could never be used.
<a name="230065"></a>
<p>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. <p>
<a name="258918"></a>
This can provide a place to put a documentation comment, or to declare that the set of checked exceptions <a href="exceptions.doc.html#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:
<blockquote><pre>class BufferEmpty extends Exception {
	BufferEmpty() { super(); }
	BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
	BufferError() { super(); }
	BufferError(String s) { super(s); }
}
public interface Buffer {
	char get() throws BufferEmpty, BufferError;
}
public abstract class InfiniteBuffer implements Buffer {
	abstract char get() throws BufferError;
}
</pre></blockquote>
<a name="259216"></a>
The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> exception, putatively because it generates the data in the buffer, and thus can never run out of data.
<a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. <p>
<a name="258923"></a>
For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
}
</pre></blockquote><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> method of class <code>Object</code>. (Class <code>Object</code> is the implicit direct superclass of class <code>Point</code>.) Adding the code:<p>
<blockquote><pre>class ColoredPoint extends Point {
	int color;
	public String toString() {
		return super.toString() + ": color " + color; // error
	}
}
</pre></blockquote><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class <code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some other method, as in:<p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
	protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
	int color;
	public String toString() {
		return objString() + ": color " + color;	// correct
	}
}
</pre></blockquote><a name="229128"></a>
<h4>8.4.3.2    <code>static</code> Methods</h4>
<a name="39431"></a>
A method that is declared <code>static</code> is called a <em>class method</em>. A class method is always invoked without reference to a particular object. An attempt to reference the current object using the keyword <code>this</code> or the keyword <code>super</code> in the body of a class method results in a compile-time error. It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="39033"></a>
A method that is not declared <code>static</code> is called an <em>instance method,</em> and sometimes called a non-<code>static</code> method. An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<h4>8.4.3.3    <code>final</code> Methods</h4>
<a name="30456"></a>
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding it. It is a compile-time error to attempt to override or hide a <code>final</code> method.<p>
<a name="38958"></a>
A <code>private</code> method and all methods declared in a <code>final</code> class <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a> are implicitly <code>final</code>, because it is impossible to override them. It is permitted but not required for the declarations of such methods to redundantly include the <code>final</code> keyword. <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run time, a machine-code generator or optimizer can "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is <code>null</code>, then a <code>NullPointerException</code> must be thrown even if the method is inlined. The compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.<p>
<a name="258931"></a>
Consider the example:
<blockquote><pre>final class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
	public static void main(String[] args) {
		Point[] p = new Point[100];
		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			p[i].move(i, p.length-1-i);
		}
	}
}
</pre></blockquote><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform the <code>for</code> loop to the form:<p>
<blockquote><pre>		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			Point pi = p[i];
			int j = p.length-1-i;
			pi.x += i;
			pi.y += j;
		}
</pre></blockquote><a name="31122"></a>
The loop might then be subject to further optimizations.<p>
<a name="259226"></a>
Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.
<a name="31125"></a>
<h4>8.4.3.4    <code>native</code> Methods</h4>
<a name="30468"></a>
A method that is <code>native</code> is implemented in platform-dependent code, typically written in another programming language such as C, C++, FORTRAN, or assembly language. The body of a <code>native</code> method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.<p>
<a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
For example, the class <code>RandomAccessFile</code> of the package <code>java.io</code> might declare the following <code>native</code> methods:
<blockquote><pre>package java.io;
public class RandomAccessFile
	implements DataOutput, DataInput
{	. . .
	public native void open(String name, boolean writeable)
		throws IOException;
	public native int readBytes(byte[] b, int off, int len)
		throws IOException;
	public native void writeBytes(byte[] b, int off, int len)
		throws IOException;
	public native long getFilePointer() throws IOException;
	public native void seek(long pos) throws IOException;
	public native long length() throws IOException;
	public native void close() throws IOException;
}
</pre></blockquote><a name="55408"></a>
<h4>8.4.3.5    <code>strictfp </code>Methods</h4>
<a name="260393"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the method body be explicitly FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>.<p>
<a name="260369"></a>
<h4>8.4.3.6    <code>synchronized</code> Methods</h4>
<a name="30531"></a>
A <code>synchronized</code> method acquires a lock <a href="memory.doc.html#28287">(&#167;17.1)</a> before it executes. For a class (<code>static)</code> method, the lock associated with the <code>Class</code> object for the method's class is used. For an instance method, the lock associated with <code>this</code> (the object for which the method was invoked) is used. <p>
<a name="258940"></a>
These are the same locks that can be used by the <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a>; thus, the code:
<blockquote><pre>class Test {
	int count;
	synchronized void bump() { count++; }
	static int classCount;
	static synchronized void classBump() {
		classCount++;
	}
}
</pre></blockquote><a name="39096"></a>
has exactly the same effect as:<p>
<blockquote><pre>class BumpTest {
	int count;
	void bump() {
		synchronized (this) {
			count++;
		}
	}
	static int classCount;
	static void classBump() {
		try {
			synchronized (Class.forName("BumpTest")) {
				classCount++;
			}
		} catch (ClassNotFoundException e) {
				...
		}
	}
}
</pre></blockquote><a name="39078"></a>
The more elaborate example:<p>
<blockquote><pre>public class Box {
	private Object boxContents;
	public synchronized Object get() {
		Object contents = boxContents;
		boxContents = null;
		return contents;
	}
	public synchronized boolean put(Object contents) {
		if (boxContents != null)
			return false;
		boxContents = contents;
		return true;
	}
}
</pre></blockquote><a name="30546"></a>
defines a class which is designed for concurrent use. Each instance of the class <code>Box</code> has an instance variable <code>contents</code> that can hold a reference to any object. You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a null reference if the <code>box</code> is empty.<p>
<a name="39151"></a>
If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.
<p>
<a name="259236"></a>
See <a href="memory.doc.html#26250">&#167;17</a> for more discussion of threads and locks.
<a name="78323"></a>
<h3>8.4.4    Method Throws</h3>
<a name="41401"></a>
A <em>throws clause</em> is used to declare any checked exceptions <a href="exceptions.doc.html#44121">(&#167;11.2)</a> that can result from the execution of a method or constructor:<p>
<ul><pre>
<em>Throws:
</em>	throws<em> ClassTypeList

ClassTypeList:
	ClassType
	ClassTypeList , ClassType
</em></pre></ul><a name="39173"></a>
A compile-time error occurs if any <em>ClassType</em> mentioned in a <code>throws</code> clause is not the class <code>Throwable</code> or a subclass of <code>Throwable</code>. It is permitted but not required to mention other (unchecked) exceptions in a <code>throws</code> clause.<p>
<a name="39177"></a>
For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a superclass of that exception type is mentioned in a <code>throws</code> clause in the declaration of the method or constructor.<p>
<a name="259241"></a>
The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a <code>throws</code> clause. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.
<a name="55271"></a>
<p>
The predefined exceptions that are not checked in this way are those for which declaring every possible occurrence would be unimaginably inconvenient:<p>
<ul><a name="41434"></a>
<li>Exceptions that are represented by the subclasses of class <code>Error</code>, for example <code>OutOfMemoryError</code>, are thrown due to a failure in or of the virtual machine. Many of these are the result of linkage failures and can occur at unpredictable points in the execution of a program. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
<a name="41435"></a>
<li>The exceptions that are represented by the subclasses of the class <code>RuntimeException</code>, &#32;for example <code>NullPointerException</code>, result from run-time &#32;integrity checks and are thrown either directly from the program or in library routines. It is beyond the scope of the Java programming language, and perhaps beyond the state of the art, to include sufficient information in the program to reduce to a manageable number the places where these can be proven not to occur.
</ul><a name="230101"></a>
A method that overrides or hides another method <a href="classes.doc.html#228745">(&#167;8.4.6)</a>, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.<p>
<a name="230102"></a>
More precisely, suppose that <i>B</i> is a class or interface, and <i>A</i> is a superclass or superinterface of <i>B</i>, and a method declaration <i>n</i> in <i>B</i> overrides or hides a method declaration <i>m</i> in <i>A</i>. If <i>n</i> has a <code>throws</code> clause that mentions any checked exception types, then <i>m</i> must have a <code>throws</code> clause, and for every checked exception type listed in the <code>throws</code> clause of <i>n</i>, that same exception class or one of its superclasses must occur in the <code>throws</code> clause of <i>m</i>; otherwise, a compile-time error occurs.<p>
<a name="24563"></a>
See <a href="exceptions.doc.html#44043">&#167;11</a> for more information about exceptions and a large example.<p>
<a name="37316"></a>
<h3>8.4.5    Method Body</h3>
<a name="32175"></a>
A <em>method body</em> is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation. The body of a method must be a semicolon if and only if the method is either <code>abstract</code> <a href="classes.doc.html#34484">(&#167;8.4.3.1)</a> or <code>native</code> <a href="classes.doc.html#31125">(&#167;8.4.3.4)</a>.<p>
<ul><pre>
<em>MethodBody</em>:
<em>	Block</em> 
	;
</pre></ul><a name="38770"></a>
A compile-time error occurs if a method declaration is either <code>abstract</code> or <code>native</code> and has a block for its body. A compile-time error occurs if a method declaration is neither <code>abstract</code> nor <code>native</code> and has a semicolon for its body.<p>
<a name="39311"></a>
If an implementation is to be provided for a method but the implementation requires no executable code, the method body should be written as a block that contains no statements: "<code>{ }</code>".
<a name="228178"></a>
<p>
If a method is declared <code>void</code>, then its body must not contain any <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> that has an <em>Expression</em>.<p>
<a name="244552"></a>
If a method is declared to have a return type, then every <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> in its body must have an <em>Expression</em>. A compile-time error occurs if the body of the method can complete normally <a href="statements.doc.html#5894">(&#167;14.1)</a>. <p>
<a name="258957"></a>
In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body."
<p>
<a name="228370"></a>
Note that it is possible for a method to have a declared return type and yet contain no return statements. Here is one example:
<blockquote><pre>class DizzyDean {
	int pitch() { throw new RuntimeException("90 mph?!"); }
}
</pre></blockquote><a name="228745"></a>
<h3>8.4.6    Inheritance, Overriding, and Hiding</h3>
<a name="227926"></a>
A class <em>inherits</em> from its direct superclass and direct superinterfaces all the non-private methods (whether <code>abstract</code> or not) of the superclass and superinterfaces that are accessible to code in the class and are neither overridden <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a> nor hidden <a href="classes.doc.html#227928">(&#167;8.4.6.2)</a> by a declaration in the class.<p>
<a name="227927"></a>
<h4>8.4.6.1    Overriding (by Instance Methods)</h4>
<a name="39521"></a>
An instance method <i>m1</i> declared in a class <i>C</i> <em>overrides</em> another method with the same signature, <i>m2</i>, declared in class <i>A</i> if both
<ol>
<a name="247097"></a>
<li>C is a subclass of <i>A</i>.
<a name="247099"></a>
<li>Either
<ul>
<a name="247100"></a>
<li><i>m</i>2 is non-private and accessible from <i>C</i>, or
<a name="247101"></a>
<li><i>m1</i> overrides a method <i>m3</i>, <i>m3</i> distinct from <i>m1</i>, <i>m3</i> distinct from <i>m2</i>, such that <i>m3</i> overrides <i>m2</i>.
</ul>
</ol>
<a name="247108"></a>
Moreover, if <i>m1</i> is not <code>abstract</code>, then <i>m1</i> is said to <em>implement</em> any and all declarations of <code>abstract</code> methods that it overrides.<p>
<a name="227929"></a>
A compile-time error occurs if an instance method overrides a <code>static</code> method. <p>
<a name="258962"></a>
In this respect, overriding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for an instance variable to hide a <code>static</code> variable.
<a name="259251"></a>
<p>
An overridden method can be accessed by using a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code>. Note that a qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields. See <a href="expressions.doc.html#239751">&#167;15.12.4.9</a> for discussion and examples of this point.
<a name="246534"></a>
<p>
The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.<p>
<a name="227928"></a>
<h4>8.4.6.2    Hiding (by Class Methods)</h4>
<a name="227961"></a>
If a class declares a <code>static</code> method, then the declaration of that method is said to <em>hide</em> any and all methods with the same signature in the superclasses and superinterfaces of the class that would otherwise be accessible to code in the class. A compile-time error occurs if a <code>static</code> method hides an instance method. <p>
<a name="258967"></a>
In this respect, hiding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for a <code>static</code> variable to hide an instance variable. Hiding is also distinct from shadowing <a href="names.doc.html#34133">(&#167;6.3.1)</a> and obscuring <a href="names.doc.html#104058">(&#167;6.3.2)</a>.
<a name="259256"></a>
<p>
A hidden method can be accessed by using a qualified name or by using a method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code> or a cast to a superclass type. In this respect, hiding of methods is similar to hiding of fields.
<a name="227965"></a>
<h4>8.4.6.3    Requirements in Overriding and Hiding</h4>
<a name="227966"></a>
If a method declaration overrides or hides the declaration of another method, then a compile-time error occurs if they have different return types or if one has a return type and the other is <code>void</code>. Moreover, a method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.doc.html#78323">(&#167;8.4.4)</a> with that of any method that it overrides or hides; otherwise, &#32;a compile-time error occurs. <p>
<a name="259261"></a>
In these respects, overriding of methods differs from hiding of fields <a href="classes.doc.html#40898">(&#167;8.3)</a>, for it is permissible for a field to hide a field of another type.
<a name="39548"></a>
<p>
The access modifier <a href="names.doc.html#104285">(&#167;6.6)</a> of an overriding or hiding method must provide at least as much access as the overridden or hidden method, or a compile-time error occurs. In more detail:<p>
<ul><a name="39549"></a>
<li>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.
<a name="39550"></a>
<li>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.
<a name="39551"></a>
<li>If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be <code>private</code>; otherwise, a compile-time error occurs.
<a name="259266"></a>
</ul>
Note that a <code>private</code> method cannot be hidden or overridden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a <code>private</code> method in one of its superclasses, and there is no requirement that the return type or <code>throws</code> clause of such a method bear any relationship to those of the <code>private</code> method in the superclass.
<a name="227941"></a>
<h4>8.4.6.4    Inheriting Methods with the Same Signature</h4>
<a name="39557"></a>
It is possible for a class to inherit more than one method with the same signature. Such a situation does not in itself cause a compile-time error. There are then two possible cases:<p>
<ul><a name="39561"></a>
<li>If one of the inherited methods is not <code>abstract</code>, then there are two subcases:
<ul>
<a name="39562"></a>
<li>If the method that is not <code>abstract</code> is <code>static</code>, a compile-time error occurs.
<a name="39563"></a>
<li>Otherwise, the method that is not <code>abstract</code> is considered to override, and therefore to implement, all the other methods on behalf of the class that inherits it. A compile-time error occurs if, comparing the method that is not <code>abstract</code> with each of the other of the inherited methods, for any such pair, either they have different return types or one has a return type and the other is <code>void</code>. Moreover, a compile-time error occurs if the inherited method that is not <code>abstract</code> has a <code>throws</code> clause that conflicts <a href="classes.doc.html#78323">(&#167;8.4.4)</a> with that of any other of the inherited methods.
</ul>
<a name="39567"></a>
<li>If all the inherited methods are <code>abstract</code>, then the class is necessarily an <code>abstract</code> class and is considered to inherit all the <code>abstract</code> methods. A compile-time error occurs if, for any two such inherited methods, either they have different return types or one has a return type and the other is <code>void</code>.  (The <code>throws</code> clauses do not cause errors in this case.)
</ul><a name="39568"></a>
It is not possible for two or more inherited methods with the same signature not to be <code>abstract</code>, because methods that are not <code>abstract</code> are inherited only from the direct superclass, not from superinterfaces.<p>
<a name="39569"></a>
There might be several paths by which the same method declaration might be inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.<p>
<a name="227768"></a>
<h3>8.4.7    Overloading</h3>
<a name="39587"></a>
If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but different signatures, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name but different signatures.<p>
<a name="39909"></a>
Methods are overridden on a signature-by-signature basis. <p>
<a name="258985"></a>
If, for example, a class declares two <code>public</code> methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.
<a name="39591"></a>
<p>
When a method is invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>, the number of actual arguments and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked <a href="expressions.doc.html#289905">(&#167;15.12.2)</a>. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup <a href="expressions.doc.html#45677">(&#167;15.12.4)</a>.
<a name="39598"></a>
<h3>8.4.8    Examples of Method Declarations</h3>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method declarations.<p>
<a name="39600"></a>
<h4>8.4.8.1    Example: Overriding</h4>
<a name="39601"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
	int xLimit, yLimit;
	void move(int dx, int dy) {
		super.move(limit(dx, xLimit), limit(dy, yLimit));
	}
	static int limit(int d, int limit) {
		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
	}
}
</pre></blockquote><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> with its own <code>move</code> method, which limits the distance that the point can move on each invocation of the method. When the <code>move</code> method is invoked for an instance of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be called, even if the reference to the <code>SlowPoint</code> object is taken from a variable whose type is <code>Point</code>.<p>
<a name="39617"></a>
<h4>8.4.8.2    Example: Overloading, Overriding, and Hiding</h4>
<a name="39618"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name <code>move</code> with another method with a different signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a>.<p>
<a name="39633"></a>
In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.
<a name="39634"></a>
<p>
Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="expressions.doc.html#20448">&#167;15.12</a>.
<a name="39638"></a>
<h4>8.4.8.3    Example: Incorrect Overriding</h4>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0, color;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	float getX() { return x; }
	float getY() { return y; }
}
</pre></blockquote><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class <code>Point</code> return values of type <code>int</code>, but the wanna-be overriding methods in class <code>RealPoint</code> return values of type <code>float</code>.<p>
<a name="39655"></a>
<h4>8.4.8.4    Example: Overriding versus Hiding</h4>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	int getX() { return (int)Math.floor(x); }
	int getY() { return (int)Math.floor(y); }
}
</pre></blockquote><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same return types as the methods of class <code>Point</code> that they override, so this code can be successfully compiled.<p>
<a name="39672"></a>
Consider, then, this test program:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		RealPoint rp = new RealPoint();
		Point p = rp;
		rp.move(1.71828f, 4.14159f);
		p.move(1, -1);
		show(p.x, p.y);
		show(rp.x, rp.y);
		show(p.getX(), p.getY());
		show(rp.getX(), rp.getY());
	}
	static void show(int x, int y) {
		System.out.println("(" + x + ", " + y + ")");
	}
	static void show(float x, float y) {
		System.out.println("(" + x + ", " + y + ")");
	}
}
</pre></blockquote><a name="39691"></a>
The output from this program is:<p>
<blockquote><pre>(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)
</pre></blockquote>
<a name="39696"></a>
The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.
<a name="39697"></a>
<p>The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.
<a name="230120"></a>
<p>The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.
</pre></blockquote><a name="229207"></a>
<h4>8.4.8.5    Example: Invocation of Hidden Class Methods</h4>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type is the class that actually contains the declaration of the method. In this respect, hiding of static methods is different from overriding of instance methods. The example:<p>
<blockquote><pre>class Super {
	static String greeting() { return "Goodnight"; }
	String name() { return "Richard"; }
}
class Sub extends Super {
	static String greeting() { return "Hello"; }
	String name() { return "Dick"; }
}
class Test {
	public static void main(String[] args) {
		Super s = new Sub();
		System.out.println(s.greeting() + ", " + s.name());
	}
}
</pre></blockquote><a name="229223"></a>
produces the output:<p>
<blockquote><pre>Goodnight, Dick
</pre></blockquote><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure out, at compile time, which class method to invoke, whereas the invocation of <code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance method to invoke.<p>
<a name="229149"></a>
<h4>8.4.8.6    Large Example of Overriding</h4>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:<p>
<blockquote><pre>import java.io.OutputStream;
import java.io.IOException;
class BufferOutput {
	private OutputStream o;
	BufferOutput(OutputStream o) { this.o = o; }
	protected byte[] buf = new byte[512];
	protected int pos = 0;
	public void putchar(char c) throws IOException {
		if (pos == buf.length)
			flush();
		buf[pos++] = (byte)c;
	}
	public void putstr(String s) throws IOException {
		for (int i = 0; i &lt; s.length(); i++)
			putchar(s.charAt(i));
	}
	public void flush() throws IOException {
		o.write(buf, 0, pos);
		pos = 0;
	}
}
class LineBufferOutput extends BufferOutput {
	LineBufferOutput(OutputStream o) { super(o); }
	public void putchar(char c) throws IOException {
		super.putchar(c);
		if (c == '\n')
			flush();
	}
}
class Test {
	public static void main(String[] args)
		throws IOException
	{
		LineBufferOutput lbo =
			new LineBufferOutput(System.out);
		lbo.putstr("lbo\nlbo");
		System.out.print("print\n");
		lbo.putstr("\n");
	}
}
</pre></blockquote><a name="229188"></a>
This example produces the output:<p>
<blockquote><pre>lbo
print
lbo
</pre></blockquote>
<a name="229192"></a>
The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>BufferOutput</code>.
<p>
<a name="229193"></a>
In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.
<a name="229194"></a>
<p>
Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.
<a name="229195"></a>
<p>
Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="binaryComp.doc.html#44871">&#167;13</a>, especially <a href="binaryComp.doc.html#44952">&#167;13.2</a>.
<a name="229203"></a>
<h4>8.4.8.7    Example: Incorrect Overriding because of Throws</h4>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception type, in its declaration of the class <code>BadPointException</code>:<p>
<blockquote><pre>class BadPointException extends Exception {
	BadPointException() { super(); }
	BadPointException(String s) { super(s); }
}
class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
	void move(int dx, int dy) throws BadPointException {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="39718"></a>
This example results in a compile-time error, because the override of method <code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract between it and <code>Point</code> broken if this exception were thrown.<p>
<a name="39725"></a>
Removing the <code>throws</code> clause does not help:
<blockquote><pre>class CheckedPoint extends Point {
	void move(int dx, int dy) {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote>
<a name="259271"></a>
<p>
A different compile-time error now occurs, because the body of the method <code>move</code> cannot throw a checked exception, namely <code>BadPointException</code>, that does not appear in the <code>throws</code> clause for <code>move</code>.
<a name="246026"></a>
<h2>8.5    Member Type Declarations</h2>
<a name="247539"></a>
A <em>member class </em>is a class whose declaration is directly enclosed in another class or interface declaration. Similarly, a <em>member interface </em>is an interface whose declaration is directly enclosed in another class or interface declaration. The scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a member class or interface is specified in <a href="classes.doc.html#18988">&#167;8.1.5</a>. <p>
<a name="289016"></a>
If the class declares a member type with a certain name, then the declaration of that type is said to <em>hide</em> any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class. <p>
<a name="260651"></a>
Within a class <i>C</i>, a declaration <i>d</i> of a member type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs.<p>
<a name="247579"></a>
If a member class or interface declared with simple name C is directly enclosed within the declaration of a class with fully qualified name N, then the member class or interface has the fully qualified name N.C. <p>
<a name="247722"></a>
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name.<p>
<a name="247732"></a>
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once. It may be referred to by its simple name without ambiguity.<p>
<a name="247581"></a>
<h3>8.5.1    Access Modifiers</h3>
<a name="246857"></a>
The access modifiers public, protected, and private are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if a member type declaration has more than one of the access modifiers public, protected, and private. <p>
<a name="246853"></a>
<h3>8.5.2    Static Member Type Declarations</h3>
<a name="246645"></a>
The static keyword may modify the declaration of a member type C within the body of a non-inner class T. Its effect is to declare that C is not an inner class. Just as a static method of T has no current instance of T in its body, C also has no current instance of T, nor does it have any lexically enclosing instances.<p>
<a name="250215"></a>
It is a compile-time error if a static class contains a usage of a non-static member of an enclosing class.<p>
<a name="247136"></a>
Member interfaces are always implicitly static. It is permitted but not required for the declaration of a member interface to explicitly list the static modifier.<p>
<a name="246032"></a>
<h2>8.6    Instance Initializers</h2>
<a name="246072"></a>
An <em>instance initializer</em> declared in a class is executed when an instance of the class is created <a href="expressions.doc.html#41147">(&#167;15.9)</a>, as specified in <a href="classes.doc.html#229267">&#167;8.8.5.1</a>. <p>
<ul><pre>
<em>InstanceInitializer:
	Block
</em></pre></ul><a name="262742"></a>
An instance initializer of a named class may not throw a checked exception unless that exception or one of its superclasses is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance initializer in an anonymous class <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="273818"></a>
The rules above distinguish between instance initializers in named and anonymous classes. This distinction is deliberate. A given anonymous class is only instantiated at a single point in a program. It is therefore possible to directly propagate information about what exceptions might be raised by an anonymous class' instance initializer to the surrounding expression. Named classes, on the other hand, can be instantiated in many places. Therefore the only way to propagate information about what exceptions might be raised by an instance initializer of a named class is through the throws clauses of its constructors. It follows that a more liberal rule can be used in the case of anonymous classes. Similar comments apply to instance variable initializers.
<a name="273817"></a>
<p>
It is a compile-time error if an instance initializer cannot complete normally <a href="statements.doc.html#236365">(&#167;14.20)</a>. If a return statement <a href="statements.doc.html#6767">(&#167;14.16)</a> appears anywhere within an instance initializer, then a compile-time error occurs.<p>
<a name="294486"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="247361"></a>
Instance initializers are permitted to refer to the current object this <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> and to use the keyword super (<a href="expressions.doc.html#20860">&#167;15.11.2</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>).<p>
<a name="39245"></a>
<h2>8.7    Static Initializers</h2>
<a name="39251"></a>
Any <em>static initializers </em>declared in a class are executed when the class is initialized and, together with any field initializers <a href="classes.doc.html#24510">(&#167;8.3.2)</a> for class variables, may be used to initialize the class variables of the class <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<ul><pre>
<em>StaticInitializer</em>:
	<em>static Block</em>
</pre></ul><a name="41620"></a>
It is a compile-time error for a static initializer to be able to complete abruptly (<a href="statements.doc.html#5894">&#167;14.1</a>, <a href="expressions.doc.html#79448">&#167;15.6</a>) with a checked exception <a href="exceptions.doc.html#44121">(&#167;11.2)</a>. It is a compile-time error if a static initializer cannot complete normally <a href="statements.doc.html#236365">(&#167;14.20)</a>.<p>
<a name="260750"></a>
The static initializers and class variable initializers are executed in textual order. <p>
<a name="294412"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.doc.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="41700"></a>
If a <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="39966"></a>
If the keyword <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.doc.html#41267">&#167;15.11</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>) appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="41652"></a>
<h2>8.8    Constructor Declarations</h2>
<a name="78391"></a>
A <em>constructor</em> is used in the creation of an object that is an instance of a class:<p>
<ul><pre>
<em>ConstructorDeclaration</em>:
<em>	ConstructorModifiers</em><sub><i>opt</i></sub>&#32;<em>ConstructorDeclarator
		Throws<sub><i>opt</i></sub>&#32;ConstructorBody

ConstructorDeclarator:
	SimpleTypeName ( FormalParameterList<sub><i>opt</i></sub> )
</em></pre></ul><a name="30689"></a>
The <em>SimpleTypeName </em>in the <em>ConstructorDeclarator</em> must be the simple name of the class that contains the constructor declaration; otherwise a compile-time error occurs. In all other respects, the constructor declaration looks just like a method declaration that has no result type.<p>
<a name="229252"></a>
<p>
<a name="229249"></a>
Here is a simple example:
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
</pre></blockquote><a name="41721"></a>
Constructors are invoked by class instance creation expressions <a href="expressions.doc.html#41147">(&#167;15.9)</a>, by the conversions and concatenations caused by the string concatenation operator + <a href="expressions.doc.html#39990">(&#167;15.18.1)</a>, and by explicit constructor invocations from other constructors <a href="classes.doc.html#78435">(&#167;8.8.5)</a>. Constructors are never invoked by method invocation expressions <a href="expressions.doc.html#20448">(&#167;15.12)</a>.<p>
<a name="29483"></a>
Access to constructors is governed by access modifiers <a href="names.doc.html#104285">(&#167;6.6)</a>. <p>
<a name="258999"></a>
This is useful, for example, in preventing instantiation by declaring an inaccessible constructor <a href="classes.doc.html#16830">(&#167;8.8.8)</a>.
<a name="39897"></a>
Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.<p>
<a name="29488"></a>
<h3>8.8.1    Formal Parameters</h3>
<a name="41970"></a>
The formal parameters of a constructor are identical in structure and behavior to the formal parameters of a method <a href="classes.doc.html#38698">(&#167;8.4.1)</a>.<p>
<a name="41990"></a>
<h3>8.8.2    Constructor Signature</h3>
<a name="263235"></a>
The <em>signature</em> of a constructor consists of the number and types of formal parameters to the constructor. A class may not declare two constructors with the same signature, or a compile-time error occurs. <p>
<a name="42018"></a>
<h3>8.8.3    Constructor Modifiers</h3>
<ul><pre>
<em>ConstructorModifiers:
	ConstructorModifier
	ConstructorModifiers ConstructorModifier

ConstructorModifier: one of
</em>	public&#32;protected&#32;private
</pre></ul><a name="36010"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a constructor declaration, or if a constructor declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>.<p>
<a name="259286"></a>
Unlike methods, a constructor cannot be <code>abstract</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A constructor is not inherited, so there is no need to declare it <code>final</code> and an <code>abstract</code> constructor could never be implemented. A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be <code>static</code>. There is no practical need for a constructor to be <code>synchronized</code>, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. The lack of <code>native</code> constructors is an arbitrary language design choice that makes it easy for an implementation of the Java virtual machine to verify that superclass constructors are always properly invoked during object creation.
<a name="246538"></a>
<p>Note that a <em>ConstructorModifier</em> cannot be declared <code>strictfp</code>. This difference in the definitions for <em>ConstructorModifier</em> and <em>MethodModifier</em> <a href="classes.doc.html#78188">(&#167;8.4.3)</a> is an intentional language design choice; it effectively ensures that a constructor is FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a> if and only if its class is FP-strict.

<a name="244611"></a>
<h3>8.8.4    Constructor Throws</h3>
<a name="244612"></a>
The <code>throws</code> clause for a constructor is identical in structure and behavior to the <code>throws</code> clause for a method <a href="classes.doc.html#78323">(&#167;8.4.4)</a>.<p>
<a name="78435"></a>
<h3>8.8.5    Constructor Body</h3>
<a name="42051"></a>
The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass <a href="classes.doc.html#229267">(&#167;8.8.5.1)</a>.<p>
<ul><pre>
<em>ConstructorBody:
	{ ExplicitConstructorInvocation<sub>opt</sub> BlockStatements<sub><i>opt</i></sub> }
</em></pre></ul><a name="230283"></a>
<em></em>It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving <code>this</code>. <p>
<a name="229836"></a>
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class <code>Object</code>, then the constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "<code>super();</code>", an invocation of the constructor of its direct superclass that takes no arguments.<p>
<a name="30734"></a>
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method <a href="classes.doc.html#37316">(&#167;8.4.5)</a>. A <code>return</code> statement <a href="statements.doc.html#6767">(&#167;14.16)</a> may be used in the body of a constructor if it does not include an expression.<p>
<a name="42056"></a>
In the example:
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
	static final int WHITE = 0, BLACK = 1;
	int color;
	ColoredPoint(int x, int y) {
		this(x, y, WHITE);
	}
	ColoredPoint(int x, int y, int color) {
		super(x, y);
		this.color = color;
	}
}
</pre></blockquote><a name="271283"></a>
the first constructor of <code>ColoredPoint</code> invokes the second, providing an additional argument; the second constructor of <code>ColoredPoint</code> invokes the constructor of its superclass <code>Point</code>, passing along the coordinates.<p>
<a name="229264"></a>
<a href="execution.doc.html#44670">&#167;12.5</a> and <a href="expressions.doc.html#41147">&#167;15.9</a> describe the creation and initialization of new class instances.<p>
<a name="229267"></a>
<h4>8.8.5.1    Explicit Constructor Invocations</h4>
<ul><pre>
<em>ExplicitConstructorInvocation:
	</em>this<em> ( ArgumentList<sub><i>opt</i></sub> ) ;
</em>	super<em> ( ArgumentList<sub><i>opt</i></sub> ) ;
	Primary.super ( ArgumentList<sub><i>opt</i></sub> ) ; 
</em></pre></ul><a name="255778"></a>
<p>
<a name="255762"></a>
Explicit constructor invocation statements can be divided into two kinds:<p>
<ul><a name="255763"></a>
<li><em>Alternate constructor invocations</em> begin with the keyword this. They are used to invoke an alternate constructor of the same class.
<a name="255764"></a>
<li><em>Superclass constructor invocation</em>s begin with either the keyword super or a <em>Primary</em> expression. They are used to invoke a constructor of the direct superclass. Superclass constructor invocations may be further subdivided:
<ul>
<a name="255765"></a>
<li><em>Unqualified superclass constructor invocations</em> begin with the keyword super. 
<a name="255766"></a>
<li><em>Qualified superclass constructor invocations</em> begin with a <em>Primary</em> expression. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass <a href="classes.doc.html#262890">(&#167;8.1.2)</a>. This may be necessary when the superclass is an inner class.
<a name="255697"></a>
Here is an example of a qualified superclass constructor invocation:
</ul>
</ul><blockquote><pre>class Outer {
	class Inner{}
}
class ChildOfInner extends Outer.Inner {
	ChildOfInner(){(new Outer()).super();}
}
</pre></blockquote><a name="287141"></a>
</ul></ul>
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs. <p>
<a name="291517"></a>
For example, if the first constructor of <code>ColoredPoint</code> in the example above were changed to:
<blockquote><pre>ColoredPoint(int x, int y) {
	this(x, y, color);
}
</pre></blockquote><a name="259296"></a>
then a compile-time error would occur, because an instance variable cannot be used within a superclass constructor invocation.<p>
<a name="255702"></a>
If an anonymous class instance creation expression appears within an explicit constructor invocation statement, then the anonymous class may not refer to any of the enclosing instances of the class whose constructor is being invoked.<p>
<a name="255703"></a>
For example:
<blockquote><pre>class Top {
	int x;
	class Dummy {
		Dummy(Object o) {}
	}
	class Inside extends Dummy {
		Inside() {
			super(new Object() { int r = x; }); // error
		}
		Inside(final int y) {
			super(new Object() { int r = y; }); // correct
		}
	}
}
</pre></blockquote><a name="255722"></a>
Let <i>C</i> be the class being instantiated, let <i>S</i> be the direct superclass of <i>C</i>, and let <i>i</i> be the instance being created. The evaluation of an explicit constructor invocation proceeds as follows:<p>
<ul><a name="255921"></a>
<li>First, if the constructor invocation statement is a superclass constructor invocation, then the immediately enclosing instance of <i>i</i> with respect to <i>S</i> (if any) must be determined. Whether or not <i>i</i> has an immediately enclosing instance with respect to <i>S</i> is determined by the superclass constructor invocation as follows:
<ul>
<a name="255723"></a>
<li>If <i>S</i> is not an inner class, or if the declaration of <i>S</i> occurs in a static context, no immediately enclosing instance of <i>i</i> with respect to <i>S</i> exists. A compile-time error occurs if the superclass constructor invocation is a qualified superclass constructor invocation.
<a name="255724"></a>
<li>Otherwise:
<ul>
<a name="255725"></a>
<li>If the superclass constructor invocation is qualified, then the <em>Primary</em> expression <i>p</i> immediately preceding ".<code>super</code>" is evaluated. If the primary expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly. Otherwise, the result of this evaluation is the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. Let <i>O</i> be the immediately lexically enclosing class of <i>S</i>; it is a compile-time error if the type of <i>p</i> is not <i>O</i> or a subclass of <i>O</i>.
<a name="255726"></a>
<li>Otherwise:
<ul>
<a name="255730"></a>
<li>If <i>S</i> is a local class <a href="statements.doc.html#247766">(&#167;14.3)</a>, then <i>S</i> must be declared in a method declared in a lexically enclosing class <i>O</i>. Let <em>n</em> be an integer such that <i>O</i> is the <em>n</em>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <em>n</em>th lexically enclosing instance of this.
<a name="255734"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.doc.html#246026">(&#167;8.5)</a>. It is a compile-time error if <i>S</i> is not a member of a lexically enclosing class. Let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <em>n</em> be an integer such that <i>O</i> is the <em>n</em>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <em>n</em>th lexically enclosing instance of this.
</ul>
</ul>
</ul>
<a name="255735"></a>
<li>Second, the arguments to the constructor are evaluated, left-to-right, as in an ordinary method invocation.
<a name="255924"></a>
<li>Next, the constructor is invoked.
<a name="255859"></a>
<li>Finally, if the constructor invocation statement is a superclass constructor invocation and the constructor invocation statement completes normally, then all instance variable initializers of <i>C</i> and all instance initializers of <i>C</i> are executed. If an instance initializer or instance variable initializer <i>I</i> textually precedes another instance initializer or instance variable initializer <i>J</i>, then <i>I</i> is executed before <i>J</i>. This action is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically. An alternate constructor invocation does not perform this additional implicit action.
</ul><a name="229266"></a>
<h3>8.8.6    Constructor Overloading</h3>
<a name
<a name="16815"></a>
Overloading of constructors is identical in behavior to overloading of methods. The overloading is resolved at compile time by each class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>.<p>
<a name="16823"></a>
<h3>8.8.7    Default Constructor</h3>
<a name="229830"></a>
If a class contains no constructor declarations, then a <em>default constructor</em> that takes no parameters is automatically provided:<p>
<ul><a name="229831"></a>
<li>If the class being declared is the primordial class <code>Object</code>, then the default constructor has an empty body.
<a name="229832"></a>
<li>Otherwise, the default constructor takes no parameters and simply invokes the superclass constructor with no arguments.
</ul><a name="16772"></a>
A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have an accessible constructor that takes no arguments.<p>
<a name="257593"></a>
<p>A default constructor has no <code>throws</code> clause.<p>
It follows that is the nullary constructor of the superclass has a
<code>throws</code> clause, then a compile-time error will occur.
<p>
<a name="16773"></a>
If the class is declared public, then the default constructor is implicitly given the access modifier public <a href="names.doc.html#104285">(&#167;6.6)</a>; if the class is declared protected, then the default constructor is implicitly given the access modifier protected <a href="names.doc.html#104285">(&#167;6.6)</a>; if the class is declared private, then the default constructor is implicitly given the access modifier private <a href="names.doc.html#104285">(&#167;6.6)</a>; otherwise, the default constructor has the default access implied by no access modifier. <p>
<a name="259026"></a>
Thus, the example:
<blockquote><pre>public class Point {
	int x, y;
}
</pre></blockquote><a name="16781"></a>
is equivalent to the declaration:<p>
<blockquote><pre>public class Point {
	int x, y;
	public Point() { super(); }
}
</pre></blockquote><a name="16786"></a>
where the default constructor is <code>public</code> because the class <code>Point</code> is <code>public</code>.<p>

The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider
<blockquote><pre>package p1;
public class Outer {
 	protected class Inner{}
}
package p2;
class SonOfOuter extends p1.Outer {
	void foo() {
 		new Inner(); // compile-time access error
	}
}

</pre></blockquote><a name="259796"></a>
The constructor for <code>Inner</code> is protected. However, the constructor is protected relative to <code>Inner</code>, while <code>Inner</code> is protected relative to <code>Outer</code>. So, <code>Inner</code> is accessible in <code>SonOfOuter</code>, since it is a subclass of <code>Outer</code>. <code>Inner</code>'s constructor is not accessible in <code>SonOfOuter</code>, because the class <code>SonOfOuter</code> is not a subclass of <code>Inner</code>! Hence, even though <code>Inner </code>is accessible, its default constructor is not.<p>
<a name="16830"></a>
<h3>8.8.8    Preventing Instantiation of a Class</h3>
<a name="16831"></a>
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and declaring all constructors to be <code>private</code>. A <code>public</code> class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with <code>public</code> access, and declaring no constructor that is <code>public</code>.<p>
<a name="16833"></a>
Thus, in the example:
<blockquote><pre>class ClassOnly {
	private ClassOnly() { }
	static String just = "only the lonely";
}
</pre></blockquote><a name="16838"></a>
the class <code>ClassOnly</code> cannot be instantiated, while in the example:<p>
<blockquote><pre>package just;
public class PackageOnly {
	PackageOnly() { }
	String[] justDesserts = { "cheesecake", "ice cream" };
}
</pre></blockquote><a name="259306"></a>
the class <code>PackageOnly</code> can be instantiated only within the package <code>just</code>, in which it is declared.
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="packages.doc.html">Prev</a> | <a href="interfaces.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on May 19, 2000)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 2000 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Interfaces</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="classes.doc.html">Prev</a> | <a href="arrays.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="238678"></a>
<p><strong>
CHAPTER
 9 </strong></p>
<a name="238680"></a>
<h1>Interfaces</h1>
<hr><p>
<a name="236346"></a>
An interface declaration introduces a new reference type whose members are classes, interfaces, constants and abstract methods. This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods.<p>
<a name="245713"></a>
A nested interface is any interface whose declaration occurs within the body of another class or interface. A top-level interface is an interface that is not a nested interface.<p>
<a name="245720"></a>
This chapter discusses the common semantics of all interfaces-top-level <a href="packages.doc.html#26783">(&#167;7.6)</a> and nested (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.<p>
<a name="247545"></a>
Programs can use interfaces to make it unnecessary for related classes to share a common abstract superclass or to add methods to <code>Object</code>.
<a name="247549"></a>
An interface may be declared to be a <em>direct extension </em>of one or more other interfaces, meaning that it implicitly specifies all the member types, abstract methods and constants of the interfaces it extends, except for any member types and constants that it may hide.<p>
<a name="30809"></a>
A class may be declared to <em>directly implement</em> one or more interfaces, meaning that any instance of the class implements all the abstract methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing any implementation.<p>
<a name="35467"></a>
A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the abstract methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.<p>
<a name="35470"></a>
<h2>9.1    Interface Declarations</h2>
<a name="27727"></a>
An <em>interface declaration</em> specifies a new named reference type:<p>
<ul><pre>
<em>InterfaceDeclaration:
	InterfaceModifiers<sub><i>opt</i></sub></em> interface <em>Identifier
		ExtendsInterfaces<sub><i>opt</i></sub> InterfaceBody</em>
</pre></ul><a name="252341"></a>
The <em>Identifier</em> in an interface declaration specifies the name of the interface. A compile-time error occurs if an interface has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="235947"></a>
<h3>9.1.1    Interface Modifiers</h3>
<a name="17033"></a>
An interface declaration may include <em>interface modifiers</em>:<p>
<ul><pre>
<em>InterfaceModifiers:
	InterfaceModifier
	InterfaceModifiers InterfaceModifier

InterfaceModifier: one of
</em>	public&#32;protected&#32;private
	abstract&#32;static&#32;strictfp
</pre></ul><a name="78582"></a>
The access modifier public is discussed in <a href="names.doc.html#104285">&#167;6.6</a>. Not all modifiers are applicable to all kinds of interface declarations. The access modifiers protected and private pertain only to member interfaces within a directly enclosing class declaration <a href="classes.doc.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.doc.html#247581">&#167;8.5.1</a>. The access modifier static pertains only to member interfaces (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in an interface declaration. <p>
<a name="30820"></a>
<h4>9.1.1.1    <code>abstract</code> Interfaces</h4>
<a name="30821"></a>
Every interface is implicitly <code>abstract</code>. This modifier is obsolete and should not be used in new programs.<p>
<a name="246350"></a>
<h4>9.1.1.2    <code>strictfp</code> Interfaces</h4>
<a name="251658"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the interface declaration be explicitly FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>. <p>
<a name="252569"></a>
This implies that all nested types declared in the interface are implicitly <code>strictfp</code>.<p>
<a name="78598"></a>
<h3>9.1.2    Superinterfaces and Subinterfaces</h3>
<a name="78599"></a>
If an <code>extends</code> clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces. These other named interfaces are the <em>direct superinterfaces</em> of the interface being declared. Any class that <code>implements</code> the declared interface is also considered to implement all the interfaces that this interface <code>extends</code>.<p>
<ul><pre>
<em>ExtendsInterfaces:
</em>	extends <em>InterfaceType
	ExtendsInterfaces , InterfaceType
</em></pre></ul><a name="21599"></a>
The following is repeated from <a href="typesValues.doc.html#85587">&#167;4.2</a> to make the presentation here clearer:<p>
<ul><pre>
<em>InterfaceType:
	TypeName
</em></pre></ul><a name="152015"></a>
Each <em>InterfaceType </em>in the <code>extends</code> clause of an interface declaration must name an accessible interface type; otherwise a compile-time error occurs.<p>
<a name="246991"></a>
An interface <i>I directly depends</i> on a type <i>T </i>if <i>T</i> is mentioned in the <code>extends</code> clause of <i>I</i> either as a superinterface or as a qualifier within a superinterface name. An interface <i>I</i> depends on a reference type <i>T</i> if any of the following conditions hold:<p>
<ul><a name="246992"></a>
<li><i>I</i> directly depends on <i>T</i>.
<a name="246996"></a>
<li><i>I</i> directly depends on a class <i>C</i> that depends <a href="classes.doc.html#262560">(&#167;8.1.3)</a> on <i>T</i>.
<a name="252497"></a>
<li><i>I</i> directly depends on an interface <i>J</i> that depends on <i>T</i> (using this definition recursively).
</ul><a name="252500"></a>
A compile-time error occurs if an interface depends on itself.<p>
<a name="78603"></a>
While every class is an extension of class <code>Object</code>, there is no single interface of which all interfaces are extensions. <p>
<a name="245858"></a>
The <em>superinterface </em>relationship is the transitive closure of the direct superinterface relationship. An interface <i>K</i> is a superinterface of interface <i>I</i> if either of the following is true:<p>
<ul><a name="236096"></a>
<li><i>K</i> is a direct superinterface of <i>I</i>.
<a name="236097"></a>
<li>There exists an interface <i>J</i> such that <i>K</i> is a superinterface of <i>J</i>, and <i>J</i> is a superinterface of <i>I</i>, applying this definition recursively.
</ul><a name="236428"></a>
Interface <i>I</i> is said to be a <em>subinterface </em>of interface <i>K</i> whenever <i>K</i> is a superinterface of <i>I</i>.<p>
<a name="236431"></a>
<h3>9.1.3    Interface Body and Member Declarations</h3>
<a name="78608"></a>
The body of an interface may declare members of the interface:<p>
<ul><pre>
<em>
InterfaceBody:
	{ InterfaceMemberDeclarations<sub><i>opt</i></sub> }

InterfaceMemberDeclarations:
	InterfaceMemberDeclaration
	InterfaceMemberDeclarations InterfaceMemberDeclaration

InterfaceMemberDeclaration:
	ConstantDeclaration
	AbstractMethodDeclaration
	ClassDeclaration 
	InterfaceDeclaration
	<code>;</code></em>
</pre></ul><a name="253070"></a>
<strong></strong>The scope of the declaration of a member m declared in or inherited by an interface type I is the entire body of <i>I</i>, including any nested type declarations.<p>
<a name="17144"></a>
<h3>9.1.4    Access to Interface Member Names</h3>
<a name="17145"></a>
All interface members are implicitly <code>public</code>. They are accessible outside the package where the interface is declared if the interface is also declared <code>public</code> or <code>protected</code>, in accordance with the rules of <a href="names.doc.html#104285">&#167;6.6</a>.<p>
<a name="32392"></a>
<h2>9.2    Interface Members</h2>
<a name="253076"></a>
The members of an interface are:<p>
<ul><a name="253077"></a>
<li>Those members declared in the interface.
<a name="253080"></a>
<li>Those members inherited from direct superinterfaces.
<a name="253081"></a>
<li>If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method <i>m</i> with signature <i>s</i>, return type <i>r</i>, and <code>throws</code> clause <i>t</i> corresponding to each public instance method <i>m</i> with signature <i>s</i>, return type <i>r</i>, and <code>throws</code> clause <i>t</i> declared in <code>Object</code>, unless a method with the same signature, same return type, and a compatible <code>throws</code> clause is explicitly declared by the interface.
</ul><a name="252465"></a>
It follows that it is a compile-time error if the interface declares a method with the same signature and different return type or incompatible <code>throws</code> clause.<p>
<a name="245677"></a>
The interface inherits, from the interfaces it extends, all members of those interfaces, except for fields, classes, and interfaces that it hides and methods that it overrides.<p>
<a name="78642"></a>
<h2>9.3    Field (Constant) Declarations</h2>
<ul><pre>
<em>
ConstantDeclaration:
	ConstantModifiers<sub><i>opt</i></sub> Type VariableDeclarators

ConstantModifiers: 
	ConstantModifier
<code>	</code>ConstantModifiers ConstantModifer<code>&#32;
</code>
ConstantModifier: one of</em>
	public&#32;static&#32;final
</pre></ul><a name="40575"></a>
Every field declaration in the body of an interface is implicitly <code>public</code>, <code>static</code>, and <code>final</code>. It is permitted to redundantly specify any or all of these modifiers for such fields.<p>
<a name="252384"></a>
If the interface declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superinterfaces of the interface.<p>
<a name="252453"></a>
It is a compile-time error for the body of an interface declaration to declare two fields with the same name.<p>
<a name="40725"></a>
It is possible for an interface to inherit more than one field with the same name <a href="classes.doc.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to either field by its simple name will result in a compile-time error, because such a reference is ambiguous.<p>
<a name="40729"></a>
There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity. <p>
<a name="40720"></a>
<h3>9.3.1    Initialization of Fields in Interfaces</h3>
<a name="236695"></a>
Every field in the body of an interface must have an initialization expression, which need not be a constant expression. The variable initializer is evaluated and the assignment performed exactly once, when the interface is initialized <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="247455"></a>
A compile-time error occurs if an initialization expression for an interface field contains a reference by simple name to the same field or to another field whose declaration occurs textually later in the same interface.<p>
<a name="247101"></a>
Thus:
<blockquote><pre>interface Test {
	float f = j;
	int j = 1;
	int k = k+1;
}
</pre></blockquote><a name="41013"></a>
causes two compile-time errors, because <code>j</code> is referred to in the initialization of <code>f</code> before <code>j</code> is declared and because the initialization of <code>k</code> refers to <code>k</code> itself.<p>
<a name="247483"></a>
One subtlety here is that, at run time, fields that are initialized with compile-time constant values are initialized first. This applies also to <code>static</code> <code>final</code> fields in classes <a href="classes.doc.html#38010">(&#167;8.3.2.1)</a>. This means, in particular, that these fields will never be observed to have their default initial values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>, even by devious programs. See <a href="execution.doc.html#44630">&#167;12.4.2</a> and <a href="binaryComp.doc.html#45139">&#167;13.4.8</a> for more discussion.
<p>
<a name="41024"></a>
If the keyword <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.doc.html#20860">15.11.2</a>, <a href="expressions.doc.html#20448">15.12</a>) occurs in an initialization expression for a field of an interface, then unless the occurrence is within the body of an anonymous class <a href="expressions.doc.html#252986">(&#167;15.9.5)</a>, a compile-time error occurs.<p>
<a name="40595"></a>
<h3>9.3.2    Examples of Field Declarations</h3>
<a name="40743"></a>
The following example illustrates some (possibly subtle) points about field declarations.<p>
<a name="40596"></a>
<h4>9.3.2.1    Ambiguous Inherited Fields</h4>
<a name="40648"></a>
If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single <em>ambiguous member</em> results. Any use of this ambiguous member will result in a compile-time error. Thus in the example:<p>
<blockquote><pre>interface BaseColors {
	int RED = 1, GREEN = 2, BLUE = 4;
}
interface RainbowColors extends BaseColors {
	int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7;
}
interface PrintColors extends BaseColors {
	int YELLOW = 8, CYAN = 16, MAGENTA = 32;
}
interface LotsOfColors extends RainbowColors, PrintColors {
	int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90;
}
</pre></blockquote><a name="40661"></a>
the interface <code>LotsOfColors</code> inherits two fields named <code>YELLOW</code>. This is all right as long as the interface does not contain any reference by simple name to the field <code>YELLOW</code>. (Such a reference could occur within a variable initializer for a field.)<p>
<a name="40696"></a>
Even if interface <code>PrintColors</code> were to give the value <code>3</code> to <code>YELLOW</code> rather than the value <code>8</code>, a reference to field <code>YELLOW</code> within interface <code>LotsOfColors</code> would still be considered ambiguous.
<p>
<a name="40599"></a>
<h4>9.3.2.2    Multiply Inherited Fields</h4>
<a name="236005"></a>
If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results. This situation does not in itself cause a compile-time error. <p>
<a name="247488"></a>
In the example in the previous section, the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by interface <code>LotsOfColors</code> in more than one way, through interface <code>RainbowColors</code> and also through interface <code>PrintColors</code>, but the reference to field <code>RED</code> in interface <code>LotsOfColors</code> is not considered ambiguous because only one actual declaration of the field <code>RED</code> is involved.
<p>
<a name="78651"></a>
<h2>9.4    Abstract Method Declarations</h2>
<ul><pre>
<em>AbstractMethodDeclaration:
	AbstractMethodModifiers<sub><i>opt</i></sub> ResultType MethodDeclarator Throws<sub><i>opt</i></sub> ;

AbstractMethodModifiers:
	AbstractMethodModifier
	AbstractMethodModifiers AbstractMethodModifier

AbstractMethodModifier: one of</em>
	public&#32;abstract
</pre></ul><a name="36046"></a>
The access modifier <code>public</code> is discussed in <a href="names.doc.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in an abstract method declaration.<p>
<a name="247503"></a>
Every method declaration in the body of an interface is implicitly <code>abstract</code>, so its body is always represented by a semicolon, not a block.<p>
<a name="250791"></a>
Every method declaration in the body of an interface is implicitly <code>public</code>.<p>
<a name="247508"></a>
For compatibility with older versions of the Java platform, it is permitted but discouraged, as a matter of style, to redundantly specify the <code>abstract</code> modifier for methods declared in interfaces.
<a name="247493"></a>
<p>It is permitted, but strongly discouraged as a matter of style, to redundantly specify the <code>public</code> modifier for interface methods.<p>
<a name="38687"></a>
Note that a method declared in an interface must not be declared <code>static</code>, or a compile-time error occurs, because <code>static</code> methods cannot be <code>abstract</code>.<p>
<a name="245194"></a>
Note that a method declared in an interface must not be declared <code>strictfp</code> or <code>native</code> or <code>synchronized</code>, or a compile-time error occurs, because those keywords describe implementation properties rather than interface properties. However, a method declared in an interface may be implemented by a method that is declared <code>strictfp</code> or <code>native</code> or <code>synchronized</code> in a class that implements the interface.<p>
<a name="252440"></a>
It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with the same signature (name, number of parameters, and types of any parameters) <a href="classes.doc.html#38649">(&#167;8.4.2)</a>. However, an interface may inherit several methods with the same signature <a href="interfaces.doc.html#40247">(&#167;9.4.1)</a>.<p>
<a name="38671"></a>
Note that a method declared in an interface must not be declared <code>final</code> or a compile-time error occurs. However, a method declared in an interface may be implemented by a method that is declared <code>final</code> in a class that implements the interface.<p>
<a name="40247"></a>
<h3>9.4.1    Inheritance and Overriding</h3>
<a name="40229"></a>
If the interface declares a method, then the declaration of that method is said to <em>override</em> any and all methods with the same signature in the superinterfaces of the interface.<p>
<a name="245222"></a>
If a method declaration in an interface overrides the declaration of a method in another interface, a compile-time error occurs if the methods have different return types or if one has a return type and the other is <code>void</code>. Moreover, a method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.doc.html#78323">(&#167;8.4.4)</a> with that of any method that it overrides; otherwise, a compile-time error occurs.<p>
<a name="236025"></a>
Methods are overridden on a signature-by-signature basis. If, for example, an interface declares two <code>public</code> methods with the same name, and a subinterface overrides one of them, the subinterface still inherits the other method.<p>
<a name="40237"></a>
An interface inherits from its direct superinterfaces all methods of the superinterfaces that are not overridden by a declaration in the interface.<p>
<a name="40242"></a>
It is possible for an interface to inherit more than one method with the same signature <a href="classes.doc.html#38649">(&#167;8.4.2)</a>. Such a situation does not in itself cause a compile-time error. The interface is considered to inherit all the methods. However, a compile-time error occurs if, for any two such inherited methods, either they have different return types or one has a return type and the other is <code>void</code>. (The <code>throws</code> clauses do not cause errors in this case.) There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never of itself results in a compile-time error.<p>
<a name="236017"></a>
<h3>9.4.2    Overloading</h3>
<a name="40243"></a>
If two methods of an interface (whether both declared in the same interface, or both inherited by an interface, or one declared and one inherited) have the same name but different signatures, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name but different signatures.<p>
<a name="40248"></a>
<h3>9.4.3    Examples of Abstract Method Declarations</h3>
<a name="40738"></a>
The following examples illustrate some (possibly subtle) points about abstract method declarations.<p>
<a name="40734"></a>
<h4>9.4.3.1    Example: Overriding</h4>
<a name="40251"></a>
Methods declared in interfaces are <code>abstract</code> and thus contain no implementation. About all that can be accomplished by an overriding method declaration, other than to affirm a method signature, is to restrict the exceptions that might be thrown by an implementation of the method. Here is a variation of the example shown in <a href="classes.doc.html#34484">&#167;8.4.3.1</a>:<p>
<blockquote><pre>class BufferEmpty extends Exception {
	BufferEmpty() { super(); }
	BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
	BufferError() { super(); }
	BufferError(String s) { super(s); }
}
public interface Buffer {
	char get() throws BufferEmpty, BufferError;
}
public interface InfiniteBuffer extends Buffer {
	 char get() throws BufferError;												// override
}
</pre></blockquote><a name="40735"></a>
<h4>9.4.3.2    Example: Overloading</h4>
<a name="40788"></a>
In the example code:<p>
<blockquote><pre>interface PointInterface {
	void move(int dx, int dy);
}
interface RealPointInterface extends PointInterface {
	void move(float dx, float dy);
	void move(double dx, double dy);
}
</pre></blockquote><a name="252555"></a>
the method name <code>move</code> is overloaded in interface <code>RealPointInterface</code> with three different signatures, two of them declared and one inherited. Any non-<code>abstract</code> class that implements interface <code>RealPointInterface</code> must provide implementations of all three method signatures.<p>
<a name="252566"></a>
<h2>9.5    Member Type Declarations</h2>
<a name="245919"></a>
Interfaces may contain member type declarations <a href="classes.doc.html#246026">(&#167;8.5)</a>. A member type declaration in an interface is implicitly <code>static</code> and <code>public</code>.<p>
<a name="245949"></a>
If a member type declared with simple name C is directly enclosed within the declaration of an interface with fully qualified name N, then the member type has the fully qualified name N.C. <p>
<a name="252418"></a>
If the interface declares a member type with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of member types with the same name in superinterfaces of the interface.<p>
<a name="239523"></a>
An interface may inherit two or more type declarations with the same name. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name. If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once; it may be referred to by its simple name without ambiguity.<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="classes.doc.html">Prev</a> | <a href="arrays.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Arrays</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="interfaces.doc.html">Prev</a> | <a href="exceptions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="27803"></a>
<p><strong>
CHAPTER
 10 </strong></p>
<a name="27805"></a>
<h1>Arrays</h1>
<hr><p>
<a name="25550"></a>
In the Java programming language <em>arrays</em> are objects <a href="typesValues.doc.html#12028">(&#167;4.3.1)</a>, are dynamically created, and may be assigned to variables of type <code>Object</code> <a href="typesValues.doc.html#11055">(&#167;4.3.2)</a>. All methods of class <code>Object</code> may be invoked on an array.<p>
<a name="25500"></a>
An array object contains a number of variables. The number of variables may be zero, in which case the array is said to be <em>empty</em>. The variables contained in an array have no names; instead they are referenced by array access expressions that use nonnegative integer index values. These variables are called the <em>components</em> of the array. If an array has <em>n</em> components, we say <em>n</em> is the <em>length</em> of the array; the components of the array are referenced using integer indices from 0 to <i>n</i> - 1, inclusive.<p>
<a name="61129"></a>
All the components of an array have the same type, called the <em>component type</em> of the array. If the component type of an array is <i>T</i>, then the type of the array itself is written <i>T</i><code>[]</code>.<p>
<a name="61371"></a>
The value of an array component of type <code>float</code> is always an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, the value of an array component of type <code>double</code> is always an element of the double value set. It is not permitted for the value of an array component of type <code>float</code> to be an element of the float-extended-exponent value set that is not also an element of the float value set, nor for the value of an array component of type <code>double</code> to be an element of the double-extended-exponent value set that is not also an element of the double value set.<p>
<a name="25502"></a>
The component type of an array may itself be an array type. The components of such an array may contain references to subarrays. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the <em>element type</em> of the original array, and the components at this level of the data structure are called the <em>elements</em> of the original array.<p>
<a name="63008"></a>
There are some situations in which an element of an array can be an array: if the element type is <code>Object</code> or <code>Cloneable</code> or <code>java.io.Serializable</code>, then some or all of the elements may be arrays, because any array object can be assigned to any variable of these types.
<a name="25518"></a>
<h2>10.1    Array Types</h2>
<a name="25519"></a>
An array type is written as the name of an element type followed by some number of empty pairs of square brackets <code>[]</code>. The number of bracket pairs indicates the depth of array nesting. An array's length is not part of its type.<p>
<a name="30943"></a>
The element type of an array may be any type, whether primitive or reference. In particular:<p>
<ul><a name="26084"></a>
<li>Arrays with an interface type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any type that implements the interface.
<a name="26075"></a>
<li>Arrays with an <code>abstract</code> class type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any subclass of the <code>abstract</code> class that is not itself <code>abstract</code>.
</ul><a name="25523"></a>
Array types are used in declarations and in cast expressions <a href="expressions.doc.html#238146">(&#167;15.16)</a>.<p>
<a name="25891"></a>
<h2>10.2    Array Variables</h2>
<a name="17235"></a>
A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator <a href="classes.doc.html#40898">(&#167;8.3)</a> may create an array, a reference to which then becomes the initial value of the variable.<p>
<a name="61598"></a>
Because an array's length is not part of its type, a single variable of array type may contain references to arrays of different lengths.<p>
<a name="25894"></a>
Here are examples of declarations of array variables that do not create arrays:
<blockquote><pre>
int[] ai;		// array of int
short[][] as;		// array of array of short
Object[]    ao,		// array of Object
	otherAo;	// array of Object
short	s,		// scalar short 
	aas[][];	// array of array of short
</pre></blockquote><a name="25902"></a>
Here are some examples of declarations of array variables that create array objects:<p>
<blockquote><pre>
Exception ae[] = new Exception[3]; 
Object aao[][] = new Exception[2][3];
int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac[] = { 'n', 'o', 't', ' ', 'a', ' ',
				 'S', 't', 'r', 'i', 'n', 'g' }; 
String[] aas = { "array", "of", "String", };
</pre></blockquote><a name="25909"></a>
The <code>[]</code> may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both, as in this example:<p>
<blockquote><pre>byte[] rowvector, colvector, matrix[];
</pre></blockquote><a name="25911"></a>
This declaration is equivalent to:<p>
<blockquote><pre>byte rowvector[], colvector[], matrix[][];
</pre></blockquote><a name="25915"></a>
Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.<p>
<a name="25953"></a>
If an array variable <i>v</i> has type <i>A</i><code>[]</code>, where <i>A</i> is a reference type, then <i>v</i> can hold a reference to an instance of any array type <i>B</i><code>[]</code>, provided <i>B</i> can be assigned to <i>A</i>. This may result in a run-time exception on a later assignment; see <a href="arrays.doc.html#11430">&#167;10.10</a> for a discussion.<p>
<a name="25959"></a>
<h2>10.3    Array Creation</h2>
<a name="25650"></a>
An array is created by an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a> or an array initializer <a href="arrays.doc.html#11358">(&#167;10.6)</a>.<p>
<a name="25675"></a>
An array creation expression specifies the element type, the number of levels of nested arrays, and the length of the array for at least one of the levels of nesting. The array's length is available as a final instance variable <code>length</code>.<p>
<a name="25676"></a>
An array initializer creates an array and provides initial values for all its components. <p>
<a name="25566"></a>
<h2>10.4    Array Access</h2>
<a name="53523"></a>
A component of an array is accessed by an array access expression <a href="expressions.doc.html#239587">(&#167;15.13)</a> that consists of an expression whose value is an array reference followed by an indexing expression enclosed by <code>[</code> and <code>]</code>, as in <code>A[i]</code>. All arrays are <code>0</code>-origin. An array with length <i>n</i> can be indexed by the integers <code>0</code> to <i>n</i><code>-1</code>.<p>
<a name="25570"></a>
Arrays must be indexed by <code>int</code> values; <code>short</code>, <code>byte</code>, or <code>char</code> values may also be used as index values because they are subjected to unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a> and become <code>int</code> values. An attempt to access an array component with a <code>long</code> index value results in a compile-time error.<p>
<a name="61612"></a>
All array accesses are checked at run time; an attempt to use an index that is less than zero or greater than or equal to the length of the array causes an <code>ArrayIndexOutOfBoundsException</code> &#32;to be thrown.<p>
<a name="54000"></a>
<h2>10.5    Arrays: A Simple Example</h2>
<a name="25421"></a>
The example:<p>
<blockquote><pre>class Gauss {
	public static void main(String[] args) {
		int[] ia = new int[101];
		for (int i = 0; i &lt; ia.length; i++)
			ia[i] = i;
		int sum = 0;
		for (int i = 0; i &lt; ia.length; i++)
			sum += ia[i];
		System.out.println(sum);
	}
}
</pre></blockquote><a name="25454"></a>
that produces the output:<p>
<blockquote><pre>5050
</pre></blockquote><a name="25463"></a>
declares a variable <code>ia</code> that has type array of <code>int</code>, that is, <code>int[]</code>. The variable <code>ia</code> is initialized to reference a newly created array object, created by an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>. The array creation expression specifies that the array should have <code>101</code> components. The length of the array is available using the field <code>length</code>, as shown.<p>
<a name="61617"></a>
The example program fills the array with the integers from <code>0</code> to <code>100</code>, sums these integers, and prints the result.
<a name="11358"></a>
<h2>10.6    Array Initializers</h2>
<a name="25749"></a>
An <em>array initializer</em> may be specified in a declaration, or as part of an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>, creating an array and providing some initial values:<p>
<ul><pre>
<em>ArrayInitializer:
	<code>{ </code>VariableInitializers<sub><i>opt</i></sub><code> ,</code><sub><i>opt</i></sub><code> }
</code>
VariableInitializers:
	VariableInitializer
	VariableInitializers<code> , </code>VariableInitializer
</em></pre></ul><a name="25741"></a>
The following is repeated from <a href="classes.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<ul><pre>
<em>VariableInitializer:
	Expression
	ArrayInitializer
</em></pre></ul><a name="25727"></a>
An array initializer is written as a comma-separated list of expressions, enclosed by braces "<code>{</code>" and "<code>}</code>".<p>
<a name="64369"></a>
The length of the constructed array will equal the number of expressions.<p>
<a name="25755"></a>
The expressions in an array initializer are executed from left to right in the textual order they occur in the source code. The <em>n</em>th variable initializer specifies the value of the <em>n-1</em>st array component. Each expression must be assignment-compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the array's component type, or a compile-time error results.<p>
<a name="25756"></a>
If the component type is itself an array type, then the expression specifying a component may itself be an array initializer; that is, array initializers may be nested.<p>
<a name="61622"></a>
A trailing comma may appear after the last expression in an array initializer and is ignored.<p>
<a name="25758"></a>
As an example:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int ia[][] = { {1, 2}, null };
		for (int i = 0; i &lt; 2; i++)
			for (int j = 0; j &lt; 2; j++)
				System.out.println(ia[i][j]);
	}
}
</pre></blockquote><a name="25767"></a>
prints:<p>
<blockquote><pre>1
2
</pre></blockquote><a name="61627"></a>
before causing a <code>NullPointerException</code> in trying to index the second component of the array <code>ia</code>, which is a null reference.<p>
<a name="64347"></a>
<h2>10.7    Array Members</h2>
<a name="64511"></a>
The members of an array type are all of the following:<p>
<ul><a name="64513"></a>
<li>The <code>public</code> <code>final</code> field <code>length</code>, which contains the number of components of the array (<code>length</code> may be positive or zero)
<a name="64515"></a>
<li>The <code>public</code> method <code>clone</code>, which overrides the method of the same name in class <code>Object</code> and throws no checked exceptions
<a name="64517"></a>
<li>All the members inherited from class <code>Object</code>; the only method of <code>Object</code> that is not inherited is its <code>clone</code> method
</ul><a name="29781"></a>
<p>
<a name="62964"></a>
An array thus has the same public fields and methods as the following class:<p>
<blockquote><pre>class A implements Cloneable, java.io.Serializable {
	public final int length = <sup>X</sup>;
	public Object clone() {
		try {
			return super.clone();
		} catch (CloneNotSupportedException e) {
			throw new InternalError(e.getMessage());
		}
	}
}
</pre></blockquote><a name="61637"></a>
Every array implements the interfaces <code>Cloneable</code> and <code>java.io.Serializable</code>. <p>
<a name="61641"></a>
That arrays are cloneable is shown by the test program:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int ia1[] = { 1, 2 };
		int ia2[] = (int[])ia1.clone();
		System.out.print((ia1 == ia2) + " ");
		ia1[1]++;
		System.out.println(ia2[1]);
	}
}
</pre></blockquote><a name="25812"></a>
which prints:<p>
<blockquote><pre>false 2
</pre></blockquote><a name="61648"></a>
showing that the components of the arrays referenced by <code>ia1</code> and <code>ia2</code> are different variables. (In some early implementations of the Java programming language this example failed to compile because the compiler incorrectly believed that the clone method for an array could throw a <code>CloneNotSupportedException</code>.)<p>
<a name="61654"></a>
A <code>clone</code> of a multidimensional array is shallow, which is to say that it creates only a single new array. Subarrays are shared.<p>
<a name="61652"></a>
This is shown by the example program:
<blockquote><pre>class Test {
	public static void main(String[] args) throws Throwable {
		int ia[][] = { { 1 , 2}, null };
		int ja[][] = (int[][])ia.clone();
		System.out.print((ia == ja) + " ");
		System.out.println(ia[0] == ja[0] &amp;&amp; ia[1] == ja[1]);
	}
}
</pre></blockquote><a name="25855"></a>
which prints:<p>
<blockquote><pre>false true
</pre></blockquote><a name="61659"></a>
showing that the <code>int[]</code> array that is <code>ia[0]</code> and the <code>int[]</code> array that is <code>ja[0]</code> are the same array.<p>
<a name="40879"></a>
<h2>10.8    <code></code>Class<code></code> Objects for Arrays</h2>
<a name="40882"></a>
Every array has an associated <code>Class</code> object, shared with all other arrays with the same component type. The direct superclass of an array type is <code>Object</code>. Every array type implements the interfaces <code>Cloneable</code> and <code>java.io.Serializable</code>.<p>
<a name="62923"></a>
This is shown by the following example code:
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[] ia = new int[3];
		System.out.println(ia.getClass());
		System.out.println(ia.getClass().getSuperclass());
	}
}
</pre></blockquote><a name="40893"></a>
which prints:<p>
<blockquote><pre>class [I
class java.lang.Object
</pre></blockquote><a name="40896"></a>
where the string "<code>[I</code>" is the run-time type signature for the class object "array with component type <code>int</code>".<p>
<a name="25726"></a>
<h2>10.9    An Array of Characters is Not a String</h2>
<a name="25730"></a>
In Java programming language, unlike C, an array of <code>char</code> is not a <code>String</code>, and neither a <code>String</code> nor an array of <code>char</code> is terminated by <code>'\u0000'</code> (the NUL character).<p>
<a name="25731"></a>
A <code>String</code> object is immutable, that is, its contents never change, while an array of <code>char</code> has mutable elements. The method <code>toCharArray</code> in class <code>String</code> returns an array of characters containing the same character sequence as a <code>String</code>. The class <code>StringBuffer</code> implements useful methods on mutable arrays of characters.<p>
<a name="11430"></a>
<h2>10.10    Array Store Exception</h2>
<a name="61664"></a>
If an array variable <i>v</i> has type <i>A</i><code>[]</code>, where <i>A</i> is a reference type, then <i>v</i> can hold a reference to an instance of any array type <i>B</i><code>[]</code>, provided <i>B</i> can be assigned to <i>A</i>.<p>
<a name="53134"></a>
Thus, the example:
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
	public static void main(String[] args) {
		ColoredPoint[] cpa = new ColoredPoint[10];
		Point[] pa = cpa;
		System.out.println(pa[1] == null);
		try {
			pa[0] = new Point();
		} catch (ArrayStoreException e) {
			System.out.println(e);
		}
	}
}
</pre></blockquote><a name="25743"></a>
produces the output:<p>
<blockquote><pre>true
java.lang.ArrayStoreException
</pre></blockquote><a name="26018"></a>
Here the variable <code>pa</code> has type <code>Point[]</code> and the variable <code>cpa</code> has as its value a reference to an object of type <code>ColoredPoint[]</code>. A <code>ColoredPoint</code> can be assigned to a <code>Point</code>; therefore, the value of <code>cpa</code> can be assigned to <code>pa</code>.<p>
<a name="26025"></a>
A reference to this array <code>pa</code>, for example, testing whether <code>pa[1]</code> is <code>null</code>, will not result in a run-time type error. This is because the element of the array of type <code>ColoredPoint[]</code> is a <code>ColoredPoint</code>, and every <code>ColoredPoint</code> can stand in for a <code>Point</code>, since <code>Point</code> is the superclass of <code>ColoredPoint</code>.
<p>
<a name="61669"></a>
On the other hand, an assignment to the array <code>pa</code> can result in a run-time error. At compile time, an assignment to an element of <code>pa</code> is checked to make sure that the value assigned is a <code>Point</code>. But since <code>pa</code> holds a reference to an array of <code>ColoredPoint</code>, &#32;the assignment is valid only if the type of the value assigned at run-time is, more specifically, a <code>ColoredPoint</code>.
<a name="26044"></a>
<p>
The Java virtual machine checks for such a situation at run-time to ensure that the assignment is valid; if not, an <code>ArrayStoreException</code> is thrown. More formally: an assignment to an element of an array whose type is <i>A</i><code>[]</code>, where <i>A</i> is a reference type, is checked at run-time to ensure that the value assigned can be assigned to the actual element type of the array, where the actual element type may be any reference type that is assignable to <i>A</i>.
<a name="26055"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="interfaces.doc.html">Prev</a> | <a href="exceptions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Blocks and Statements</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="binaryComp.doc.html">Prev</a> | <a href="expressions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="44383"></a>
<p><strong>
CHAPTER
 14 </strong></p>
<a name="101241"></a>
<h1>Blocks and Statements</h1>
<hr><p>
<a name="45234"></a>
The sequence of execution of a program is controlled by <em>statements</em>, which are executed for their effect and do not have values.<p>
<a name="17960"></a>
Some statements <em>contain</em> other statements as part of their structure; such other statements are substatements of the statement. We say that statement <i>S</i> <em>immediately &#32;contains</em> statement <i>U</i> if there is no statement <i>T</i> different from <i>S</i> and <i>U</i> such that <i>S</i> contains <i>T</i> and <i>T</i> contains <i>U</i>. In the same manner, some statements contain expressions <a href="expressions.doc.html#4709">(&#167;15)</a> as part of their structure.<p>
<a name="43082"></a>
The first section of this chapter discusses the distinction between normal and abrupt completion of statements <a href="statements.doc.html#5894">(&#167;14.1)</a>. Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.<p>
<a name="43210"></a>
Blocks are explained first <a href="statements.doc.html#246838">(&#167;14.2)</a>, followed by local class declarations <a href="statements.doc.html#247766">(&#167;14.3)</a> and local variable declaration statements <a href="statements.doc.html#5920">(&#167;14.4)</a>. <p>
<a name="43203"></a>
Next a grammatical maneuver that sidesteps the familiar "dangling <code>else</code>" problem <a href="statements.doc.html#32584">(&#167;14.5)</a> is explained.<p>
<a name="43118"></a>
Statements that will be familiar to C and C++ programmers are the empty <a href="statements.doc.html#5970">(&#167;14.6)</a>, labeled <a href="statements.doc.html#78993">(&#167;14.7)</a>, expression <a href="statements.doc.html#5984">(&#167;14.8)</a>, <code>if</code> <a href="statements.doc.html#5991">(&#167;14.9)</a>, <code>switch</code> <a href="statements.doc.html#35518">(&#167;14.10)</a>, <code>while</code> <a href="statements.doc.html#237277">(&#167;14.11)</a>, <code>do</code> <a href="statements.doc.html#6045">(&#167;14.12)</a>, <code>for</code> <a href="statements.doc.html#24588">(&#167;14.13)</a>, <code>break</code> <a href="statements.doc.html#6842">(&#167;14.14)</a>, <code>continue</code> <a href="statements.doc.html#6122">(&#167;14.15)</a>, and <code>return</code> <a href="statements.doc.html#6767">(&#167;14.16)</a> statements.<p>
<a name="43199"></a>
Unlike C and C++, the Java programming language has no <code>goto</code> statement. However, the <code>break</code> and <code>continue</code> statements are allowed to mention statement labels.<p>
<a name="43200"></a>
The Java programming language statements that are not in the C language are the <code>throw</code> <a href="statements.doc.html#237350">(&#167;14.17)</a>, <code>synchronized</code> <a href="statements.doc.html#255769">(&#167;14.18)</a>, and <code>try</code> <a href="statements.doc.html#79311">(&#167;14.19)</a> statements.<p>
<a name="43110"></a>
The last section <a href="statements.doc.html#236365">(&#167;14.20)</a> of this chapter addresses the requirement that every statement be <em>reachable</em> in a certain technical sense.<p>
<a name="5894"></a>
<h2>14.1    Normal and Abrupt Completion of Statements</h2>
<a name="78796"></a>
Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. <p>
<a name="256000"></a>
If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to <em>complete normally</em>. However, certain events may prevent a statement from completing normally:<p>
<ul><a name="47062"></a>
<li>The <code>break</code> <a href="statements.doc.html#6842">(&#167;14.14)</a>, <code>continue</code> <a href="statements.doc.html#6122">(&#167;14.15)</a>, and <code>return</code> <a href="statements.doc.html#6767">(&#167;14.16)</a> statements cause a transfer of control that may prevent normal completion of statements that contain them.
<a name="78802"></a>
<li>Evaluation of certain expressions may throw exceptions from the Java virtual machine; these expressions are summarized in <a href="expressions.doc.html#79448">&#167;15.6</a>. An explicit <code>throw</code> <a href="statements.doc.html#237350">(&#167;14.17)</a> statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.
</ul><a name="5898"></a>
If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to <em>complete abruptly</em>. <p>
<a name="255999"></a>
An abrupt completion always has an associated <em>reason</em>, which is one of the following:<p>
<ul><a name="5899"></a>
<li>A <code>break</code> with no label
<a name="78812"></a>
<li>A <code>break</code> with a given label
<a name="5901"></a>
<li>A <code>continue</code> with no label
<a name="78822"></a>
<li>A <code>continue</code> with a given label
<a name="5903"></a>
<li>A <code>return</code> with no value
<a name="5904"></a>
<li>A <code>return</code> with a given value
<a name="78827"></a>
<li>A <code>throw</code> with a given value, including exceptions thrown by the Java virtual machine
</ul><a name="237105"></a>
The terms "complete normally" and "complete abruptly" also apply to the evaluation of expressions <a href="expressions.doc.html#79448">(&#167;15.6)</a>. The only reason an expression can complete abruptly is that an exception is thrown, because of either a <code>throw</code> with a given value <a href="statements.doc.html#237350">(&#167;14.17)</a> or a run-time exception or error (<a href="exceptions.doc.html#44043">&#167;11</a>, <a href="expressions.doc.html#79448">&#167;15.6</a>).<p>
<a name="237118"></a>
If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.<p>
<a name="24642"></a>
Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.<p>
<a name="24647"></a>
Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.<p>
<a name="246838"></a>
<h2>14.2    Blocks</h2>
<a name="6391"></a>
A <em>block</em> is a sequence of statements, local class declarations and local variable declaration statements within braces.<p>
<ul><pre>
<em>Block:
	{ BlockStatements<sub><i>opt</i></sub> }

BlockStatements:
	BlockStatement
	BlockStatements BlockStatement

BlockStatement:
	LocalVariableDeclarationStatement
	ClassDeclaration
	Statement
</em></pre></ul><a name="5918"></a>
A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.<p>
<a name="247766"></a>
<h2>14.3    Local Class Declarations</h2>
<a name="247773"></a>
A local class is a nested class <a href="classes.doc.html#3857">(&#167;8)</a> that is not a member of any class and that has a name. All local classes are inner classes <a href="classes.doc.html#262890">(&#167;8.1.2)</a>. Every local class declaration statement is immediately contained by a block. Local class declaration statements may be intermixed freely with other kinds of statements in the block.<p>
<a name="257083"></a>
The scope of a local class declared in a block is the rest of the immediately enclosing block, including its own class declaration.<p>
<a name="247735"></a>
The name of a local class <i>C</i> may not be redeclared as a local class of the directly enclosing method, constructor, or initializer block within the scope of <i>C</i>, or a compile-time error occurs. However, a local class declaration may be shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the local class declaration's scope. A local class does not have a canonical name, nor does it have a fully qualified name. <p>
<a name="247589"></a>
It is a compile-time error if a local class declaration contains any one of the following access modifiers: <code>public</code>, <code>protected</code>, <code>private, </code>or <code>static</code>.<p>
<a name="253218"></a>
Here is an example that illustrates several aspects of the rules given above:<p>
<blockquote><pre>class Global {
	class Cyclic {}
	void foo() {
		new Cyclic(); // create a Global.Cyclic
		class Cyclic extends Cyclic{}; // circular definition
		{
			class Local{};
			{
				class Local{}; // compile-time error
			}
			class Local{}; // compile-time error
			class AnotherLocal {
				void bar() {
					class Local {}; // ok
				}
			}
		}
		class Local{}; // ok, not in scope of prior Local
}
</pre></blockquote><a name="249828"></a>
The first statement of method foo creates an instance of the member class <code>Global.Cyclic</code> rather than an instance of the local class <code>Cyclic</code>, because the local class declaration is not yet in scope. <p>
<a name="249848"></a>
The fact that the scope of a local class encompasses its own declaration (not only its body) means that the definition of the local class <code>Cyclic</code> is indeed cyclic because it extends itself rather than <code>Global.Cyclic</code>. Consequently, the declaration of the local class <code>Cyclic</code> will be rejected at compile time. <p>
<a name="249829"></a>
Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of <code>Local</code> result in compile-time errors. However, <code>Local</code> can be redeclared in the context of another, more deeply nested, class such as <code>AnotherLocal</code>. <p>
<a name="249872"></a>
The fourth and last declaration of <code>Local</code> is legal, since it occurs outside the scope of any prior declaration of <code>Local</code>.<p>
<a name="5920"></a>
<h2>14.4    Local Variable Declaration Statements</h2>
<a name="25561"></a>
A <em>local variable declaration statement</em> declares one or more local variable names.<p>
<ul><pre>
<em>LocalVariableDeclarationStatement:
	LocalVariableDeclaration ;

LocalVariableDeclaration:
	</em>final<em><sub>opt</sub> Type VariableDeclarators
</em></pre></ul><a name="238231"></a>
The following are repeated from <a href="classes.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<ul><pre>
<em>VariableDeclarators:
	VariableDeclarator
	VariableDeclarators , VariableDeclarator

VariableDeclarator:
	VariableDeclaratorId
	VariableDeclaratorId = VariableInitializer

VariableDeclaratorId:
	Identifier
	VariableDeclaratorId </em>[ ]<em>

VariableInitializer:
	Expression
	ArrayInitializer
</em></pre></ul><a name="32641"></a>
Every local variable declaration statement is immediately contained by a block. Local variable declaration statements may be intermixed freely with other kinds of statements in the block.<p>
<a name="35375"></a>
A local variable declaration can also appear in the header of a <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>. In this case it is executed in the same manner as if it were part of a local variable declaration statement.<p>
<a name="35393"></a>
<h3>14.4.1    Local Variable Declarators and Types</h3>
<a name="35391"></a>
Each <em>declarator</em> in a local variable declaration declares one local variable, whose name is the <em>Identifier</em> that appears in the declarator.<p>
<a name="255532"></a>
If the optional keyword final appears at the start of the declarator, the variable being declared is a final variable<a href="typesValues.doc.html#10931">(&#167;4.5.4)</a>.<p>
<a name="35396"></a>
The type of the variable is denoted by the <em>Type</em> that appears in the local variable declaration, followed by any bracket pairs that follow the <em>Identifier</em> in the declarator. <p>
<a name="252173"></a>
Thus, the local variable declaration:<p>
<blockquote><pre>int a, b[], c[][];
</pre></blockquote><a name="35401"></a>
is equivalent to the series of declarations:<p>
<blockquote><pre>int a;
int[] b;
int[][] c;
</pre></blockquote><a name="35405"></a>
Brackets are allowed in declarators as a nod to the tradition of C and C++. The general rule, however, also means that the local variable declaration:<p>
<blockquote><pre>float[][] f[][], g[][][], h[];													// Yechh!
</pre></blockquote><a name="35409"></a>
is equivalent to the series of declarations:<p>
<blockquote><pre>float[][][][] f;
float[][][][][] g;
float[][][] h;
</pre></blockquote><a name="35427"></a>
We do not recommend such "mixed notation" for array declarations.<p>
<a name="247538"></a>
A local variable of type <code>float</code> always contains a value that is an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>; similarly, a local variable of type <code>double</code> always contains a value that is an element of the double value set. It is not permitted for a local variable of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.<p>
<a name="32644"></a>
<h3>14.4.2    Scope of Local Variable Declarations</h3>
<a name="257091"></a>
The scope of a local variable declaration in a block <a href="statements.doc.html#246838">(&#167;14.2)</a> is the rest of the block in which the declaration appears, starting with its own initializer <a href="statements.doc.html#5920">(&#167;14.4)</a> and including any further declarators to the right in the local variable declaration statement. <p>
<a name="248105"></a>
The name of a local variable <em>v</em> may not be redeclared as a local variable of the directly enclosing method, constructor or initializer block within the scope of <em>v</em>, or a compile-time error occurs. The name of a local variable <em>v</em> may not be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block within the scope of <em>v</em>, or a compile-time error occurs. However, a local variable of a method or initializer block may be shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the scope of the local variable. <p>
<a name="253395"></a>
A local variable cannot be referred to using a qualified name <a href="names.doc.html#104285">(&#167;6.6)</a>, only a simple name.<p>
<a name="253396"></a>
The example:<p>
<blockquote><pre>class Test {
	static int x;
	public static void main(String[] args) {
		int x = x;
	}
}
</pre></blockquote><a name="32604"></a>
causes a compile-time error because the initialization of <code>x</code> is within the scope of the declaration of <code>x</code> as a local variable, and the local <code>x</code> does not yet have a value and cannot be used.<p>
<a name="32610"></a>
The following program does compile:<p>
<blockquote><pre>class Test {
	static int x;
	public static void main(String[] args) {
		int x = (x=2)*2;
		System.out.println(x);
	}
}
</pre></blockquote><a name="32611"></a>
because the local variable <code>x</code> is definitely assigned <a href="defAssign.doc.html#25979">(&#167;16)</a> before it is used. It prints:<p>
<blockquote><pre>4
<a name="5925"></a>
Here is another example:<p>
class Test {
	public static void main(String[] args) {
		System.out.print("2+1=");
		int two = 2, three = two + 1;
		System.out.println(three);
	}
}
</pre></blockquote><a name="17863"></a>
which compiles correctly and produces the output:<p>
<blockquote><pre>2+1=3
</pre></blockquote><a name="7616"></a>
The initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable <code>three</code> declared earlier in the block.<p>
<a name="35349"></a>
The scope of a local variable declared in a <code>for</code> statement is the rest of the <code>for</code> statement, including its own initializer.<p>
<a name="32558"></a>
If a declaration of an identifier as a local variable of the same method, constructor, or initializer block appears within the scope of a parameter or local variable of the same name, a compile-time error occurs.<p>
<a name="252192"></a>
Thus the following example does not compile:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int i;
		for (int i = 0; i &lt; 10; i++)
			System.out.println(i);
	}
}
</pre></blockquote>
<a name="249885"></a>
This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well. Hence, the following example compiles without error:<p>
<blockquote><pre>
class Test {
	public static void main(String[] args) {
		int i;
		class Local {
			{
				for (int i = 0; i &lt; 10; i++)
				System.out.println(i);
			}
		}
		new Local();
	}
}
</pre></blockquote>
<a name="35322"></a>
On the other hand, local variables with the same name may be declared in two separate blocks or <code>for</code> statements neither of which contains the other. Thus:<p>
<blockquote><pre>
class Test {
	public static void main(String[] args) {
		for (int i = 0; i &lt; 10; i++)
			System.out.print(i + " ");
		for (int i = 10; i &gt; 0; i--)
			System.out.print(i + " ");
		System.out.println();
	}
}
</pre></blockquote><a name="17897"></a>
compiles without error and, when executed, produces the output:<p>
<blockquote><pre>0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1
</pre></blockquote><a name="32673"></a>
<h3>14.4.3    Shadowing of Names by Local Variables</h3>
<a name="32716"></a>
If a name declared as a local variable is already declared as a field name, then that outer declaration is shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> throughout the scope of the local variable. Similarly, if a name is already declared as a variable or parameter name, then that outer declaration is shadowed throughout the scope of the local variable (provided that the shadowing does not cause a compile-time error under the rules of <a href="statements.doc.html#32644">&#167;14.4.2</a>). The shadowed name can sometimes be accessed using an appropriately qualified name. <p>
<a name="252205"></a>
For example, the keyword <code>this</code> can be used to access a shadowed field <code>x</code>, using the form <code>this.x</code>. Indeed, this idiom typically appears in constructors <a href="classes.doc.html#41652">(&#167;8.8)</a>:<p>
<blockquote><pre>class Pair {
	Object first, second;
	public Pair(Object first, Object second) {
		this.first = first;
		this.second = second;
	}
}
</pre></blockquote><a name="32573"></a>
In this example, the constructor takes parameters having the same names as the fields to be initialized. This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as fields.<p>
<a name="32717"></a>
<h3>14.4.4    Execution of Local Variable Declarations</h3>
<a name="32574"></a>
A local variable declaration statement is an executable statement. Every time it is executed, the declarators are processed in order from left to right. If a declarator has an initialization expression, the expression is evaluated and its value is assigned to the variable. If a declarator does not have an initialization expression, then a Java compiler must prove, using exactly the algorithm given in <a href="defAssign.doc.html#25979">&#167;16</a>, that every reference to the variable is necessarily preceded by execution of an assignment to the variable. If this is not the case, then a compile-time error occurs.<p>
<a name="32578"></a>
Each initialization (except the first) is executed only if the evaluation of the preceding initialization expression completes normally. Execution of the local variable declaration completes normally only if evaluation of the last initialization expression completes normally; if the local variable declaration contains no initialization expressions, then executing it always completes normally.<p>
<a name="32584"></a>
<h2>14.5    Statements</h2>
<a name="32588"></a>
There are many kinds of statements in the Java programming language. Most correspond to statements in the C and C++ languages, but some are unique.<p>
<a name="5958"></a>
As in C and C++, the <code>if</code> statement of the Java programming language suffers from the so-called "dangling <code>else</code> problem," illustrated by this misleadingly formatted example:<p>
<pre><a name="17933"></a>
if (door.isOpen())
<a name="5960"></a>	if (resident.isVisible())
<a name="35428"></a>		resident.greet("Hello!");
<a name="5961"></a>else door.bell.ring();	// A "dangling else"
</pre><a name="5962"></a>
The problem is that both the outer <code>if</code> statement and the inner <code>if</code> statement might conceivably own the <code>else</code> clause. In this example, one might surmise that the programmer intended the <code>else</code> clause to belong to the outer <code>if</code> statement. The Java programming language, like C and C++ and many programming languages before them, arbitrarily decree that an <code>else</code> clause belongs to the innermost <code>if</code> to which it might possibly belong. This rule is captured by the following grammar:<p>
<ul><pre>
<em>Statement:
	StatementWithoutTrailingSubstatement
	LabeledStatement
	IfThenStatement
	IfThenElseStatement
	WhileStatement
	ForStatement

StatementWithoutTrailingSubstatement:
	Block
	EmptyStatement
	ExpressionStatement
	SwitchStatement
	DoStatement
	BreakStatement
	ContinueStatement
	ReturnStatement
	SynchronizedStatement
	ThrowStatement
	TryStatement

StatementNoShortIf:
	StatementWithoutTrailingSubstatement
	LabeledStatementNoShortIf
	IfThenElseStatementNoShortIf
	WhileStatementNoShortIf
	ForStatementNoShortIf
</em></pre></ul><a name="8344"></a>
The following are repeated from <a href="statements.doc.html#5991">&#167;14.9</a> to make the presentation here clearer:<p>
<ul><pre>
<em>IfThenStatement:
	</em>if<em> ( Expression ) Statement

IfThenElseStatement:
	</em>if<em> ( Expression ) StatementNoShortIf </em>else<em> Statement

IfThenElseStatementNoShortIf:
	</em>if<em> ( Expression ) StatementNoShortIf </em>else<em> StatementNoShortIf
</em></pre></ul><a name="5969"></a>
Statements are thus grammatically divided into two categories: those that might end in an <code>if</code> statement that has no <code>else</code> clause (a "short <code>if</code> statement") and those that definitely do not. Only statements that definitely do not end in a short <code>if</code> statement may appear as an immediate substatement before the keyword <code>else</code> in an <code>if</code> statement that does have an <code>else</code> clause.<p>
<a name="252213"></a>
This simple rule prevents the "dangling <code>else</code>" problem. The execution behavior of a statement with the "no short <code>if</code>" restriction is identical to the execution behavior of the same kind of statement without the "no short <code>if</code>" restriction; the distinction is drawn purely to resolve the syntactic difficulty.<p>
<a name="5970"></a>
<h2>14.6    The Empty Statement</h2>
<a name="5971"></a>
An <em>empty statement</em> does nothing.<p>
<ul><pre>
<em>EmptyStatement:
	;
</em></pre></ul><a name="5973"></a>
Execution of an empty statement always completes normally.<p>
<a name="78993"></a>
<h2>14.7    Labeled Statements</h2>
<a name="78994"></a>
Statements may have <em>label</em> prefixes.<p>
<ul><pre>
<em>LabeledStatement:
	Identifier : Statement

LabeledStatementNoShortIf:
	Identifier : StatementNoShortIf
</em></pre></ul><a name="78997"></a>
The <em>Identifier</em> is declared to be the label of the immediately contained <em>Statement</em>.<p>
<a name="17941"></a>
Unlike C and C++, the Java programming language has no <code>goto</code> statement; identifier statement labels are used with <code>break</code> <a href="statements.doc.html#6842">(&#167;14.14)</a> or <code>continue</code> <a href="statements.doc.html#6122">(&#167;14.15)</a> statements appearing anywhere within the labeled statement.<p>
<a name="257102"></a>
The scope of a label declared by a labeled statement is the statement immediately enclosed by the labeled statement.<p>
<a name="78998"></a>
 Let <i>l</i> be a label, and let <i>m</i> be the immediately enclosing method, constructor, instance initializer or static initializer. It is a compile-time error if <i>l</i> shadows <a href="names.doc.html#34133">(&#167;6.3.1)</a> the declaration of another label immediately enclosed in <i>m</i>.<p>
<a name="247865"></a>
There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable. Use of an identifier to label a statement does not obscure <a href="names.doc.html#104058">(&#167;6.3.2)</a> a package, class, interface, method, field, parameter, or local variable with the same name. Use of an identifier &#32;as a class, interface, method, field, local variable or as the parameter of an exception handler <a href="statements.doc.html#79311">(&#167;14.19)</a> does not obscure a statement label with the same name.<p>
<a name="247869"></a>
A labeled statement is executed by executing the immediately contained <em>Statement</em>. If the statement is labeled by an <em>Identifier</em> and the contained <em>Statement</em> completes abruptly because of a <code>break</code> with the same <em>Identifier</em>, then the labeled statement completes normally. In all other cases of abrupt completion of the <em>Statement</em>, &#32;the labeled statement completes abruptly for the same reason.<p>
<a name="5984"></a>
<h2>14.8    Expression Statements</h2>
<a name="5985"></a>
Certain kinds of expressions may be used as statements by following them with semicolons:<p>
<ul><pre>
<em>ExpressionStatement:
	StatementExpression ;

StatementExpression:
	Assignment
	PreIncrementExpression
	PreDecrementExpression
	PostIncrementExpression
	PostDecrementExpression
	MethodInvocation
	ClassInstanceCreationExpression
</em></pre></ul><a name="5988"></a>
An <em>expression statement</em> is executed by evaluating the expression; if the expression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.<p>
<a name="5989"></a>
Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements. Note that the Java programming language does not allow a "cast to <code>void</code>"-<code>void</code> is not a type-so the traditional C trick of writing an expression statement such as:<p>
<blockquote><pre>(void) ... ;			// incorrect!
</pre></blockquote><a name="35457"></a>
does not work. On the other hand, the language allows all the most useful kinds of expressions in expressions statements, and it does not require a method invocation used as an expression statement to invoke a <code>void</code> method, so such a trick is almost never needed. If a trick is needed, either an assignment statement <a href="expressions.doc.html#5281">(&#167;15.26)</a> or a local variable declaration statement <a href="statements.doc.html#5920">(&#167;14.4)</a> can be used instead.<p>
<a name="5991"></a>
<h2>14.9    The <code>if</code> Statement</h2>
<a name="35469"></a>
The <code>if</code> statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.<p>
<ul><pre>
<em>IfThenStatement:
	</em>if<em> ( Expression ) Statement

IfThenElseStatement:
	</em>if<em> ( Expression ) StatementNoShortIf </em>else<em> Statement

IfThenElseStatementNoShortIf:
	</em>if<em> ( Expression ) StatementNoShortIf </em>else<em> StatementNoShortIf
</em></pre></ul><a name="24313"></a>
The <em>Expression</em> must have type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="237433"></a>
<h3>14.9.1    The <code>if-then</code> Statement</h3>
<a name="35473"></a>
An <code>if</code>-<code>then</code> statement is executed by first evaluating the <em>Expression</em>. If evaluation of the <em>Expression</em> completes abruptly for some reason, the <code>if</code>-<code>then</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="5997"></a>
<li>If the value is <code>true</code>, then the contained <em>Statement</em> is executed; the <code>if</code>-<code>then</code> statement completes normally if and only if execution of the <em>Statement</em> completes normally.
<a name="5998"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>if</code>-<code>then</code> statement completes normally.
</ul><a name="237435"></a>
<h3>14.9.2    The <code>if-then-else</code> Statement</h3>
<a name="236506"></a>
An <code>if</code>-<code>then</code>-<code>else</code> statement is executed by first evaluating the <em>Expression</em>. If evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>if</code>-<code>then</code>-<code>else</code> &#32;statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="6000"></a>
<li>If the value is <code>true</code>, then the first contained <em>Statement</em> (the one before the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally if and only if execution of that statement completes normally.
<a name="42708"></a>
<li>If the value is <code>false</code>, then the second contained <em>Statement</em> (the one after the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally if and only if execution of that statement completes normally. 
</ul><a name="35518"></a>
<h2>14.10    The <code>switch</code> Statement</h2>
<a name="35522"></a>
The <code>switch</code> statement transfers control to one of several statements depending on the value of an expression.<p>
<ul><pre>
<em>SwitchStatement:
</em>	switch<em> ( Expression ) SwitchBlock

SwitchBlock:
	{ SwitchBlockStatementGroups<sub><i>opt</i></sub> SwitchLabels<sub><i>opt</i></sub> }

SwitchBlockStatementGroups:
	SwitchBlockStatementGroup
	SwitchBlockStatementGroups SwitchBlockStatementGroup

SwitchBlockStatementGroup:
	SwitchLabels BlockStatements

SwitchLabels:
	SwitchLabel
	SwitchLabels SwitchLabel

SwitchLabel:
	</em>case<em> ConstantExpression :
	default :
</em></pre></ul><a name="256918"></a>
The type of the <em>Expression</em> must be <code>char</code>, <code>byte</code>, <code>short</code>, or <code>int</code>, or a compile-time error occurs.<p>
<a name="256924"></a>
The body of a <code>switch</code> statement is known as a <em>switch block</em>. Any statement immediately contained by the switch block may be labeled with one or more <code>case</code> or <code>default</code> labels. These labels are said to be <em>associated</em> with the <code>switch</code> statement, as are the values of the constant expressions <a href="expressions.doc.html#5313">(&#167;15.28)</a> in the <code>case</code> labels.<p>
<a name="237328"></a>
All of the following must be true, or a compile-time error will result:<p>
<ul><a name="237329"></a>
<li>Every <code>case</code> constant expression associated with a <code>switch</code> statement must be assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to the type of the <code>switch</code> <em>Expression</em>.
<a name="237333"></a>
<li>No two of the <code>case</code> constant expressions associated with a <code>switch</code> statement may have the same value.
<a name="237334"></a>
<li>At most one <code>default</code> label may be associated with the same <code>switch</code> statement.
<a name="252239"></a>
In C and C++ the body of a <code>switch</code> statement can be a statement and statements with <code>case</code> labels do not have to be immediately contained by that statement. Consider the simple loop:<p>
</ul><blockquote><pre>for (i = 0; i &lt; n; ++i) foo();
</pre></blockquote><a name="237282"></a>
where <code>n</code> is known to be positive. A trick known as <em>Duff's device</em> can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:<p>
<blockquote><pre>int q = (n+7)/8;
switch (n%8) {
case 0:		do {	foo();		// Great C hack, Tom,
case 7:			foo();		// but it's not valid here.
case 6:			foo();
case 5:			foo();
case 4:			foo();
case 3:			foo();
case 2:			foo();
case 1:			foo();
		} while (--q &gt;= 0);
}
</pre></blockquote><a name="237295"></a>
Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.<p>
<a name="217138"></a>
When the <code>switch</code> statement is executed, first the <em>Expression</em> is evaluated. If evaluation of the <em>Expression</em> completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason. Otherwise, execution continues by comparing the value of the <em>Expression </em>with each <code>case</code> constant. Then there is a choice:<p>
<ul><a name="6012"></a>
<li>If one of the <code>case</code> constants is equal to the value of the expression, then we say that the <code>case</code> matches, and all statements after the matching <code>case</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the matching <code>case</code> label, then the entire <code>switch</code> statement completes normally.
<a name="6013"></a>
<li>If no <code>case</code> matches but there is a <code>default</code> label, then all statements after the matching <code>default</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the <code>default</code> label, then the entire <code>switch</code> statement completes normally.
<a name="6014"></a>
<li>If no <code>case</code> matches and there is no <code>default</code> label, then no further action is taken and the <code>switch</code> statement completes normally.
</ul><a name="237254"></a>
If any statement immediately contained by the <em>Block</em> body of the <code>switch</code> statement completes abruptly, it is handled as follows:<p>
<ul><a name="6017"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>switch</code> statement completes normally.
<a name="237272"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>switch</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.doc.html#78993">(&#167;14.7)</a>.
</ul><a name="237607"></a>
As in C and C++, execution of statements in a switch block "falls through labels." <p>
<a name="252252"></a>
For example, the program:<p>
<blockquote><pre>class Toomany {
	static void howMany(int k) {
		switch (k) {
		case 1:			System.out.print("one ");
		case 2:			System.out.print("too ");
		case 3:			System.out.println("many");
		}
	}
	public static void main(String[] args) {
		howMany(3);
		howMany(2);
		howMany(1);
	}
}
</pre></blockquote><a name="237629"></a>
contains a switch block in which the code for each case falls through into the code for the next case. As a result, the program prints:<p>
<blockquote><pre>many
too many
one too many
</pre></blockquote><a name="237630"></a>
If code is not to fall through case to case in this manner, then <code>break</code> statements should be used, as in this example:<p>
<blockquote><pre>class Twomany {
	static void howMany(int k) {
		switch (k) {
		case 1:			System.out.println("one");
					break;					// exit the switch
		case 2:			System.out.println("two");
					break;					// exit the switch
		case 3:			System.out.println("many");
					break;					// not needed, but good style
		}
	}
	public static void main(String[] args) {
		howMany(1);
		howMany(2);
		howMany(3);
	}
}
</pre></blockquote><a name="237642"></a>
This program prints:<p>
<blockquote><pre>one
two
many
</pre></blockquote><a name="237277"></a>
<h2>14.11    The while Statement</h2>
<a name="237278"></a>
The <code>while</code> statement executes an <em>Expression</em> and a <em>Statement</em> repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<ul><pre>
WhileStatement:
	while ( Expression ) Statement

WhileStatementNoShortIf:
	while ( Expression ) StatementNoShortIf
</pre></ul><a name="35485"></a>
The <em>Expression</em> must have type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="217153"></a>
A <code>while</code> statement is executed by first evaluating the <em>Expression</em>. If evaluation of the <em>Expression</em> completes abruptly for some reason, the <code>while</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="6028"></a>
<li>If the value is <code>true</code>, then the contained <em>Statement</em> is executed. Then there is a choice:
<ul>
<a name="6029"></a>
<li>If execution of the <em>Statement</em> completes normally, then the entire <code>while</code> statement is executed again, beginning by re-evaluating the <em>Expression</em>.
<a name="6030"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.doc.html#21139">&#167;14.11.1</a> below.
</ul>
<a name="6031"></a>
<li>If the value of the <em>Expression</em> is <code>false</code>, no further action is taken and the <code>while</code> statement completes normally.
</ul><a name="6032"></a>
If the value of the <em>Expression</em> is <code>false</code> the first time it is evaluated, then the <em>Statement</em> &#32;is not executed.<p>
<a name="21139"></a>
<h3>14.11.1    Abrupt Completion</h3>
<a name="6033"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6034"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>while</code> statement completes normally.
<ul>
<a name="6035"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the entire <code>while</code> statement is executed again.
<a name="79063"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79064"></a>
<li>If the <code>while</code> statement has label <i>L</i>, then the entire <code>while</code> statement is executed again.
<a name="79065"></a>
<li>If the <code>while</code> statement does not have label <i>L</i>, the <code>while</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="79070"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>while</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.doc.html#78993">(&#167;14.7)</a>.
</ul>
</ul><a name="6045"></a>
<h2>14.12    The do Statement</h2>
<a name="246911"></a>
The <code>do</code> statement executes a <em>Statement</em> and an <em>Expression</em> repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<ul><pre>
DoStatement:
	do Statement while ( Expression ) ;
</pre></ul><a name="35496"></a>
The <em>Expression</em> must have type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="6048"></a>
A <code>do</code> statement is executed by first executing the <em>Statement</em>. Then there is a choice:<p>
<ul><a name="217176"></a>
<li>If execution of the <em>Statement</em> completes normally, then the <em>Expression</em> is evaluated. If evaluation of the <em>Expression</em> completes abruptly for some reason, the <code>do</code> statement completes abruptly for the same reason. Otherwise, there is a choice based on the resulting value:
<ul>
<a name="217172"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6051"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="6052"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.doc.html#45366">&#167;14.12.1</a> below.
</ul><a name="6053"></a>
Executing a <code>do</code> statement always executes the contained <em>Statement</em> at least once.<p>
<a name="45366"></a>
<h3>14.12.1    Abrupt Completion</h3>
<a name="43246"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6714"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, then no further action is taken and the <code>do</code> statement completes normally.
<a name="6056"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the <em>Expression</em> is evaluated. Then there is a choice based on the resulting value:
<ul>
<a name="6057"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6058"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79109"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79110"></a>
<li>If the <code>do</code> statement has label <i>L</i>, then the <em>Expression</em> is evaluated. Then there is a choice:
<ul>
<a name="79111"></a>
<li>If the value of the <em>Expression</em> is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="79112"></a>
<li>If the value of the <em>Expression</em> is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79113"></a>
<li>If the <code>do</code> statement does not have label <i>L</i>, the <code>do</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="24581"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>do</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule <a href="statements.doc.html#78993">(&#167;14.7)</a>.
</ul><a name="24585"></a>
<h3>14.12.2    Example of do statement</h3>
<a name="252264"></a>
The following code is one possible implementation of the <code>toHexString</code> method of class <code>Integer</code>:<p>
<blockquote><pre>public static String toHexString(int i) {
	StringBuffer buf = new StringBuffer(8);
	do {
		buf.append(Character.forDigit(i &amp; 0xF, 16));
		i &gt;&gt;&gt;= 4;
	} while (i != 0);
	return buf.reverse().toString();
}
</pre></blockquote><a name="24586"></a>
Because at least one digit must be generated, the <code>do</code> statement is an appropriate control structure.<p>
<a name="24588"></a>
<h2>14.13    The <code>for</code> Statement</h2>
<a name="35537"></a>
The <code>for</code> statement executes some initialization code, then executes an <em>Expression</em>, a <em>Statement</em>, and some update code repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<ul><pre>
<em>ForStatement:
	</em>for<em> ( ForInit<sub><i>opt</i></sub> ; Expression<sub><i>opt</i></sub> ; ForUpdate<sub><i>opt</i></sub> )
		Statement

ForStatementNoShortIf:
	</em>for<em> ( ForInit<sub><i>opt</i></sub> ; Expression<sub><i>opt</i></sub> ; ForUpdate<sub><i>opt</i></sub> )
		StatementNoShortIf

ForInit:
	StatementExpressionList
	LocalVariableDeclaration

ForUpdate:
	StatementExpressionList

StatementExpressionList:
	StatementExpression
	StatementExpressionList , StatementExpression
</em></pre></ul><a name="35529"></a>
The <em>Expression</em> must have type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="45367"></a>
<h3>14.13.1    Initialization of <code>for</code> statement</h3>
<a name="11751"></a>
A <code>for</code> statement is executed by first executing the <em>ForInit</em> code:<p>
<ul><a name="6081"></a>
<li>If the <em>ForInit</em> code is a list of statement expressions <a href="statements.doc.html#5984">(&#167;14.8)</a>, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <em>ForInit</em> statement expressions to the right of the one that completed abruptly are not evaluated.
</ul><a name="257107"></a>
If the <em>ForInit</em> code is a local variable declaration, it is executed as if it were a local variable declaration statement <a href="statements.doc.html#5920">(&#167;14.4)</a> appearing in a block. The scope of a local variable declared in the <em>ForInit</em> part of a <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a> includes all of the following:<p>
<ul><a name="257112"></a>
<li>Its own initializer
<a name="257115"></a>
<li>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement
<a name="257116"></a>
<li>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement
<a name="257117"></a>
<li>The contained <em>Statement</em>
</ul><a name="256793"></a>
If execution of the local variable declaration completes abruptly for any reason, the <code>for</code> statement completes abruptly for the same reason.<p>
<ul><a name="6083"></a>
<li>If the <em>ForInit</em> part is not present, no action is taken.
</ul><a name="45370"></a>
<h3>14.13.2    Iteration of for statement</h3>
<a name="217196"></a>
Next, a <code>for</code> iteration step is performed, as follows:<p>
<ul><a name="217202"></a>
<li>If the <em>Expression</em> is present, it is evaluated, and if evaluation of the <em>Expression</em> completes abruptly, the <code>for</code> statement completes abruptly for the same reason. Otherwise, there is then a choice based on the presence or absence of the <em>Expression</em> and the resulting value if the <em>Expression</em> is present:
<ul>
<a name="6086"></a>
<li>If the <em>Expression</em> is not present, or it is present and the value resulting from its evaluation is <code>true</code>, then the contained <em>Statement</em> is executed. Then there is a choice:
<ul>
<a name="6087"></a>
<li>If execution of the <em>Statement</em> completes normally, then the following two steps are performed in sequence:
<ul>
<a name="45351"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <em>ForUpdate</em> statement expressions to the right of the one that completed abruptly are not evaluated. If the <em>ForUpdate</em> part is not present, no action is taken.
<a name="236152"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="236156"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.doc.html#45371">&#167;14.13.3</a> below.
</ul>
<a name="236157"></a>
<li>If the <em>Expression</em> is present and the value resulting from its evaluation is <code>false</code>, no further action is taken and the <code>for</code> statement completes normally.
</ul>
</ul><a name="6092"></a>
If the value of the <em>Expression</em> is <code>false</code> the first time it is evaluated, then the <em>Statement</em> is not executed.<p>
<a name="6093"></a>
If the <em>Expression</em> is not present, then the only way a <code>for</code> statement can complete normally is by use of a <code>break</code> statement.<p>
<a name="45371"></a>
<h3>14.13.3    Abrupt Completion of <code>for</code> statement</h3>
<a name="43248"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6095"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>for</code> statement completes normally.
<a name="6096"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the following two steps are performed in sequence:
<ul>
<a name="6097"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the <em>ForUpdate</em> &#32;part is not present, no action is taken.
<a name="6098"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79161"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79162"></a>
<li>If the <code>for</code> statement has label <i>L</i>, then the following two steps are performed in sequence:
<ul>
<a name="79163"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the<em> ForUpdate</em> is not present, no action is taken.
<a name="79164"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79165"></a>
<li>If the <code>for</code> statement does not have label <i>L</i>, the <code>for</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="6104"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>for</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.doc.html#78993">(&#167;14.7)</a>.
</ul><a name="6842"></a>
<h2>14.14    The <code>break</code> Statement</h2>
<a name="35540"></a>
A break statement transfers control out of an enclosing statement.<p>
<ul><pre>
<em>BreakStatement:
</em>	break<em> Identifier<sub><i>opt</i></sub> ;
</em></pre></ul><a name="43392"></a>
A <code>break</code> statement with no label attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block; this statement, which is called the <em>break target</em>, then immediately completes normally. <p>
<a name="256041"></a>
To be precise, a <code>break</code> statement with no label always completes abruptly, the reason being a <code>break</code> with no label. If no <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="79188"></a>
A <code>break</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement <a href="statements.doc.html#78993">(&#167;14.7)</a> that has the same <em>Identifier</em> as its label; this statement, which is called the <em>break target</em>, then immediately completes normally. In this case, the <code>break</code> target need not be a <code>while</code>, <code>do</code>, <code>for</code>, or <code>switch</code> statement. A break statement must refer to a label within the immediately enclosing method or initializer block. There are no non-local jumps.<p>
<a name="247471"></a>
To be precise, a <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>break</code> with label <em>Identifier</em>. If no labeled statement with <em>Identifier</em> &#32;as its label encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="43504"></a>
It can be seen, then, that a <code>break</code> statement always completes abruptly.<p>
<a name="43404"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.doc.html#79311">(&#167;14.19)</a> within the break target whose <code>try</code> blocks contain the <code>break</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>break</code> statement.<p>
<a name="18004"></a>
In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes <i>P</i> and <i>Q</i>, where <i>Q</i> may be the same as <i>P</i>, there is at most one edge from <i>P</i> to <i>Q</i>. Nodes are represented by integers, and there is an edge from node <i>i</i> to node <code>edges[</code><i>i</i><code>][</code><i>j</i><code>]</code> for every <i>i</i> and <i>j</i> for which the array reference <code>edges[</code><i>i</i><code>][</code><i>j</i><code>]</code> does not throw an <code>IndexOutOfBoundsException</code>.<p>
<a name="42801"></a>
The task of the method <code>loseEdges</code>, given integers <i>i</i> and <i>j</i>, is to construct a new graph by copying a given graph but omitting the edge from node <i>i</i> to node <i>j</i>, if any, and the edge from node <i>j</i> to node <i>i</i>, if any:<p>
<blockquote><pre>class Graph {
	int edges[][];
	public Graph(int[][] edges) { this.edges = edges; }
	public Graph loseEdges(int i, int j) {
		int n = edges.length;
		int[][] newedges = new int[n][];
		for (int k = 0; k &lt; n; ++k) {
			edgelist: {
				int z;
				search: {
					if (k == i) {
						for (z = 0; z &lt; edges[k].length; ++z)
							if (edges[k][z] == j)
								break search;
					} else if (k == j) {
						for (z = 0; z &lt; edges[k].length; ++z)
							if (edges[k][z] == i)
								break search;
					}
					// No edge to be deleted; share this list.
					newedges[k] = edges[k];
					break edgelist;
				} //search
				// Copy the list, omitting the edge at position z.
				int m = edges[k].length - 1;
				int ne[] = new int[m];
				System.arraycopy(edges[k], 0, ne, 0, z);
				System.arraycopy(edges[k], z+1, ne, z, m-z);
				newedges[k] = ne;
			} //edgelist
		}
		return new Graph(newedges);
	}
}
</pre></blockquote><a name="42887"></a>
Note the use of two statement labels, <code>edgelist</code> and <code>search</code>, and the use of <code>break</code> statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node <i>i</i> to node <i>j</i>, and the test for an edge from node <i>j</i> to node <i>i</i>.<p>
<a name="6122"></a>
<h2>14.15    The <code>continue</code> Statement</h2>
<a name="6123"></a>
A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements of these three kinds are called <em>iteration statements</em>. Control passes to the loop-continuation point of an iteration statement.<p>
<ul><pre>
<em>ContinueStatement:
	</em>continue<em> Identifier<sub><i>opt</i></sub> ;
</em></pre></ul><a name="6125"></a>
A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block; this statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one. <p>
<a name="256040"></a>
To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label. If no <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block encloses the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="247489"></a>
A <code>continue</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement <a href="statements.doc.html#78993">(&#167;14.7)</a> that has the same <em>Identifier</em> as its label; that statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one. The continue target must be a <code>while</code>, <code>do</code>, or <code>for</code> statement or a compile-time error occurs. A continue statement must refer to a label within the immediately enclosing method or initializer block. There are no non-local jumps.<p>
<a name="79215"></a>
More precisely, a <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>continue</code> with label <em>Identifier</em>. If no labeled statement with <em>Identifier</em> as its label contains the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="43498"></a>
It can be seen, then, that a <code>continue</code> statement always completes abruptly.<p>
<a name="6136"></a>
See the descriptions of the <code>while</code> statement <a href="statements.doc.html#237277">(&#167;14.11)</a>, <code>do</code> statement <a href="statements.doc.html#6045">(&#167;14.12)</a>, and <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a> for a discussion of the handling of abrupt termination because of <code>continue</code>.<p>
<a name="252288"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.doc.html#79311">(&#167;14.19)</a> within the continue target whose <code>try</code> blocks contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.<p>
<a name="42935"></a>
In the <code>Graph</code> example in the preceding section, one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This <code>break</code> can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:<p>
<blockquote><pre>class Graph {
	. . .
	public Graph loseEdges(int i, int j) {
		int n = edges.length;
		int[][] newedges = new int[n][];
		edgelists: for (int k = 0; k &lt; n; ++k) {
			int z;
			search: {
				if (k == i) {
					. . .
				} else if (k == j) {
					. . .
				}
				newedges[k] = edges[k];
				continue edgelists;
			} // search
			. . .
		} // edgelists
		return new Graph(newedges);
	}
}
</pre></blockquote><a name="42984"></a>
Which to use, if either, is largely a matter of programming style.<p>
<a name="6767"></a>
<h2>14.16    The <code>return</code> Statement</h2>
<a name="124158"></a>
A <code>return</code> statement returns control to the invoker of a method (<a href="classes.doc.html#40420">&#167;8.4</a>, <a href="expressions.doc.html#20448">&#167;15.12</a>) or constructor (<a href="classes.doc.html#41652">&#167;8.8</a>, <a href="expressions.doc.html#41147">&#167;15.9</a>).<p>
<ul><pre>
<em>ReturnStatement:
	</em>return<em> Expression<sub><i>opt</i></sub> ;
</em></pre></ul><a name="236030"></a>
A <code>return</code> statement with no <em>Expression </em>must be contained in the body of a method that is declared, using the keyword <code>void</code>, not to return any value <a href="classes.doc.html#40420">(&#167;8.4)</a>, or in the body of a constructor <a href="classes.doc.html#41652">(&#167;8.8)</a>. A compile-time error occurs if a <code>return</code> statement appears within an instance initializer or a static initializer <a href="classes.doc.html#39245">(&#167;8.7)</a>. A <code>return</code> statement with no <em>Expression</em> attempts to transfer control to the invoker of the method or constructor that contains it. <p>
<a name="256046"></a>
To be precise, a <code>return</code> statement with no <em>Expression</em> always completes abruptly, the reason being a <code>return</code> with no value.<p>
<a name="6148"></a>
A <code>return</code> statement with an <em>Expression</em> must be contained in a method declaration that is declared to return a value <a href="classes.doc.html#40420">(&#167;8.4)</a> or a compile-time error occurs. The <em>Expression</em> must denote a variable or value of some type <i>T</i>, or a compile-time error occurs. The type <i>T</i> must be assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to the declared result type of the method, or a compile-time error occurs.<p>
<a name="247542"></a>
A <code>return</code> statement with an <em>Expression</em> attempts to transfer control to the invoker of the method that contains it; the value of the <em>Expression</em> becomes the value of the method invocation. More precisely, execution of such a <code>return</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <i>V</i>, then the <code>return</code> statement completes abruptly, the reason being a <code>return</code> with value <i>V</i>. If the expression is of type <code>float</code> and is not FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>, then the value may be an element of either the float value set or the float-extended-exponent value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>. If the expression is of type <code>double</code> and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.<p>
<a name="43495"></a>
It can be seen, then, that a <code>return</code> statement always completes abruptly.<p>
<a name="43508"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.doc.html#79311">(&#167;14.19)</a> within the method or constructor whose <code>try</code> blocks contain the <code>return</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>return</code> statement.<p>
<a name="237350"></a>
<h2>14.17    The <code>throw</code> Statement</h2>
<a name="79254"></a>
A <code>throw</code> statement causes an exception <a href="exceptions.doc.html#44043">(&#167;11)</a> to be thrown. The result is an immediate transfer of control <a href="exceptions.doc.html#44153">(&#167;11.3)</a> that may exit multiple statements and multiple constructor, instance initializer, static initializer and field initializer evaluations, and method invocations until a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a> is found that catches the thrown value. If no such <code>try</code> statement is found, then execution of the thread (<a href="memory.doc.html#26250">&#167;17</a>) that executed the <code>throw</code> is terminated <a href="exceptions.doc.html#44153">(&#167;11.3)</a> after invocation of the <code>uncaughtException</code> method for the thread group to which the thread belongs.<p>
<ul><pre>
<em>ThrowStatement:
	</em>throw<em> Expression ;
</em></pre></ul><a name="236072"></a>
The <em>Expression</em> in a throw statement must denote a variable or value of a reference type which is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to the type <code>Throwable</code>, or a compile-time error occurs. Moreover, at least one of the following three conditions must be true, or a compile-time error occurs:<p>
<ul><a name="236073"></a>
<li>The exception is not a checked exception <a href="exceptions.doc.html#44121">(&#167;11.2)</a>-specifically, one of the following situations is true:
<ul>
<a name="39922"></a>
<li>The type of the <em>Expression</em> is the class <code>RuntimeException</code> or a subclass of <code>RuntimeException</code>.
<a name="236074"></a>
<li>The type of the <em>Expression</em> is the class <code>Error</code> or a subclass of <code>Error</code>.
</ul>
<a name="236078"></a>
<li>The <code>throw</code> statement is contained in the <code>try</code> block of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a> and the type of the <em>Expression</em> is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to the type of the parameter of at least one <code>catch</code> clause of the <code>try</code> statement. (In this case we say the thrown value is <em>caught</em> by the <code>try</code> statement.)
<a name="236082"></a>
<li>The <code>throw</code> statement is contained in a method or constructor declaration and the type of the <em>Expression</em> is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to at least one type listed in the <code>throws</code> clause (<a href="classes.doc.html#78323">&#167;8.4.4</a>, <a href="classes.doc.html#244611">&#167;8.8.4</a>) of the declaration.
</ul><a name="254469"></a>
A <code>throw</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>throw</code> completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a non-<code>null</code> value <i>V</i>, then the <code>throw</code> statement completes abruptly, the reason being a <code>throw</code> with value <i>V</i>. If evaluation of the <em>Expression</em> completes normally, producing a <code>null</code> value, then an instance <i>V'</i> of class <code>NullPointerException</code> is created and thrown instead of <code>null</code>. The <code>throw</code> statement then completes abruptly, the reason being a <code>throw</code> with value<i> V'</i>.<p>
<a name="254470"></a>
It can be seen, then, that a <code>throw</code> statement always completes abruptly.<p>
<a name="254474"></a>
If there are any enclosing <code>try</code> statements <a href="statements.doc.html#79311">(&#167;14.19)</a> whose <code>try</code> blocks contain the <code>throw</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>throw</code> statement.<p>
<a name="79283"></a>
If a <code>throw</code> statement is contained in a method declaration, but its value is not caught by some <code>try</code> statement that contains it, then the invocation of the method completes abruptly because of the <code>throw</code>.<p>
<a name="79284"></a>
If a <code>throw</code> statement is contained in a constructor declaration, but its value is not caught by some <code>try</code> statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the <code>throw</code>.<p>
<a name="43567"></a>
If a <code>throw</code> statement is contained in a static initializer <a href="classes.doc.html#39245">(&#167;8.7)</a>, then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some <code>try</code> statement that contains it. If at run-time, despite this check, the value is not caught by some <code>try</code> statement that contains the <code>throw</code> statement, then the value is rethrown if it is an instance of class <code>Error</code> or one of its subclasses; otherwise, it is wrapped in an <code>ExceptionInInitializerError</code> object, which is then thrown <a href="execution.doc.html#44630">(&#167;12.4.2)</a>.<p>
<a name="248568"></a>
If a <code>throw</code> statement is contained in an instance initializer <a href="classes.doc.html#246032">(&#167;8.6)</a>, then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the throws clause of every constructor of the class.<p>
<a name="255757"></a>
By convention, user-declared throwable types should usually be declared to be subclasses of class <code>Exception</code>, which is a subclass of class <code>Throwable</code> (<a href="exceptions.doc.html#44278">&#167;11.5</a>).<p>
<a name="255769"></a>
<h2>14.18    The <code>synchronized</code> Statement</h2>
<a name="79291"></a>
A <code>synchronized</code> statement acquires a mutual-exclusion lock <a href="memory.doc.html#28460">(&#167;17.13)</a> on behalf of the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.<p>
<ul><pre>
<em>SynchronizedStatement:
</em>	synchronized<em> ( Expression ) Block
</em></pre></ul><a name="217233"></a>
The type of <em>Expression</em> must be a reference type, or a compile-time error occurs. <p>
<a name="217245"></a>
A <code>synchronized</code> statement is executed by first evaluating the <em>Expression</em>.<p>
<a name="236514"></a>
If evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>synchronized</code> statement completes abruptly for the same reason.<p>
<a name="236515"></a>
Otherwise, if the value of the <em>Expression</em> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="247651"></a>
Otherwise, let the non-<code>null</code> value of the <em>Expression</em> be <i>V</i>. The executing thread locks the lock associated with V. Then the Block is executed. If execution of the <em>Block</em> completes normally, then the lock is unlocked and the <code>synchronized</code> statement completes normally. If execution of the <em>Block</em> completes abruptly for any reason, then the lock is unlocked and the <code>synchronized</code> statement then completes abruptly for the same reason.<p>
<a name="79305"></a>
Acquiring the lock associated with an object does not of itself prevent other threads from accessing fields of the object or invoking unsynchronized methods on the object. Other threads can also use <code>synchronized</code> methods or the <code>synchronized</code> &#32;statement in a conventional manner to achieve mutual exclusion.<p>
<a name="79306"></a>
The locks acquired by <code>synchronized</code> statements are the same as the locks that are acquired implicitly by <code>synchronized</code> methods; see <a href="classes.doc.html#260369">&#167;8.4.3.6</a>. A single thread may hold a lock more than once. <p>
<a name="252313"></a>
The example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		Test t = new Test();
		synchronized(t) {
			synchronized(t) {
				System.out.println("made it!");
			}
		}
	}
}
</pre></blockquote><a name="22901"></a>
prints:<p>
<blockquote><pre>made it!
</pre></blockquote><a name="22903"></a>
This example would deadlock if a single thread were not permitted to lock a lock more than once.<p>
<a name="79311"></a>
<h2>14.19    The <code>try</code> statement</h2>
<a name="79312"></a>
A <code>try</code> statement executes a block. If a value is thrown and the <code>try</code> statement has one or more <code>catch</code> clauses that can catch it, then control will be transferred to the first such <code>catch</code> clause. If the <code>try</code> statement has a <code>finally</code> clause, then another block of code is executed, no matter whether the <code>try</code> block completes normally or abruptly, and no matter whether a <code>catch</code> clause is first given control. <p>
<ul><pre>
<em>TryStatement:
	</em>try<em> Block Catches
	</em>try<em> Block Catches<sub><i>opt</i></sub> Finally

Catches:
	CatchClause
	Catches CatchClause

CatchClause:
</em>	catch<em> ( FormalParameter ) Block

Finally:
	</em>finally<em> Block
</em></pre></ul><a name="250063"></a>
The following is repeated from <a href="classes.doc.html#38698">&#167;8.4.1</a> to make the presentation here clearer:<p>
<ul><pre>
<em>FormalParameter:
	</em>final<em><sub>opt</sub> Type VariableDeclaratorId
</em></pre></ul><a name="237406"></a>
The following is repeated from <a href="classes.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<ul><pre>
<em>VariableDeclaratorId:
	Identifier
	VariableDeclaratorId</em> [ ]
</pre></ul><a name="79317"></a>
The <em>Block</em> immediately after the keyword <code>try</code> is called the <code>try</code> block of the <code>try</code> statement. The <em>Block</em> immediately after the keyword <code>finally</code> is called the <code>finally</code> block of the <code>try</code> statement.<p>
<a name="79318"></a>
A <code>try</code> statement may have <code>catch</code> clauses (also called <em>exception handlers</em>). A &#32;<code>catch</code> clause must have exactly one parameter (which is called an <em>exception parameter</em>); the declared type of the exception parameter must be the class <code>Throwable</code> or a subclass of <code>Throwable</code>, or a compile-time error occurs. The scope of the parameter variable is the <em>Block</em> of the <code>catch</code> clause. <p>
<a name="247654"></a>
An exception parameter of a catch clause must not have the same name as a local variable or parameter of the method or initializer block immediately enclosing the catch clause, or a compile-time error occurs.<p>
<a name="257131"></a>
The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.doc.html#79311">(&#167;14.19)</a> is the entire block associated with the <code>catch</code>.<p>
<a name="247671"></a>
Within the <em>Block</em> of the <code>catch</code> clause, the name of the parameter may not be redeclared as a local variable of the directly enclosing method or initializer block, nor may it be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method or initializer block, or a compile-time error occurs. However, an exception parameter may be shadowed <a href="names.doc.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the Block of the catch clause. <p>
<a name="247536"></a>
It is a compile-time error if an exception parameter that is declared final is assigned to within the body of the catch clause. <p>
<a name="45880"></a>
Exception parameters cannot be referred to using qualified names <a href="names.doc.html#104285">(&#167;6.6)</a>, only by simple names.<p>
<a name="24142"></a>
Exception handlers are considered in left-to-right order: the earliest possible <code>catch</code> clause accepts the exception, receiving as its actual argument the thrown exception object.<p>
<a name="24143"></a>
A <code>finally</code> clause ensures that the <code>finally</code> block is executed after the <code>try</code> block and any <code>catch</code> block that might be executed, no matter how control leaves the <code>try</code> block or <code>catch</code> block.<p>
<a name="79319"></a>
Handling of the <code>finally</code> block is rather complex, so the two cases of a <code>try</code> statement with and without a <code>finally</code> block are described separately.<p>
<a name="24134"></a>
<h3>14.19.1    Execution of try-catch<code><b></b></code></h3>
<a name="79320"></a>
A <code>try</code> statement without a <code>finally</code> block is executed by first executing the <code>try</code> block. Then there is a choice:<p>
<ul><a name="79321"></a>
<li>If execution of the <code>try</code> block completes normally, then no further action is taken and the <code>try</code> statement completes normally.
<a name="79322"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79323"></a>
<li>If the run-time type of <i>V</i><i></i> is assignable <a href="conversions.doc.html#184206">(&#167;5.2)</a> to the <em>Parameter</em> of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i> is assigned to the parameter of the selected <code>catch</code> clause, and the <em>Block</em> of that <code>catch</code> clause is executed. If that block completes normally, then the <code>try</code> statement completes normally; if that block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
<a name="79324"></a>
<li>If the run-time type of <i>V</i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
</ul>
<a name="79325"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason, then the <code>try</code> statement completes abruptly for the same reason.
<a name="256055"></a>
In the example:<p>
</ul><blockquote><pre>class BlewIt extends Exception {
	BlewIt() { }
	BlewIt(String s) { super(s); }
}
class Test {
	static void blowUp() throws BlewIt { throw new BlewIt(); }
	public static void main(String[] args) {
		try {
			blowUp();
		} catch (RuntimeException r) {
			System.out.println("RuntimeException:" + r);
		} catch (BlewIt b) {
			System.out.println("BlewIt");
		}
	}
}
</pre></blockquote><a name="236651"></a>
the exception <code>BlewIt</code> is thrown by the method <code>blowUp</code>. The <code>try</code><strong>-</strong><code>catch</code> statement in the body of <code>main</code> has two <code>catch</code> clauses. The run-time type of the exception is <code>BlewIt</code> which is not assignable to a variable of type <code>RuntimeException</code>, but is assignable to a variable of type <code>BlewIt</code>, so the output of the example is:<p>
<blockquote><pre>BlewIt
</pre></blockquote><a name="236653"></a>
<h3>14.19.2    Execution of try-catch-finally<code><b></b></code></h3>
<a name="79326"></a>
A <code>try</code> statement with a <code>finally</code> block is executed by first executing the <code>try</code> block. Then there is a choice:<p>
<ul><a name="79327"></a>
<li>If execution of the <code>try</code> block completes normally, then the <code>finally</code> block is executed, and then there is a choice:
<ul>
<a name="160341"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160342"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i>.
</ul>
<a name="79328"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79329"></a>
<li>If the run-time type of <i>V</i> is assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i> is assigned to the parameter of the selected <code>catch</code> clause, and the <em>Block</em> of that <code>catch</code> clause is executed. Then there is a choice:
<ul>
<a name="79330"></a>
<li>If the <code>catch</code> block completes normally, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="160348"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160349"></a>
<li>If the <code>finally</code> block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
</ul>
<a name="79331"></a>
<li>If the <code>catch</code> block completes abruptly for reason <i>R</i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79332"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i>.
<a name="79333"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and reason <i>R</i> is discarded).
</ul>
</ul>
<a name="79334"></a>
<li>If the run-time type of <i>V</i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79335"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
<a name="79336"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and the <code>throw</code> of value <i>V</i> is discarded and forgotten).
</ul>
</ul>
<a name="79337"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason <i>R</i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79338"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i>.
<a name="79339"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and reason <i>R</i> is discarded).
<a name="252337"></a>
The example:<p>
</ul>
</ul><blockquote><pre>class BlewIt extends Exception {
	BlewIt() { }
	BlewIt(String s) { super(s); }
}
class Test {
	static void blowUp() throws BlewIt {
		throw new NullPointerException();
	}
	public static void main(String[] args) {
		try {
			blowUp();
		} catch (BlewIt b) {
			System.out.println("BlewIt");
		} finally {
			System.out.println("Uncaught Exception");
		}
	}
}
</pre></blockquote><a name="18070"></a>
produces the output:<p>
<blockquote><pre>Uncaught Exception
java.lang.NullPointerException
	at Test.blowUp(Test.java:7)
	at Test.main(Test.java:11)
</pre></blockquote><a name="236703"></a>
The <code>NullPointerException</code> (which is a kind of <code>RuntimeException</code>) that is thrown by method <code>blowUp</code> is not caught by the <code>try</code> statement in <code>main</code>, because a <code>NullPointerException</code> is not assignable to a variable of type <code>BlewIt</code>. This causes the <code>finally</code> clause to execute, after which the thread executing <code>main</code>, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace.<p>
<a name="236365"></a>
<h2>14.20    Unreachable Statements</h2>
<a name="237365"></a>
It is a compile-time error if a statement cannot be executed because it is <em>unreachable</em>. Every Java compiler must carry out the conservative flow analysis specified here to make sure all statements are reachable.<p>
<a name="237366"></a>
This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of <code>while</code>, <code>do</code>, and <code>for</code> statements whose condition expression has the constant value <code>true</code>, the values of expressions are not taken into account in the flow analysis. <p>
<a name="252350"></a>
For example, a Java compiler will accept the code:<p>
<blockquote><pre>{
	int n = 5;
	while (n &gt; 7) k = 2;
}
</pre></blockquote><a name="79350"></a>
even though the value of <code>n</code> is known at compile time and in principle it can be known at compile time that the assignment to <code>k</code> can never be executed.<p>
<a name="252357"></a>
A Java compiler must operate according to the rules laid out in this section.<p>
<a name="79351"></a>
The rules in this section define two technical terms:<p>
<ul><a name="79352"></a>
<li>whether a statement is <em>reachable</em>
<a name="79353"></a>
<li>whether a statement <em>can complete normally</em>
</ul><a name="79354"></a>
The definitions here allow a statement to complete normally only if it is reachable.<p>
<a name="236611"></a>
To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if."<p>
<a name="236612"></a>
The rules are as follows:<p>
<ul><a name="236613"></a>
<li>The block that is the body of a constructor, method, instance initializer or static initializer is reachable.
<a name="160362"></a>
<li>An empty block that is not a switch block can complete normally iff it is reachable. A nonempty block that is not a switch block can complete normally iff the last statement in it can complete normally. The first statement in a nonempty block that is not a switch block is reachable iff the block is reachable. Every other statement <i>S</i> in a nonempty block that is not a switch block is reachable iff the statement preceding <i>S</i> can complete normally.
<a name="247970"></a>
<li>A local class declaration statement can complete normally iff it is reachable.
<a name="160365"></a>
<li>A local variable declaration statement can complete normally iff it is reachable.
<a name="79357"></a>
<li>An empty statement can complete normally iff it is reachable.
<a name="79359"></a>
<li>A labeled statement can complete normally if at least one of the following is true:
<ul>
<a name="21184"></a>
<li>The contained statement can complete normally.
<a name="21188"></a>
<li>There is a reachable <code>break</code> statement that exits the labeled statement.
</ul>
</ul><ul><a name="21187"></a>
The contained statement is reachable iff the labeled statement is reachable.
</ul><ul><a name="79360"></a>
<li>An expression statement can complete normally iff it is reachable.
<a name="236410"></a>
<li>The <code>if</code> statement, whether or not it has an <code>else</code> part, is handled in an unusual manner. For this reason, it is discussed separately at the end of this section.
<a name="79366"></a>
<li>A <code>switch</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79367"></a>
<li>The last statement in the switch block can complete normally.
<a name="237563"></a>
<li>The switch block is empty or contains only switch labels.
<a name="248980"></a>
<li>There is at least one switch label after the last switch block statement group. 
<a name="248989"></a>
<li>The switch block does not contain a <code>default</code> label.
<a name="248981"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>switch</code> statement.
</ul>
<a name="237548"></a>
<li>A switch block is reachable iff its <code>switch</code> statement is reachable.
<a name="237550"></a>
<li>A statement in a switch block is reachable iff its <code>switch</code> statement is reachable and at least one of the following is true:
<ul>
<a name="79370"></a>
<li>It bears a <code>case</code> or <code>default</code> label.
<a name="79371"></a>
<li>There is a statement preceding it in the <code>switch</code> block and that preceding statement can complete normally.
</ul>
<a name="79372"></a>
<li>A <code>while</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79373"></a>
<li>The <code>while</code> statement is reachable and the condition expression is not a constant expression with value <code>true</code>.
<a name="79374"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>while</code> statement.
</ul>
</ul><ul><a name="79375"></a>
The contained statement is reachable iff the <code>while</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79376"></a>
<li>A <code>do</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79377"></a>
<li>The contained statement can complete normally and the condition expression is not a constant expression with value <code>true</code>.
<a name="248990"></a>
<li>The <code>do</code> statement contains a reachable <code>continue</code> statement with no label, and the <code>do</code> statement is the innermost <code>while</code>, <code>do</code>, or <code>for</code> statement that contains that <code>continue</code> statement, and the condition expression is not a constant expression with value <code>true</code>.
<a name="248991"></a>
<li>The <code>do</code> statement contains a reachable <code>continue</code> statement with a label <i>L</i>, and the <code>do</code> statement has label <i>L, </i>and the condition expression is not a constant expression with value <code>true</code>.
<a name="79378"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>do</code> statement.
</ul>
</ul><ul><a name="79379"></a>
The contained statement is reachable iff the <code>do</code> statement is reachable.
</ul><ul><a name="79380"></a>
<li>A <code>for</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79381"></a>
<li>The <code>for</code> statement is reachable, there is a condition expression, and the condition expression is not a constant expression with value <code>true</code>.
<a name="79382"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>for</code> statement.
</ul>
</ul><ul><a name="79383"></a>
The contained statement is reachable iff the <code>for</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79384"></a>
<li>A <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement cannot complete normally.
<a name="79385"></a>
<li>A <code>synchronized</code> statement can complete normally iff the contained statement can complete normally. The contained statement is reachable iff the <code>synchronized</code> statement is reachable.
<a name="79386"></a>
<li>A <code>try</code> statement can complete normally iff both of the following are true:
<ul>
<a name="79387"></a>
<li>The <code>try</code> block can complete normally or any <code>catch</code> block can complete <code>normally</code>.
<a name="79388"></a>
<li>If the <code>try</code> statement has a <code>finally</code> block, then the <code>finally</code> block can complete normally.
</ul>
<a name="79389"></a>
<li>The <code>try</code> block is reachable iff the <code>try</code> statement is reachable.
<a name="79390"></a>
<li>A <code>catch</code> block <i>C</i> is reachable iff both of the following are true:
<ul>
<a name="79391"></a>
<li>Some expression or <code>throw</code> statement in the <code>try</code> block is reachable and can throw an exception whose type is assignable to the parameter of the <code>catch</code> clause <i>C</i>. (An expression is considered reachable iff the innermost statement containing it is reachable.)
<a name="79392"></a>
<li>There is no earlier <code>catch</code> block <i>A</i> in the <code>try</code> statement such that the type of <i>C</i>'s parameter is the same as or a subclass of the type of <i>A</i>'s parameter.
</ul>
<a name="236212"></a>
<li>If a <code>finally</code> block is present, it is reachable iff the <code>try</code> statement is reachable.
<a name="236419"></a>
One might expect the <code>if</code> statement to be handled in the following manner, but these are not the rules that the Java programming language actually uses:<p>
<a name="236554"></a>
<li>HYPOTHETICAL: An <code>if-then</code> statement can complete normally iff at least one of the following is <code>true</code>:
<ul>
<a name="236555"></a>
<li>The <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
<a name="236407"></a>
<li>The <code>then</code>-statement can complete normally.
</ul>
</ul><a name="236408"></a>
The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.<p>
<ul><a name="236409"></a>
<li>HYPOTHETICAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>. The <code>else</code> statement is reachable iff the <code>if</code>-<code>then</code>-<code>else </code>statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
<a name="236422"></a>
This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for "conditional compilation" purposes, the actual rules differ.<p>
</ul><a name="252364"></a>
The actual rules for the if statement are as follows:<p>
<ul><a name="236424"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code> statement can complete normally iff it is reachable. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable.
<a name="236428"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable. The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.
<a name="252376"></a>
As an example, the following statement results in a compile-time error:<p>
</ul><blockquote><pre>while (false) { x=3; }
</pre></blockquote><a name="236453"></a>
because the statement <code>x=3;</code> is not reachable; but the superficially similar case:<p>
<blockquote><pre>if (false) { x=3; }
</pre></blockquote><a name="236454"></a>
does not result in a compile-time error. An optimizing compiler may realize that the statement <code>x=3;</code> will never be executed and may choose to omit the code for that statement from the generated <code>class</code> file, but the statement <code>x=3;</code> is not regarded as "unreachable" in the technical sense specified here.<p>
<a name="238244"></a>
The rationale for this differing treatment is to allow programmers to define "flag variables" such as:<p>
<blockquote><pre>static final boolean DEBUG = false;
</pre></blockquote><a name="236471"></a>
and then write code such as:<p>
<blockquote><pre>if (DEBUG) { x=3; }
</pre></blockquote><a name="236477"></a>
The idea is that it should be possible to change the value of <code>DEBUG</code> from <code>false</code> to <code>true</code> or from <code>true</code> to <code>false</code> and then compile the code correctly with no other changes to the program text.<p>
<a name="238425"></a>
This ability to "conditionally compile" has a significant impact on, and relationship to, binary compatibility <a href="binaryComp.doc.html#44871">(&#167;13)</a>. If a set of classes that use such a "flag" variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. A change to the value of a flag is, therefore, not binary compatible with preexisting binaries <a href="binaryComp.doc.html#45139">(&#167;13.4.8)</a>. (There are other reasons for such incompatibility as well, such as the use of constants in <code>case</code> labels in <code>switch</code> statements; see <a href="binaryComp.doc.html#45139">&#167;13.4.8</a>.)<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="binaryComp.doc.html">Prev</a> | <a href="expressions.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Expressions</title>
<meta name="collection" content="exclude">

</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="statements.doc.html">Prev</a> | <a href="defAssign.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="4709"></a>
<p><strong>
CHAPTER
 15 </strong></p>
<a name="44393"></a>
<h1>Expressions</h1>
<hr><p>
<a name="11757"></a>
Much of the work in a program is done by evaluating <em>expressions</em>, either for their side effects, such as assignments to variables, or for their values, which can be used as arguments or operands in larger expressions, or to affect the execution sequence in statements, or both.<p>
<a name="236101"></a>
This chapter specifies the meanings of expressions and the rules for their evaluation.<p>
<a name="228862"></a>
<h2>15.1    Evaluation, Denotation, and Result</h2>
<a name="290570"></a>
When an expression in a program is <em>evaluated</em> (<em>executed</em>), the <em>result </em>denotes one of three things:<p>
<ul><a name="228896"></a>
<li>A variable <a href="typesValues.doc.html#18470">(&#167;4.5)</a> (in C, this would be called an <em>lvalue</em>)
<a name="19788"></a>
<li>A value (<a href="typesValues.doc.html#85587">&#167;4.2</a>, <a href="typesValues.doc.html#9317">&#167;4.3</a>)
<a name="229505"></a>
<li>Nothing (the expression is said to be <code>void</code>)
</ul><a name="233971"></a>
Evaluation of an expression can also produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations.<p>
<a name="229523"></a>
An expression denotes nothing if and only if it is a method invocation <a href="expressions.doc.html#20448">(&#167;15.12)</a> that invokes a method that does not return a value, that is, a method declared <code>void</code> <a href="classes.doc.html#40420">(&#167;8.4)</a>. Such an expression can be used only as an expression statement <a href="statements.doc.html#5984">(&#167;14.8)</a>, because every other context in which an expression can appear requires the expression to denote something. An expression statement that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.<p>
<a name="249221"></a>
Value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> is applied to the result of every expression that produces a value.<p>
<a name="39859"></a>
Each expression occurs in the declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in a constructor declaration, or in the code for a method.<p>
<a name="229188"></a>
<h2>15.2    Variables as Values</h2>
<a name="229204"></a>
If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the <em>value</em> of the expression.<p>
<a name="249233"></a>
If the value of a variable of type <code>float</code> or <code>double</code> is used in this manner, then value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> is applied to the value of the variable.<p>
<a name="198550"></a>
<h2>15.3    Type of an Expression</h2>
<a name="229255"></a>
If an expression denotes a variable or a value, then the expression has a type known at compile time. The rules for determining the type of an expression are explained separately below for each kind of expression.<p>
<a name="229277"></a>
The value of an expression is always assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the type of the expression, just as the value stored in a variable is always compatible with the type of the variable. <p>
<a name="264235"></a>
In other words, the value of an expression whose type is <i>T</i> is always suitable for assignment to a variable of type <i>T</i>.<p>
<a name="264237"></a>
Note that an expression whose type is a class type <i>F</i> that is declared <code>final</code> is guaranteed to have a value that is either a null reference or an object whose class is <i>F</i> itself, because <code>final</code> types have no subclasses.<p>
<a name="249198"></a>
<h2>15.4    FP-strict Expressions</h2>
<a name="272660"></a>
If the type of an expression is <code>float</code> or <code>double</code>, then there is a question as to what value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a> the value of the expression is drawn from. This is governed by the rules of value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>; these rules in turn depend on whether or not the expression is <em>FP-strict</em>.<p>
<a name="272652"></a>
Every compile-time constant expression <a href="expressions.doc.html#5313">(&#167;15.28)</a> is FP-strict. If an expression is not a compile-time constant expression, then consider all the class declarations, interface declarations, and method declarations that contain the expression. If <em>any</em> such declaration bears the <code>strictfp</code> modifier, then the expression is FP-strict.<p>
<a name="286261"></a>
If a class, interface, or method, <i>X</i>, is declared <code>strictfp</code>, then <i>X</i> and any class, interface, method, constructor, instance initializer, static initializer or variable initializer within <i>X</i> is said to be <em>FP-strict</em>.<p>
<a name="272653"></a>
It follows that an expression is not FP-strict if and only if it is not a compile-time constant expression <em>and</em> it does not appear within any declaration that has the <code>strictfp</code> modifier.<p>
<a name="290065"></a>
Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FP-strict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats. Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.<p>
<a name="290072"></a>
<h2>15.5    Expressions and Run-Time Checks</h2>
<a name="233993"></a>
If the type of an expression is a primitive type, then the value of the expression is of that same primitive type. But if the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than <code>null</code>, is not necessarily known at compile time. There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression. They are as follows:<p>
<ul><a name="79422"></a>
<li>Method invocation <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The particular method used for an invocation <code>o.m(</code>...<code>)</code> is chosen based on the methods that are part of the class or interface that is the type of <code>o</code>. For instance methods, the class of the object referenced by the run-time value of <code>o</code> participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked. (The overriding method may or may not choose to further invoke the original overridden <code>m</code> method.)
<a name="79436"></a>
<li>The <code>instanceof</code> operator <a href="expressions.doc.html#80289">(&#167;15.20.2)</a>. An expression whose type is a reference type may be tested using <code>instanceof</code> to find out whether the class of the object referenced by the run-time value of the expression is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with some other reference type.
<a name="35797"></a>
<li>Casting (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>). The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast. For reference types, this may require a run-time check that throws an exception if the class of the referenced object, as determined at run time, is not assignment &#32;compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the target type.
<a name="35800"></a>
<li>Assignment to an array component of reference type (<a href="arrays.doc.html#11430">&#167;10.10</a>, <a href="expressions.doc.html#239587">&#167;15.13</a>, <a href="expressions.doc.html#5295">&#167;15.26.1</a>). The type-checking rules allow the array type <i>S</i><code>[]</code> to be treated as a subtype of <i>T</i><code>[]</code> if <i>S</i> is a subtype of <i>T</i>, but this requires a run-time check for assignment to an array component, similar to the check performed for a cast.
<a name="79438"></a>
<li>Exception handling <a href="statements.doc.html#79311">(&#167;14.19)</a>. An exception is caught by a <code>catch</code> clause only if the class of the thrown exception object is an <code>instanceof</code> the type of the formal parameter of the <code>catch</code> clause.
</ul><a name="35847"></a>
The first two of the cases just listed ought never to result in detecting a type error. Thus, a run-time type error can occur only in these situations:<p>
<ul><a name="79443"></a>
<li>In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast operator (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>); in this case a <code>ClassCastException</code> is thrown.
<a name="79444"></a>
<li>In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the actual run-time component type of the array (<a href="arrays.doc.html#11430">&#167;10.10</a>, <a href="expressions.doc.html#239587">&#167;15.13</a>, <a href="expressions.doc.html#5295">&#167;15.26.1</a>); in this case an <code>ArrayStoreException</code> is thrown.
<a name="79445"></a>
<li>When an exception is not caught by any <code>catch</code> handler <a href="exceptions.doc.html#44153">(&#167;11.3)</a>; in this case the thread of control that encountered the exception first invokes the method <code>uncaughtException</code> &#32; for its thread group and then terminates.
</ul><a name="79448"></a>
<h2>15.6    Normal and Abrupt Completion of Evaluation</h2>
<a name="79449"></a>
Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression. If all the steps are carried out without an exception being thrown, the expression is said to <em>complete normally</em>. <p>
<a name="217304"></a>
If, however, evaluation of an expression throws an exception, then the expression is said to <em>complete abruptly</em>. An abrupt completion always has an associated <em>reason</em>, which is always a <code>throw</code> with a given value.<p>
<a name="217294"></a>
Run-time exceptions are thrown by the predefined operators as follows:<p>
<ul><a name="43791"></a>
<li>A class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a>, array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>, or string concatenation operatior expression <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> throws an <code>OutOfMemoryError</code> if there is insufficient memory available.
<a name="43795"></a>
<li>An array creation expression throws a <code>NegativeArraySizeException</code> if the value of any dimension expression is less than zero <a href="expressions.doc.html#46168">(&#167;15.10)</a>.
<a name="43780"></a>
<li>A field access <a href="expressions.doc.html#41267">(&#167;15.11)</a> throws a <code>NullPointerException</code> if the value of the object reference &#32;expression is <code>null</code>.
<a name="43784"></a>
<li>A method invocation expression <a href="expressions.doc.html#20448">(&#167;15.12)</a> that invokes an instance method throws a <code>NullPointerException</code> if the target reference is <code>null</code>.
<a name="43730"></a>
<li>An array access <a href="expressions.doc.html#239587">(&#167;15.13)</a> throws a <code>NullPointerException</code> if the value of the array reference &#32;expression is <code>null</code>.
<a name="43758"></a>
<li>An array access <a href="expressions.doc.html#239587">(&#167;15.13)</a> throws an <code>ArrayIndexOutOfBoundsException</code> if the value &#32;of the array index expression is negative or greater than or equal to the <code>length</code> of the array.
<a name="217340"></a>
<li>A cast <a href="expressions.doc.html#238146">(&#167;15.16)</a> throws a <code>ClassCastException</code> if a cast is found to be impermissible at run time.
<a name="217346"></a>
<li>An integer division <a href="expressions.doc.html#5047">(&#167;15.17.2)</a> or integer remainder <a href="expressions.doc.html#24956">(&#167;15.17.3)</a> operator throws an <code>ArithmeticException</code> if the value of the right-hand operand expression is zero.
<a name="234027"></a>
<li>An assignment to an array component of reference type <a href="expressions.doc.html#5295">(&#167;15.26.1)</a> throws an <code>ArrayStoreException</code> when the value to be assigned is not compatible with the component type of the array.
</ul><a name="21217"></a>
A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly. A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly. Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle.<p>
<a name="6969"></a>
If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly. The terms "complete normally" and &#32;"complete abruptly" are also applied to the execution of statements <a href="statements.doc.html#5894">(&#167;14.1)</a>. A &#32;statement may complete abruptly for a variety of reasons, not just because an exception is thrown.<p>
<a name="79456"></a>
If evaluation of an expression requires evaluation of a subexpression, abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.<p>
<a name="4779"></a>
<h2>15.7    Evaluation Order</h2>
<a name="264242"></a>
The Java programming language guarantees that the operands of operators appear to be evaluated in a specific <em>evaluation order</em>, namely, from left to right.<p>
<a name="264247"></a>
It is recommended that code not rely crucially on this specification. Code is usually clearer when each expression contains at most one side effect, as its outermost &#32;operation, and when code does not depend on exactly which exception arises as a consequence of the left-to-right evaluation of expressions.<p>
<a name="18498"></a>
<h3>15.7.1    Evaluate Left-Hand Operand First</h3>
<a name="264252"></a>
The left-hand operand of a binary operator appears to be fully evaluated before any part of the right-hand operand is evaluated. For example, if the left-hand operand contains an assignment to a variable and the right-hand operand contains a reference to that same variable, then the value produced by the reference will reflect the fact that the assignment occurred first.<p>
<a name="18540"></a>
Thus:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int i = 2;
		int j = (i=3) * i;
		System.out.println(j);
	}
}
</pre></blockquote><a name="18539"></a>
prints:<p>
<blockquote><pre><code>9
</code></pre></blockquote><a name="35994"></a>
It is not permitted for it to print <code>6</code> instead of <code>9</code>.<p>
<a name="240786"></a>
If the operator is a compound-assignment operator <a href="expressions.doc.html#5304">(&#167;15.26.2)</a>, then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied combining operation. So, for example, the test program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int a = 9;
		a += (a = 3);									// first example
		System.out.println(a);
		int b = 9;
		b = b + (b = 3);									// second example
		System.out.println(b);
	}
}
</pre></blockquote><a name="18725"></a>
prints:<p>
<blockquote><pre>12
12
</pre></blockquote><a name="264257"></a>
because the two assignment statements both fetch and remember the value of the left-hand operand, which is <code>9</code>, before the right-hand operand of the addition is evaluated, thereby setting the variable to <code>3</code>. It is not permitted for either example to produce the result <code>6</code>. Note that both of these examples have unspecified behavior in C, according to the ANSI/ISO standard.<p>
<a name="264262"></a>
If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.<p>
<a name="18857"></a>
Thus, the test program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int j = 1;
		try {
			int i = forgetIt() / (j = 2);
		} catch (Exception e) {
			System.out.println(e);
			System.out.println("Now j = " + j);
		}
	}
	static int forgetIt() throws Exception {
		throw new Exception("I'm outta here!");
	}
}
</pre></blockquote><a name="18858"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: I'm outta here!
Now j = 1
</pre></blockquote><a name="264267"></a>
That is, the left-hand operand <code>forgetIt()</code> of the operator <code>/</code> throws an exception before the right-hand operand is evaluated and its embedded assignment of <code>2</code> to <code>j</code> occurs.<p>
<a name="18740"></a>
<h3>15.7.2    Evaluate Operands before Operation</h3>
<a name="18749"></a>
The Java programming language also guarantees that every operand of an operator (except the conditional operators <code>&amp;&amp;</code>, <code>||</code>, and <code>?</code> <code>:</code>) appears to be fully evaluated before any part of the operation itself is performed.<p>
<a name="264272"></a>
If the binary operator is an integer division <code>/</code> <a href="expressions.doc.html#5047">(&#167;15.17.2)</a> or integer remainder <code>%</code> <a href="expressions.doc.html#24956">(&#167;15.17.3)</a>, then its execution may raise an <code>ArithmeticException</code>, but this exception is thrown only after both operands of the binary operator have been evaluated and only if these evaluations completed normally.<p>
<a name="36160"></a>
So, for example, the program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int divisor = 0;
		try {
			int i = 1 / (divisor * loseBig());
		} catch (Exception e) {
			System.out.println(e);
		}
	}
	static int loseBig() throws Exception {
		throw new Exception("Shuffle off to Buffalo!");
	}
}
</pre></blockquote><a name="36174"></a>
always prints:<p>
<blockquote><pre>java.lang.Exception: Shuffle off to Buffalo!
</pre></blockquote><a name="36176"></a>
and not:<p>
<blockquote><pre>java.lang.ArithmeticException: / by zero
</pre></blockquote><a name="264277"></a>
since no part of the division operation, including signaling of a divide-by-zero exception, may appear to occur before the invocation of <code>loseBig</code> completes, even though the implementation may be able to detect or infer that the division operation would certainly result in a divide-by-zero exception.<p>
<a name="23213"></a>
<h3>15.7.3    Evaluation Respects Parentheses and Precedence</h3>
<a name="23217"></a>
Java programming language implementations must respect the order of evaluation as indicated explicitly by parentheses and implicitly by operator precedence. An implementation may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in <a href="memory.doc.html#26250">&#167;17</a>), for all possible computational values that might be involved.<p>
<a name="23218"></a>
In the case of floating-point calculations, this rule applies also for infinity and not-a-number (NaN) values. For example, <code>!(x&lt;y)</code> may not be rewritten as <code>x&gt;=y</code>, because these expressions have different values if either <code>x</code> or <code>y</code> is NaN or both are NaN.<p>
<a name="264283"></a>
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered. <p>
<a name="264281"></a>
For example, it is not correct for a Java compiler to rewrite <code>4.0*x*0.5</code> as <code>2.0*x</code>; while roundoff happens not to be an issue here, there are large values of <code>x</code> for which the first expression produces infinity (because of overflow) but the second expression produces a finite result.<p>
<a name="238102"></a>
So, for example, the test program:<p>
<blockquote><pre>strictfp class Test {
	public static void main(String[] args) {
		double d = 8e+307;
		System.out.println(4.0 * d * 0.5);
		System.out.println(2.0 * d);
	}
}
</pre></blockquote><a name="23231"></a>
prints:<p>
<blockquote><pre>Infinity
1.6e+308
</pre></blockquote><a name="264288"></a>
because the first expression overflows and the second does not.<p>
<a name="264295"></a>
In contrast, integer addition and multiplication <em>are</em> provably associative in the Java programming language.<p>
<a name="264300"></a>
For example <code>a+b+c</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are local variables (this simplifying assumption avoids issues involving multiple threads and <code>volatile</code> variables), will always produce the same answer whether evaluated as <code>(a+b)+c</code> or <code>a+(b+c)</code>; if the expression <code>b+c</code> occurs nearby in the code, a smart compiler may be able to use this common subexpression.<p>
<a name="23789"></a>
<h3>15.7.4    Argument Lists are Evaluated Left-to-Right</h3>
<a name="264305"></a>
In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas. Each argument expression appears to be fully evaluated before any part of any argument expression to its right.<p>
<a name="23791"></a>
Thus:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		String s = "going, ";
		print3(s, s, s = "gone");
	}
	static void print3(String a, String b, String c) {
		System.out.println(a + b + c);
	}
}
</pre></blockquote><a name="23800"></a>
always prints:<p>
<blockquote><pre>going, going, gone
</pre></blockquote><a name="264310"></a>
because the assignment of the string <code>"gone"</code> to <code>s</code> occurs after the first two arguments to <code>print3</code> have been evaluated.<p>
<a name="264315"></a>
If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.<p>
<a name="23804"></a>
Thus, the example:<p>
<blockquote><pre>class Test {
	static int id;
	public static void main(String[] args) {
		try {
			test(id = 1, oops(), id = 3);
		} catch (Exception e) {
			System.out.println(e + ", id=" + id);
		}
	}
	static int oops() throws Exception {
		throw new Exception("oops");
	}
	static int test(int a, int b, int c) {
		return a + b + c;
	}
}
</pre></blockquote><a name="23821"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: oops, id=1
</pre></blockquote><a name="264320"></a>
because the assignment of <code>3</code> to <code>id</code> is not executed.<p>
<a name="23451"></a>
<h3>15.7.5    Evaluation Order for Other Expressions</h3>
<a name="23452"></a>
The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified. See, specifically, the detailed explanations of evaluation order for the following kinds of expressions:<p>
<ul><a name="249837"></a>
<li>class instance creation expressions <a href="expressions.doc.html#251881">(&#167;15.9.4)</a>
<a name="249842"></a>
<li>array creation expressions <a href="expressions.doc.html#23605">(&#167;15.10.1)</a>
<a name="249846"></a>
<li>method invocation expressions <a href="expressions.doc.html#45677">(&#167;15.12.4)</a>
<a name="23491"></a>
<li>array access expressions <a href="expressions.doc.html#23958">(&#167;15.13.1)</a>
<a name="240795"></a>
<li>assignments involving array components <a href="expressions.doc.html#5281">(&#167;15.26)</a>
</ul><a name="23302"></a>
<h2>15.8    Primary Expressions</h2>
<a name="36225"></a>
Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, class literals, field accesses, method invocations, and array accesses. A parenthesized expression is also treated syntactically as a primary expression.<p>
<ul><pre>
<em>Primary:
	PrimaryNoNewArray
	ArrayCreationExpression

PrimaryNoNewArray:
	Literal
	Type . class 
</em>	void</em> . class 
	this
	ClassName.this
	( Expression )
	ClassInstanceCreationExpression
	FieldAccess
	MethodInvocation
	ArrayAccess
</em></pre></ul><a name="224125"></a>
<h3>15.8.1    Lexical Literals</h3>
<a name="36407"></a>
A literal <a href="lexical.doc.html#48272">(&#167;3.10)</a> denotes a fixed, unchanging value.<p>
<a name="36387"></a>
The following production from <a href="lexical.doc.html#48272">&#167;3.10</a> is repeated here for convenience:<p>
<ul><pre>
<em>Literal: 
	IntegerLiteral
	FloatingPointLiteral
	BooleanLiteral
	CharacterLiteral
	StringLiteral
	NullLiteral
</em></pre></ul><a name="36400"></a>
The type of a literal is determined as follows:<p>
<ul><a name="43814"></a>
<li>The type of an integer literal that ends with <code>L</code> or <code>l</code> is <code>long</code>; the type of any other integer literal is <code>int</code>.
<a name="251041"></a>
<li>The type of a floating-point literal that ends with <code>F</code> or <code>f</code> is <code>float</code> and its value must be an element of the float value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a>. The type of any other floating-point literal is <code>double</code> and its value must be an element of the double value set.
<a name="36429"></a>
<li>The type of a boolean literal is <code>boolean</code>.
<a name="36436"></a>
<li>The type of a character literal is <code>char</code>.
<a name="36437"></a>
<li>The type of a string literal is <code>String</code>.
<a name="250692"></a>
<li>The type of the null literal <code>null</code> is the null type; its value is the null reference.
</ul><a name="250775"></a>
Evaluation of a lexical literal always completes normally.<p>
<a name="251530"></a>
<h3>15.8.2    Class Literals </h3>
<a name="250782"></a>
A class literal is an expression consisting of the name of a class, interface, array, or primitive type followed by a `.' and the token class. The type of a class literal is Class. It evaluates to the Class object for the named type (or for void) as defined by the defining class loader of the class of the current instance. <p>
<a name="251519"></a>
<h3>15.8.3    <code>this</code> </h3>
<a name="251520"></a>
The keyword <code>this</code> may be used only in the body of an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class. If it appears anywhere else, a compile-time error occurs.<p>
<a name="264342"></a>
When used as a primary expression, the keyword <code>this</code> denotes a value, that is a reference to the object for which the instance method was invoked <a href="expressions.doc.html#20448">(&#167;15.12)</a>, or to the object being constructed. The type of <code>this</code> is the class <i>C</i> within which the keyword <code>this</code> occurs. At run time, the class of the actual object referred to may be the class <i>C</i> or any subclass of <i>C</i>.<p>
<a name="31984"></a>
In the example:<p>
<blockquote><pre>class IntVector {
	int[] v;
	boolean equals(IntVector other) {
		if (this == other)
			return true;
		if (v.length != other.v.length)
			return false;
		for (int i = 0; i &lt; v.length; i++)
			if (v[i] != other.v[i])
				return false;
		return true;
	}
}
</pre></blockquote><a name="264347"></a>
the class <code>IntVector</code> implements a method <code>equals</code>, which compares two vectors. If the <code>other</code> vector is the same vector object as the one for which the <code>equals</code> method was invoked, then the check can skip the length and value comparisons. The <code>equals</code> method implements this check by comparing the reference to the <code>other</code> object to <code>this</code>.<p>
<a name="20077"></a>
The keyword <code>this</code> is also used in a special explicit constructor invocation statement, which can appear at the beginning of a constructor body <a href="classes.doc.html#78435">(&#167;8.8.5)</a>.<p>
<a name="251603"></a>
<h3>15.8.4    Qualified <code>this</code></h3>
<a name="250907"></a>
Any lexically enclosing instance can be referred to by explicitly qualifying the keyword <code>this</code>.<p>
<a name="250970"></a>
Let <i>C</i> be the class denoted by <i>ClassName</i>. Let <i>n</i> be an integer such that <i>C</i> is the <i>n</i>th lexically enclosing class of the class in which the qualified this expression appears. The value of an expression of the form <i>ClassName</i>.<code>this</code> is the <i>n</i>th lexically enclosing instance of <code>this</code> <a href="classes.doc.html#262890">(&#167;8.1.2)</a>. The type of the expression is <i>C</i>. It is a compile-time error if the current class is not an inner class of class <i>C</i> or <i>C</i> itself.<p>
<a name="236822"></a>
<h3>15.8.5    Parenthesized Expressions</h3>
<a name="236823"></a>
A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression. If the contained expression denotes a variable then the parenthesized expression also denotes that variable. <p>
<a name="249265"></a>
Parentheses do not affect in any way the choice of value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a> for the value of an expression of type <code>float</code> or <code>double</code>.<p>
<a name="41147"></a>
<h2>15.9    Class Instance Creation Expressions</h2>
<a name="36595"></a>
A class instance creation expression is used to create new objects that are instances of classes.<p>
<ul><pre>
<i>ClassInstanceCreationExpression:
</i>	new<i> ClassOrInterfaceType ( ArgumentList<sub><i>opt</i></sub> ) ClassBodyopt
	Primary.new Identifier ( ArgumentListopt ) ClassBodyopt

ArgumentList:
	Expression
	ArgumentList , Expression
</i></pre></ul><a name="252035"></a>
Class instance creation expressions have two forms: <p>
<ul><a name="253146"></a>
<li><i>Unqualified class instance creation expressions</i> begin with the keyword <code>new</code>. An unqualified class instance creation expression may be used to create an instance of a class, regardless of whether the class is a top-level <a href="packages.doc.html#26783">(&#167;7.6)</a>, member (<a href="classes.doc.html#246026">&#167;8.5</a>, <a href="interfaces.doc.html#252566">&#167;9.5</a>), local <a href="statements.doc.html#247766">(&#167;14.3)</a> or anonymous class <a href="expressions.doc.html#252986">(&#167;15.9.5)</a>.
<a name="253111"></a>
<li><i>Qualified class instance creation expressions</i> begin with a <i>Primary</i>. A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses. 
</ul><a name="252044"></a>
Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an <i>anonymous class</i> <a href="expressions.doc.html#252986">(&#167;15.9.5)</a> and creates an instance of it. <p>
<a name="253411"></a>
We say that a class is <i>instantiated</i> when an instance of the class is created by a class instance creation expression. Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created instance are, what constructor should be invoked to create the new instance and what arguments should be passed to that constructor.<p>
<a name="23745"></a>
<h3>15.9.1    Determining the Class being Instantiated</h3>
<a name="253090"></a>
If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class. Then:<p>
<ul><a name="253179"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then let <i>T</i> be the <i>ClassOrInterfaceType</i> after the new token. It is a compile-time error if the class or interface named by <i>T</i> is not accessible <a href="names.doc.html#104285">(&#167;6.6)</a>. If <i>T</i> is the name of a class, then an anonymous direct subclass of the class named by <i>T</i> is declared. It is a compile-time error if the class named by <i>T</i> is a <code>final</code> class. If <i>T</i> is the name of an interface then an anonymous direct subclass of <code>Object</code> that implements the interface named by <i>T</i> is declared. In either case, the body of the subclass is the <i>ClassBody</i> given in the class instance creation expression. The class being instantiated is the anonymous subclass.
<a name="253194"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. Let <i>T</i> be the name of the <i>Identifier</i> after the new token. It is a compile-time error if <i>T</i> is not the simple name <a href="names.doc.html#31692">(&#167;6.2)</a> of an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> non-<code>final</code> inner class <a href="classes.doc.html#262890">(&#167;8.1.2)</a> that is a member of the compile-time type of the <i>Primary</i>. It is also a compile-time error if <i>T</i> is ambiguous <a href="classes.doc.html#246026">(&#167;8.5)</a>. An anonymous direct subclass of the class named by <i>T</i> is declared. The body of the subclass is the <i>ClassBody</i> given in the class instance creation expression. The class being instantiated is the anonymous subclass. 
</ul><a name="253236"></a>
If a class instance creation expression does not declare an anonymous class, then:<p>
<ul><a name="253239"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then the <em>ClassOrInterfaceType </em>must name a class that is accessible <a href="names.doc.html#104285">(&#167;6.6)</a> and not <code>abstract</code>, or a compile-time error occurs. In this case, the class being instantiated is the class denoted by ClassOrInterfaceType.
<a name="253242"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. It is a compile-time error if <i>Identifier</i> is not the simple name <a href="names.doc.html#31692">(&#167;6.2)</a> of an accessible <a href="names.doc.html#104285">(&#167;6.6)</a> non-<code>abstract</code> inner class <a href="classes.doc.html#262890">(&#167;8.1.2)</a> T that is a member of the compile-time type of the <i>Primary</i>. It is also a compile-time error if <i>Identifier</i> is ambiguous <a href="classes.doc.html#246026">(&#167;8.5)</a>. The class being instantiated is the class denoted by <i>Identifier</i>.
</ul><a name="253435"></a>
The type of the class instance creation expression is the class type being instantiated.<p>
<a name="253028"></a>
<h3>15.9.2    Determining Enclosing Instances</h3>
<a name="253034"></a>
Let <i>C</i> be the class being instantiated, and let <i>i</i> the instance being created. If <i>C</i> is an inner class then <i>i</i> may have an immediately enclosing instance. The immediately enclosing instance of <i>i</i> <a href="classes.doc.html#262890">(&#167;8.1.2)</a> is determined as follows:<p>
<ul><a name="253038"></a>
<li>If <i>C</i> is an anonymous class, then:
<ul>
<a name="254032"></a>
<li>If the class instance creation expression occurs in a static context <a href="classes.doc.html#262890">(&#167;8.1.2)</a>, then <i>i</i> has no immediately enclosing instance.
<a name="254034"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> is <code>this</code>.
</ul>
<a name="254064"></a>
<li>If <i>C</i> is a local class <a href="statements.doc.html#247766">(&#167;14.3)</a>, <i>C</i> must be declared in a method declared in a lexically enclosing class <i>O</i>. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. Then:
<ul>
<a name="254067"></a>
<li>If <i>C</i> occurs in a static context, then <i>i</i> has no immediately enclosing instance.
<a name="267182"></a>
<li>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254059"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> is the <I>n</i>th lexically enclosing instance of <code>this </code><a href="classes.doc.html#262890">(&#167;8.1.2)</a>. 
</ul>
<a name="253336"></a>
<li>Otherwise, <i>C</i> is an inner member class <a href="classes.doc.html#246026">(&#167;8.5)</a>. 
<ul>
<a name="253064"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then:
<ul>
<a name="253350"></a>
<li>If the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254073"></a>
<li>Otherwise, if <i>C</i> is a member of an enclosing class then let <i>O</i> be the innermost lexically enclosing class of which <i>C</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. The immediately enclosing instance of <i>i</i> is the <i>n</i>th lexically enclosing instance of <code>this.</code>
<a name="253408"></a>
<li>Otherwise, a compile-time error occurs.
</ul>
<a name="253340"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. The immediately enclosing instance of <i>i</i> is the object that is the value of the <i>Primary</i> expression.
</ul>
</ul><a name="253300"></a>
In addition, if <i>C</i> is an anonymous class, and the direct superclass of <i>C</i>, <i>S</i>, is an inner class then <i>i</i> may have an immediately enclosing instance with respect to <i>S</i> which is determined as follows:<p>
<ul><a name="253304"></a>
<li>If <i>S</i> is a local class <a href="statements.doc.html#247766">(&#167;14.3)</a>, then <i>S</i> must be declared in a method declared in a lexically enclosing class <i>O</i>. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. Then:
<ul>
<a name="267205"></a>
<li>If <i>S</i> occurs within a static context, then <i>i</i> has no immediately enclosing instance with respect to <i>S</i>.
<a name="267208"></a>
<li>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254087"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this.</code>
</ul>
<a name="253365"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.doc.html#246026">(&#167;8.5)</a>. 
<ul>
<a name="253366"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then:
<ul>
<a name="253367"></a>
<li>If the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254096"></a>
<li>Otherwise, if <i>S</i> is a member of an enclosing class then let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this.</code>
<a name="253368"></a>
<li>Otherwise, a compile-time error occurs.
</ul>
<a name="253369"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the object that is the value of the <i>Primary</i> expression.
</ul>
</ul><a name="253029"></a>
<h3>15.9.3    Choosing the Constructor and its Arguments</h3>
<a name="253097"></a>
Let <i>C</i> be the class type being instantiated. To create an instance of <i>C</i>, <i>i</i>, a constructor of <i>C</i> is chosen at compile-time by the following rules:<p>
<ul><a name="253098"></a>
<li>First, the actual arguments to the constructor invocation are determined.
<ul>
<a name="253099"></a>
<li>If <i>C</i> is an anonymous class, and the direct superclass of <i>C</i>, <i>S</i>, is an inner class, then:
<ul>
<a name="254143"></a>
<li>If the <i>S</i> is a local class and <i>S</i> occurs in a static context, then the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
<a name="254144"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the first argument to the constructor, followed by the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
</ul>
<a name="253100"></a>
<li>Otherwise the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
</ul>
<a name="253101"></a>
<li>Once the actual arguments have been determined, they are used to select a constructor of <i>C</i>, using the same rules as for method invocations <a href="expressions.doc.html#20448">(&#167;15.12)</a>. As in method invocations, a compile-time method matching error results if there is no unique most-specific constructor that is both applicable and accessible.
</ul><a name="253105"></a>
Note that the type of the class instance creation expression may be an anonymous class type, in which case the constructor being invoked is an anonymous constructor.<p>
<a name="251881"></a>
<h3>15.9.4    Run-time Evaluation of Class Instance Creation Expressions</h3>
<a name="36655"></a>
At run time, evaluation of a class instance creation expression is as follows.<p>
<a name="265442"></a>
First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.<p>
<a name="23746"></a>
Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an <code>OutOfMemoryError</code> <a href="expressions.doc.html#36687">(&#167;15.9.6)</a>.<p>
<a name="23753"></a>
The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>.<p>
<a name="36584"></a>
Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.<p>
<a name="36513"></a>
Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements <a href="classes.doc.html#41652">(&#167;8.8)</a> and is described in detail in <a href="execution.doc.html#44670">&#167;12.5</a>.<p>
<a name="23747"></a>
The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.<p>
<a name="252986"></a>
<h3>15.9.5    Anonymous Class Declarations</h3>
<a name="252987"></a>
An anonymous class declaration is automatically derived from a class instance creation expression by the compiler.<p>
<a name="252992"></a>
An anonymous class is never <code>abstract</code> <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a>. An anonymous class is always an inner class <a href="classes.doc.html#262890">(&#167;8.1.2)</a>; it is never <code>static</code> (<a href="classes.doc.html#21613">&#167;8.1.1</a>, <a href="classes.doc.html#246853">&#167;8.5.2</a>). An anonymous class is always implicitly <code>final</code> <a href="classes.doc.html#54727">(&#167;8.1.1.2)</a>.<p>
<a name="253002"></a>
<h4>15.9.5.1    Anonymous Constructors</h4>
<a name="253003"></a>
An anonymous class cannot have an explicitly declared constructor. Instead, the compiler must automatically provide an <i>anonymous constructor</i> for the anonymous class. The form of the anonymous constructor of an anonymous class <i>C</i> with direct superclass <i>S</i> is as follows:<p>
<ul><a name="253005"></a>
<li>If <i>S</i> is not an inner class, or if <i>S</i> is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression in which <i>C</i> is declared. The actual arguments to the class instance creation expression are used to determine a constructor <i>cs</i> of <i>S</i>, using the same rules as for method invocations <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <i>cs</i>. 
<a name="290200"></a>
The body of the constructor consists of an explicit constructor invocation <a href="classes.doc.html#229267">(&#167;8.8.5.1)</a> of the form <code>super</code>(...), where the actual arguments are the formal parameters of the constructor, in the order they were declared.<p>
<a name="253006"></a>
<li>Otherwise, the first formal parameter of the constructor of <i>C</i> represents the value of the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. The type of this parameter is the class type that immediately encloses the declaration of <i>S</i>. The constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class. The <i>n</i>th formal parameter <i>e</i> corresponds to the <i>n</i> - 1st actual argument. The actual arguments to the class instance creation expression are used to determine a constructor <i>cs</i> of <i>S</i>, using the same rules as for method invocations <a href="expressions.doc.html#20448">(&#167;15.12)</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <i>cs</i>. The body of the constructor consists of an explicit constructor invocation <a href="classes.doc.html#229267">(&#167;8.8.5.1)</a> of the form <i>o</i>.<code>super</code>(...), where <i>o</i> is the first formal parameter of the constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared.
</ul><a name="264352"></a>
In all cases, the throws clause of an anonymous constructor must list all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.<p>
<a name="289502"></a>
Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor <i>cs</i>). This does not, in itself, cause any errors at either compile time or run time.<p>
<a name="36687"></a>
<h3>15.9.6    Example: Evaluation Order and Out-of-Memory Detection</h3>
<a name="36695"></a>
If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. This check occurs before any argument expressions are evaluated.<p>
<a name="36696"></a>
So, for example, the test program:<p>
<blockquote><pre>class List {
	int value;
	List next;
	static List head = new List(0);
	List(int n) { value = n; next = head; head = this; }
}
class Test {
	public static void main(String[] args) {
		int id = 0, oldid = 0;
		try {
			for (;;) {
				++id;
				new List(oldid = id);
			}
		} catch (Error e) {
			System.out.println(e + ", " + (oldid==id));
		}
	}
}
</pre></blockquote><a name="36716"></a>
prints:<p>
<blockquote><pre>java.lang.OutOfMemoryError: List, false
</pre></blockquote><a name="36788"></a>
because the out-or-memory condition is detected before the argument expression <code>oldid</code> <code>=</code> <code>id</code> is evaluated.<p>
<a name="264357"></a>
Compare this to the treatment of array creation expressions <a href="expressions.doc.html#46168">(&#167;15.10)</a>, for which the out-of-memory condition is detected after evaluation of the dimension expressions <a href="expressions.doc.html#36736">(&#167;15.10.3)</a>.<p>
<a name="46168"></a>
<h2>15.10    Array Creation Expressions</h2>
<a name="46169"></a>
An array instance creation expression is used to create new arrays <a href="arrays.doc.html#27803">(&#167;10)</a>.<p>
<ul><pre>
<em>ArrayCreationExpression:
	</em>new<em> PrimitiveType DimExprs Dims<sub><i>opt
	</i></sub></em>new<em> TypeName DimExprs Dims<sub><i>opt
</i></sub>	</em>new<em> PrimitiveType Dims ArrayInitializer 
	</em>new<em> TypeName Dims ArrayInitializer
</em></pre></ul><a name="250757"></a>
<p>
<ul><pre>
<em>DimExprs:
	DimExpr
	DimExprs DimExpr

DimExpr:
	</em>[<em> Expression</em> ]<em>

Dims:
	</em>[ ]<em>
	Dims </em>[ ]
</pre></ul><a name="224310"></a>
An array creation expression creates an object that is a new array whose elements are of the type specified by the <em>PrimitiveType</em> or <em>TypeName</em>. The <em>TypeName</em> may name any named reference type, even an <code>abstract</code> class type <a href="classes.doc.html#34944">(&#167;8.1.1.1)</a> or an interface type <a href="interfaces.doc.html#238678">(&#167;9)</a>.<p>
<a name="264364"></a>
The type of the creation expression is an array type that can denoted by a copy of the creation expression from which the <code>new</code> keyword and every <em>DimExpr</em> expression and array initializer have been deleted.<p>
<a name="264361"></a>
For example, the type of the creation expression:<p>
<blockquote><pre>new double[3][3][]
</pre></blockquote><a name="224312"></a>
is:<p>
<blockquote><pre>double[][][]
</pre></blockquote><a name="23548"></a>
The type of each dimension expression within a <em>DimExpr</em> must be an integral type, or a compile-time error occurs. Each expression undergoes unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a>. The promoted type must be <code>int</code>, or a compile-time error occurs; this means, specifically, that the type of a dimension expression must not be <code>long</code>.<p>
<a name="260981"></a>
If an array initializer is provided, the newly allocated array will be initialized with the values provided by the array initializer as described in <a href="arrays.doc.html#11358">&#167;10.6</a>.<p>
<a name="23605"></a>
<h3>15.10.1    Run-time Evaluation of Array Creation Expressions</h3>
<a name="36668"></a>
At run time, evaluation of an array creation expression behaves as follows. If there are no dimension expressions, then there must be an array initializer. The value of the array initializer is the value of the array creation expression. Otherwise:<p>
<a name="23552"></a>
First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.<p>
<a name="23543"></a>
Next, the values of the dimension expressions are checked. If the value of any <em>DimExpr</em> expression is less than zero, then an <code>NegativeArraySizeException</code> is thrown.<p>
<a name="36922"></a>
Next, space is allocated for the new array. If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an <code>OutOfMemoryError</code>.<p>
<a name="23658"></a>
Then, if a single <em>DimExpr</em> appears, a single-dimensional array is created of the specified length, and each component of the array is initialized to its default value <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>.<p>
<a name="264375"></a>
If an array creation expression contains <em>N</em> <em>DimExpr</em> expressions, then it effectively executes a set of nested loops of depth <em>N</em> - 1 to create the implied arrays of arrays. <p>
<a name="264373"></a>
For example, the declaration:<p>
<blockquote><pre><code>float[][] matrix = new float[3][3];
</code></pre></blockquote><a name="23642"></a>
is equivalent in behavior to:<p>
<blockquote><pre>float[][] matrix = new float[3][];
for (int <em>d</em> = 0; <em>d</em> &lt; matrix.length; <em>d</em>++)
	matrix[<em>d</em>] = new float[3];
</pre></blockquote><a name="23645"></a>
and:<p>
<blockquote><pre>Age[][][][][] Aquarius = new Age[6][10][8][12][];
</pre></blockquote><a name="23647"></a>
is equivalent to:<p>
<blockquote><pre>Age[][][][][] Aquarius = new Age[6][][][][];
for (int <em>d1</em> = 0; <em>d1</em> &lt; Aquarius.length; <em>d1</em>++) {
	Aquarius[<em>d1</em>] = new Age[10][][][];
	for (int <em>d2</em> = 0; <em>d2</em> &lt; Aquarius[<em>d1</em>].length; <em>d2</em>++) {
		Aquarius[<em>d1</em>][<em>d2</em>] = new Age[8][][];
		for (int <em>d3</em> = 0; <em>d3</em> &lt; Aquarius[<em>d1</em>][<em>d2</em>].length; <em>d3</em>++) {
			Aquarius[<em>d1</em>][<em>d2</em>][<em>d3</em>] = new Age[12][];
		}
	}
}
</pre></blockquote><a name="36995"></a>
with <i>d,</i> <i>d1</i>, <i>d2</i> and <i>d3</i> replaced by names that are not already locally declared. Thus, a single <code>new</code> expression actually creates one array of length 6, 6 arrays of length 10, 6 x 10 = 60 arrays of length 8, and 6 x 10 x 8 = 480 arrays of length 12. This example leaves the fifth dimension, which would be arrays containing the actual array elements (references to <code>Age</code> objects), initialized only to null references. These arrays can be filled in later by other code, such as:<p>
<blockquote><pre>Age[] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius[1][9][6][9] = Hair;
<a name="264386"></a>
A multidimensional array need not have arrays of the same length at each level. <p>
<a name="264384"></a>
Thus, a triangular matrix may be created by:<p>
float triang[][] = new float[100][];
for (int i = 0; i &lt; triang.length; i++)
	triang[i] = new float[i+1];
</pre></blockquote><a name="286280"></a>
<h3>15.10.2    Example: Array Creation Evaluation Order</h3>
<a name="264396"></a>
In an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>, there may be one or more dimension expressions, each within brackets. Each dimension expression is fully evaluated before any part of any dimension expression to its right.<p>
<a name="23510"></a>
Thus:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int i = 4;
		int ia[][] = new int[i][i=3];
		System.out.println(
			"[" + ia.length + "," + ia[0].length + "]");
	}
}
</pre></blockquote><a name="23519"></a>
prints:<p>
<blockquote><pre>[4,3]
</pre></blockquote><a name="23521"></a>
because the first dimension is calculated as <code>4</code> before the second dimension expression sets <code>i</code> to <code>3</code>.<p>
<a name="23522"></a>
If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated. Thus, the example: <p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[][] a = { { 00, 01 }, { 10, 11 } };
		int i = 99;
		try {
			a[val()][i = 1]++;
		} catch (Exception e) {
			System.out.println(e + ", i=" + i);
		}
	}
	static int val() throws Exception {
		throw new Exception("unimplemented");
	}
}
</pre></blockquote><a name="23536"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: unimplemented, i=99
</pre></blockquote><a name="23538"></a>
because the embedded assignment that sets <code>i</code> to <code>1</code> is never executed.<p>
<a name="36736"></a>
<h3>15.10.3    Example: Array Creation and Out-of-Memory Detection</h3>
<a name="36885"></a>
If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. This check occurs only after evaluation of all dimension expressions has completed normally. <p>
<a name="36744"></a>
So, for example, the test program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int len = 0, oldlen = 0;
		Object[] a = new Object[0];
		try {
			for (;;) {
				++len;
				Object[] temp = new Object[oldlen = len];
				temp[0] = a;
				a = temp;
			}
		} catch (Error e) {
			System.out.println(e + ", " + (oldlen==len));
		}
	}
}
</pre></blockquote><a name="36764"></a>
prints:<p>
<blockquote><pre>java.lang.OutOfMemoryError, true
</pre></blockquote><a name="36901"></a>
because the out-of-memory condition is detected after the dimension expression <code>oldlen</code> = <code>len</code> is evaluated.<p>
<a name="264401"></a>
Compare this to class instance creation expressions <a href="expressions.doc.html#41147">(&#167;15.9)</a>, which detect the out-of-memory condition before evaluating argument expressions <a href="expressions.doc.html#36687">(&#167;15.9.6)</a>.<p>
<a name="41267"></a>
<h2>15.11    Field Access Expressions</h2>
<a name="37024"></a>
A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword <code>super</code>. (It is also possible to refer to a field of the current instance or current class by using a simple name; see <a href="names.doc.html#21650">&#167;6.5.6</a>.)<p>
<ul><pre>
<em>FieldAccess: 
	Primary . Identifier
	</em>super<em> . Identifier
	ClassName .</em>super<em> . Identifier
</em></pre></ul><a name="37051"></a>
The meaning of a field access expression is determined using the same rules as for qualified names <a href="names.doc.html#104285">(&#167;6.6)</a>, but limited by the fact that an expression cannot denote a package, class type, or interface type.<p>
<a name="37055"></a>
<h3>15.11.1    Field Access Using a Primary</h3>
<a name="37056"></a>
The type of the <em>Primary</em> must be a reference type <i>T</i>, or a compile-time error occurs. The meaning of the field access expression is determined as follows:<p>
<ul><a name="20394"></a>
<li>If the identifier names several accessible member fields of type <i>T</i>, then the field access is ambiguous and a compile-time error occurs.
<a name="37075"></a>
<li>If the identifier does not name an accessible member field of type <i>T</i>, then the field access is undefined and a compile-time error occurs.
<a name="20398"></a>
<li>Otherwise, the identifier names a single accessible member field of type <i>T</i> and the type of the field access expression is the declared type of the field. At run time, the result of the field access expression is computed as follows:
<ul>
<a name="37316"></a>
<li>If the field is <code>static</code>:
<ul>
<a name="37335"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified class variable in the class or interface that is the type of the <em>Primary</em> expression.
<a name="37336"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified class variable in the class that is the type of the <em>Primary</em> expression.
</ul>
<a name="37320"></a>
<li>If the field is not <code>static</code>:
<ul>
<a name="37110"></a>
<li>If the value of the <em>Primary</em> is <code>null</code>, then a <code>NullPointerException</code> is thrown.
<a name="20427"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified instance variable in the object referenced by the value of the <em>Primary</em>.
<a name="264406"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified instance variable in the object referenced by the value of the <em>Primary</em>.
</ul>
</ul>
</ul><a name="37135"></a>
Note, specifically, that only the type of the <em>Primary</em> expression, not the class of the actual object referred to at run time, is used in determining which field to use.<p>
<a name="21262"></a>
Thus, the example:<p>
<blockquote><pre>class S { int x = 0; }
class T extends S { int x = 1; }
class Test {
	public static void main(String[] args) {
		T t = new T();
		System.out.println("t.x=" + t.x + when("t", t));
		S s = new S();
		System.out.println("s.x=" + s.x + when("s", s));
		s = t;
		System.out.println("s.x=" + s.x + when("s", s));
	}
	static String when(String name, Object t) {
		return " when " + name + " holds a "
			+ t.getClass() + " at run time.";
	}
}
</pre></blockquote><a name="20906"></a>
produces the output:<p>
<blockquote><pre>t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class S at run time.
s.x=0 when s holds a class T at run time.
</pre></blockquote><a name="45446"></a>
The last line shows that, indeed, the field that is accessed does not depend on the run-time class of the referenced object; even if <code>s</code> holds a reference to an object of class <code>T</code>, the expression <code>s.x</code> refers to the <code>x</code> field of class <code>S</code>, because the type of the expression <code>s</code> is <code>S</code>. Objects of class <code>T</code> contain two fields named <code>x</code>, one for class <code>T</code> and one for its superclass <code>S</code>.<p>
<a name="22264"></a>
This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations. The power of late binding and overriding is available in, but only when instance methods are used. Consider the same example using instance methods to access the fields:<p>
<blockquote><pre>class S { int x = 0; int z() { return x; } }
class T extends S { int x = 1; int z() { return x; } }
class Test {
	public static void main(String[] args) {
		T t = new T();
		System.out.println("t.z()=" + t.z() + when("t", t));
		S s = new S();
		System.out.println("s.z()=" + s.z() + when("s", s));
		s = t;
		System.out.println("s.z()=" + s.z() + when("s", s));
	}
	static String when(String name, Object t) {
		return " when " + name + " holds a "
			+ t.getClass() + " at run time.";
	}
}
</pre></blockquote><a name="238134"></a>
Now the output is:<p>
<blockquote><pre>t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class S at run time.
s.z()=1 when s holds a class T at run time.
</pre></blockquote><a name="37254"></a>
The last line shows that, indeed, the method that is accessed <em>does</em> depend on the run-time class of referenced object; when <code>s</code> holds a reference to an object of class <code>T</code>, the expression <code>s.z()</code> refers to the <code>z</code> method of class <code>T</code>, despite the fact that the type of the expression <code>s</code> is <code>S</code>. Method <code>z</code> of class <code>T</code> overrides method <code>z</code> of class <code>S</code>.<p>
<a name="22234"></a>
The following example demonstrates that a null reference may be used to access a class (<code>static</code>) variable without causing an exception:<p>
<blockquote><pre>class Test {
	static String mountain = "Chocorua";
	static Test favorite(){
		System.out.print("Mount ");
		return null;
	}
	public static void main(String[] args) {
		System.out.println(favorite().mountain);
	}
}
</pre></blockquote><a name="22242"></a>
It compiles, executes, and prints:<p>
<blockquote><pre>Mount Chocorua
</pre></blockquote>
<a name="264411"></a>
Even though the result of <code>favorite()</code> is <code>null</code>, a <code>NullPointerException</code> is <em>not</em> thrown. That "<code>Mount </code>" is printed demonstrates that the <em>Primary</em> expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field <code>mountain</code> is <code>static</code>).<p>
<a name="20860"></a>
<h3>15.11.2    Accessing Superclass Members using <code>super</code></h3>
<a name="20451"></a>
The special forms using the keyword <code>super</code> are valid only in an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class; these are exactly the same situations in which the keyword <code>this</code> may be used <a href="expressions.doc.html#251519">(&#167;15.8.3)</a>. The forms involving <code>super</code> may not be used anywhere in the class <code>Object</code>, since <code>Object</code> has no superclass; if <code>super</code> appears in class <code>Object</code>, then a compile-time error results.<p>
<a name="264416"></a>
Suppose that a field access expression <code>super.</code><i>name</i> appears within class <i>C</i>, and the immediate superclass of <i>C</i> is class <i>S</i>. Then <code>super.</code><i>name</i> is treated exactly as if it had been the expression <code>((</code><i>S</i><code>)this).</code><i>name</i>; thus, it refers to the field named <i>name</i> of the current object, but with the current object viewed as an instance of the superclass. Thus it can access the field named <i>name</i> that is visible in class <i>S</i>, even if that field is hidden by a declaration of a field named <i>name</i> in class <i>C</i>.<p>
<a name="20763"></a>
The use of <code>super</code> is demonstrated by the following example:<p>
<blockquote><pre>interface I { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1 { int x = 2; }
class T3 extends T2 {
	int x = 3;
	void test() {
		System.out.println("x=\t\t"+x);
		System.out.println("super.x=\t\t"+super.x);
		System.out.println("((T2)this).x=\t"+((T2)this).x);
		System.out.println("((T1)this).x=\t"+((T1)this).x);
		System.out.println("((I)this).x=\t"+((I)this).x);
	}
}
class Test {
	public static void main(String[] args) {
		new T3().test();
	}
}
</pre></blockquote><a name="20520"></a>
which produces the output:<p>
<blockquote><pre>x=					3
super.x=					2
((T2)this).x=					2
((T1)this).x=					1
((I)this).x=					0
</pre></blockquote><a name="37491"></a>
Within class <code>T3</code>, the expression <code>super.x</code> is treated exactly as if it were:<p>
<blockquote><pre><code>((T2)this).x</code>
</pre></blockquote><a name="251555"></a>
Suppose that a field access expression <code>T.super</code>.<i>name</i> appears within class <i>C</i>, and the immediate superclass of the class denoted by <i>T</i> is a class whose fully qualified name is <i>S</i>. Then <code>T.super</code>.<i>name</i> is treated exactly as if it had been the expression ((<i>S</i>)<code>T.this</code>).<i>name</i>. <p>
<a name="253969"></a>
Thus the expression <code>T.super</code>.<i>name</i> can access the field named name that is visible in the class named by <i>S</i>, even if that field is hidden by a declaration of a field named name in the class named by <i>T</i>.<p>
<a name="253972"></a>
It is a compile-time error if the class denoted by <i>T </i>is not a lexically enclosing class of the current class.<p>
<a name="20448"></a>
<h2>15.12    Method Invocation Expressions</h2>
<a name="37518"></a>
A method invocation expression is used to invoke a class or instance method.<p>
<ul><pre>
<em>MethodInvocation:
	MethodName ( ArgumentList<sub><i>opt</i></sub> )
	Primary . Identifier ( ArgumentList<sub><i>opt</i></sub> )
	</em>super<em> . Identifier ( ArgumentList<sub><i>opt</i></sub> )
	ClassName .</em> super<em> . Identifier ( ArgumentList<sub>opt</sub> )
</em></pre></ul><a name="8506"></a>
The definition of <em>ArgumentList</em> from <a href="expressions.doc.html#41147">&#167;15.9</a> is repeated here for convenience:<p>
<ul><pre>
<em>ArgumentList:
	Expression
	ArgumentList , Expression
</em></pre></ul>
<a name="264431"></a>
Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading. Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.<p>
</pre></ul><a name="38751"></a>
Determining the method that will be invoked by a method invocation expression involves several steps. The following three sections describe the compile-time processing of a method invocation; the determination of the type of the method invocation expression is described in <a href="expressions.doc.html#23617">&#167;15.12.3</a>.<p>
<a name="21692"></a>
<h3>15.12.1    Compile-Time Step 1: Determine Class or Interface to Search</h3>
<a name="37532"></a>
The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to check for definitions of methods of that name. There are several cases to consider, depending on the form that precedes the left parenthesis, as follows:<p>
<ul><a name="37552"></a>
<li>If the form is <em>MethodName</em>, then there are three subcases:
<ul>
<a name="37575"></a>
<li>If it is a simple name, that is, just an <em>Identifier</em>, then the name of the method is the <em>Identifier</em>. If the <i>Identifier</i> appears within the scope <a href="names.doc.html#103228">(&#167;6.3)</a> of a visible method declaration with that name, then there must be an enclosing type declaration of which that method is a member. Let <i>T</i> be the innermost such type declaration. The class or interface to search is <i>T</i>.
<a name="37556"></a>
<li>If it is a qualified name of the form <em>TypeName</em> <code>.</code> <em>Identifier</em>, then the name of the method is the <em>Identifier</em> and the class to search is the one named by the <em>TypeName</em>. If <em>TypeName</em> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code>static</code> methods and interfaces have no <code>static</code> methods.
<a name="37591"></a>
<li>In all other cases, the qualified name has the form <em>FieldName</em> <code>.</code> <em>Identifier</em>; then the name of the method is the <em>Identifier</em> and the class or interface to search is the declared type of the field named by the <em>FieldName</em>.
</ul>
<a name="37589"></a>
<li>If the form is <em>Primary</em> <code>.</code> <em>Identifier</em>, then the name of the method is the <em>Identifier</em> &#32;and the class or interface to be searched is the type of the <em>Primary</em> expression.
<a name="37600"></a>
<li>If the form is <code>super</code> <code>.</code> <em>Identifier</em>, then the name of the method is the <em>Identifier</em> and the class to be searched is the superclass of the class whose declaration contains the method invocation. Let <i>T</i> be the type declaration immediately enclosing the method invocation. It is a compile-time error if any of the following situations occur:
<ul>
<a name="256960"></a>
<li><i>T</i> is the class <code>Object</code>.
<a name="289724"></a>
<li><i>T</i> is an interface.
</ul>
<a name="289785"></a>
<li>If the form is ClassName.super . Identifier, then the name of the method is the Identifier and the class to be searched is the superclass of the class C denoted by ClassName. It is a compile-time error if C is not a lexically enclosing class of the current class. It is a compile-time error if C is the class Object. Let T be the type declaration immediately enclosing the method invocation. It is a compile-time error if any of the following situations occur:
<ul>
<a name="256987"></a>
<li><i>T</i> is the class Object.
<a name="289900"></a>
<li><i>T</i> is an interface.
</ul>
</ul><a name="289905"></a>
<h3>15.12.2    Compile-Time Step 2: Determine Method Signature</h3>
<a name="19915"></a>
The second step searches the class or interface determined in the previous step for method declarations. This step uses the name of the method and the types of the argument expressions to locate method declarations that are both <em>applicable</em> and <em>accessible</em>, that is, declarations that can be correctly invoked on the given arguments. There may be more than one such method declaration, in which case the <em>most specific</em> one is chosen. The descriptor (signature plus return type) of the most specific method declaration is one used at run time to do the method dispatch.<p>
<a name="18427"></a>
<h4>15.12.2.1    Find Methods that are Applicable and Accessible</h4>
<a name="21818"></a>
A method declaration is <em>applicable</em> to a method invocation if and only if both of the following are true:<p>
<ul><a name="37650"></a>
<li>The number of parameters in the method declaration equals the number of argument &#32;expressions in the method invocation.
<a name="37653"></a>
<li>The type of each actual argument can be converted by method invocation conversion <a href="conversions.doc.html#12687">(&#167;5.3)</a> to the type of the corresponding parameter. Method invocation conversion is the same as assignment conversion <a href="conversions.doc.html#184206">(&#167;5.2)</a>, except that constants of type <code>int</code> are never implicitly narrowed to <code>byte</code>, <code>short</code>, or <code>char</code>.
</ul><a name="21702"></a>
The class or interface determined by the process described in <a href="expressions.doc.html#21692">&#167;15.12.1</a> is searched for all method declarations applicable to this method invocation; method definitions inherited from superclasses and superinterfaces are included in this search.<p>
<a name="37690"></a>
Whether a method declaration is <em>accessible </em><a href="names.doc.html#104285">(&#167;6.6)</a> at a method invocation depends on the access modifier (<code>public</code>, none, <code>protected</code>, or <code>private</code>) in the method declaration and on where the method invocation appears.<p>
<a name="264456"></a>
If the class or interface has no method declaration that is both applicable and accessible, then a compile-time error occurs.<p>
<a name="37720"></a>
In the example program:<p>
<blockquote><pre>public class Doubler {
	static int two() { return two(1); }
	private static int two(int i) { return 2*i; }
}
class Test extends Doubler {	
	public static long two(long j) {return j+j; }
	public static void main(String[] args) {
		System.out.println(two(3));
		System.out.println(Doubler.two(3)); // compile-time error
	}
}
</pre></blockquote><a name="37704"></a>
for the method invocation <code>two(1)</code> within class <code>Doubler</code>, there are two accessible methods named <code>two</code>, but only the second one is applicable, and so that is the one invoked at run time. For the method invocation <code>two(3)</code> within class <code>Test</code>, there are two applicable methods, but only the one in class <code>Test</code> is accessible, and so that is the one to be invoked at run time (the argument <code>3</code> is converted to type <code>long</code>). For the method invocation <code>Doubler.two(3)</code>, the class <code>Doubler</code>, not class <code>Test</code>, is searched for methods named <code>two</code>; the only applicable method is not accessible, and so this method invocation causes a compile-time error.<p>
<a name="21942"></a>
Another example is:<p>
<blockquote><pre>class ColoredPoint {
	int x, y;
	byte color;
	void setColor(byte color) { this.color = color; }
}
class Test {
	public static void main(String[] args) {
		ColoredPoint cp = new ColoredPoint();
		byte color = 37;
		cp.setColor(color);
		cp.setColor(37);											// compile-time error
	}
}
</pre></blockquote><a name="21881"></a>
Here, a compile-time error occurs for the second invocation of <code>setColor</code>, because no applicable method can be found at compile time. The type of the literal <code>37</code> is <code>int</code>, and <code>int</code> cannot be converted to <code>byte</code> by method invocation conversion. Assignment conversion, which is used in the initialization of the variable <code>color</code>, performs an implicit conversion of the constant from type <code>int</code> to <code>byte</code>, which is permitted because the value <code>37</code> is small enough to be represented in type <code>byte</code>; but such a conversion is not allowed for method invocation conversion.<p>
<a name="21968"></a>
If the method <code>setColor</code> had, however, been declared to take an <code>int</code> instead of a <code>byte</code>, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from <code>byte</code> to <code>int</code>. However, a narrowing cast would then be required in the body of <code>setColor</code>:<p>
<blockquote><pre>	void setColor(int color) { this.color = (byte)color; }
</pre></blockquote><a name="18428"></a>
<h4>15.12.2.2    Choose the Most Specific Method</h4>
<a name="272863"></a>
If more than one method declaration is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the <em>most specific</em> method is chosen.<p>
<a name="272868"></a>
The informal intuition is that one method declaration is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.<p>
<a name="272869"></a>
The precise definition is as follows. Let <i>m</i> be a name and suppose that there are two declarations of methods named <i>m</i>, each having <i>n</i> parameters. Suppose that one declaration appears within a class or interface <i>T</i> and that the types of the parameters are <i>T1</i>,&#32;. . . ,&#32;<i>Tn</i>; suppose moreover that the other declaration appears within a class or interface <i>U</i> and that the types of the parameters are <i>U1</i>, . . . ,&#32;<i>Un</i>. Then the method <i>m</i> declared in <i>T</i> is <em>more specific</em> than the method <i>m</i> declared in <i>U</i> if and only if both of the following are true:<p>
<ul><a name="37872"></a>
<li><i>T</i> can be converted to <i>U</i> by method invocation conversion.
<a name="37876"></a>
<li><i>Tj</i> can be converted to <i>Uj</i> by method invocation conversion, for all <i>j</i> from <code>1</code> to <i>n</i>.
</ul><a name="37912"></a>
A method is said to be <em>maximally specific</em> for a method invocation if it is applicable and accessible and there is no other applicable and accessible method that is more specific.<p>
<a name="37937"></a>
If there is exactly one maximally specific method, then it is in fact <em>the most specific</em> method; it is necessarily more specific than any other method that is applicable and accessible. It is then subjected to some further compile-time checks as described in <a href="expressions.doc.html#23617">&#167;15.12.3</a>.<p>
<a name="264476"></a>
It is possible that no method is the most specific, because there are two or more maximally specific methods. In this case:<p>
<ul><a name="289532"></a>
<li>If all the maximally specific methods have the same signature, then:
<ul>
<a name="289533"></a>
<li>If one of the maximally specific methods is not declared <code>abstract</code>, it is the most specific method.
<a name="289534"></a>
<li>Otherwise, all the maximally specific methods are necessarily declared <code>abstract</code>. The most specific method is chosen arbitrarily among the maximally specific methods. However, the most specific method is considered to throw a checked exception if and only if that exception is declared in the <code>throws</code> clauses of each of the maximally specific methods.
</ul>
<a name="289531"></a>
<li>Otherwise, we say that the method invocation is <em>ambiguous</em>, and a compile-time error occurs.
</ul><a name="21711"></a>
<h4>15.12.2.3    Example: Overloading Ambiguity</h4>
<a name="21712"></a>
Consider the example:<p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }

class Test {
	static void test(ColoredPoint p, Point q) {
		System.out.println("(ColoredPoint, Point)");
	}
	static void test(Point p, ColoredPoint q) {
		System.out.println("(Point, ColoredPoint)");
	}
	public static void main(String[] args) {
		ColoredPoint cp = new ColoredPoint();
		test(cp, cp);											// compile-time error
	}
}
</pre></blockquote><a name="21726"></a>
This example produces an error at compile time. The problem is that there are two declarations of <code>test</code> that are applicable and accessible, and neither is more specific than the other. Therefore, the method invocation is ambiguous.<p>
<a name="38010"></a>
If a third definition of <code>test</code> were added:<p>
<blockquote><pre>	static void test(ColoredPoint p, ColoredPoint q) {
		System.out.println("(ColoredPoint, ColoredPoint)");
	}
</pre></blockquote><a name="38011"></a>
then it would be more specific than the other two, and the method invocation would no longer be ambiguous.<p>
<a name="21727"></a>
<h4>15.12.2.4    Example: Return Type Not Considered</h4>
<a name="21728"></a>
As another example, consider:<p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
	static int test(ColoredPoint p) {
		return p.color;
	}
	static String test(Point p) {
		return "Point";
	}
	public static void main(String[] args) {
		ColoredPoint cp = new ColoredPoint();
		String s = test(cp);											// compile-time error
	}
}
</pre></blockquote><a name="21743"></a>
Here the most specific declaration of method <code>test</code> is the one taking a parameter of type <code>ColoredPoint</code>. Because the result type of the method is <code>int</code>, a compile-time error occurs because an <code>int</code> cannot be converted to a <code>String</code> by assignment conversion. This example shows that the result types of methods do not participate in resolving overloaded methods, so that the second <code>test</code> method, which returns a <code>String</code>, is not chosen, even though it has a result type that would allow the example program to compile without error.<p>
<a name="29775"></a>
<h4>15.12.2.5    Example: Compile-Time Resolution</h4>
<a name="30681"></a>
The most applicable method is chosen at compile time; its descriptor determines what method is actually executed at run time. If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen.<p>
<a name="30687"></a>
So, for example, consider two compilation units, one for class <code>Point</code>:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public Point(int x, int y) { this.x = x; this.y = y; }
	public String toString() { return toString(""); }
	public String toString(String s) {
		return "(" + x + "," + y + s + ")";
	}
}
</pre></blockquote><a name="30799"></a>
and one for class <code>ColoredPoint</code>:<p>
<blockquote><pre>package points;
public class ColoredPoint extends Point {
	public static final int
		RED = 0, GREEN = 1, BLUE = 2;
	public static String[] COLORS =
		{ "red", "green", "blue" };
	public byte color;
	public ColoredPoint(int x, int y, int color) {
		super(x, y); this.color = (byte)color;
	}
	/** Copy all relevant fields of the argument into
		 &#32; &#32;this <code>ColoredPoint</code> object. */
	public void adopt(Point p) { x = p.x; y = p.y; }
	public String toString() {
		String s = "," + COLORS[color];
		return super.toString(s);
	}
}
</pre></blockquote><a name="30815"></a>
Now consider a third compilation unit that uses <code>ColoredPoint</code>:<p>
<blockquote><pre>import points.*;
class Test {
	public static void main(String[] args) {
		ColoredPoint cp =
			new ColoredPoint(6, 6, ColoredPoint.RED);
		ColoredPoint cp2 =
			new ColoredPoint(3, 3, ColoredPoint.GREEN);
		cp.adopt(cp2);
		System.out.println("cp: " + cp);
	}
}
</pre></blockquote><a name="30754"></a>
The output is:<p>
<blockquote><pre>cp: (3,3,red)
</pre></blockquote>
<a name="30756"></a>
The application programmer who coded class <code>Test</code> has expected to see the word <code>green</code>, because the actual argument, a <code>ColoredPoint</code>, has a <code>color</code> field, and <code>color</code> would seem to be a "relevant field" (of course, the documentation for the package <code>Points</code> ought to have been much more precise!).<p>
<a name="38120"></a>
Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of <code>adopt</code> has a signature that indicates a method of one parameter, and the parameter is of type <code>Point</code>. This signature becomes part of the binary representation of class <code>Test</code> produced by the compiler and is used by the method invocation at run time.<p>
<a name="38098"></a>
Suppose the programmer reported this software error and the maintainer of the <code>points</code> package decided, after due deliberation, to correct it by adding a method to class <code>ColoredPoint</code>:<p>
<blockquote><pre>
public void adopt(ColoredPoint p) {
	adopt((Point)p); color = p.color;
}
</pre></blockquote>
<a name="239516"></a>
If the application programmer then runs the old binary file for <code>Test</code> with the new binary file for <code>ColoredPoint</code>, the output is still:<p>
<blockquote><pre>
cp: (3,3,red)
</pre></blockquote><a name="38138"></a>
because the old binary file for <code>Test</code> still has the descriptor "one parameter, whose type is <code>Point</code>; <code>void</code>" associated with the method call <code>cp.adopt(cp2)</code>. If the source code for <code>Test</code> is recompiled, the compiler will then discover that there are now two applicable <code>adopt</code> methods, and that the signature for the more specific one is "one parameter, whose type is <code>ColoredPoint</code>; <code>void</code>"; running the program will then produce the desired output:<p>
<blockquote><pre>cp: (3,3,green)
</pre></blockquote>
<a name="30865"></a>
With forethought about such problems, the maintainer of the <code>points</code> package could fix the <code>ColoredPoint</code> class to work with both newly compiled and old code, by adding defensive code to the old <code>adopt</code> method for the sake of old code that still invokes it on <code>ColoredPoint</code> arguments:<p>
<blockquote><pre>
public void adopt(Point p) {
	if (p instanceof ColoredPoint)
		color = ((ColoredPoint)p).color;
	x = p.x; y = p.y;
}
</pre></blockquote>
<a name="264481"></a>
Ideally, source code should be recompiled whenever code that it depends on is changed. However, in an environment where different classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See <a href="binaryComp.doc.html#44871">&#167;13</a> for a detailed discussion of binary compatibility and type evolution.<p>
<a name="23617"></a>
<h3>15.12.3    Compile-Time Step 3: Is the Chosen Method Appropriate?</h3>
<a name="23618"></a>
If there is a most specific method declaration for a method invocation, it is called the <em>compile-time declaration</em> for the method invocation. Three further checks must be made on the compile-time declaration:<p>
<ul><a name="289578"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the &#32;form <em>Identifier</em>, and the method is an instance method, then:
<ul>
<a name="289583"></a>
<li>If the invocation appears within a static context <a href="classes.doc.html#262890">(&#167;8.1.2)</a>, then a compile-time error occurs. (The reason is that a method invocation of this form cannot be used to invoke an instance method in places where <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a> is not defined.)
<a name="289594"></a>
<li>Otherwise, let <i>C</i> be the innermost enclosing class of which the method is a member. If the invocation is not directly enclosed by <i>C</i> or an inner class of <i>C</i>, then a compile-time error occurs
</ul>
<a name="21464"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the &#32;form <em>TypeName</em> <code>.</code> <em>Identifier</em>, then the compile-time declaration should be <code>static</code>. If the compile-time declaration for the method invocation is for an instance &#32;method, then a compile-time error occurs. (The reason is that a method invocation of this form does not specify a reference to an object that can serve as <code>this</code> within the instance method.)
<a name="289655"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the form <code>super</code> . <i>Identifier</i>, then:
<ul>
<a name="289657"></a>
<li>If the method is <code>abstract</code>, a compile-time error occurs
<a name="289632"></a>
<li>If the method invocation occurs in a static context, a compile-time error occurs
</ul>
<a name="289639"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the form <i>ClassName</i>.<code>super</code> . <i>Identifier</i>, then: 
<ul>
<a name="289662"></a>
<li>If the method is <code>abstract</code>, a compile-time error occurs
<a name="289663"></a>
<li>If the method invocation occurs in a static context, a compile-time error occurs
<a name="289672"></a>
<li>Otherwise, let <i>C</i> be the class denoted by <i>ClassName</i>. If the invocation is not directly enclosed by <i>C</i> or an inner class of <i>C</i>, then a compile-time error occurs
</ul>
<a name="289640"></a>
<li>If the compile-time declaration for the method invocation is <code>void</code>, then the method invocation must be a top-level expression, that is, the <em>Expression</em> in an expression statement <a href="statements.doc.html#5984">(&#167;14.8)</a> or in the <em>ForInit</em> or <em>ForUpdate</em> part of a <code>for</code> statement <a href="statements.doc.html#24588">(&#167;14.13)</a>, or a compile-time error occurs. (The reason is that such a method invocation produces no value and so must be used only in a situation where a value is not needed.)
</ul><a name="38703"></a>
The following compile-time information is then associated with the method invocation for use at run time:<p>
<ul><a name="38709"></a>
<li>The name of the method.
<a name="250715"></a>
<li>The qualifying type of the method invocation <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>.
<a name="38716"></a>
<li>The number of parameters and the types of the parameters, in order.
<a name="38717"></a>
<li>The result type, or <code>void</code>, as declared in the compile-time declaration.
<a name="38712"></a>
<li>The invocation mode, computed as follows:
<ul>
<a name="38723"></a>
<li>If the compile-time declaration has the <code>static</code> modifier, then the invocation mode is <code>static</code>.
<a name="43892"></a>
<li>Otherwise, if the compile-time declaration has the <code>private</code> modifier, then the invocation mode is <code>nonvirtual</code>.
<a name="262784"></a>
<li>Otherwise, if the part of the method invocation before the left parenthesis is of the form <code>super</code> <code>.</code> <em>Identifier</em> or of the form ClassName.super.Identifier<em> </em>then the invocation mode is <code>super</code>.
<a name="38796"></a>
<li>Otherwise, if the compile-time declaration is in an interface, then the invocation mode is <code>interface</code>. 
<a name="38732"></a>
<li>Otherwise, the invocation mode is <code>virtual</code>.
</ul>
</ul><a name="38220"></a>
If the compile-time declaration for the method invocation is not <code>void</code>, then the type of the method invocation expression is the result type specified in the compile-time declaration.<p>
<a name="45677"></a>
<h3>15.12.4    Runtime Evaluation of Method Invocation</h3>
<a name="45678"></a>
At run time, method invocation requires five steps. First, a <em>target reference</em> may be computed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the method to be executed is located. Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code.<p>
<a name="38359"></a>
<h4>15.12.4.1    Compute Target Reference (If Necessary)</h4>
<a name="38338"></a>
There are several cases to consider, depending on which of the four productions for <em>MethodInvocation</em> <a href="expressions.doc.html#20448">(&#167;15.12)</a> is involved:<p>
<ul><a name="239420"></a>
<li>If the first production for <em>MethodInvocation</em>, which includes a <em>MethodName</em>, is involved, then there are three subcases:
<ul>
<a name="239421"></a>
<li>If the <em>MethodName</em> is a simple name, that is, just an <em>Identifier</em>, then there are two subcases:
<ul>
<a name="38362"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="267467"></a>
<li>Otherwise, let <i>T</i> be the enclosing type declaration of which the method is a member, and let <em>n</em> be an integer such that <i>T</i> is the <em>n</em>th lexically enclosing type declaration <a href="classes.doc.html#262890">(&#167;8.1.2)</a> of the class whose declaration immediately contains the method invocation. Then the target reference is the <em>n</em>th lexically enclosing instance <a href="classes.doc.html#262890">(&#167;8.1.2)</a> of <code>this</code>. It is a compile-time error if the <em>n</em>th lexically enclosing instance <a href="classes.doc.html#262890">(&#167;8.1.2)</a> of <code>this</code> does not exist.
</ul>
<a name="38341"></a>
<li>If the <em>MethodName</em> is a qualified name of the form <em>TypeName</em> <code>.</code> <em>Identifier</em>, then there is no target reference.
<a name="38805"></a>
<li>If the <em>MethodName</em> is a qualified name of the form <em>FieldName</em> <code>.</code> <em>Identifier</em>, then there are two subcases:
<ul>
<a name="38806"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="38807"></a>
<li>Otherwise, the target reference is the value of the expression <em>FieldName</em>.
</ul>
</ul>
<a name="38815"></a>
<li>If the second production for <em>MethodInvocation</em>, which includes a <em>Primary</em>, is involved, then there are two subcases:
<ul>
<a name="38816"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference. The expression <em>Primary </em>is evaluated, but the result is then discarded.
<a name="38817"></a>
<li>Otherwise, the expression <em>Primary </em>is evaluated and the result is used as the target reference.
</ul>
</ul><ul><a name="38346"></a>
In either case, if the evaluation of the <em>Primary</em> expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
</ul><ul><a name="38347"></a>
<li>If the third production for <em>MethodInvocation</em>, which includes the keyword <code>super</code>, is involved, then the target reference is the value of <code>this</code>.
<a name="251575"></a>
<li>If the fourth production for MethodInvocation, <em>ClassName</em>.super, is involved, then the target reference is the value of <em>ClassName</em>.this.
</ul><a name="45449"></a>
<h4>15.12.4.2    Evaluate Arguments</h4>
<a name="21593"></a>
The argument expressions are evaluated in order, from left to right. If the evaluation of any argument expression completes abruptly, then no part of any argument expression to its right appears to have been evaluated, and the method invocation completes abruptly for the same reason.<p>
<a name="45453"></a>
<h4>15.12.4.3    Check Accessibility of Type and Method</h4>
<a name="251693"></a>
Let <i>C</i> be the class containing the method invocation, and let <i>T</i> be the qualifying type of the method invocation <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>, and <i>m</i> be the name of the method, as determined at compile time <a href="expressions.doc.html#23617">(&#167;15.12.3)</a>. An implementation of the Java programming language must insure, as part of linkage, that the method <i>m</i> still exists in the type <i>T</i>. If this is not true, then a <code>NoSuchMethodError</code> (which is a subclass of <code>IncompatibleClassChangeError</code>) occurs. If the invocation mode is <code>interface</code>, then the implementation must also check that the target reference type still implements the specified interface. If the target reference type does not still implement the interface, then an <code>IncompatibleClassChangeError</code> occurs.<p>
<a name="251696"></a>
The implementation must also insure, during linkage, that the type <i>T</i> and the method <i>m</i> are accessible. For the type <i>T</i>:<p>
<ul><a name="45547"></a>
<li>If <i>T</i> is in the same package as <i>C</i>, then <i>T</i> is accessible.
<a name="45548"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is <code>public</code>, then <i>T</i> is accessible.
<a name="253445"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is protected, then <i>T</i> is accessible if and only if <i>C</i> is a subclass of <i>T</i>.
</ul><a name="239521"></a>
For the method <i>m</i>:<p>
<ul><a name="45542"></a>
<li>If <i>m</i> is <code>public</code>, then <i>m</i> is accessible. (All members of interfaces are <code>public</code> <a href="interfaces.doc.html#32392">(&#167;9.2)</a>).
<a name="45694"></a>
<li>If <i>m</i> is <code>protected</code>, then <i>m</i> is accessible if and only if either <i>T</i> is in the same package as <i>C</i>, or <i>C</i> is <i>T</i> or a subclass of <i>T</i>.
<a name="45695"></a>
<li>If <i>m</i> has default (package) access, then <i>m</i> is accessible if and only if <i>T</i> is in the same package as <i>C</i>.
<a name="45565"></a>
<li>If <i>m</i> is <code>private</code>, then <i>m</i> is accessible if and only if  <i>C</i> is <i>T</i>, or C encloses T, or T encloses C, or T and C are both enclosed by a third class<i></i>.
</ul><a name="45566"></a>
If either <i>T</i> or <i>m</i> is not accessible, then an <code>IllegalAccessError</code> occurs <a href="execution.doc.html#44487">(&#167;12.3)</a>.<p>
<a name="45606"></a>
<h4>15.12.4.4    Locate Method to Invoke</h4>
<a name="38785"></a>
The strategy for method lookup depends on the invocation mode.<p>
<a name="45702"></a>
If the invocation mode is <code>static</code>, no target reference is needed and overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="45395"></a>
Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is <code>null</code>, a <code>NullPointerException</code> is thrown at this point. Otherwise, the target reference is said to refer to a <em>target object</em> and will be used as the value of the keyword <code>this</code> in the invoked method. The other four possibilities for the invocation mode are then considered.<p>
<a name="38856"></a>
If the invocation mode is <code>nonvirtual</code>, overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="38864"></a>
Otherwise, the invocation mode is <code>interface</code>, <code>virtual</code>, or <code>super</code>, and overriding may occur. A <em>dynamic method lookup</em> is used. The dynamic lookup process starts from a class <i>S</i>, determined as follows:<p>
<ul><a name="290412"></a>
<li>If the invocation mode is <code>interface</code> or <code>virtual</code>, then <i>S</i> is initially the actual run-time class <i>R</i> of the target object. This is true even if the target object is an array instance. (Note that for invocation mode <code>interface</code>, <i>R</i> necessarily implements <i>T</i>; for invocation mode <code>virtual</code>, <i>R</i> is necessarily either <i>T</i> or a subclass of <i>T</i>.)
<a name="45403"></a>
<li>If the invocation mode is <code>super</code>, then <i>S</i> is initially the qualifying type <a href="binaryComp.doc.html#44909">(&#167;13.1)</a> of the method invocation.
</ul><a name="39033"></a>
The dynamic method lookup uses the following procedure to search class <i>S</i>, and then the superclasses of class <i>S</i>, as necessary, for method <i>m</i>.<p>
<a name="250473"></a>
Let <i>X</i> be the compile-time type of the target reference of the method invocation.<p>
<ol>
<a name="250480"></a>
<li>If class <i>S</i> contains a declaration for a non-abstract method named <i>m</i> with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time <a href="expressions.doc.html#23617">(&#167;15.12.3)</a>, then: 
<ul>
<a name="250485"></a>
<li>If the invocation mode is <code>super</code> or <code>interface</code>, then this is the method to be invoked, and the procedure terminates. 
<a name="250487"></a>
<li>If the invocation mode is <code>virtual</code>, and the declaration in <i>S</i> overrides <a href="classes.doc.html#227927">(&#167;8.4.6.1)</a> <i>X.m</i>, then the method declared in <i>S</i> is the method to be invoked, and the procedure terminates. 
</ul>
<a name="267561"></a>
<li>Otherwise, if <i>S</i> has a superclass, this same lookup procedure is performed recursively using the direct superclass of <i>S</i> in place of <i>S</i>; the method to be invoked is the result of the recursive invocation of this lookup procedure. 
</ol>
<a name="264492"></a>
The above procedure will always find a non-abstract, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled. However, if this is not the case, then various errors may occur. The specification of the behavior of a Java virtual machine under these circumstances is given by <em>The Java Virtual Machine Specification, Second Edition</em>.<p>
<a name="267569"></a>
We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.<p>
<a name="39078"></a>
<h4>15.12.4.5    Create Frame, Synchronize, Transfer Control</h4>
<a name="39080"></a>
A method <i>m</i> in some class <i>S</i> has been identified as the one to be invoked.<p>
<a name="39084"></a>
Now a new <em>activation frame</em> is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, an <code>OutOfMemoryError</code> is thrown.<p>
<a name="39085"></a>
The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as <code>this</code>, if there is a target reference. Before each argument value is assigned to its corresponding parameter variable, it is subjected to method invocation conversion <a href="conversions.doc.html#12687">(&#167;5.3)</a>, which includes any required value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>.<p>
<a name="42183"></a>
If the method <i>m</i> is a <code>native</code> method but the necessary native, implementation-dependent binary code has not been loaded or otherwise cannot be dynamically linked, then an <code>UnsatisfiedLinkError</code> is thrown.<p>
<a name="41731"></a>
If the method <i>m</i> is not <code>synchronized</code>, control is transferred to the body of the method <i>m</i> to be invoked.<p>
<a name="264497"></a>
If the method <i>m</i> is <code>synchronized</code>, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target must be locked; otherwise the <code>Class</code> object for class <i>S</i>, the class of the method <i>m</i>, must be locked. Control is then transferred to the body of the method <i>m</i> to be invoked. The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a <code>synchronized</code> statement <a href="statements.doc.html#255769">(&#167;14.18)</a>.<p>
<a name="39122"></a>
<h4>15.12.4.6    Example: Target Reference and Static Methods</h4>
<a name="39148"></a>
When a target reference is computed and then discarded because the invocation mode is <code>static</code>, the reference is not examined to see whether it is <code>null</code>:<p>
<blockquote><pre>class Test {
	static void mountain() {
		System.out.println("Monadnock");
	}
	static Test favorite(){
		System.out.print("Mount ");
		return null;
	}
	public static void main(String[] args) {
		favorite().mountain();
	}
}
</pre></blockquote><a name="39138"></a>
which prints:<p>
<blockquote><pre>Mount Monadnock
</pre></blockquote><a name="39140"></a>
Here <code>favorite</code> returns <code>null</code>, yet no <code>NullPointerException</code> is thrown.<p>
<a name="23837"></a>
<h4>15.12.4.7    Example: Evaluation Order</h4>
<a name="23841"></a>
As part of an instance method invocation <a href="expressions.doc.html#20448">(&#167;15.12)</a>, there is an expression that denotes the object to be invoked. This expression appears to be fully evaluated before any part of any argument expression to the method invocation is evaluated.<p>
<a name="23842"></a>
So, for example, in:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		String s = "one";
		if (s.startsWith(s = "two"))
			System.out.println("oops");
	}
}
</pre></blockquote><a name="272804"></a>
the occurrence of <code>s</code> before "<code>.startsWith</code>" is evaluated first, before the argument expression <code>s="two"</code>. Therefore, a reference to the string <code>"one"</code> is remembered as the target reference before the local variable s is changed to refer to the string <code>"two"</code>. As a result, the <code>startsWith</code> method is invoked for target object <code>"one"</code> with argument <code>"two"</code>, so the result of the invocation is <code>false</code>, as the string <code>"one"</code> does not start with <code>"two"</code>. It follows that the test program does not print "<code>oops</code>".<p>
<a name="239650"></a>
<h4>15.12.4.8    Example: Overriding</h4>
<a name="239651"></a>
In the example:<p>
<blockquote><pre>class Point {
	final int EDGE = 20;
	int x, y;
	void move(int dx, int dy) {
		x += dx; y += dy;
		if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
			clear();
	}
	void clear() {
		System.out.println("\tPoint clear");
		x = 0; y = 0;
	}
}
class ColoredPoint extends Point {
	int color;
	void clear() {
		System.out.println("\tColoredPoint clear");
		super.clear();
		color = 0;
	}
}
</pre></blockquote><a name="239673"></a>
the subclass <code>ColoredPoint</code> extends the <code>clear</code> abstraction defined by its superclass <code>Point</code>. It does so by overriding the <code>clear</code> method with its own method, which invokes the <code>clear</code> method of its superclass, using the form <code>super.clear</code>.<p>
<a name="239674"></a>
This method is then invoked whenever the target object for an invocation of <code>clear</code> is a <code>ColoredPoint</code>. Even the method <code>move</code> in <code>Point</code> invokes the <code>clear</code> method of class <code>ColoredPoint</code> when the class of <code>this</code> is <code>ColoredPoint</code>, as shown by the output of this test program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println("p.move(20,20):");
		p.move(20, 20);
		ColoredPoint cp = new ColoredPoint();
		System.out.println("cp.move(20,20):");
		cp.move(20, 20);
		p = new ColoredPoint();
		System.out.println("p.move(20,20), p colored:");
		p.move(20, 20);
	}
}
</pre></blockquote><a name="239688"></a>
which is:<p>
<blockquote><pre>p.move(20,20):
	Point clear
cp.move(20,20):
	ColoredPoint clear
	Point clear
p.move(20,20), p colored:
	ColoredPoint clear
	Point clear
</pre></blockquote>
<a name="239749"></a>
Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to <code>clear</code> in the body of <code>Point.move</code> (which is really syntactic shorthand for <code>this.clear</code>) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by <code>this</code>) rather than a method chosen "early" (at compile time, based only on the type of <code>this</code>). This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.<p>
<a name="239751"></a>
<h4>15.12.4.9    Example: Method Invocation using super</h4>
<a name="239647"></a>
An overridden instance method of a superclass may be accessed by using the keyword <code>super</code> to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation.<p>
<a name="39225"></a>
When accessing an instance variable, <code>super</code> means the same as a cast of <code>this</code> <a href="expressions.doc.html#20860">(&#167;15.11.2)</a>, but this equivalence does not hold true for method invocation. This is demonstrated by the example:<p>
<blockquote><pre>class T1 {
	String s() { return "1"; }
}
class T2 extends T1 {
	String s() { return "2"; }
}
class T3 extends T2 {
	String s() { return "3"; }
	void test() {
		System.out.println("s()=\t\t"+s());
		System.out.println("super.s()=\t"+super.s());
		System.out.print("((T2)this).s()=\t");
			System.out.println(((T2)this).s());
		System.out.print("((T1)this).s()=\t");
			System.out.println(((T1)this).s());
	}
}
class Test {
	public static void main(String[] args) {
		T3 t3 = new T3();
		t3.test();
	}
}
</pre></blockquote><a name="42586"></a>
which produces the output:<p>
<blockquote><pre>s()=					3
super.s()=					2
((T2)this).s()=					3
((T1)this).s()=					3
</pre></blockquote>
<a name="264502"></a>
The casts to types <code>T1</code> and <code>T2</code> do not change the method that is invoked, because the instance method to be invoked is chosen according to the run-time class of the object referred to be <code>this</code>. A cast does not change the class of an object; it only checks that the class is compatible with the specified type.<p>
<a name="239587"></a>
<h2>15.13    Array Access Expressions</h2>
<a name="39327"></a>
An array access expression refers to a variable that is a component of an array.<p>
<ul><pre>
<em>ArrayAccess:
	ExpressionName </em>[<em> Expression </em>]<em>
	PrimaryNoNewArray</em> [<em> Expression</em> ]
</pre></ul><a name="19392"></a>
An array access expression contains two subexpressions, the <em>array reference expression</em> (before the left bracket) and the <em>index expression</em> (within the brackets). Note that the array reference expression may be a name or any primary expression that is not an array creation expression <a href="expressions.doc.html#46168">(&#167;15.10)</a>.<p>
<a name="22123"></a>
The type of the array reference expression must be an array type (call it <i>T</i><code>[]</code>, an array whose components are of type <i>T</i>) or a compile-time error results. Then the type of the array access expression is <i>T</i>.<p>
<a name="22103"></a>
The index expression undergoes unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a>; the promoted type must be <code>int</code>.<p>
<a name="23960"></a>
The result of an array reference is a variable of type <i>T</i>, namely the variable within the array selected by the value of the index expression. This resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference was obtained from a <code>final</code> variable.<p>
<a name="23958"></a>
<h3>15.13.1    Runtime Evaluation of Array Access</h3>
<a name="39346"></a>
An array access expression is evaluated using the following procedure:<p>
<ul><a name="22142"></a>
<li>First, the array reference expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason and the index expression is not evaluated.
<a name="22130"></a>
<li>Otherwise, the index expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
<a name="22098"></a>
<li>Otherwise, if the value of the array reference expression is <code>null</code>, then a <code>NullPointerException</code> &#32;is thrown.
<a name="6936"></a>
<li>Otherwise, the value of the array reference expression indeed refers to an array. If the value of the index expression is less than zero, or greater than or equal to the array's length, then an <code>ArrayIndexOutOfBoundsException</code> is thrown.
<a name="264507"></a>
<li>Otherwise, the result of the array access is the variable of type T, within the array, selected by the value of the index expression. (Note that this resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference expression is a <code>final</code> variable.)
</ul><a name="23902"></a>
<h3>15.13.2    Examples: Array Access Evaluation Order</h3>
<a name="23906"></a>
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. For example, in the (admittedly monstrous) expression <code>a[(a=b)[3]]</code>, the expression <code>a</code> is fully evaluated before the expression <code>(a=b)[3]</code>; this means that the original value of <code>a</code> is fetched and remembered while the expression <code>(a=b)[3]</code> is evaluated. This array referenced by the original value of <code>a</code> is then subscripted by a value that is element <code>3</code> of another array (possibly the same array) that was referenced by <code>b</code> and is now also referenced by <code>a</code>.<p>
<a name="23907"></a>
Thus, the example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[] a = { 11, 12, 13, 14 };
		int[] b = { 0, 1, 2, 3 };
		System.out.println(a[(a=b)[3]]);
	}
}
</pre></blockquote><a name="23915"></a>
prints:<p>
<blockquote><pre>14
</pre></blockquote><a name="290083"></a>
because the monstrous expression's value is equivalent to <code>a[b[3]]</code> or <code>a[3]</code> or <code>14</code>.<p>
<a name="290084"></a>
If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int index = 1;
		try {
			skedaddle()[index=2]++;
		} catch (Exception e) {
			System.out.println(e + ", index=" + index);
		}
	}
	static int[] skedaddle() throws Exception {
		throw new Exception("Ciao");
	}
}
</pre></blockquote><a name="23931"></a>
prints: <p>
<blockquote><pre>java.lang.Exception: Ciao, index=1
</pre></blockquote><a name="23933"></a>
because the embedded assignment of <code>2</code> to <code>index</code> never occurs.<p>
<a name="23937"></a>
If the array reference expression produces <code>null</code> instead of a reference to an array, then a <code>NullPointerException</code> is thrown at run time, but only after all parts of the array access expression have been evaluated and only if these evaluations completed normally. Thus, the example:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int index = 1;
		try {
			nada()[index=2]++;
		} catch (Exception e) {
			System.out.println(e + ", index=" + index);
		}
	}
	static int[] nada() { return null; }
}
</pre></blockquote><a name="23950"></a>
prints:<p>
<blockquote><pre>java.lang.NullPointerException, index=2
</pre></blockquote><a name="23952"></a>
because the embedded assignment of <code>2</code> to <code>index</code> occurs before the check for a null pointer. As a related example, the program:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[] a = null;
		try {
			int i = a[vamoose()];
			System.out.println(i);
		} catch (Exception e) {
			System.out.println(e);
		}
	}
	static int vamoose() throws Exception {
		throw new Exception("Twenty-three skidoo!");
	}
}
</pre></blockquote><a name="36149"></a>
always prints:<p>
<blockquote><pre>java.lang.Exception: Twenty-three skidoo!
</pre></blockquote>
<a name="264512"></a>
A <code>NullPointerException</code> never occurs, because the index expression must be completely evaluated before any part of the indexing operation occurs, and that includes the check as to whether the value of the left-hand operand is <code>null</code>.<p>
<a name="36254"></a>
<h2>15.14    Postfix Expressions</h2>
<a name="39432"></a>
Postfix expressions include uses of the postfix <code>++</code> and <code>--</code> operators. Also, as discussed in <a href="expressions.doc.html#23302">&#167;15.8</a>, names are not considered to be primary expressions, but are handled separately in the grammar to avoid certain ambiguities. They become interchangeable only here, at the level of precedence of postfix expressions.<p>
<ul><pre>
<em>PostfixExpression:
	Primary
	ExpressionName
	PostIncrementExpression
	PostDecrementExpression<strong>
</strong></em></pre></ul><a name="39438"></a>
<h3>15.14.1    Postfix Increment Operator ++</h3>
<ul><pre>
<em>PostIncrementExpression:
	PostfixExpression </em>++
</pre></ul><a name="40093"></a>
A postfix expression followed by a <code>++</code> operator is a postfix increment expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value.<p>
<a name="249305"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="conversions.doc.html#25363">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable <em>before </em>the new value is stored.<p>
<a name="249315"></a>
Note that the binary numeric promotion mentioned above may include value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. If necessary, value set conversion is applied to the sum prior to its being stored in the variable.<p>
<a name="249312"></a>
A variable that is declared <code>final</code> cannot be incremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix increment operator.<p>
<a name="4987"></a>
<h3>15.14.2    Postfix Decrement Operator --</h3>
<ul><pre>
<em>PostDecrementExpression:
	PostfixExpression </em>--
</pre></ul><a name="40094"></a>
A postfix expression followed by a <code>--</code> operator is a postfix decrement expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value.<p>
<a name="39668"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="conversions.doc.html#25363">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable <em>before </em>the new value is stored.<p>
<a name="249327"></a>
Note that the binary numeric promotion mentioned above may include value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. If necessary, value set conversion is applied to the difference prior to its being stored in the variable.<p>
<a name="41352"></a>
A variable that is declared <code>final</code> cannot be decremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix decrement operator.<p>
<a name="4990"></a>
<h2>15.15    Unary Operators</h2>
<a name="31520"></a>
The <em>unary operators</em> include <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and cast operators. Expressions with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.<p>
<ul><pre>
<em>UnaryExpression:
	PreIncrementExpression
	PreDecrementExpression
</em>	+<em> UnaryExpression
	</em>-<em> UnaryExpression
	UnaryExpressionNotPlusMinus

PreIncrementExpression:
	</em>++<em> UnaryExpression

PreDecrementExpression:
	</em>--<em> UnaryExpression

UnaryExpressionNotPlusMinus:
	PostfixExpression
	</em>~<em> UnaryExpression
	</em>!<em> UnaryExpression
	CastExpression
</em></pre></ul><a name="29719"></a>
The following productions from <a href="expressions.doc.html#238146">&#167;15.16</a> are repeated here for convenience:<p>
<ul><pre>
<em>CastExpression:
	</em>(<em> PrimitiveType </em>)<em> UnaryExpression
	</em>(<em> ReferenceType </em>)&#32;U<em>naryExpressionNotPlusMinus</em>
</pre></ul><a name="39547"></a>
<h3>15.15.1    Prefix Increment Operator ++</h3>
<a name="5002"></a>
A unary expression preceded by a <code>++</code> operator is a prefix increment expression. The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix increment expression is the type of the variable. The result of the prefix increment expression is not a variable, but a value.<p>
<a name="39621"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="conversions.doc.html#25363">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable <em>after </em>the new value is stored.<p>
<a name="249342"></a>
Note that the binary numeric promotion mentioned above may include value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. If necessary, value set conversion is applied to the sum prior to its being stored in the variable.<p>
<a name="239134"></a>
A variable that is declared <code>final</code> cannot be incremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix increment operator.<p>
<a name="239136"></a>
<h3>15.15.2    Prefix Decrement Operator --</h3>
<a name="5005"></a>
A unary expression preceded by a <code>--</code> operator is a prefix decrement expression. The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix decrement expression is the type of the variable. The result of the prefix decrement expression is not a variable, but a value.<p>
<a name="39634"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="conversions.doc.html#25363">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable <em>after </em>the new value is stored.<p>
<a name="249349"></a>
Note that the binary numeric promotion mentioned above may include value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. If necessary, format conversion is applied to the difference prior to its being stored in the variable.<p>
<a name="41323"></a>
A variable that is declared <code>final</code> cannot be decremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix decrement operator.<p>
<a name="24924"></a>
<h3>15.15.3    Unary Plus Operator +</h3>
<a name="24926"></a>
The type of the operand expression of the unary <code>+</code> operator must be a primitive numeric type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a> is performed on the operand. The type of the unary plus expression is the promoted type of the operand. The result of the unary plus expression is not a variable, but a value, even if the result of the operand expression is a variable.<p>
<a name="39701"></a>
At run time, the value of the unary plus expression is the promoted value of the operand.<p>
<a name="236345"></a>
<h3>15.15.4    Unary Minus Operator -</h3>
<a name="39711"></a>
The type of the operand expression of the unary <code>-</code> operator must be a primitive numeric type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a> is performed on the operand. The type of the unary minus expression is the promoted type of the operand.<p>
<a name="251073"></a>
Note that unary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. Whatever value set the promoted operand value is drawn from, the unary negation operation is carried out and the result is drawn from that same value set. That result is then subject to further value set conversion.<p>
<a name="249384"></a>
At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand.<p>
<a name="79921"></a>
For integer values, negation is the same as subtraction from zero. The Java programming language uses two's-complement representation for integers, and the range of two's-complement values is not symmetric, so negation of the maximum negative <code>int</code> or <code>long</code> results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values <code>x</code>, <code>-x</code> equals <code>(~x)+1</code>.<p>
<a name="5013"></a>
For floating-point values, negation is not the same as subtraction from zero, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> is <code>+0.0</code>, but <code>-x</code> is <code>-0.0</code>. Unary minus merely inverts the sign of a floating-point number. Special cases of interest:<p>
<ul><a name="5014"></a>
<li>If the operand is NaN, the result is NaN (recall that NaN has no sign).
<a name="5015"></a>
<li>If the operand is an infinity, the result is the infinity of opposite sign.
<a name="5016"></a>
<li>If the operand is a zero, the result is the zero of opposite sign.
</ul><a name="5017"></a>
<h3>15.15.5    Bitwise Complement Operator ~</h3>
<a name="39739"></a>
The type of the operand expression of the unary <code>~</code> operator must be a primitive integral type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a> is performed on the operand. The type of the unary bitwise complement expression is the promoted type of the operand.<p>
<a name="39743"></a>
At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand; note that, in all cases, <code>~x</code> &#32;equals <code>(-x)-1</code>.<p>
<a name="13350"></a>
<h3>15.15.6    Logical Complement Operator !</h3>
<a name="39767"></a>
The type of the operand expression of the unary <code>!</code> operator must be <code>boolean,</code> or a compile-time error occurs. The type of the unary logical complement expression is <code>boolean</code>.<p>
<a name="39771"></a>
At run time, the value of the unary logical complement expression is <code>true</code> if the operand value is <code>false</code> and <code>false</code> if the operand value is <code>true</code>.<p>
<a name="238146"></a>
<h2>15.16    Cast Expressions</h2>
<a name="236464"></a>
A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is <code>boolean</code>; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type.<p>
<ul><pre>
<em>CastExpression:
	</em>(<em> PrimitiveType Dims<sub><i>opt</i></sub> </em>)<em> UnaryExpression
	</em>(<em> ReferenceType </em>)<em> UnaryExpressionNotPlusMinus
</em></pre></ul><a name="39813"></a>
See <a href="expressions.doc.html#4990">&#167;15.15</a> for a discussion of the distinction between <em>UnaryExpression</em> and <em>UnaryExpressionNotPlusMinus</em>.<p>
<a name="39826"></a>
The type of a cast expression is the type whose name appears within the parentheses. (The parentheses and the type they contain are sometimes called the <em>cast operator</em>.) The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.<p>
<a name="251082"></a>
A cast operator has no effect on the choice of value set <a href="typesValues.doc.html#9208">(&#167;4.2.3)</a> for a value of type <code>float</code> or type <code>double</code>. Consequently, a cast to type <code>float</code> within an expression that is not FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a> does not necessarily cause its value to be converted to an element of the float value set, and a cast to type <code>double</code> within an expression that is not FP-strict does not necessarily cause its value to be converted to an element of the double value set.<p>
<a name="264531"></a>
At run time, the operand value is converted by casting conversion <a href="conversions.doc.html#20232">(&#167;5.5)</a> to the type specified by the cast operator.<p>
<a name="264536"></a>
Not all casts are permitted by the language. Some casts result in an error at compile time. For example, a primitive value may not be cast to a reference type. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time. <p>
<a name="264529"></a>
A <code>ClassCastException</code> is thrown if a cast is found at run time to be impermissible.<p>
<a name="239829"></a>
<h2>15.17    Multiplicative Operators</h2>
<a name="5029"></a>
The operators <code>*</code>, <code>/</code>, and <code>%</code> are called the <em>multiplicative operators</em>. They have the same precedence and are syntactically left-associative (they group left-to-right).<p>
<ul><pre>
<em>MultiplicativeExpression:
	UnaryExpression
	MultiplicativeExpression * UnaryExpression
	MultiplicativeExpression / UnaryExpression
	MultiplicativeExpression % UnaryExpression
</em></pre></ul><a name="39873"></a>
The type of each of the operands of a multiplicative operator must be a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands <a href="conversions.doc.html#170983">(&#167;5.6.2)</a>. The type of a multiplicative expression is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="251088"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>.<p>
<a name="5036"></a>
<h3>15.17.1    Multiplication Operator *</h3>
<a name="5037"></a>
The binary <code>*</code> operator performs multiplication, producing the product of its operands. Multiplication is a commutative operation if the operand expressions have no side effects. While integer multiplication is associative when the operands are all of the same type, floating-point multiplication is not associative.<p>
<a name="79991"></a>
If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.<p>
<a name="5039"></a>
The result of a floating-point multiplication is governed by the rules of IEEE 754 arithmetic:<p>
<ul><a name="5040"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5041"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs.
<a name="24701"></a>
<li>Multiplication of an infinity by a zero results in NaN.
<a name="24702"></a>
<li>Multiplication of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="251092"></a>
<li>In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical product is computed. A floating-point value set is then chosen:
<ul>
<a name="251093"></a>
<li>If the multiplication expression is FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251094"></a>
<li>If the type of the multiplication expression is <code>float</code>, then the float value set must be chosen.
<a name="251095"></a>
<li>If the type of the multiplication expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251096"></a>
<li>If the multiplication expression is not FP-strict:
<ul>
<a name="251097"></a>
<li>If the type of the multiplication expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251098"></a>
<li>If the type of the multiplication expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251099"></a>
<br><br>Next, a value must be chosen from the chosen value set to represent the product. If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the product is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5045"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator <code>*</code> never throws a run-time exception.<p>
<a name="5047"></a>
<h3>15.17.2    Division Operator /</h3>
<a name="5048"></a>
The binary <code>/</code> operator performs division, producing the quotient of its operands. The left-hand operand is the dividend and the right-hand operand is the divisor.<p>
<a name="45471"></a>
Integer division rounds toward <code>0</code>. That is, the quotient produced for operands <em>n</em> and <em>d</em> that are integers after binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is an integer value <em>q</em> whose magnitude is as large as possible while satisfying <img src="15.doc.anc4.gif">; moreover, <em>q </em>is positive when <img src="15.doc.anc5.gif"> and <em>n</em> and <em>d</em> have the same sign, but <em>q</em> is negative when <img src="15.doc.anc6.gif"> and <em>n</em> and <em>d </em>have opposite signs. There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is <code>-1</code>, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is <code>0</code>, then an <code>ArithmeticException</code> is thrown.<p>
<a name="45481"></a>
The result of a floating-point division is determined by the specification of IEEE arithmetic:<p>
<ul><a name="5054"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5055"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
<a name="5056"></a>
<li>Division of an infinity by an infinity results in NaN.
<a name="5057"></a>
<li>Division of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="5058"></a>
<li>Division of a finite value by an infinity results in a signed zero. The sign is determined by the rule stated above.
<a name="236610"></a>
<li>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero. The sign is determined by the rule stated above.
<a name="236611"></a>
<li>Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule stated above.
<a name="251106"></a>
<li>In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical quotient is computed. A floating-point value set is then chosen:
<ul>
<a name="251107"></a>
<li>If the division expression is FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251108"></a>
<li>If the type of the division expression is <code>float</code>, then the float value set must be chosen.
<a name="251109"></a>
<li>If the type of the division expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251110"></a>
<li>If the division expression is not FP-strict:
<ul>
<a name="251111"></a>
<li>If the type of the division expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251112"></a>
<li>If the type of the division expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251113"></a>
Next, a value must be chosen from the chosen value set to represent the quotient. If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the quotient is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5062"></a>
Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator <code>/</code> never throws a run-time exception<p>
<a name="24956"></a>
<h3>15.17.3    Remainder Operator %</h3>
<a name="264541"></a>
The binary <code>%</code> operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor.<p>
<a name="264546"></a>
In C and C++, the remainder operator accepts only integral operands, but in the Java programming language, it also accepts floating-point operands.<p>
<a name="264551"></a>
The remainder operation for operands that are integers after binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> produces a result value such that <code>(a/b)*b+(a%b)</code> is equal to <code>a</code>. This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is <code>-1</code> (the remainder is <code>0</code>). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor. If the value of the divisor for an integer remainder operator is <code>0</code>, then an <code>ArithmeticException</code> is thrown.Examples:<p>
<blockquote><pre>
5%3 produces 2				(note that 5/3 produces 1)
5%(-3) produces 2			(note that 5/(-3) produces -1)
(-5)%3 produces -2			(note that (-5)/3 produces -1)
(-5)%(-3) produces -2			(note that (-5)/(-3) produces 1)
</pre></blockquote><a name="249585"></a>
The result of a floating-point remainder operation as computed by the <code>%</code> operator is <em>not</em> the same as that produced by the remainder operation defined by IEEE 754. The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is <em>not</em> analogous to that of the usual integer remainder operator. Instead, the Java programming language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function <code>fmod</code>. The IEEE 754 remainder operation may be computed by the library routine <code>Math.IEEEremainder</code>.<p>
<a name="5068"></a>
The result of a floating-point remainder operation is determined by the rules of IEEE arithmetic:<p>
<ul><a name="5069"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5070"></a>
<li>If the result is not NaN, the sign of the result equals the sign of the dividend.
<a name="5071"></a>
<li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
<a name="5072"></a>
<li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.
<a name="5073"></a>
<li>If the dividend is a zero and the divisor is finite, the result equals the dividend.
<a name="5074"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder <em>r</em> from the division of a dividend <em>n</em> by a divisor <em>d</em> is defined by the mathematical relation <img src="15.doc.anc.gif"> where <em>q</em> is an integer that is negative only if <img src="15.doc.anc1.gif"> is negative and positive only if <img src="15.doc.anc2.gif"> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <em>n</em> and <em>d</em>.
</ul><a name="264565"></a>
Evaluation of a floating-point remainder operator <code>%</code> never throws a run-time exception, even if the right-hand operand is zero. Overflow, underflow, or loss of precision cannot occur.<p>
<a name="40146"></a>
Examples:<p>
<blockquote><pre>5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0
</pre></blockquote><a name="15746"></a>
<h2>15.18    Additive Operators</h2>
<a name="15749"></a>
The operators <code>+</code> and <code>-</code> are called the <em>additive operators</em>. They have the same precedence and are syntactically left-associative (they group left-to-right).<p>
<ul><pre>
<em>AdditiveExpression:
	MultiplicativeExpression
	AdditiveExpression </em>+<em> MultiplicativeExpression
	AdditiveExpression </em>-<em> MultiplicativeExpression
</em></pre></ul><a name="39987"></a>
If the type of either operand of a + operator is <code>String</code>, then the operation is string concatenation.<p>
<a name="39998"></a>
Otherwise, the type of each of the operands of the <code>+</code> operator must be a primitive numeric type, or a compile-time error occurs. <p>
<a name="40002"></a>
In every case, the type of each of the operands of the binary <code>-</code> operator must be a primitive numeric type, or a compile-time error occurs. <p>
<a name="39990"></a>
<h3>15.18.1    String Concatenation Operator +</h3>
<a name="7894"></a>
If only one operand expression is of type <code>String</code>, then string conversion is performed on the other operand to produce a string at run time. The result is a reference to a newly created <code>String</code> object that is the concatenation of the two operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string.<p>
<a name="40220"></a>
<h4>15.18.1.1    String Conversion</h4>
<a name="40222"></a>
Any type may be converted to type <code>String</code> by <em>string conversion</em>.<p>
<a name="22621"></a>
A value <i>x</i> of primitive type <i>T</i> is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression:<p>
<ul><a name="40316"></a>
<li>If <i>T</i> is <code>boolean</code>, then use <code>new</code> <code>Boolean(</code><i>x</i><code>)</code>.
<a name="40320"></a>
<li>If <i>T</i> is <code>char</code>, then use <code>new</code> <code>Character(</code><i>x</i><code>)</code>.
<a name="40265"></a>
<li>If <i>T</i> is <code>byte</code>, <code>short</code>, or <code>int</code>, then use <code>new</code> <code>Integer(</code><i>x</i><code>)</code>.
<a name="40272"></a>
<li>If <i>T</i> is <code>long</code>, then use <code>new</code> <code>Long(</code><i>x</i><code>)</code>.
<a name="40279"></a>
<li>If <i>T</i> is <code>float</code>, then use <code>new</code> <code>Float(</code><i>x</i><code>)</code>.
<a name="40286"></a>
<li>If <i>T</i> is <code>double</code>, then use <code>new</code> <code>Double(</code><i>x</i><code>)</code>.
</ul><a name="40362"></a>
This reference value is then converted to type <code>String</code> by string conversion.<p>
<a name="22740"></a>
Now only reference values need to be considered. If the reference is <code>null</code>, it is converted to the string "<code>null</code>" (four ASCII characters <code>n</code>, <code>u</code>, <code>l</code>, <code>l</code>). Otherwise, the conversion is performed as if by an invocation of the <code>toString</code> method of the referenced object with no arguments; but if the result of invoking the <code>toString</code> method is <code>null</code>, then the string "<code>null</code>" is used instead. <p>
<a name="290252"></a>
The <code>toString</code> method is defined by the primordial class <code>Object</code>; many classes override it, notably <code>Boolean</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double,</code> and <code>String</code>.<p>
<a name="40226"></a>
<h4>15.18.1.2    Optimization of String Concatenation</h4>
<a name="40227"></a>
An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate <code>String</code> object. To increase the performance of repeated string concatenation, a Java compiler may use the <code>StringBuffer</code> class or a similar technique to reduce the number of intermediate <code>String</code> objects that are created by evaluation of an expression.<p>
<a name="22668"></a>
For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.<p>
<a name="40423"></a>
<h4>15.18.1.3    Examples of String Concatenation</h4>
<a name="40221"></a>
The example expression:<p>
<blockquote><pre>"The square root of 2 is " + Math.sqrt(2)
</pre></blockquote><a name="21343"></a>
produces the result:<p>
<blockquote><pre>"The square root of 2 is 1.4142135623730952"
</pre></blockquote>
<a name="21344"></a>
The + operator is syntactically left-associative, no matter whether it is later determined by type analysis to represent string concatenation or addition. In some cases care is required to get the desired result. For example, the expression:<p>
<blockquote><pre>
a + b + c
</pre></blockquote><a name="40518"></a>
is always regarded as meaning:<p>
<blockquote><pre>(a + b) + c
</pre></blockquote><a name="40520"></a>
Therefore the result of the expression:<p>
<blockquote><pre>1 + 2 + " fiddlers"
</pre></blockquote><a name="40522"></a>
is:<p>
<blockquote><pre>"3 fiddlers"
</pre></blockquote><a name="40524"></a>
but the result of:<p>
<blockquote><pre>"fiddlers " + 1 + 2
</pre></blockquote><a name="40526"></a>
is:<p>
<blockquote><pre>"fiddlers 12"
</pre></blockquote>
<a name="238156"></a>
In this jocular little example:<p>
<blockquote><pre>
class Bottles {
	static void printSong(Object stuff, int n) {
		String plural = (n == 1) ? "" : "s";
		loop: while (true) {
			System.out.println(n + " bottle" + plural
				+ " of " + stuff + " on the wall,");
			System.out.println(n + " bottle" + plural
				+ " of " + stuff + ";");
			System.out.println("You take one down "
				+ "and pass it around:");
			--n;
			plural = (n == 1) ? "" : "s";
			if (n == 0)
				break loop;
			System.out.println(n + " bottle" + plural
				+ " of " + stuff + " on the wall!");
			System.out.println();
		}
		System.out.println("No bottles of " +
								stuff + " on the wall!");
	}
}
</pre></blockquote><a name="40427"></a>
the method <code>printSong</code> will print a version of a children's song. Popular values for stuff include <code>"pop"</code> and <code>"beer"</code>; the most popular value for <code>n</code> is <code>100</code>. Here is the output that results from <code>Bottles.printSong("slime", 3)</code>:<p>
<blockquote><pre>3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!
</pre></blockquote>
<a name="40459"></a>
In the code, note the careful conditional generation of the singular "<code>bottle</code>" when appropriate rather than the plural "<code>bottles</code>"; note also how the string concatenation operator was used to break the long constant string:<p>
<blockquote><pre>
"You take one down and pass it around:"
</pre></blockquote>
<a name="264580"></a>
into two pieces to avoid an inconveniently long line in the source code.<p>
<a name="13510"></a>
<h3>15.18.2    Additive Operators (+ and -) for Numeric Types</h3>
<a name="235182"></a>
The binary <code>+</code> operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The binary <code>-</code> operator performs subtraction, producing the difference of two numeric operands.<p>
<a name="39970"></a>
Binary numeric promotion is performed on the operands <a href="conversions.doc.html#170983">(&#167;5.6.2)</a>. The type of an additive expression on numeric operands is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="251120"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>.<p>
<a name="39968"></a>
Addition is a commutative operation if the operand expressions have no side effects. Integer addition is associative when the operands are all of the same type, but floating-point addition is not associative.<p>
<a name="13512"></a>
If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.<p>
<a name="13513"></a>
The result of a floating-point addition is determined using the following rules of IEEE arithmetic:<p>
<ul><a name="13514"></a>
<li>If either operand is NaN, the result is NaN.
<a name="13515"></a>
<li>The sum of two infinities of opposite sign is NaN.
<a name="13516"></a>
<li>The sum of two infinities of the same sign is the infinity of that sign.
<a name="13517"></a>
<li>The sum of an infinity and a finite value is equal to the infinite operand.
<a name="13518"></a>
<li>The sum of two zeros of opposite sign is positive zero.
<a name="13519"></a>
<li>The sum of two zeros of the same sign is the zero of that sign.
<a name="13520"></a>
<li>The sum of a zero and a nonzero finite value is equal to the nonzero operand.
<a name="13521"></a>
<li>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
<a name="251124"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the exact mathematical sum is computed. A floating-point value set is then chosen:
<ul>
<a name="251125"></a>
<li>If the addition expression is FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251126"></a>
<li>If the type of the addition expression is <code>float</code>, then the float value set must be chosen.
<a name="251127"></a>
<li>If the type of the addition expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251128"></a>
<li>If the addition expression is not FP-strict:
<ul>
<a name="251129"></a>
<li>If the type of the addition expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251130"></a>
<li>If the type of the addition expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251131"></a>
Next, a value must be chosen from the chosen value set to represent the sum. If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the sum is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="13523"></a>
The binary <code>-</code> operator performs subtraction when applied to two operands of numeric type producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend. For both integer and floating-point subtraction, it is always the case that <code>a-b</code> produces the same result as <code>a+(-b)</code>. <p>
<a name="290253"></a>
Note that, for integer values, subtraction from zero is the same as negation. However, for floating-point operands, subtraction from zero is <em>not</em> the same as negation, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> is <code>+0.0</code>, but <code>-x</code> is <code>-0.0</code>. <p>
<a name="13524"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.<p>
<a name="5121"></a>
<h2>15.19    Shift Operators</h2>
<a name="5122"></a>
The <em>shift operators</em> include left shift <code>&lt;&lt;</code>, signed right shift <code>&gt;&gt;</code>, and unsigned right shift <code>&gt;&gt;&gt;</code>; they are syntactically left-associative (they group left-to-right). The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.<p>
<ul><pre>
<em>ShiftExpression:
	AdditiveExpression
	ShiftExpression &lt;&lt; AdditiveExpression
	ShiftExpression &gt;&gt; AdditiveExpression
	ShiftExpression &gt;&gt;&gt; AdditiveExpression
</em></pre></ul><a name="40554"></a>
The type of each of the operands of a shift operator must be a primitive integral type, or a compile-time error occurs. Binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is <em>not</em> performed on the operands; rather, unary numeric promotion <a href="conversions.doc.html#170952">(&#167;5.6.1)</a> is performed on each operand separately. The type of the shift expression is the promoted type of the left-hand operand.<p>
<a name="13680"></a>
If the promoted type of the left-hand operand is <code>int</code>, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="expressions.doc.html#5233">(&#167;15.22.1)</a> with the mask value <code>0x1f</code>. The shift distance actually used is therefore always in the range 0 to 31, inclusive.<p>
<a name="19183"></a>
If the promoted type of the left-hand operand is <code>long</code>, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="expressions.doc.html#5233">(&#167;15.22.1)</a> with the mask value <code>0x3f</code>. The shift distance actually used is therefore always in the range 0 to 63, inclusive.<p>
<a name="19187"></a>
At run time, shift operations are performed on the two's complement integer representation of the value of the left operand.<p>
<a name="19188"></a>
The value of <code>n&lt;&lt;s</code> is <code>n</code> left-shifted <code>s</code> bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power <code>s</code>.<p>
<a name="5140"></a>
The value of <code>n&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with sign-extension. The resulting value is <img src="15.doc.anc3.gif">. For nonnegative values of <code>n</code>, this is equivalent to truncating integer division, as computed by the integer division operator <code>/</code>, by two to the power <code>s</code>.<p>
<a name="40638"></a>
The value of <code>n&gt;&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with zero-extension. If <code>n</code> is positive, then the result is the same as that of <code>n&gt;&gt;s</code>; if <code>n</code> is negative, the result is equal to that of the expression <code>(n&gt;&gt;s)+(2&lt;&lt;~s)</code> if the type of the left-hand operand is <code>int</code>, and to the result of the expression <code>(n&gt;&gt;s)+(2L&lt;&lt;~s)</code> if the type of the left-hand operand is <code>long</code>. The added term <code>(2&lt;&lt;~s)</code> or <code>(2L&lt;&lt;~s)</code> cancels out the propagated sign bit. (Note that, because of the implicit masking of the right-hand operand of a shift operator, <code>~s</code> as a shift distance is equivalent to <code>31-s</code> when shifting an <code>int</code> value and to <code>63-s</code> when shifting a <code>long</code> value.)<p>
<a name="40641"></a>
<h2>15.20    Relational Operators</h2>
<a name="139595"></a>
The <em>relational operators</em> are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, <code>a&lt;b&lt;c</code> parses as <code>(a&lt;b)&lt;c</code>, which is always a compile-time error, because the type of <code>a&lt;b</code> is always <code>boolean</code> and <code>&lt;</code> is not an operator on <code>boolean</code> values.<p>
<ul><pre>
<em>RelationalExpression:
	ShiftExpression
	RelationalExpression &lt; ShiftExpression
	RelationalExpression &gt; ShiftExpression
	RelationalExpression &lt;= ShiftExpression
	RelationalExpression &gt;= ShiftExpression
	RelationalExpression instanceof ReferenceType
</em></pre></ul><a name="235261"></a>
The type of a relational expression is always <code>boolean</code>.<p>
<a name="153654"></a>
<h3>15.20.1    Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;= </h3>
<a name="40647"></a>
The type of each of the operands of a numerical comparison operator must be a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands <a href="conversions.doc.html#170983">(&#167;5.6.2)</a>. If the promoted type of the operands is <code>int</code> or <code>long</code>, then signed integer comparison is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point comparison is performed.<p>
<a name="251144"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.<p>
<a name="5155"></a>
The result of a floating-point comparison, as determined by the specification of the IEEE 754 standard, is:<p>
<ul><a name="5156"></a>
<li>If either operand is NaN, then the result is <code>false</code>.
<a name="5157"></a>
<li>All values other than NaN are ordered, with negative infinity less than all finite values, and positive infinity greater than all finite values.
<a name="5158"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0&lt;0.0</code> is <code>false</code>, for example, but <code>-0.0&lt;=0.0</code> is <code>true</code>. (Note, however, that the methods <code>Math.min</code> and <code>Math.max</code> treat negative zero as being strictly smaller than positive zero.)
</ul><a name="5159"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5160"></a>
<li>The value produced by the <code>&lt;</code> operator is <code>true</code> if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5161"></a>
<li>The value produced by the <code>&lt;=</code> operator is <code>true</code> if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5162"></a>
<li>The value produced by the <code>&gt;</code> operator is <code>true</code> if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5163"></a>
<li>The value produced by the <code>&gt;=</code> operator is <code>true</code> if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
</ul><a name="80289"></a>
<h3>15.20.2    Type Comparison Operator instanceof</h3>
<a name="80291"></a>
The type of a <em>RelationalExpression</em> operand of the <code>instanceof</code> operator must be a reference type or the null type; otherwise, a compile-time error occurs. The <em>ReferenceType</em> mentioned after the <code>instanceof</code> operator must denote a reference type; otherwise, a compile-time error occurs.<p>
<a name="240816"></a>
At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <em>RelationalExpression</em> is not <code>null</code> and the reference could be cast <a href="expressions.doc.html#238146">(&#167;15.16)</a> to the <em>ReferenceType</em> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.<p>
<a name="264585"></a>
If a cast of the <em>RelationalExpression</em> to the <em>ReferenceType</em> would be rejected as a compile-time error, then the <code>instanceof</code> relational expression likewise produces a compile-time error. In such a situation, the result of the <code>instanceof</code> expression could never be <code>true</code>.<p>
<a name="238166"></a>
Consider the example program:<p>
<blockquote><pre>class Point { int x, y; }
class Element { int atomicNumber; }
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		Element e = new Element();
		if (e instanceof Point) {											// compile-time error
			System.out.println("I get your point!");
			p = (Point)e;										// compile-time error
		}
	}
}
</pre></blockquote><a name="22819"></a>
This example results in two compile-time errors. The cast <code>(Point)e</code> is incorrect because no instance of <code>Element</code> or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of <code>Point</code>. The <code>instanceof</code> expression is incorrect for exactly the same reason. If, on the other hand, the class <code>Point</code> were a subclass of <code>Element</code> (an admittedly strange notion in this example):<p>
<blockquote><pre>class Point extends Element { int x, y; }
</pre></blockquote><a name="264590"></a>
then the cast would be possible, though it would require a run-time check, and the <code>instanceof</code> expression would then be sensible and valid. The cast <code>(Point)e</code> would never raise an exception because it would not be executed if the value of <code>e</code> could not correctly be cast to type <code>Point</code>.<p>
<a name="5192"></a>
<h2>15.21    Equality Operators</h2>
<a name="24723"></a>
The equality operators are syntactically left-associative (they group left-to-right), but this fact is essentially never useful; for example, <code>a==b==c</code> parses as <code>(a==b)==c</code>. The result type of <code>a==b</code> is always <code>boolean</code>, and <code>c</code> must therefore be of type <code>boolean</code> or a compile-time error occurs. Thus, <code>a==b==c</code> does <em>not</em> test to see whether <code>a</code>, <code>b</code>, and <code>c</code> are all equal.<p>
<ul><pre>
<em>EqualityExpression:
	RelationalExpression
	EqualityExpression == RelationalExpression
	EqualityExpression != RelationalExpression
</em></pre></ul><a name="5195"></a>
The == (equal to) and the != (not equal to) operators are analogous to the relational operators except for their lower precedence. Thus, <code>a&lt;b==c&lt;d</code> is <code>true</code> whenever <code>a&lt;b</code> and <code>c&lt;d</code> have the same truth value.<p>
<a name="5196"></a>
The equality operators may be used to compare two operands of numeric type, or two operands of type <code>boolean</code>, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always <code>boolean</code>.<p>
<a name="235280"></a>
In all cases, <code>a!=b</code> produces the same result as <code>!(a==b)</code>. The equality operators are commutative if the operand expressions have no side effects.<p>
<a name="5198"></a>
<h3>15.21.1    Numerical Equality Operators ==&#32;and != </h3>
<a name="40803"></a>
If the operands of an equality operator are both of primitive numeric type, binary numeric promotion is performed on the operands <a href="conversions.doc.html#170983">(&#167;5.6.2)</a>. If the promoted type of the operands is <code>int</code> or <code>long</code>, then an integer equality test is performed; if the promoted type is <code>float</code> or <code>double</code>, then a floating-point equality test is performed.<p>
<a name="251162"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>. Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.<p>
<a name="5203"></a>
Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard:<p>
<ul><a name="5204"></a>
<li>If either operand is NaN, then the result of <code>==</code> is <code>false</code> but the result of <code>!=</code> is <code>true</code>. Indeed, the test <code>x!=x</code> is true if and only if the value of <code>x</code> is NaN. (The methods <code>Float.isNaN</code> and <code>Double.isNaN</code> may also be used to test whether a value is NaN.)
<a name="54500"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0==0.0</code> is <code>true</code>, for example.
<a name="54501"></a>
<li>Otherwise, two distinct floating-point values are considered unequal by the equality operators. In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
</ul><a name="5207"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5208"></a>
<li>The value produced by the <code>==</code> operator is <code>true</code> if the value of the left-hand operand is equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
<a name="236629"></a>
<li>The value produced by the <code>!=</code> operator is <code>true</code> if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
</ul><a name="54508"></a>
<h3>15.21.2    Boolean Equality Operators ==&#32;and != </h3>
<a name="80389"></a>
If the operands of an equality operator are both of type <code>boolean</code>, then the operation is boolean equality. The <code>boolean</code> equality operators are associative.<p>
<a name="5214"></a>
The result of <code>==</code> is <code>true</code> if the operands are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>false</code>.<p>
<a name="5215"></a>
The result of <code>!=</code> is <code>false</code> if the operands are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>true</code>. Thus <code>!=</code> behaves the same as <code>^</code> <a href="expressions.doc.html#5242">(&#167;15.22.2)</a> when applied to boolean operands.<p>
<a name="236163"></a>
<h3>15.21.3    Reference Equality Operators ==&#32;and !=</h3>
<a name="236164"></a>
If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality.<p>
<a name="80399"></a>
A compile-time error occurs if it is impossible to convert the type of either operand to the type of the other by a casting conversion <a href="conversions.doc.html#20232">(&#167;5.5)</a>. The run-time values of the two operands would necessarily be unequal.<p>
<a name="5225"></a>
At run time, the result of <code>==</code> is <code>true</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>false</code>.<p>
<a name="264595"></a>
The result of <code>!=</code> is <code>false</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>true</code>.<p>
<a name="264600"></a>
While <code>==</code> may be used to compare references of type <code>String</code>, such an equality test determines whether or not the two operands refer to the same <code>String</code> object. The result is <code>false</code> if the operands are distinct <code>String</code> objects, even if they contain the same sequence of characters. The contents of two strings <code>s</code> and <code>t</code> can be tested for equality by the method invocation <code>s.equals(t)</code>. See also <a href="lexical.doc.html#101083">&#167;3.10.5</a>.<p>
<a name="5228"></a>
<h2>15.22    Bitwise and Logical Operators</h2>
<a name="5229"></a>
The <em>bitwise</em> <em>operators</em> and <em>logical operators</em> include the AND operator <code>&amp;</code>, exclusive OR operator <code>^</code>, and inclusive OR operator <code>|</code>. These operators have different precedence, with <code>&amp;</code> having the highest precedence and <code>|</code> the lowest precedence. Each of these operators is syntactically left-associative (each groups left-to-right). Each operator is commutative if the operand expressions have no side effects. Each operator is associative.<p>
<ul><pre>
<em>AndExpression:
	EqualityExpression
	AndExpression &amp; EqualityExpression

ExclusiveOrExpression:
	AndExpression
	ExclusiveOrExpression ^ AndExpression

InclusiveOrExpression:
	ExclusiveOrExpression
	InclusiveOrExpression | ExclusiveOrExpression
</em></pre></ul><a name="40906"></a>
The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type <code>boolean</code>. All other cases result in a compile-time error.<p>
<a name="5233"></a>
<h3>15.22.1    Integer Bitwise Operators &amp;, ^, and |</h3>
<a name="5234"></a>
When both operands of an operator <code>&amp;</code>, <code>^</code>, or <code>|</code> are of primitive integral type, binary numeric promotion is first performed on the operands <a href="conversions.doc.html#170983">(&#167;5.6.2)</a>. The type of the bitwise operator expression is the promoted type of the operands.<p>
<a name="5238"></a>
For <code>&amp;</code>, the result value is the bitwise AND of the operand values.<p>
<a name="5239"></a>
For <code>^</code>, the result value is the bitwise exclusive OR of the operand values.<p>
<a name="264605"></a>
For <code>|</code>, the result value is the bitwise inclusive OR of the operand values.<p>
<a name="264610"></a>
For example, the result of the expression <code>0xff00</code> <code>&amp;</code> <code>0xf0f0</code> is <code>0xf000</code>. The result of <code>0xff00</code> <code>^</code> <code>0xf0f0</code> is <code>0x0ff0</code>.The result of <code>0xff00</code> <code>|</code> <code>0xf0f0</code> is <code>0xfff0</code>.<p>
<a name="5242"></a>
<h3>15.22.2    Boolean Logical Operators &amp;, ^, and |</h3>
<a name="5243"></a>
When both operands of a <code>&amp;</code>, <code>^</code>, or <code>|</code> operator are of type <code>boolean</code>, then the type of the bitwise operator expression is <code>boolean</code>.<p>
<a name="5244"></a>
For <code>&amp;</code>, the result value is <code>true</code> if both operand values are <code>true</code>; otherwise, the result is <code>false</code>.<p>
<a name="5245"></a>
For <code>^</code>, the result value is <code>true</code> if the operand values are different; otherwise, the result is <code>false</code>.<p>
<a name="5246"></a>
For <code>|</code>, the result value is <code>false</code> if both operand values are <code>false</code>; otherwise, the result is <code>true</code>.<p>
<a name="5247"></a>
<h2>15.23    Conditional-And Operator &amp;&amp;</h2>
<a name="5248"></a>
The <code>&amp;&amp;</code> operator is like <code>&amp;</code> <a href="expressions.doc.html#5242">(&#167;15.22.2)</a>, but evaluates its right-hand operand only if the value of its left-hand operand is <code>true</code>. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression <code>((</code><i>a</i><code>)&amp;&amp;(</code><i>b</i><code>))&amp;&amp;(</code><i>c</i><code>)</code> produces the same result, with the same side effects occurring in the same order, as evaluation of the expression <code>(</code><i>a</i><code>)&amp;&amp;((</code><i>b</i><code>)&amp;&amp;(</code><i>c</i><code>))</code>.<p>
<ul><pre>
<em>ConditionalAndExpression:
	InclusiveOrExpression
	ConditionalAndExpression &amp;&amp; InclusiveOrExpression
</em></pre></ul><a name="5251"></a>
Each operand of <code>&amp;&amp;</code> must be of type <code>boolean</code>, or a compile-time error occurs. The type of a conditional-and expression is always <code>boolean</code>.<p>
<a name="41086"></a>
At run time, the left-hand operand expression is evaluated first; if its value is <code>false</code>, the value of the conditional-and expression is <code>false</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>true</code>, then the right-hand expression is evaluated and its value becomes the value of the conditional-and expression. Thus, <code>&amp;&amp;</code> computes the same result as <code>&amp;</code> on <code>boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.<p>
<a name="54532"></a>
<h2>15.24    Conditional-Or Operator ||</h2>
<a name="41053"></a>
The <code>||</code> operator is like <code>|</code> <a href="expressions.doc.html#5242">(&#167;15.22.2)</a>, but evaluates its right-hand operand only if the value of its left-hand operand is <code>false</code>. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression <code>((</code><i>a</i><code>)||(</code><i>b</i><code>))||(</code><i>c</i><code>)</code> produces the same result, with the same side effects occurring in the same order, as evaluation of the expression <code>(</code><i>a</i><code>)||((</code><i>b</i><code>)||(</code><i>c</i><code>))</code>.<p>
<ul><pre>
<em>ConditionalOrExpression:
	ConditionalAndExpression
	ConditionalOrExpression || ConditionalAndExpression
</em></pre></ul><a name="41088"></a>
Each operand of <code>||</code> must be of type <code>boolean,</code> or a compile-time error occurs. The type of a conditional-or expression is always <code>boolean</code>.<p>
<a name="264616"></a>
At run time, the left-hand operand expression is evaluated first; if its value is <code>true</code>, the value of the conditional-or expression is <code>true</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>false</code>, then the right-hand expression is evaluated and its value becomes the value of the conditional-or expression. <p>
<a name="290289"></a>
Thus, <code>||</code> computes the same result as <code>|</code> on <code>boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.<p>
<a name="290293"></a>
<h2>15.25    Conditional Operator ?&#32;:</h2>
<a name="5258"></a>
The conditional operator <code>?&#32;:</code> uses the boolean value of one expression to decide which of two other expressions should be evaluated.<p>
<a name="41113"></a>
The conditional operator is syntactically right-associative (it groups right-to-left), so that <code>a?b:c?d:e?f:g</code> means the same as <code>a?b:(c?d:(e?f:g))</code>.<p>
<ul><pre>
<em>ConditionalExpression:
	ConditionalOrExpression
	ConditionalOrExpression ? Expression : ConditionalExpression
</em></pre></ul><a name="236253"></a>
The conditional operator has three operand expressions; <code>?</code> appears between the first and second expressions, and <code>:</code> appears between the second and third expressions.<p>
<a name="40128"></a>
The first expression must be of type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="40129"></a>
The conditional operator may be used to choose between second and third operands of numeric type, or second and third operands of type <code>boolean</code>, or second and third operands that are each of either reference type or the null type. All other cases result in a compile-time error.<p>
<a name="41144"></a>
Note that it is not permitted for either the second or the third operand expression to be an invocation of a <code>void</code> method. In fact, it is not permitted for a conditional expression to appear in any context where an invocation of a <code>void</code> method could appear <a href="statements.doc.html#5984">(&#167;14.8)</a>.<p>
<a name="236267"></a>
The type of a conditional expression is determined as follows:<p>
<ul><a name="41198"></a>
<li>If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.
<a name="236254"></a>
<li>Otherwise, if the second and third operands have numeric type, then there are several cases:
<ul>
<a name="5262"></a>
<li>If one of the operands is of type <code>byte</code> and the other is of type <code>short</code>, then the type of the conditional expression is <code>short</code>.
<a name="5264"></a>
<li>If one of the operands is of type <i>T</i> where <i>T</i> is <code>byte</code>, <code>short</code>, or <code>char</code>, and the other operand is a constant expression of type <code>int</code> whose value is representable in type <i>T</i>, then the type of the conditional expression is <i>T</i>.
<a name="249508"></a>
<li>Otherwise, binary numeric promotion <a href="conversions.doc.html#170983">(&#167;5.6.2)</a> is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands. Note that binary numeric promotion performs value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a>.
</ul>
<a name="249501"></a>
<li>If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
<a name="76547"></a>
<li>If the second and third operands are of different reference types, then it must be possible to convert one of the types to the other type (call this latter type <i>T</i>) by assignment conversion <a href="conversions.doc.html#184206">(&#167;5.2)</a>; the type of the conditional expression is <i>T</i>. It is a compile-time error if neither type is assignment compatible with the other type. 
</ul><a name="40134"></a>
At run time, the first operand expression of the conditional expression is evaluated first; its <code>boolean</code> value is then used to choose either the second or the third operand expression:<p>
<ul><a name="5277"></a>
<li>If the value of the first operand is <code>true</code>, then the second operand expression is chosen.
<a name="5278"></a>
<li>If the value of the first operand is <code>false</code>, then the third operand expression is chosen.
</ul><a name="5279"></a>
The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated above. The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.<p>
<a name="5281"></a>
<h2>15.26    Assignment Operators</h2>
<a name="5282"></a>
There are 12 <em>assignment operators</em>; all are syntactically right-associative (they group right-to-left). Thus, <code>a=b=c</code> means <code>a=(b=c)</code>, which assigns the value of <code>c</code> to <code>b</code> and then assigns the value of <code>b</code> to <code>a</code>.<p>
<ul><pre>
<em>AssignmentExpression:
	ConditionalExpression
	Assignment

Assignment:
	LeftHandSide AssignmentOperator AssignmentExpression

LeftHandSide:
	ExpressionName
	FieldAccess
	ArrayAccess

AssignmentOperator: one of</em>
	=&#32;*=&#32;/=&#32;%=&#32;+=&#32;-=&#32;&lt;&lt;=&#32;&gt;&gt;=&#32;&gt;&gt;&gt;=&#32;&amp;=&#32;^=&#32;|=
</pre></ul><a name="236643"></a>
The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs. This operand may be a named variable, such as a local variable or a field of the current object or class, or it may be a computed variable, as can result from a field access <a href="expressions.doc.html#41267">(&#167;15.11)</a> or an array access <a href="expressions.doc.html#239587">(&#167;15.13)</a>. The type of the assignment expression is the type of the variable.<p>
<a name="41276"></a>
At run time, the result of the assignment expression is the value of the variable after the assignment has occurred. The result of an assignment expression is not itself a variable.<p>
<a name="41365"></a>
A variable that is declared <code>final</code> cannot be assigned to (unless it is a blank final variable <a href="typesValues.doc.html#10931">(&#167;4.5.4)</a>), because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the first operand of an assignment operator.<p>
<a name="5295"></a>
<h3>15.26.1    Simple Assignment Operator =</h3>
<a name="22840"></a>
A compile-time error occurs if the type of the right-hand operand cannot be converted to the type of the variable by assignment conversion <a href="conversions.doc.html#184206">(&#167;5.2)</a>.<p>
<a name="41396"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then three steps are required:<p>
<ul><a name="238369"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="249532"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="265205"></a>
<li>Otherwise, the value of the right-hand operand is converted to the type of the left-hand variable, is subjected to value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable. 
</ul><a name="265215"></a>
If the left-hand operand expression is an array access expression <a href="expressions.doc.html#239587">(&#167;15.13)</a>, then many steps are required:<p>
<ul><a name="238214"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238234"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238236"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238216"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="238217"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>ArrayIndexOutOfBoundsException</code> &#32;is thrown.
<a name="238218"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. This component is a variable; call its type <i>SC</i>. Also, let <i>TC</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="251174"></a>
<li>If <i>TC</i> is a primitive type, then <i>SC</i> is necessarily the same as <i>TC</i>. The value of the right-hand operand is converted to the type of the selected array component, is subjected to value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
<a name="238261"></a>
<li>If <i>TC</i> is a reference type, then <i>SC</i> may not be the same as <i>TC</i>, but rather a type that extends or implements <i>TC</i>. Let <i>RC</i> be the class of the object referred to by the value of the right-hand operand at run time.
<br>
The compiler may be able to prove at compile time that the array component will be of type <i>TC</i> exactly (for example, <i>TC</i> might be <code>final</code>). But if the compiler cannot prove at compile time that the array component will be of type <i>TC</i> exactly, then a check must be performed at run time to ensure that the class <i>RC</i> is assignment compatible <a href="conversions.doc.html#184206">(&#167;5.2)</a> with the actual type <i>SC</i> of the array component. This check is similar to a narrowing cast (<a href="conversions.doc.html#20232">&#167;5.5</a>, <a href="expressions.doc.html#238146">&#167;15.16</a>), except that if the check fails, an <code>ArrayStoreException</code> is thrown rather than a <code>ClassCastException</code>. Therefore:<p>
<ul>
<a name="238321"></a>
<li>If class <i>RC</i> is not assignable to type <i>SC</i>, then no assignment occurs and an <code>ArrayStoreException</code> is thrown.
</ul>
</ul></ul><a name="264626"></a>
Otherwise, the reference value of the right-hand operand is stored into the selected array component.<p>
<a name="238526"></a>
The rules for assignment to an array component are illustrated by the following example program:<p>
<blockquote><pre>class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateSimpleArrayAssignment {
	static Object[] objects = { new Object(), new Object() };
	static Thread[] threads = { new Thread(), new Thread() };
	static Object[] arrayThrow() {
		throw new ArrayReferenceThrow();
	}
	static int indexThrow() { throw new IndexThrow(); }
	static Thread rightThrow() {
		throw new RightHandSideThrow();
	}
	static String name(Object q) {
		String sq = q.getClass().getName();
		int k = sq.lastIndexOf('.');
		return (k &lt; 0) ? sq : sq.substring(k+1);
	}
	static void testFour(Object[] x, int j, Object y) {
		String sx = x == null ? "null" : name(x[0]) + "s";
		String sy = name(y);
		System.out.println();
		try {
			System.out.print(sx + "[throw]=throw =&gt; ");
			x[indexThrow()] = rightThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[throw]=" + sy + " =&gt; ");
			x[indexThrow()] = y;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[" + j + "]=throw =&gt; ");
			x[j] = rightThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[" + j + "]=" + sy + " =&gt; ");
			x[j] = y;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
	}
	public static void main(String[] args) {
		try {
			System.out.print("throw[throw]=throw =&gt; ");
			arrayThrow()[indexThrow()] = rightThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[throw]=Thread =&gt; ");
			arrayThrow()[indexThrow()] = new Thread();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]=throw =&gt; ");
			arrayThrow()[1] = rightThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]=Thread =&gt; ");
			arrayThrow()[1] = new Thread();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		testFour(null, 1, new StringBuffer());
		testFour(null, 1, new StringBuffer());
		testFour(null, 9, new Thread());
		testFour(null, 9, new Thread());
		testFour(objects, 1, new StringBuffer());
		testFour(objects, 1, new Thread());
		testFour(objects, 9, new StringBuffer());
		testFour(objects, 9, new Thread());
		testFour(threads, 1, new StringBuffer());
		testFour(threads, 1, new Thread());
		testFour(threads, 9, new StringBuffer());
		testFour(threads, 9, new Thread());
	}
}
</pre></blockquote><a name="238532"></a>
This program prints:<p>
<blockquote><pre>throw[throw]=throw =&gt; ArrayReferenceThrow
throw[throw]=Thread =&gt; ArrayReferenceThrow
throw[1]=throw =&gt; ArrayReferenceThrow
throw[1]=Thread =&gt; ArrayReferenceThrow
null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=StringBuffer =&gt; Okay!
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=Thread =&gt; Okay!
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=Thread =&gt; ArrayIndexOutOfBoundsException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=StringBuffer =&gt; ArrayStoreException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=Thread =&gt; Okay!
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=Thread =&gt; ArrayIndexOutOfBoundsException
</pre></blockquote><a name="238840"></a>
The most interesting case of the lot is the one thirteenth from the end:<p>
<blockquote><pre>Threads[1]=StringBuffer =&gt; ArrayStoreException
</pre></blockquote><a name="264631"></a>
which indicates that the attempt to store a reference to a <code>StringBuffer</code> into an array whose components are of type <code>Thread</code> throws an <code>ArrayStoreException</code>. The code is type-correct at compile time: the assignment has a left-hand side of type <code>Object[]</code> and a right-hand side of type <code>Object</code>. At run time, the first actual argument to method <code>testFour</code> is a reference to an instance of "array of <code>Thread</code>" and the third actual argument is a reference to an instance of class <code>StringBuffer</code>.<p>
<a name="5304"></a>
<h3>15.26.2    Compound Assignment Operators</h3>
<a name="5305"></a>
All compound assignment operators require both operands to be of primitive type, except for <code>+=</code>, which allows the right-hand operand to be of any type if the left-hand operand is of type <code>String</code>.<p>
<a name="5306"></a>
A compound assignment expression of the form <i>E1</i> <i>op</i>= <i>E2</i> is equivalent to <i>E1</i> &#32;<code>=</code> &#32;<code>(</code><i>T</i><code>)((</code><i>E1</i><code>)</code> <i>op</i> <code>(</code><i>E2</i><code>))</code>, where <i>T</i> is the type of <i>E1</i>, except that <i>E1</i> is evaluated only once. Note that the implied cast to type <i>T</i> may be either an identity conversion <a href="conversions.doc.html#25209">(&#167;5.1.1)</a> or a narrowing primitive conversion <a href="conversions.doc.html#25363">(&#167;5.1.3)</a>. For example, the following code is correct:<p>
<pre><a name="236396"></a>
short x = 3;
<a name="236397"></a>x += 4.6;
</pre><a name="236398"></a>
and results in <code>x</code> having the value <code>7</code> because it is equivalent to:<p>
<pre><a name="236400"></a>
short x = 3;
<a name="249528"></a>x = (short)(x + 4.6);
</pre><a name="249529"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:<p>
<ul><a name="238396"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="238397"></a>
<li>Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238433"></a>
<li>Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="expressions.doc.html#5047">&#167;15.17.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="251178"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.
</ul><a name="238402"></a>
If the left-hand operand expression is an array access expression <a href="expressions.doc.html#239587">(&#167;15.13)</a>, then many steps are required:<p>
<ul><a name="238403"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238404"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238449"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="238450"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>ArrayIndexOutOfBoundsException</code> &#32;is thrown.
<a name="238405"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. (For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.)
<a name="238408"></a>
<li>Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type <i>S</i>. Also, let <i>T</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="238409"></a>
<li>If <i>T</i> is a primitive type, then <i>S</i> is necessarily the same as <i>T</i>.
<ul>
<a name="238472"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="expressions.doc.html#5047">&#167;15.17.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="251182"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the selected array component, subjected to value set conversion <a href="conversions.doc.html#184225">(&#167;5.1.8)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
</ul>
<a name="238410"></a>
<li>If <i>T</i> is a reference type, then it must be <code>String</code>. Because class <code>String</code> is a <code>final</code> class, <i>S</i> must also be <code>String</code>. Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
<ul>
<a name="238488"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily <code>+=</code>). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
</ul>
</ul>
</ul><a name="264636"></a>
Otherwise, the <code>String</code> result of the binary operation is stored into the array component.<p>
<a name="238860"></a>
The rules for compound assignment to an array component are illustrated by the following example program:<p>
<blockquote><pre>class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateCompoundArrayAssignment {
	static String[] strings = { "Simon", "Garfunkel" };
	static double[] doubles = { Math.E, Math.PI };
	static String[] stringsThrow() {
		throw new ArrayReferenceThrow();
	}
	static double[] doublesThrow() {
		throw new ArrayReferenceThrow();
	}
	static int indexThrow() { throw new IndexThrow(); }
	static String stringThrow() {
		throw new RightHandSideThrow();
	}
	static double doubleThrow() {
		throw new RightHandSideThrow();
	}
	static String name(Object q) {
		String sq = q.getClass().getName();
		int k = sq.lastIndexOf('.');
		return (k &lt; 0) ? sq : sq.substring(k+1);
	}
	static void testEight(String[] x, double[] z, int j) {
		String sx = (x == null) ? "null" : "Strings";
		String sz = (z == null) ? "null" : "doubles";
		System.out.println();
		try {
			System.out.print(sx + "[throw]+=throw =&gt; ");
			x[indexThrow()] += stringThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sz + "[throw]+=throw =&gt; ");
			z[indexThrow()] += doubleThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
			x[indexThrow()] += "heh";
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sz + "[throw]+=12345 =&gt; ");
			z[indexThrow()] += 12345;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[" + j + "]+=throw =&gt; ");
			x[j] += stringThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sz + "[" + j + "]+=throw =&gt; ");
			z[j] += doubleThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
			x[j] += "heh";
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
			z[j] += 12345;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
	}
	public static void main(String[] args) {
		try {
			System.out.print("throw[throw]+=throw =&gt; ");
			stringsThrow()[indexThrow()] += stringThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[throw]+=throw =&gt; ");
			doublesThrow()[indexThrow()] += doubleThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[throw]+=\"heh\" =&gt; ");
			stringsThrow()[indexThrow()] += "heh";
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[throw]+=12345 =&gt; ");
			doublesThrow()[indexThrow()] += 12345;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]+=throw =&gt; ");
			stringsThrow()[1] += stringThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]+=throw =&gt; ");
			doublesThrow()[1] += doubleThrow();
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]+=\"heh\" =&gt; ");
			stringsThrow()[1] += "heh";
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		try {
			System.out.print("throw[1]+=12345 =&gt; ");
			doublesThrow()[1] += 12345;
			System.out.println("Okay!");
		} catch (Throwable e) { System.out.println(name(e)); }
		testEight(null, null, 1);
		testEight(null, null, 9);
		testEight(strings, doubles, 1);
		testEight(strings, doubles, 9);
	}
}
</pre></blockquote><a name="238992"></a>
This program prints:<p>
<blockquote><pre>throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+="heh" =&gt; ArrayReferenceThrow
throw[throw]+=12345 =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+="heh" =&gt; ArrayReferenceThrow
throw[1]+=12345 =&gt; ArrayReferenceThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[1]+=throw =&gt; NullPointerException
null[1]+=throw =&gt; NullPointerException
null[1]+="heh" =&gt; NullPointerException
null[1]+=12345 =&gt; NullPointerException
null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[9]+=throw =&gt; NullPointerException
null[9]+=throw =&gt; NullPointerException
null[9]+="heh" =&gt; NullPointerException
null[9]+=12345 =&gt; NullPointerException
Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
Strings[1]+="heh" =&gt; Okay!
doubles[1]+=12345 =&gt; Okay!
Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[9]+=throw =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=throw =&gt; ArrayIndexOutOfBoundsException
Strings[9]+="heh" =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=12345 =&gt; ArrayIndexOutOfBoundsException
</pre></blockquote><a name="239051"></a>
The most interesting cases of the lot are tenth and eleventh from the end:<p>
<blockquote><pre>Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
</pre></blockquote><a name="238861"></a>
They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot. This demonstrates that the evaluation of the right-hand operand indeed occurs after the checks for a null array reference value and an out-of-bounds index value.<p>
<a name="240007"></a>
The following program illustrates the fact that the value of the left-hand side of a compound assignment is saved before the right-hand side is evaluated:<p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int k = 1;
		int[] a = { 1 };
		k += (k = 4) * (k + 2);
		a[0] += (a[0] = 4) * (a[0] + 2);
		System.out.println("k==" + k + " and a[0]==" + a[0]);
	}
}
</pre></blockquote><a name="240021"></a>
This program prints:<p>
<blockquote><pre>k==25 and a[0]==25
</pre></blockquote><a name="240027"></a>
The value <code>1</code> of <code>k</code> is saved by the compound assignment operator <code>+=</code> before its right-hand operand <code>(k</code> <code>=</code> <code>4)</code> <code>*</code> <code>(k</code> <code>+</code> <code>2)</code> is evaluated. Evaluation of this right-hand operand then assigns <code>4</code> to <code>k</code>, calculates the value <code>6</code> for <code>k</code> <code>+</code> <code>2</code>, and then multiplies <code>4</code> &#32;by &#32;<code>6</code> to get <code>24</code>. This is added to the saved value <code>1</code> to get <code>25</code>, which is then stored into <code>k</code> by the <code>+=</code> operator. An identical analysis applies to the case that uses <code>a[0]</code>. In short, the statements<p>
<blockquote><pre>k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);
</pre></blockquote><a name="240066"></a>
behave in exactly the same manner as the statements:<p>
<blockquote><pre>k = k + (k = 4) * (k + 2);
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre></blockquote><a name="5308"></a>
<h2>15.27    Expression</h2>
<a name="5309"></a>
An <em>Expression</em> is any assignment expression:<p>
<ul><pre>
<em>Expression:
	AssignmentExpression</em>
</ul></pre>
<a name="264651"></a>
Unlike C and C++, the Java programming language has no comma operator.<p>
</pre></ul><a name="5313"></a>
<h2>15.28    Constant Expression</h2>
<ul><pre>
<em>ConstantExpression:
	Expression</em>
</pre></ul><a name="5314"></a>
A compile-time <em>constant expression</em> is an expression denoting a value of primitive type or a <code>String</code> that is composed using only the following:<p>
<ul><a name="236320"></a>
<li>Literals of primitive type and literals of type <code>String</code>
<a name="236323"></a>
<li>Casts to primitive types and casts to type <code>String</code>
<a name="236324"></a>
<li>The unary operators <code>+</code>, <code>-</code>, <code>~</code>, and <code>! </code>(but not <code>++</code> or <code>--</code>)
<a name="239222"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code>
<a name="239261"></a>
<li>The additive operators <code>+</code> and <code>-</code>
<a name="239263"></a>
<li>The shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>
<a name="239226"></a>
<li>The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;= </code>(but not <code>instanceof</code>)
<a name="239228"></a>
<li>The equality operators <code>==</code> and <code>!=</code>
<a name="239255"></a>
<li>The bitwise and logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code>
<a name="239257"></a>
<li>The conditional-and operator <code>&amp;&amp;</code> and the conditional-or operator <code>||</code>
<a name="236327"></a>
<li>The ternary conditional operator <code>?</code>&#32;<code>:</code>
<a name="8720"></a>
<li>Simple names that refer to <code>final</code> variables whose initializers are constant expressions
<a name="239286"></a>
<li>Qualified names of the form <em>TypeName</em> <code>.</code> <em>Identifier</em> that refer to <code>final</code> variables whose initializers are constant expressions
</ul><a name="5315"></a>
Compile-time constant expressions are used in <code>case</code> labels in <code>switch</code> statements <a href="statements.doc.html#35518">(&#167;14.10)</a> and have a special significance for assignment conversion <a href="conversions.doc.html#184206">(&#167;5.2)</a>.<p>
<a name="264656"></a>
A compile-time constant expression is always treated as FP-strict <a href="expressions.doc.html#249198">(&#167;15.4)</a>, even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.<p>
<a name="236407"></a>
Examples of constant expressions:<p>
<blockquote><pre>true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI
"The integer " + Long.MAX_VALUE + " is mighty big."
</pre></blockquote>

<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="statements.doc.html">Prev</a> | <a href="defAssign.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
