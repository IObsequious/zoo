<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<title>XML Path Language (XPath) 2.0</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
      
table.small    { font-size: x-small; }
/*]]>*/
</style>
<link type="text/css" rel="stylesheet" href=
"http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src=
"http://www.w3.org/Icons/w3c_home" /></a></p>
<h1><a id="title" name="title"></a>XML Path Language (XPath) 2.0</h1>
<h2><a id="w3c-doctype" name="w3c-doctype"></a>W3C Working Draft 12 November
2003</h2>
<dl>
<dt>This version:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/2003/WD-xpath20-20031112">http://www.w3.org/TR/2003/WD-xpath20-20031112</a></span></dd>
<dt>Latest version:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></dd>
<dt>Previous versions:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/2003/WD-xpath20-20030822/">http://www.w3.org/TR/2003/WD-xpath20-20030822/</a></span>
<span class="xpath"><a href=
"http://www.w3.org/TR/2003/WD-xpath20-20030502/">http://www.w3.org/TR/2003/WD-xpath20-20030502/</a></span>
<span class="xpath"><a href=
"http://www.w3.org/TR/2002/WD-xpath20-20021115/">http://www.w3.org/TR/2002/WD-xpath20-20021115/</a></span>
<span class="xpath"><a href=
"http://www.w3.org/TR/2002/WD-xpath20-20020816/">http://www.w3.org/TR/2002/WD-xpath20-20020816/</a></span></dd>
<dt>Editors:</dt>
<dd class="xpath">Anders Berglund (XSL WG), IBM Research <a href=
"mailto:%20alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd>
<dd>Scott Boag (XSL WG), IBM Research <a href=
"mailto:%20scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>
<dd>Don Chamberlin (XML Query WG), IBM Almaden Research Center <a href=
"mailto:%20chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>
<dd>Mary F. Fernández (XML Query WG), AT&amp;T Labs <a href=
"mailto:%20mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>
<dd class="xpath">Michael Kay (XSL WG), Software AG <a href=
"mailto:%20Michael.Kay@softwareag.com">&lt;Michael.Kay@softwareag.com&gt;</a></dd>
<dd>Jonathan Robie (XML Query WG), DataDirect Technologies <a href=
"mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>
<dd>Jérôme Siméon (XML Query WG), Bell Labs, Lucent Technologies <a href=
"mailto:%20simeon@research.bell-labs.com">&lt;simeon@research.bell-labs.com&gt;</a></dd>
</dl>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2003&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.lcs.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>,
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> and <a href=
"http://www.w3.org/Consortium/Legal/copyright-software">software
licensing</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a id="abstract" name="abstract"></a>Abstract</h2>
<div class="xpath">
<p class="xpath">XPath 2.0 is an expression language that allows the
processing of values conforming to the data model defined in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The data model
provides a tree representation of XML documents as well as atomic values such
as integers, strings, and booleans, and sequences that may contain both
references to nodes in an XML document and atomic values. The result of an
XPath expression may be a selection of nodes from the input documents, or an
atomic value, or more generally, any sequence allowed by the data model. The
name of the language derives from its most distinctive feature, the path
expression, which provides a means of hierarchic addressing of the nodes in
an XML tree. XPath 2.0 is a superset of <a href="#XPath">[XPath 1.0]</a>,
with the added capability to support a richer set of data types, and to take
advantage of the type information that becomes available when documents are
validated using XML Schema. A backwards compatibility mode is provided to
ensure that nearly all XPath 1.0 expressions continue to deliver the same
result with XPath 2.0; exceptions to this policy are noted in [<a href=
"#id-backwards-compatibility"><b>H Backwards Compatibility with XPath
1.0</b></a>].</p>
</div>
</div>
<div>
<h2><a id="status" name="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current
W3C publications and the latest revision of this technical report can be
found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a>
at http://www.w3.org/TR/.</em></p>
<p>This is a public W3C Working Draft for review by W3C Members and other
interested parties. Publication as a Working Draft does not imply endorsement
by the W3C Membership. This is a draft document and may be updated, replaced
or obsoleted by other documents at any time. It is inappropriate to cite this
document as other than work in progress.</p>
<p>XPath 2.0 has been defined jointly by the <a href=
"http://www.w3.org/XML/Query">XML Query Working Group</a> and the <a href=
"http://www.w3.org/Style/XSL/">XSL Working Group</a> (both part of the
<a href="http://www.w3.org/XML/Activity.html">XML Activity</a>). The XPath
2.0 and XQuery 1.0 Working Drafts are generated from a common source. These
languages are closely related, sharing much of the same expression syntax and
semantics, and much of the text found in the two Working Drafts is
identical.</p>
<p>This version contains several changes. The section entitled "SequenceType
Matching" has been rewritten and includes new material on handling of
unrecognized types. A new concrete type, <code>xdt:untypedAny</code>, has
been introduced, and the <code>isnot</code> comparison operator has been
removed. Rules for static and dynamic implementations have been clarified. A
complete list of changes can be found in <a href="#id-revisions-log"><b>J
Revision Log</b></a>.</p>
<p>This is a <span class="force"><a href=
"http://www.w3.org/2003/06/Process-20030618/tr.html#last-call">Last Call
Working Draft</a></span>. Comments on this document are due on 15 February
2004. Comments should be sent to the W3C mailing list <span class=
"force"><a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a></span>
(archived at <span class="force"><a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a></span>)
with <span class="xpath"><span class="xpath">[XPath]</span></span> at the
beginning of the subject field.</p>
<p>Patent disclosures relevant to this specification may be found on the XML
Query Working Group's patent disclosure page at <a href=
"http://www.w3.org/2002/08/xmlquery-IPR-statements">http://www.w3.org/2002/08/xmlquery-IPR-statements</a>
and the XSL Working Group's patent disclosure page at <a href=
"http://www.w3.org/Style/XSL/Disclosures">http://www.w3.org/Style/XSL/Disclosures</a>.</p>
</div>
<div class="toc">
<h2><a id="contents" name="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">Introduction</a><br />
2 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#context">Expression Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#id-processing-model">Processing
Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#id-data-model-generation">Data Model Generation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#id-schema-import-processing">Schema Import Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#id-expression-processing">Expression Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1
<a href="#id-static-analysis">Static Analysis Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2
<a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#id-serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
"#id-consistency-constraints">Consistency Constraints</a><br />
&#160;&#160;&#160;&#160;2.3 <a href=
"#id-important-concepts">Documents</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#N1079B">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;2.4 <a href="#id-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#id-predefined-types">Predefined Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#id-sequencetype-syntax">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href=
"#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.1
<a href="#id-matching-value">Matching a SequenceType and a Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.2
<a href="#id-matching-item">Matching an ItemType and an Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.3
<a href="#id-matching-elem">Matching an ElementTest and an Element
Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.4
<a href="#id-matching-attr">Matching an AttributeTest and an Attribute
Node</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#errors">Error Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
"#id-kinds-of-errors">Kinds of Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
"#id-handling-dynamic">Handling Dynamic Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
"#id-errors-and-opt">Errors and Optimization</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#id-optional-features">Optional
Features</a><br />
3 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#id-primary-expressions">Primary
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
"#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
"#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href=
"#id-function-calls">Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.6 <a href=
"#comments">XPath Comments</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#id-path-expressions">Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#id-axis-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.1
<a href="#axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.2
<a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#id-predicates">Predicates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
"#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#id-sequence-expressions">Sequence
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
"#construct_seq">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
"#combining_seq">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#id-arithmetic">Arithmetic
Expressions</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#id-comparisons">Comparison
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href=
"#id-value-comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href=
"#id-general-comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href=
"#id-node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#id-logical-expressions">Logical
Expressions</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#id-for-expressions">For
Expressions</a><br />
&#160;&#160;&#160;&#160;3.8 <a href="#id-conditionals">Conditional
Expressions</a><br />
&#160;&#160;&#160;&#160;3.9 <a href="#id-quantified-expressions">Quantified
Expressions</a><br />
&#160;&#160;&#160;&#160;3.10 <a href=
"#id-expressions-on-datatypes">Expressions on SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
"#id-instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
"#id-cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href=
"#id-castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a href=
"#id-constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a href=
"#id-treat">Treat</a></p>
<h3><a id="appendices" name="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XPath Grammar</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#id-grammar">EBNF</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href=
"#notes-on-parsing">Grammar Notes</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#lexical-structure">Lexical
structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href=
"#whitespace-rules">White Space Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href=
"#id-lexical-states">Lexical Rules</a><br />
&#160;&#160;&#160;&#160;A.3 <a href="#id-reserved-fn-names">Reserved Function
Names</a><br />
&#160;&#160;&#160;&#160;A.4 <a href="#id-precedence-order">Precedence
Order</a><br />
B <a href="#N133DF">Type Promotion and Operator Mapping</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type Promotion</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator Mapping</a><br />
C <a href="#id-xp-context-components">Context Components</a><br />
&#160;&#160;&#160;&#160;C.1 <a href="#id-xp-static-context-components">Static
Context Components</a><br />
&#160;&#160;&#160;&#160;C.2 <a href=
"#id-xp-evaluation-context-components">Dynamic Context Components</a><br />
D <a href="#id-references">References</a><br />
&#160;&#160;&#160;&#160;D.1 <a href="#id-normative-references">Normative
References</a><br />
&#160;&#160;&#160;&#160;D.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;D.3 <a href="#id-informative-material">Non-normative
Informative Material</a><br />
E <a href="#id-glossary">Glossary</a><br />
F <a href="#id-errors">Summary of Error Conditions</a><br />
G <a href="#N141EC">Conformance</a><br />
H <a href="#id-backwards-compatibility">Backwards Compatibility with XPath
1.0</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;H.1 <a href="#N1420E">Incompatibilities when
Compatibility Mode is true</a><br />
&#160;&#160;&#160;&#160;H.2 <a href="#N142AA">Incompatibilities when
Compatibility Mode is false</a><br />
&#160;&#160;&#160;&#160;H.3 <a href="#N142DB">Incompatibilities when using a
Schema</a><br />
I <a href="#id-issues">XPath 2.0 and XQuery 1.0 Issues</a>
(Non-Normative)<br />
J <a href="#id-revisions-log">Revision Log</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href="#N14314">12 November 2003</a></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a id="id-introduction" name="id-introduction"></a>1 Introduction</h2>
<div class="xpath">
<p class="xpath">The primary purpose of XPath is to address the nodes of
<a href="#XML">[XML 1.0]</a> trees. XPath gets its name from its use of a
path notation for navigating through the hierarchical structure of an XML
document. XPath uses a compact, non-XML syntax to facilitate use of XPath
within URIs and XML attribute values.</p>
</div>
<p>[<a title="data model" id="dt-datamodel" name=
"dt-datamodel">Definition</a>: XPath operates on the abstract, logical
structure of an XML document, rather than its surface syntax. This logical
structure is known as the <b>data model</b>, which is defined in the <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> document.]</p>
<div class="xpath">
<p class="xpath">XPath is designed to be embedded in a <b>host language</b>
such as <a href="#XSLT">[XSLT 2.0]</a> or <a href="#xquery">[XQuery]</a>.
XPath has a natural subset that can be used for matching (testing whether or
not a node matches a pattern); this use of XPath is described in <a href=
"#XSLT">[XSLT 2.0]</a>.</p>
</div>
<p>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression
that is syntactically valid and executes successfully in both XPath 2.0 and
XQuery 1.0 will return the same result in both languages. Since these
languages are so closely related, their grammars and language descriptions
are generated from a common source to ensure consistency, and the editors of
these specifications work together closely.</p>
<p>XPath also depends on and is closely related to the following
specifications:</p>
<ul>
<li>
<p><a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> defines the
data model that underlies all XPath expressions.</p>
</li>
<li>
<p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a> defines the static semantics of XPath and also contains a
formal but non-normative description of the dynamic semantics that may be
useful for implementors and others who require a formal definition.</p>
</li>
<li>
<p>The type system of XPath is based on <a href="#XMLSchema">[XML
Schema]</a>.</p>
</li>
<li>
<p>The default function library and the operators supported by XPath are
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>.</p>
</li>
</ul>
<p>This document specifies a grammar for XPath, using the same Basic EBNF
notation used in <a href="#XML">[XML 1.0]</a>, except that grammar symbols
always have initial capital letters. Unless otherwise noted (see <a href=
"#lexical-structure"><b>A.2 Lexical structure</b></a>), whitespace is not
significant in the grammar. Grammar productions are introduced together with
the features that they describe, and a complete grammar is also presented in
the appendix [<a href="#nt-bnf"><b>A XPath Grammar</b></a>]. The appendix
should be regarded as the normative version.</p>
<p>In the grammar productions in this document, nonterminal symbols are
underlined and literal text is enclosed in double quotes. Certain productions
(including the productions that define DecimalLiteral, DoubleLiteral, and
StringLiteral) employ a regular-expression notation. The following example
production describes the syntax of a function call:</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="fakeid_doc-xpath-FunctionCall" name=
"fakeid_doc-xpath-FunctionCall"></a>[60]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>The production should be read as follows: A function call consists of a
QName followed by an open-parenthesis. The open-parenthesis is followed by an
optional argument list. The argument list (if present) consists of one or
more expressions, separated by commas. The optional argument list is followed
by a close-parenthesis.</p>
<p>Certain aspects of language processing are described in this specification
as <b>implementation-defined</b> or <b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a title="implementation defined" id="dt-implementation-defined" name=
"dt-implementation-defined">Definition</a>: <b>Implementation-defined</b>
indicates an aspect that may differ between implementations, but must be
specified by the implementor for each particular implementation.]</p>
</li>
<li>
<p>[<a title="implementation dependent" id="dt-implementation-dependent"
name="dt-implementation-dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ between
implementations, is not specified by this or any W3C specification, and is
not required to be specified by the implementor for any particular
implementation.]</p>
</li>
</ul>
<div class="xpath">
<p class="xpath">A language aspect described in this specification as
<b>implementation-defined</b> or <b>implementation dependent</b> may be
further constrained by the specifications of a host language in which XPath
is embedded.</p>
</div>
<p>This document normatively defines the dynamic semantics of XPath. The
static semantics of XPath are normatively defined in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>. In
this document, examples and material labeled as "Note" are provided for
explanatory purposes and are not normative.</p>
</div>
<div class="div1">
<h2><a id="id-basics" name="id-basics"></a>2 Basics</h2>
<p>The basic building block of XPath is the <b>expression</b>, which is a
string of Unicode characters. The language provides several kinds of
expressions which may be constructed from keywords, symbols, and operands. In
general, the operands of an expression are other expressions. [<a title=
"functional langauge" id="dt-functional-language" name=
"dt-functional-language">Definition</a>: XPath is a <b>functional
language</b>, which means that expressions can be nested with full
generality. ] [<a title="strongly typed" id="dt-strongly-typed" name=
"dt-strongly-typed">Definition</a>: XPath is also a <b>strongly-typed
language</b> in which the operands of various expressions, operators, and
functions must conform to the expected types.]</p>
<p>Like XML, XPath is a case-sensitive language. Keywords in XPath use
lower-case characters and are not reserved&#8212;that is, names in XPath
expressions are allowed to be the same as language keywords&#8212;except for
the list of reserved function-names in <a href="#id-reserved-fn-names"><b>A.3
Reserved Function Names</b></a>.</p>
<p>The value of an expression is always a <a title="sequence" href=
"#dt-sequence">sequence</a>. [<a title="sequence" id="dt-sequence" name=
"dt-sequence">Definition</a>: A <b>sequence</b> is an ordered collection of
zero or more <a title="item" href="#dt-item">items</a>.] [<a title="item" id=
"dt-item" name="dt-item">Definition</a>: An <b>item</b> is either an
<a title="atomic value" href="#dt-atomic-value">atomic value</a> or a
<a title="node" href="#dt-node">node</a>.] [<a title="atomic value" id=
"dt-atomic-value" name="dt-atomic-value">Definition</a>: An <b>atomic
value</b> is a value in the value space of an XML Schema <b>atomic type</b>,
as defined in <a href="#XMLSchema">[XML Schema]</a> (that is, a simple type
that is not a list type or a union type).] [<a title="node" id="dt-node"
name="dt-node">Definition</a>: A <b>node</b> is an instance of one of the
seven <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0 and XPath
2.0 Data Model]</a>.] Each node has a unique <b>node identity</b>. Some kinds
of nodes have typed values, string values, and names, which can be extracted
from the node. The <b>typed value</b> of a node is a sequence of zero or more
atomic values. The <b>string value</b> of a node is a value of type
<code>xs:string</code>. The <b>name</b> of a node is a value of type
<code>xs:QName</code>.</p>
<p>[<a title="singleton sequence" id="dt-singleton-sequence" name=
"dt-singleton-sequence">Definition</a>: A sequence containing exactly one
item is called a <b>singleton sequence</b>.] An item is identical to a
singleton sequence containing that item. Sequences are never nested&#8212;for
example, combining the values 1, (2, 3), and ( ) into a single sequence
results in the sequence (1, 2, 3). [<a title="empty sequence" id=
"dt-empty-sequence" name="dt-empty-sequence">Definition</a>: A sequence
containing zero items is called an <b>empty sequence</b>.]</p>
<p>Names in XPath conform to the syntax in <a href="#XMLNAMES">[XML
Names]</a>. This document uses the following namespace prefixes<span class=
"xpath"><span class="xpath">(these prefix bindings are illustrative rather
than normative)</span></span>:</p>
<ul>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2003/11/xpath-functions</code></p>
</li>
<li>
<p><code>xdt = http://www.w3.org/2003/11/xpath-datatypes</code></p>
</li>
</ul>
<p>In some cases, where the meaning is clear and namespaces are not important
to the discussion, built-in XML Schema typenames such as <code>integer</code>
and <code>string</code> are used without a namespace prefix.</p>
<div class="div2">
<h3><a id="context" name="context"></a>2.1 Expression Context</h3>
<p>[<a title="expression context" id="dt-expression-context" name=
"dt-expression-context">Definition</a>: The <b>expression context</b> for a
given expression consists of all the information that can affect the result
of the expression.] This information is organized into two categories called
the <a title="static context" href="#dt-static-context">static context</a>
and the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a>.</p>
<div class="div3">
<h4><a id="static_context" name="static_context"></a>2.1.1 Static
Context</h4>
<p>[<a title="static context" id="dt-static-context" name=
"dt-static-context">Definition</a>: The <b>static context</b> of an
expression is the information that is available during static analysis of the
expression, prior to its evaluation.] This information can be used to decide
whether the expression contains a <a title="static error" href=
"#dt-static-error">static error</a>. If analysis of an expression relies on
some component of the <a title="static context" href=
"#dt-static-context">static context</a> that has not been assigned a value, a
<a title="static error" href="#dt-static-error">static error</a> is
raised.[<a title="err:XP0001" href="#ERRXP0001">err:XP0001</a>]</p>
<p>The individual components of the <a title="static context" href=
"#dt-static-context">static context</a> are summarized below. Further rules
governing the semantics of these components can be found in <a href=
"#id-xp-static-context-components"><b>C.1 Static Context
Components</b></a>.</p>
<ul>
<li>
<p>[<a title="XPath 1.0 compatibility mode" id="dt-xpath-compat-mode" name=
"dt-xpath-compat-mode">Definition</a>: <b>XPath 1.0 compatibility mode.</b>
<span class="xpath"><span class="xpath">This value is <code>true</code> if
rules for backward compatibility with XPath Version 1.0 are in effect;
otherwise it is <code>false</code>.</span></span>]</p>
</li>
<li>
<p>[<a title="in-scope namespaces" id="dt-is-namespaces" name=
"dt-is-namespaces">Definition</a>: <b>In-scope namespaces.</b> This is a set
of (prefix, URI) pairs. The in-scope namespaces are used for resolving
prefixes used in QNames within the expression.]</p>
</li>
<li>
<p>[<a title="default element/type namespace" id="dt-def-elemtype-ns" name=
"dt-def-elemtype-ns">Definition</a>: <b>Default element/type namespace.</b>
This is a namespace URI. This namespace is used for any unprefixed QName
appearing in a position where an element or type name is expected.] The
initial default element/type namespace may be provided by the external
environment.</p>
</li>
<li>
<p>[<a title="default function namespace" id="dt-def-fn-ns" name=
"dt-def-fn-ns">Definition</a>: <b>Default function namespace.</b> This is a
namespace URI. This namespace URI is used for any unprefixed QName appearing
as the function name in a function call. The initial default function
namespace may be provided by the external environment.]</p>
</li>
<li>
<p>[<a title="in-scope schema definitions" id="dt-issd" name=
"dt-issd">Definition</a>: <b>In-scope schema definitions.</b> This is a
generic term for all the element, attribute, and type definitions that are in
scope during processing of an expression.] It includes the following three
parts:</p>
<ul>
<li>
<p>[<a title="in-scope type definitions" id="dt-is-types" name=
"dt-is-types">Definition</a>: <b>In-scope type definitions.</b> Each named
type definition is identified either by a QName (for a <b>named type</b>) or
by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type identifier
(for an <b>anonymous type</b>). The in-scope type definitions include the
predefined types as described in <a href="#id-predefined-types"><b>2.4.1
Predefined Types</b></a>. ]</p>
</li>
<li>
<p>[<a title="in-scope element declarations" id="dt-is-elems" name=
"dt-is-elems">Definition</a>: <b>In-scope element declarations.</b> Each
element declaration is identified either by a QName (for a top-level element
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). An element declaration includes
information about the <b>substitution groups</b> to which this element
belongs.]</p>
</li>
<li>
<p>[<a title="in-scope attribute declarations" id="dt-is-attrs" name=
"dt-is-attrs">Definition</a>: <b>In-scope attribute declarations.</b> Each
attribute declaration is identified either by a QName (for a top-level
attribute declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> attribute
identifier (for a local attribute declaration). ]</p>
</li>
</ul>
</li>
<li>
<p>[<a title="in-scope variables" id="dt-is-vars" name=
"dt-is-vars">Definition</a>: <b>In-scope variables.</b> This is a set of
(QName, type) pairs. It defines the set of variables that are available for
reference within an expression. The QName is the name of the variable, and
the type is the <a title="static type" href="#dt-static-type">static type</a>
of the variable.]</p>
<p>An expression that binds a variable (such as a <code>for</code>,
<code>some</code>, or <code>every</code> expression) extends the in-scope
variables of its subexpressions with the new bound variable and its type.</p>
</li>
<li>
<p>[<a title="in-scope functions" id="dt-is-funcs" name=
"dt-is-funcs">Definition</a>: <b>In-scope functions.</b> This component
defines the set of functions that are available to be called from within an
expression. Each function is uniquely identified by its expanded QName and
its arity (number of parameters).] [<a title="function signature" id=
"dt-function-signature" name="dt-function-signature">Definition</a>: Each
function has a <b>function signature</b> that specifies the name of the
function and the <a title="static type" href="#dt-static-type">static
types</a> of its parameters and its result.]</p>
<p>The <b>in-scope functions</b> include constructor functions, which are
discussed in <a href="#id-constructor-functions"><b>3.10.4 Constructor
Functions</b></a>.</p>
</li>
<li>
<p>[<a title="in-scope collations" id="dt-is-collations" name=
"dt-is-collations">Definition</a>: <b>In-scope collations.</b> This is a set
of (URI, collation) pairs. It defines the names of the collations that are
available for use in function calls that take a collation name as an
argument.] A collation may be regarded as an object that supports two
functions: a function that given a set of strings, returns a sequence
containing those strings in sorted order; and a function that given two
strings, returns true if they are considered equal, and false if not.</p>
</li>
<li>
<p>[<a title="default collation" id="dt-def-collation" name=
"dt-def-collation">Definition</a>: <b>Default collation.</b> This collation
is used by string comparison functions and operators when no explicit
collation is specified.]</p>
</li>
<li>
<p>[<a title="base URI" id="dt-base-uri" name="dt-base-uri">Definition</a>:
<b>Base URI.</b> This is an absolute URI, used when necessary in the
resolution of relative URIs (for example, by the <code>fn:resolve-uri</code>
function.)]</p>
</li>
<li>
<p>[<a title="statically-known documents" id="dt-known-docs" name=
"dt-known-docs">Definition</a>: <b>Statically-known documents.</b> This is a
mapping from strings onto types. The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function. The type is the type of the document node that would result from
calling the <code>fn:doc</code> function with this URI as its argument. ] If
the argument to <code>fn:doc</code> is not a string literal that is present
in statically-known documents, then the <a title="static type" href=
"#dt-static-type">static type</a> of <code>fn:doc</code> is
<code>document-node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known documents</b> is to provide type
information, not to determine which documents are available. A URI need not
be found in the <b>statically known documents</b> to be accessed using
<code>fn:doc</code>.</p>
</div>
</li>
<li>
<p>[<a title="statically-known collections" id="dt-known-collections" name=
"dt-known-collections">Definition</a>: <b>Statically-known collections.</b>
This is a mapping from strings onto types. The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function. The type is the type of the sequence of
nodes that would result from calling the <code>fn:collection</code> function
with this URI as its argument.] If the argument to <code>fn:collection</code>
is not a string literal that is present in statically-known collections, then
the <a title="static type" href="#dt-static-type">static type</a> of
<code>fn:collection</code> is <code>node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known collections</b> is to provide type
information, not to determine which collections are available. A URI need not
be found in the <b>statically known collections</b> to be accessed using
<code>fn:collection</code>.</p>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="eval_context" name="eval_context"></a>2.1.2 Dynamic Context</h4>
<p>[<a title="dynamic context" id="dt-dynamic-context" name=
"dt-dynamic-context">Definition</a>: The <b>dynamic context</b> of an
expression is defined as information that is available at the time the
expression is evaluated.] If evaluation of an expression relies on some part
of the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a> that has not been assigned a value, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0002"
href="#ERRXP0002">err:XP0002</a>]</p>
<p>The individual components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> are summarized below. Further rules
governing the semantics of these components can be found in <a href=
"#id-xp-evaluation-context-components"><b>C.2 Dynamic Context
Components</b></a>.</p>
<p>The <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a> consists of all the components of the <a title="static context"
href="#dt-static-context">static context</a>, and the additional components
listed below.</p>
<p>[<a title="focus" id="dt-focus" name="dt-focus">Definition</a>: The first
three components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (context item, context position,
and context size) are called the <b>focus</b> of the expression. ] The focus
enables the processor to keep track of which nodes are being processed by the
expression.</p>
<p>Certain language constructs, notably the path expression
<code>E1/E2</code> and the predicate expression <code>E1[E2]</code>, create a
new focus for the evaluation of a sub-expression. In these constructs,
<code>E2</code> is evaluated once for each item in the sequence that results
from evaluating <code>E1</code>. Each time <code>E2</code> is evaluated, it
is evaluated with a different focus. The focus for evaluating <code>E2</code>
is referred to below as the <b>inner focus</b>, while the focus for
evaluating <code>E1</code> is referred to as the <b>outer focus</b>. The
inner focus exists only while <code>E2</code> is being evaluated. When this
evaluation is complete, evaluation of the containing expression continues
with its original focus unchanged.</p>
<ul>
<li>
<p>[<a title="context item" id="dt-context-item" name=
"dt-context-item">Definition</a>: The <b>context item</b> is the item
currently being processed in a path expression. An item is either an atomic
value or a node.][<a title="context node" id="dt-context-node" name=
"dt-context-node">Definition</a>: When the context item is a node, it can
also be referred to as the <b>context node</b>.] The context item is returned
by the expression "<code>.</code>". When an expression <code>E1/E2</code> or
<code>E1[E2]</code> is evaluated, each item in the sequence obtained by
evaluating <code>E1</code> becomes the context item in the inner focus for an
evaluation of <code>E2</code>.</p>
</li>
<li>
<p>[<a title="context position" id="dt-context-position" name=
"dt-context-position">Definition</a>: The <b>context position</b> is the
position of the context item within the sequence of items currently being
processed in a path expression. ]It changes whenever the context item
changes. Its value is always an integer greater than zero. The context
position is returned by the expression <code>fn:position()</code>. When an
expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the
context position in the inner focus for an evaluation of <code>E2</code> is
the position of the context item in the sequence obtained by evaluating
<code>E1</code>. The position of the first item in a sequence is always 1
(one). The context position is always less than or equal to the context
size.</p>
</li>
<li>
<p>[<a title="context size" id="dt-context-size" name=
"dt-context-size">Definition</a>: The <b>context size</b> is the number of
items in the sequence of items currently being processed in a path
expression.] Its value is always an integer greater than zero. The context
size is returned by the expression <code>fn:last()</code>. When an expression
<code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in
the inner focus for an evaluation of <code>E2</code> is the number of items
in the sequence obtained by evaluating <code>E1</code>.</p>
</li>
<li>
<p>[<a title="Dynamic variables" id="dt-dyn-vars" name=
"dt-dyn-vars">Definition</a>: <b>Dynamic variables</b>. This is a set of
(QName, value) pairs. It contains the same QNames as the <a title=
"in-scope variables" href="#dt-is-vars">in-scope variables</a> in the
<a title="static context" href="#dt-static-context">static context</a> for
the expression. The QName is the name of the variable and the value is the
dynamic value of the variable.]</p>
</li>
<li>
<p>[<a title="function implementation" id="dt-function-implementation" name=
"dt-function-implementation">Definition</a>: <b>Function implementations</b>.
Each function in <a title="in-scope functions" href="#dt-is-funcs">in-scope
functions</a> has a function implementation that enables the function to map
instances of its parameter types into an instance of its result type. ]</p>
</li>
<li>
<p>[<a title="current date and time" id="dt-date-time" name=
"dt-date-time">Definition</a>: <b>Current date and time.</b> This information
represents an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point in time
during processing of a query or transformation. It can be retrieved by the
<code>fn:current-date</code>, <code>fn:current-time</code>, and
<code>fn:current-dateTime</code> functions. If invoked multiple times during
the execution of a query or transformation, these functions always return the
same result.]</p>
</li>
<li>
<p>[<a title="implicit timezone" id="dt-timezone" name=
"dt-timezone">Definition</a>: <b>Implicit timezone.</b> This is the timezone
to be used when a date, time, or dateTime value that does not have a timezone
is used in a comparison or in any other operation. This value is an instance
of <code>xdt:dayTimeDuration</code> that is <span class="xpath"><span class=
"xpath">determined by the host language</span></span>. See <a href=
"#ISO8601">[ISO 8601]</a> for the range of legal values of a timezone.]</p>
</li>
<li>
<p>[<a title="available documents" id="dt-available-docs" name=
"dt-available-docs">Definition</a>: <b>Available documents.</b> This is a
mapping of strings onto document nodes. The string represents the absolute
URI of a resource. The document node is the root of a tree that represents
that resource using the <a title="data model" href="#dt-datamodel">data
model</a>. The document node is returned by the <code>fn:doc</code> function
when applied to that URI.] The set of available documents is not constrained
by the set of statically-known documents, and it may be empty.</p>
</li>
<li>
<p>[<a title="available collections" id="dt-available-collections" name=
"dt-available-collections">Definition</a>: <b>Available collections.</b> This
is a mapping of strings onto sequences of nodes. The string represents the
absolute URI of a resource. The sequence of nodes represents the result of
the <code>fn:collection</code> function when that URI is supplied as the
argument. ] The set of available collections is not constrained by the set of
statically-known collections, and it may be empty.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-processing-model" name="id-processing-model"></a>2.2 Processing
Model</h3>
<p>XPath is defined in terms of the <a title="data model" href=
"#dt-datamodel">data model</a> and in terms of the <a title=
"expression context" href="#dt-expression-context">expression
context</a>.</p>
<img src="ProcMod-XPath.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>Figure 1 provides a schematic overview of the processing steps that are
discussed in detail below. Some of these steps are completely outside the
domain of XPath; in Figure 1, these are depicted outside the line that
represents the boundaries of the language, an area labeled the <b>external
processing domain</b>. The external processing domain includes generation of
the <a title="data model" href="#dt-datamodel">data model</a> (see <a href=
"#id-data-model-generation"><b>2.2.1 Data Model Generation</b></a>), schema
import processing (see <a href="#id-schema-import-processing"><b>2.2.2 Schema
Import Processing</b></a>) and serialization (see <a href=
"#id-serialization"><b>2.2.4 Serialization</b></a>). The area inside the
boundaries of the language is known as the <span class="xpath"><span class=
"xpath"><b>XPath processing domain</b></span></span>, which includes the
static analysis and dynamic evaluation phases (see <a href=
"#id-expression-processing"><b>2.2.3 Expression Processing</b></a>).
Consistency constraints on the <span class="xpath"><span class=
"xpath">XPath</span></span> processing domain are defined in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p>
<div class="div3">
<h4><a id="id-data-model-generation" name=
"id-data-model-generation"></a>2.2.1 Data Model Generation</h4>
<p>Before an expression can be processed, the input documents to be accessed
by the expression must be represented in the <a title="data model" href=
"#dt-datamodel">data model</a>. This process occurs outside the domain of
XPath, which is why Figure 1 represents it in the external processing domain.
Here are some steps by which an XML document might be converted to the
<a title="data model" href="#dt-datamodel">data model</a>:</p>
<ol class="enumar">
<li>
<p>A document may be parsed using an XML parser that generates an <b>XML
Information Set</b> (see <a href="#XINFO">[XML Infoset]</a>). The parsed
document may then be validated against one or more schemas. This process,
which is described in <a href="#XMLSchema">[XML Schema]</a>, results in an
abstract information structure called the <b>Post-Schema Validation
Infoset</b> (PSVI). If a document has no associated schema, its Information
Set is preserved. (See DM1 in Fig. 1.)</p>
</li>
<li>
<p>The Information Set or PSVI may be transformed into the <a title=
"data model" href="#dt-datamodel">data model</a> by a process described in
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. (See DM2 in
Fig. 1.)</p>
</li>
</ol>
<p>The above steps provide an example of how a document in the <a title=
"data model" href="#dt-datamodel">data model</a> might be constructed. A
document or fragment might also be synthesized directly from a relational
database, or constructed in some other way (see DM3 in Fig. 1.) XPath is
defined in terms of operations on the <a title="data model" href=
"#dt-datamodel">data model</a>, but it does not place any constraints on how
documents and instances in the <a title="data model" href=
"#dt-datamodel">data model</a> are constructed.</p>
<p>Each atomic value, element node, and attribute node in the <a title=
"data model" href="#dt-datamodel">data model</a> is annotated with its
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>. The dynamic
type specifies a range of values&#8212;for example, an attribute named
<code>version</code> might have the dynamic type <code>xs:decimal</code>,
indicating that it contains a decimal value. For example, if the <a title=
"data model" href="#dt-datamodel">data model</a> was derived from an input
XML document, the dynamic types of the elements and attributes are derived
from schema validation.</p>
<p>The value of an attribute is represented directly within the attribute
node. An attribute node whose type is unknown (such as might occur in a
schemaless document) is annotated with the dynamic type
<code>xdt:untypedAtomic</code>.</p>
<p>The value of an element is represented by the children of the element
node, which may include text nodes and other element nodes. The dynamic type
of an element node indicates how the values in its child text nodes are to be
interpreted. An element whose type is unknown (such as might occur in a
schemaless document) is annotated with the type
<code>xdt:untypedAny</code>.</p>
<p>An atomic value of unknown type is annotated with the type
<code>xdt:untypedAtomic</code>.</p>
</div>
<div class="div3">
<h4><a id="id-schema-import-processing" name=
"id-schema-import-processing"></a>2.2.2 Schema Import Processing</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> in the <a title="static context"
href="#dt-static-context">static context</a> are provided by the host
language (see step SI1 in Figure 1) and must satisfy the consistency
constraints defined in <a href="#id-consistency-constraints"><b>2.2.5
Consistency Constraints</b></a>.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-expression-processing" name=
"id-expression-processing"></a>2.2.3 Expression Processing</h4>
<p>XPath defines two phases of processing called the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis phase</a>
and the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1). An
implementation is free to use any strategy or algorithm whose result conforms
to these specifications.</p>
<div class="div4">
<h5><a id="id-static-analysis" name="id-static-analysis"></a>2.2.3.1 Static
Analysis Phase</h5>
<p>[<a title="static analysis phase" id="dt-static-analysis" name=
"dt-static-analysis">Definition</a>: The <b>static analysis phase</b> depends
on the expression itself and on the <a title="static context" href=
"#dt-static-context">static context</a>. The <b>static analysis phase</b>
does not depend on input data (other than schemas).]</p>
<p>During the static analysis phase, the <span class="xpath"><span class=
"xpath">XPath expression</span></span> is parsed into an internal
representation called the <b>operation tree</b> (step SQ1 in Figure 1). A
parse error is raised as a <a title="static error" href=
"#dt-static-error">static error</a>.[<a title="err:XP0003" href=
"#ERRXP0003">err:XP0003</a>] The <a title="static context" href=
"#dt-static-context">static context</a> is initialized by the implementation
(step SQ2). The <a title="static context" href="#dt-static-context">static
context</a> is used to resolve type names, function names, namespace prefixes
and variable names.</p>
<p>The <b>operation tree</b> is then <b>normalized</b> by making explicit the
implicit operations such as <a title="atomization" href=
"#dt-atomization">atomization</a>, <b>type promotion</b> and extraction of
<a title="effective boolean value" href="#dt-ebv">Effective Boolean
Values</a> (step SQ5). The normalization process is described in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
<p>If the <a title="Static Typing Feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is supported, each
expression is assigned a <a title="static type" href="#dt-static-type">static
type</a> (step SQ6). [<a title="static type" id="dt-static-type" name=
"dt-static-type">Definition</a>: The <b>static type</b> of an expression may
be either a named type or a structural description&#8212;for example,
<code>xs:boolean?</code> denotes an optional occurrence of the
<code>xs:boolean</code> type. The rules for inferring the <a title=
"static type" href="#dt-static-type">static types</a> of various expressions
are described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal Semantics]</a>.] In some cases, the <a title="static type" href=
"#dt-static-type">static type</a> is derived from the lexical form of the
expression; for example, the <a title="static type" href=
"#dt-static-type">static type</a> of the literal <code>5</code> is
<code>xs:integer</code>. In other cases, the <a title="static type" href=
"#dt-static-type">static type</a> of an expression is inferred according to
rules based on the static types of its operands; for example, the <a title=
"static type" href="#dt-static-type">static type</a> of the expression
<code>5 + 1.2</code> is <code>xs:decimal</code>.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"Static Typing Feature" href="#dt-static-typing-feature">Static Typing
Feature</a> is in effect and an operand of an expression is found to have a
<a title="static type" href="#dt-static-type">static type</a> that is not
appropriate for that operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>] If static type checking raises no errors and
assigns a <a title="static type" href="#dt-static-type">static type</a> T to
an expression, then execution of the expression on valid input data is
guaranteed either to produce a value of type T or to raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"Static Typing Feature" href="#dt-static-typing-feature">Static Typing
Feature</a> is in effect and the <a title="static type" href=
"#dt-static-type">static type</a> assigned to an expression other than
<code>()</code> is <code>empty</code>, a <a title="static error" href=
"#dt-static-error">static error</a> is raised.[<a title="err:XP0005" href=
"#ERRXP0005">err:XP0005</a>] This catches cases in which a query refers to an
element or attribute that is not present in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, possibly because of a spelling error.</p>
<p>The purpose of type-checking during the <a title="static analysis phase"
href="#dt-static-analysis">static analysis phase</a> is to provide early
detection of <a title="type error" href="#dt-type-error">type errors</a> and
to infer type information that may be useful in optimizing the evaluation of
an expression.</p>
</div>
<div class="div4">
<h5><a id="id-dynamic-evaluation" name="id-dynamic-evaluation"></a>2.2.3.2
Dynamic Evaluation Phase</h5>
<p>[<a title="dynamic evaluation phase" id="dt-dynamic-evaluation" name=
"dt-dynamic-evaluation">Definition</a>: The <b>dynamic evaluation phase</b>
occurs after completion of the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. During the dynamic
evaluation phase, the value of the <span class="xpath"><span class=
"xpath">expression</span></span> is computed.]</p>
<p>The dynamic evaluation phase can occur only if no errors were detected
during the <a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>. If the <a title="Static Typing Feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is in effect, all
<a title="type error" href="#dt-type-error">type errors</a> are detected
during static analysis and serve to inhibit the dynamic evaluation phase. If
the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static
Typing Feature</a> is not in effect, an implementation is allowed to raise
type-related warnings during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, but it must proceed with the
dynamic evaluation phase despite these warnings. In this case, <a title=
"type error" href="#dt-type-error">type errors</a> must be detected and
raised during the dynamic evaluation phase.</p>
<p>The dynamic evaluation phase depends on the <b>operation tree</b> of the
expression being evaluated (step DQ1), on the input data (step DQ4), and on
the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
(step DQ5), which in turn draws information from the external environment
(step DQ3) and the <a title="static context" href="#dt-static-context">static
context</a> (step DQ2). Execution of the evaluation phase may create new
data-model values (step DQ4) and it may extend the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> (step DQ5)&#8212;for example,
by binding values to variables.</p>
<p>[<a title="dynamic type" id="dt-dynamic-type" name=
"dt-dynamic-type">Definition</a>: A <b>dynamic type</b> is associated with
each value as it is computed. The dynamic type of a value may be either a
structural description (such as "sequence of integers") or a named type.] The
dynamic type of a value may be more specific than the <a title="static type"
href="#dt-static-type">static type</a> of the expression that computed it
(for example, the <a title="static type" href="#dt-static-type">static
type</a> of an expression might be "zero or more integers or strings," but at
evaluation time its value may have the dynamic type "integer.")</p>
<p>If an operand of an expression is found to have a <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a> that is not appropriate for that
operand, a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
<p>Even though static typing can catch many <a title="type error" href=
"#dt-type-error">type errors</a> before an expression is executed, it is
possible for an expression to raise an error during evaluation that was not
detected by static analysis. For example, an expression may contain a cast of
a string into an integer, which is statically valid. However, if the actual
value of the string at run time cannot be cast into an integer, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> will result.
Similarly, an expression may apply an arithmetic operator to a value whose
<a title="static type" href="#dt-static-type">static type</a> is
<code>xdt:untypedAtomic</code>. This is not a <a title="static error" href=
"#dt-static-error">static error</a>, but at run time, if the value cannot be
successfully cast to a numeric type, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> will be raised.</p>
<p>When the <a title="Static Typing Feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is in effect, it is
also possible for static analysis of an expression to raise a <a title=
"type error" href="#dt-type-error">type error</a>, even though execution of
the expression on certain inputs would be successful. For example, an
expression might contain a function that requires an element as its
parameter, and the static analysis phase might infer the <a title=
"static type" href="#dt-static-type">static type</a> of the function
parameter to be an optional element. This case is treated as a <a title=
"type error" href="#dt-type-error">type error</a> and inhibits evaluation,
even though the function call would have been successful for input data in
which the optional element is present.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-serialization" name="id-serialization"></a>2.2.4
Serialization</h4>
<p>[<a title="serialization" id="dt-serialization" name=
"dt-serialization">Definition</a>: <b>Serialization</b> is the process of
converting a set of nodes from the <a title="data model" href=
"#dt-datamodel">data model</a> into a sequence of octets (step DM4 in Figure
1.) ] The general framework for serialization of the <a title="data model"
href="#dt-datamodel">data model</a> is described in <a href=
"#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>.</p>
<div class="xpath">
<p class="xpath">The host language may provide a serialization option based
on this framework.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-consistency-constraints" name=
"id-consistency-constraints"></a>2.2.5 Consistency Constraints</h4>
<p>In order for XPath to be well defined, the <a title="data model" href=
"#dt-datamodel">data model</a>, the <a title="static context" href=
"#dt-static-context">static context</a>, and the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> must be mutually consistent.
The consistency constraints listed below are prerequisites for correct
functioning of an XPath implementation. Enforcement of these consistency
constraints is beyond the scope of this specification.</p>
<p>Some of the consistency constraints use the term <b>data model schema</b>.
[<a title="data model schema" id="dt-data-model-schema" name=
"dt-data-model-schema">Definition</a>: For a given node in the <a title=
"data model" href="#dt-datamodel">data model</a>, the <b>data model
schema</b> is defined as the schema from which the type annotation of that
node was derived.] For a node that was constructed by some process other than
schema validation, the <b>data model schema</b> consists simply of the type
definition that is represented by the type annotation of the node.</p>
<ul>
<li>
<p>For every data model node that has a type annotation other than
<code>xs:anyType</code>, if that type annotation is found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>
(ISSD), then its definition in the ISSD must be the same as its definition in
the <a title="data model schema" href="#dt-data-model-schema">data model
schema</a>. Furthermore, all types that are derived by extension from the
given type in the <a title="data model schema" href=
"#dt-data-model-schema">data model schema</a> must also be known by
equivalent definitions in the ISSD.</p>
</li>
<li>
<p>For every element name <em>EN</em> that is found both in a data model node
and in the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> (ISSD), all elements that are known in the <a title=
"data model schema" href="#dt-data-model-schema">data model schema</a> to be
in the same substitution group as <em>EN</em> must also be known in the ISSD
to be in the same substitution group as <em>EN</em>.</p>
</li>
<li>
<p>Every item type (i.e., every element, attribute, or type name) referenced
in <a title="in-scope variables" href="#dt-is-vars">in-scope variables</a> or
<a title="in-scope functions" href="#dt-is-funcs">in-scope functions</a> must
be in the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a>.</p>
</li>
<li>
<p>For each mapping of a string to a document node in <a title=
"available documents" href="#dt-available-docs">available documents</a>, if
there exists a mapping of the same string to a document type in <a title=
"statically-known documents" href="#dt-known-docs">statically-known
documents</a>, the document node must match the document type, using the
matching rules in <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>For each mapping of a string to a sequence of nodes in <a title=
"available collections" href="#dt-available-collections">available
collections</a>, if there exists a mapping of the same string to a type in
<a title="statically-known collections" href=
"#dt-known-collections">statically-known collections</a>, the sequence of
nodes must match the type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</li>
<li>
<p>The <a title="Dynamic variables" href="#dt-dyn-vars">dynamic variables</a>
in the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a> and the <a title="in-scope variables" href="#dt-is-vars">in-scope
variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> must correspond as follows:</p>
<ul>
<li>
<p>All variables defined in <a title="in-scope variables" href=
"#dt-is-vars">in-scope variables</a> must be defined in <a title=
"Dynamic variables" href="#dt-dyn-vars">dynamic variables</a>.</p>
</li>
<li>
<p>For each (variable, type) pair in <a title="in-scope variables" href=
"#dt-is-vars">in-scope variables</a> and the corresponding (variable, value)
pair in <a title="Dynamic variables" href="#dt-dyn-vars">dynamic
variables</a> such that the variable names are equal, the value must match
the type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-important-concepts" name="id-important-concepts"></a>2.3
Documents</h3>
<p>XPath is generally used to process <b>documents</b>. The representation of
a document is normatively defined in <a href="#datamodel">[XQuery 1.0 and
XPath 2.0 Data Model]</a>. The functions used to access documents and
collections are normatively defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>. Because documents are centrally important in XPath
processing, we provide a summary of some key concepts here.</p>
<div class="div3">
<h4><a id="N1079B" name="N1079B"></a>2.3.1 Document Order</h4>
<p>An ordering called <b>document order</b> is defined among all the nodes
used during a given query or transformation, which may consist of one or more
<b>trees</b> (documents or fragments). Document order is defined in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, and its definition is
repeated here for convenience.</p>
<p>Document order is a total ordering, although the relative order of some
nodes is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. Informally,
document order is the order returned by an in-order, depth-first traversal of
the data model. Document order is <b>stable</b>, which means that the
relative order of two nodes will not change during the processing of a given
query or transformation, even if this order is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>Within a tree, document order satisfies the following constraints:</p>
<ol class="enumar">
<li>
<p>The root node is the first node.</p>
</li>
<li>
<p>The relative order of siblings is determined by their order in the XML
representation of the tree. A node N1 occurs before a node N2 in document
order if and only if the start of N1 occurs before the start of N2 in the XML
representation.</p>
</li>
<li>
<p>Namespace nodes immediately follow the element node with which they are
associated. The relative order of namespace nodes is stable but <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Attribute nodes immediately follow the namespace nodes of the element with
which they are associated. The relative order of attribute nodes is stable
but <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Element nodes occur before their children; children occur before
following-siblings.</p>
</li>
</ol>
<p>The relative order of nodes in distinct trees is stable but <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>, subject to the
following constraint: If any node in tree T1 is before any node in tree T2,
then all nodes in tree T1 are before all nodes in tree T2.</p>
</div>
<div class="div3">
<h4><a id="id-atomization" name="id-atomization"></a>2.3.2 Atomization</h4>
<p>The semantics of some XPath operators depend on a process called <a title=
"atomization" href="#dt-atomization">atomization</a>. [<a title="atomization"
id="dt-atomization" name="dt-atomization">Definition</a>: <b>Atomization</b>
is applied to a value when the value is used in a context in which a sequence
of atomic values is required. The result of atomization is either a sequence
of atomic values or a <a title="type error" href="#dt-type-error">type
error</a>. Atomization of a sequence is defined as the result of invoking the
<code>fn:data</code> function on the sequence, as defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.]</p>
<p>The semantics of <code>fn:data</code> are repeated here for convenience.
The result of <code>fn:data</code> is the sequence of atomic values produced
by applying the following rules to each item in the input sequence:</p>
<ul>
<li>
<p>If the item is an atomic value, it is returned.</p>
</li>
<li>
<p>If the item is a node, its typed value is returned.</p>
</li>
</ul>
<p>Atomization is used in processing the following types of expressions:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Comparison expressions</p>
</li>
<li>
<p>Function calls and returns</p>
</li>
<li>
<p>Cast expressions</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-ebv" name="id-ebv"></a>2.3.3 Effective Boolean Value</h4>
<p>Under certain circumstances (listed below), it is necessary to find the
<a title="effective boolean value" href="#dt-ebv">effective boolean value</a>
of a value. [<a title="effective boolean value" id="dt-ebv" name=
"dt-ebv">Definition</a>: The <b>effective boolean value</b> of a value is
defined as the result of applying the <code>fn:boolean</code> function to the
value, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators]</a>.]</p>
<p>The semantics of <code>fn:boolean</code> are repeated here for
convenience. <code>fn:boolean</code> returns <code>false</code> if its
operand is any of the following:</p>
<ul>
<li>
<p>An empty sequence</p>
</li>
<li>
<p>The boolean value <code>false</code></p>
</li>
<li>
<p>A zero-length value of type <code>xs:string</code> or
<code>xdt:untypedAtomic</code></p>
</li>
<li>
<p>A numeric value that is equal to zero</p>
</li>
<li>
<p>The <code>xs:double</code> or <code>xs:float</code> value
<code>NaN</code></p>
</li>
</ul>
<p>Otherwise, <code>fn:boolean</code> returns <code>true</code>.</p>
<p>The <a title="effective boolean value" href="#dt-ebv">effective boolean
value</a> of a sequence is computed implicitly during processing of the
following types of expressions:</p>
<ul>
<li>
<p>Logical expressions (<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p>The <code>fn:not</code> function</p>
</li>
<li>
<p>Certain types of predicates, such as <code>a[b]</code></p>
</li>
<li>
<p>Conditional expressions (<code>if</code>)</p>
</li>
<li>
<p>Quantified expressions (<code>some</code>, <code>every</code>)</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note that the definition of <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> is not used when casting a value to the
type <code>xs:boolean</code>.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-input-sources" name="id-input-sources"></a>2.3.4 Input
Sources</h4>
<p>XPath has a set of functions that provide access to input data. These
functions are of particular importance because they provide a way in which an
expression can reference a document or a collection of documents. The input
functions are described informally here; they are defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
<p>An expression can access input documents either by calling one of the
input functions or by referencing some part of the expression context that is
initialized by the external environment, such as a <b>variable</b> or a
<a title="context item" href="#dt-context-item">context item</a>.</p>
<p>The input functions supported by XPath are as follows:</p>
<ul>
<li>
<p>The <code>fn:doc</code> function takes a string containing a URI that
refers to an XML document, and returns a document node whose content is the
<a title="data model" href="#dt-datamodel">data model</a> representation of
the given document.</p>
</li>
<li>
<p>The <code>fn:collection</code> function takes a string containing a URI,
and returns the data model representation of the collection identified by the
URI. A collection may be any sequence of nodes. For example, the expression
<code>fn:collection("http://example.org")//customer</code> identifies all the
<code>customer</code> elements that are descendants of nodes found in the
collection whose URI is <code>http://example.org</code>.</p>
</li>
</ul>
<p>If a given input function is invoked repeatedly with arguments that
resolve to the same absolute URI during the scope of a single query or
transformation, each invocation returns the same result.</p>
</div>
</div>
<div class="div2">
<h3><a id="id-types" name="id-types"></a>2.4 Types</h3>
<p>XPath is a strongly typed language with a type system based on <a href=
"#XMLSchema">[XML Schema]</a>. The XPath type system is formally defined in
<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>.</p>
<div class="div3">
<h4><a id="id-predefined-types" name="id-predefined-types"></a>2.4.1
Predefined Types</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope type definitions" href=
"#dt-is-types">in-scope type definitions</a> in the <a title="static context"
href="#dt-static-context">static context</a> are initialized with a set of
predefined types that is determined by the host language. This set may
include some or all of the types defined by <a href="#XMLSchema">[XML
Schema]</a> in the namespace <code>http://www.w3.org/2001/XMLSchema</code>,
represented in this document by the namespace prefix <code>xs</code>. It may
also include the types defined in the namespace
<code>http://www.w3.org/2003/11/xpath-datatypes</code>, represented in this
document by the namespace prefix <code>xdt</code>. The types in this
namespace are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and Operators]</a> and are summarized below.</p>
</div>
<ol class="enumar">
<li>
<p><code>xdt:anyAtomicType</code> is an abstract type that includes all
atomic values (and no values that are not atomic). It is a subtype of
<code>xs:anySimpleType</code>, which is the base type for all simple types,
including atomic, list, and union types. All specific atomic types such as
<code>xs:integer</code>, <code>xs:string</code>, and
<code>xdt:untypedAtomic</code>, are subtypes of
<code>xdt:anyAtomicType</code>.</p>
</li>
<li>
<p><code>xdt:untypedAny</code> is a concrete type used to denote the dynamic
type of an element node that has not been assigned a more specific type. It
has no subtypes. An element that has been validated in <code>skip</code>
mode, or that has a PSVI type property of <code>xs:anyType</code>, is
represented in the Data Model by an element node with the type
<code>xdt:untypedAny</code>.</p>
</li>
<li>
<p><code>xdt:untypedAtomic</code> is a concrete type used to denote untyped
atomic data, such as text that has not been assigned a more specific type. It
has no subtypes. An attribute that has been validated in <code>skip</code>
mode, or that has a PSVI property of <code>xs:anySimpleType</code>, is
represented in the Data Model by an attribute node with the type
<code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p><code>xdt:dayTimeDuration</code> is a concrete subtype of
<code>xs:duration</code> whose lexical representation contains only day,
hour, minute, and second components.</p>
</li>
<li>
<p><code>xdt:yearMonthDuration</code> is a concrete subtype of
<code>xs:duration</code> whose lexical representation is restricted to
contain only year and month components.</p>
</li>
</ol>
<p>The relationships among the types in the <code>xs</code> and
<code>xdt</code> namespaces are illustrated in Figure 2. The abstract types,
represented by ovals in the figure, may be assigned to an expression during
the <a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> if no more specific type can be inferred for the
expression. During the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>, each node or value in
the data model is assigned a concrete type, represented by one of the types
listed in the rectangular boxes in Figure 2. A more complete description of
the XPath type hierarchy can be found in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>Figure 2: Summary of XPath Type Hierarchy</p>
</div>
<div class="div3">
<h4><a id="id-typed-value" name="id-typed-value"></a>2.4.2 Typed Value and
String Value</h4>
<p>In the <a title="data model" href="#dt-datamodel">data model</a>, every
node has a <b>typed value</b> and a <b>string value</b>. The <b>typed
value</b> of a node is a sequence of atomic values and can be extracted by
applying the <code>fn:data</code> function to the node. The typed value for
each kind of node is defined by the <code>dm:typed-value</code> accessor in
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The <b>string
value</b> of a node is a string and can be extracted by applying the
<code>fn:string</code> function to the node. The string value for each kind
of node is defined by the <code>dm:string-value</code> accessor in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. Element and attribute
nodes have a <b>type annotation</b>, which represents (in an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> way) the
<a title="dynamic type" href="#dt-dynamic-type">dynamic (run-time) type</a>
of the node. In the <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
Model]</a>, type annotation is defined by the <code>dm:type</code> accessor;
however, XPath does not provide a way to directly access the type annotation
of an element or attribute node.</p>
<p>The relationship between the typed value and the string value for various
kinds of nodes is described and illustrated by examples below.</p>
<ol class="enumar">
<li>
<p>For text, document, and namespace nodes, the typed value of the node is
the same as its string value, as an instance of the type
<code>xdt:untypedAtomic</code>. (The string value of a document node is
formed by concatenating the string values of all its descendant text nodes,
in document order.)</p>
</li>
<li>
<p>The typed value of a comment or processing instruction node is the same as
its string value. It is an instance of the type <code>xs:string</code>.</p>
</li>
<li>
<p>The typed value of an attribute node with the type annotation
<code>xdt:untypedAtomic</code> is the same as its string value, as an
instance of <code>xdt:untypedAtomic</code>. The typed value of an attribute
node with any other type annotation is derived from its string value and type
annotation in a way that is consistent with schema validation.</p>
<p>Example: A1 is an attribute having string value <code>"3.14E-2"</code> and
type annotation <code>xs:double</code>. The typed value of A1 is the
<code>xs:double</code> value whose lexical representation is
<code>3.14E-2</code>.</p>
<p>Example: A2 is an attribute with type annotation <code>xs:IDREFS</code>,
which is a list datatype derived from the atomic datatype
<code>xs:IDREF</code>. Its string value is "<code>bar baz faz</code>". The
typed value of A2 is a sequence of three atomic values ("<code>bar</code>",
"<code>baz</code>", "<code>faz</code>"), each of type <code>xs:IDREF</code>.
The typed value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type (such as
<code>xs:IDREFS</code>), its typed value is treated as a sequence of the
atomic type from which it is derived (such as <code>xs:IDREF</code>).</p>
</li>
<li>
<p>For an element node, the relationship between typed value and string value
depends on the node's type annotation, as follows:</p>
<ol class="enumla">
<li>
<p>If the type annotation is <code>xdt:untypedAtomic</code>, or denotes a
complex type with mixed content, then the typed value of the node is equal to
its string value, as an instance of <code>xdt:untypedAtomic</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since <code>xs:untypedAny</code> is a complex type with mixed content,
this rule applies to elements whose type is <code>xs:untypedAny</code>.</p>
</div>
<p>Example: E1 is an element node having type annotation
<code>xdt:untypedAny</code> and string value "<code>1999-05-31</code>". The
typed value of E1 is "<code>1999-05-31</code>", as an instance of
<code>xdt:untypedAtomic</code>.</p>
<p>Example: E2 is an element node with the type annotation
<code>formula</code>, which is a complex type with mixed content. The content
of E2 consists of the character "<code>H</code>", a child element named
<code>subscript</code> with string value "<code>2</code>", and the character
"<code>O</code>". The typed value of E2 is "<code>H2O</code>" as an instance
of <code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p>If the type annotation denotes a simple type or a complex type with simple
content, then the typed value of the node is derived from its string value
and its type annotation in a way that is consistent with schema
validation.</p>
<p>Example: E3 is an element node with the type annotation <code>cost</code>,
which is a complex type that has several attributes and a simple content type
of <code>xs:decimal</code>. The string value of E3 is "<code>74.95</code>".
The typed value of E3 is <code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p>
<p>Example: E4 is an element node with the type annotation
<code>hatsizelist</code>, which is a simple type derived from the atomic type
<code>hatsize</code>, which in turn is derived from <code>xs:integer</code>.
The string value of E4 is "<code>7 8 9</code>". The typed value of E4 is a
sequence of three values (<code>7</code>, <code>8</code>, <code>9</code>),
each of type <code>hatsize</code>.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with empty content, then the
typed value of the node is the empty sequence.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with element-only content,
then the typed value of the node is undefined. The <code>fn:data</code>
function raises a <a title="type error" href="#dt-type-error">type error</a>
[<a title="err:XP0007" href="#ERRXP0007">err:XP0007</a>] when applied to such
a node.</p>
<p>Example: E5 is an element node with the type annotation
<code>weather</code>, which is a complex type whose content type specifies
<code>element-only</code>. E5 has two child elements named
<code>temperature</code> and <code>precipitation</code>. The typed value of
E5 is undefined, and the <code>fn:data</code> function applied to E5 raises
an error.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a id="id-sequencetype-syntax" name="id-sequencetype-syntax"></a>2.4.3
SequenceType Syntax</h4>
<p>[<a title="SequenceType" id="dt-sequence-type" name=
"dt-sequence-type">Definition</a>: When it is necessary to refer to a type in
an XPath expression, the <b>SequenceType</b> syntax is used. The name
<b>SequenceType</b> suggests that this syntax is used to describe the type of
an XPath value, which is always a sequence.]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SequenceType" name=
"doc-xpath-SequenceType"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ItemType">ItemType</a> <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />
| ("empty" "(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-OccurrenceIndicator" name=
"doc-xpath-OccurrenceIndicator"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ItemType" name=
"doc-xpath-ItemType"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a> | <a href=
"#doc-xpath-KindTest">KindTest</a> | ("item" "(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AtomicType" name=
"doc-xpath-AtomicType"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-KindTest" name=
"doc-xpath-KindTest"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xpath-ElementTest">ElementTest</a><br />
| <a href="#doc-xpath-AttributeTest">AttributeTest</a><br />
| <a href="#doc-xpath-PITest">PITest</a><br />
| <a href="#doc-xpath-CommentTest">CommentTest</a><br />
| <a href="#doc-xpath-TextTest">TextTest</a><br />
| <a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PITest" name=
"doc-xpath-PITest"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#doc-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CommentTest" name=
"doc-xpath-CommentTest"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TextTest" name=
"doc-xpath-TextTest"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AnyKindTest" name=
"doc-xpath-AnyKindTest"></a>[78]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DocumentTest" name=
"doc-xpath-DocumentTest"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" <a href=
"#doc-xpath-ElementTest">ElementTest</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementTest" name=
"doc-xpath-ElementTest"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" ((<a href=
"#doc-xpath-SchemaContextPath">SchemaContextPath</a> <a href=
"#doc-xpath-ElementName">ElementName</a>)<br />
| (<a href="#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a>
"nillable"?)?))? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttributeTest" name=
"doc-xpath-AttributeTest"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" ((<a href=
"#doc-xpath-SchemaContextPath">SchemaContextPath</a> <a href=
"#doc-xpath-AttributeName">AttributeName</a>)<br />
| (<a href="#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a>)?))?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementName" name=
"doc-xpath-ElementName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttributeName" name=
"doc-xpath-AttributeName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TypeName" name=
"doc-xpath-TypeName"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementNameOrWildcard" name=
"doc-xpath-ElementNameOrWildcard"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttribNameOrWildcard" name=
"doc-xpath-AttribNameOrWildcard"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TypeNameOrWildcard" name=
"doc-xpath-TypeNameOrWildcard"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TypeName">TypeName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaContextPath" name=
"doc-xpath-SchemaContextPath"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaContextPath">SchemaContextPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SchemaGlobalContext">SchemaGlobalContext</a>
"/" (<a href="#doc-xpath-SchemaContextStep">SchemaContextStep</a>
"/")*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaGlobalContext" name=
"doc-xpath-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaGlobalContext">SchemaGlobalContext</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#doc-xpath-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaContextStep" name=
"doc-xpath-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaContextStep">SchemaContextStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaGlobalTypeName" name=
"doc-xpath-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"type" "(" <a href="#prod-xpath-QName">QName</a> ")"</code></td>
</tr>
</tbody>
</table>
<p>QNames appearing in a SequenceType have their prefixes expanded to
namespace URIs by means of the <a title="in-scope namespaces" href=
"#dt-is-namespaces">in-scope namespaces</a> and the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a>. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a title="err:XP0008" href=
"#ERRXP0008">err:XP0008</a>] to use a TypeName in an ElementTest or
AttributeTest if that name is not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope type definitions</a>.
It is a <a title="static error" href="#dt-static-error">static error</a>
[<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>] to use an
ElementName in an ElementTest if that name is not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope element
definitions</a> unless a TypeNameOrWildcard is specified. It is a <a title=
"static error" href="#dt-static-error">static error</a> [<a title=
"err:XP0008" href="#ERRXP0008">err:XP0008</a>] to use a (SchemaContextPath
ElementName) pair in an ElementTest if the ElementName can not be located
from the in-scope element definitions using the SchemaContextPath. It is a
<a title="static error" href="#dt-static-error">static error</a> [<a title=
"err:XP0008" href="#ERRXP0008">err:XP0008</a>] to use an AttributeName in an
AttributeTest if that name is not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope attribute
definitions</a> unless a TypeNameOrWildcard is specified. It is a <a title=
"static error" href="#dt-static-error">static error</a> [<a title=
"err:XP0008" href="#ERRXP0008">err:XP0008</a>] to use a (SchemaContextPath
AttributeName) pair in an AttributeTest if the AttributeName can not be
located from the in-scope attribute definitions using the SchemaContextPath.
If a QName that is used as an <b>AtomicType</b> is not defined as an atomic
type in the <a title="in-scope type definitions" href="#dt-is-types">in-scope
type definitions</a>, a <a title="static error" href=
"#dt-static-error">static error</a> is raised. [<a title="err:XP0051" href=
"#ERRXP0051">err:XP0051</a>]</p>
<p>Here are some examples of SequenceTypes that might be used in XPath
expressions:</p>
<ul>
<li>
<p><code>xs:date</code> refers to the built-in Schema type
<code>date</code></p>
</li>
<li>
<p><code>attribute()?</code> refers to an optional attribute</p>
</li>
<li>
<p><code>element()</code> refers to any element</p>
</li>
<li>
<p><code>element(po:shipto, po:address)</code> refers to an element that has
the name <code>po:shipto</code> (or is in the substitution group of that
element), and has the type annotation <code>po:address</code> (or a subtype
of that type)</p>
</li>
<li>
<p><code>element(po:shipto, *)</code> refers to an element named
<code>po:shipto</code> (or in the substitution group of
<code>po:shipto</code>), with no restrictions on its type</p>
</li>
<li>
<p><code>element(*, po:address)</code> refers to an element of any name that
has the type annotation <code>po:address</code> (or a subtype of
<code>po:address</code>). If the keyword <code>nillable</code> were used
following <code>po:address</code>, that would indicate that the element may
have empty content and the attribute <code>xsi:nil="true"</code>, even though
the declaration of the type <code>po:address</code> has required content.</p>
</li>
<li>
<p><code>node()*</code> refers to a sequence of zero or more nodes of any
type</p>
</li>
<li>
<p><code>item()+</code> refers to a sequence of one or more nodes or atomic
values</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-sequencetype-matching" name=
"id-sequencetype-matching"></a>2.4.4 SequenceType Matching</h4>
<p>[<a title="SequenceType matching" id="dt-sequencetype-matching" name=
"dt-sequencetype-matching">Definition</a>: During evaluation of an
expression, it is sometimes necessary to determine whether a value with a
known type "matches" an expected type, expressed in the SequenceType syntax.
This process is known as <b>SequenceType matching</b>.] For example, an
<code>instance of</code> expression returns <code>true</code> if the actual
type of a given value matches a given type, or <code>false</code> if it does
not.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this specification, the word "type", when used without modification,
represents a type that can be expressed using the SequenceType production.
When we refer specifically to W3C XML Schema simple or complex types,
appropriate modifiers are used to make this clear.</p>
</div>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> compare the actual type
of a value with an expected type. These rules are a subset of the static
typing rules defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and
XPath 2.0 Formal Semantics]</a>, which compare the static type of an
expression with the expected type of the context in which the expression is
used. The static typing rules are a superset of the <a title=
"SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a> rules because the static type of an expression is typically more
general than the dynamic type of the value produced by evaluating the
expression. For example, the static type of the expression <code>if (expr)
then "true" else 0</code> is <code>xs:string | xs:integer</code>, as
described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal Semantics]</a>. However, if <code>expr</code> evaluates to
<code>true</code>, then the dynamic type of this expression is
<code>xs:string</code>.</p>
<p>Some of the rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> require matching of
simple or complex types to determine whether a given type is the same as or
derived from an expected type. These types may be "known" types, which are
defined in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>, or "unknown" types, which are not
defined in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>. An unknown type might be
encountered, for example, if the module in which the given type is
encountered does not import the schema in which the given type is defined. In
this case, an implementation is allowed (but is not required) to provide an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> mechanism for
determining whether the unknown type is compatible with the expected type.
For example, an implementation might maintain a data dictionary containing
information about type hierarchies.</p>
<p>We define the process of matching simple or complex types using a
pseudo-function named <code>type-matches(</code><em>ET</em>,
<em>AT</em><code>)</code> that takes an expected simple or complex type
<em>ET</em> and an actual simple or complex type <em>AT</em>, and either
returns a boolean value or raises a <a title="type error" href=
"#dt-type-error">type error</a>. [<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>] This pseudo-function <code>type-matches</code>
is defined as follows:</p>
<ul>
<li>
<p><code>type-matches(</code><em>ET</em>, <em>AT</em><code>)</code> returns
<code>true</code> if:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a known type, and is the same as <em>ET</em>, or is derived
by one or more steps of restriction or extension from <em>ET</em>, or</p>
</li>
<li>
<p><em>AT</em> is an unknown type, and an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> mechanism is
able to determine that <em>AT</em> is derived by restriction from
<em>ET</em>.</p>
</li>
</ol>
</li>
<li>
<p><code>type-matches(</code><em>ET</em>, <em>AT</em><code>)</code> returns
<code>false</code> if:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a known type, and is not the same as <em>ET</em>, and is
not derived by one or more steps of restriction or extension from
<em>ET</em>, or</p>
</li>
<li>
<p><em>AT</em> is an unknown type, and an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> mechanism is
able to determine that <em>AT</em> is not derived by restriction from
<em>ET</em>.</p>
</li>
</ol>
</li>
<li>
<p><code>type-matches(</code><em>ET</em>, <em>AT</em><code>)</code> raises a
<a title="type error" href="#dt-type-error">type error</a> [<a title=
"err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>] if:</p>
<ol class="enumar">
<li>
<p><em>ET</em> is an unknown type, or</p>
</li>
<li>
<p><em>AT</em> is an unknown type, and the implementation is not able to
determine whether <em>AT</em> is derived by restriction from <em>ET</em>.</p>
</li>
</ol>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>type-matches</code> pseudo-function can not be written as a real
XQuery function, because types are not valid function parameters.</p>
</div>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> are given below, with
examples (the examples are for purposes of illustration, and do not cover all
possible cases).</p>
<div class="div4">
<h5><a id="id-matching-value" name="id-matching-value"></a>2.4.4.1 Matching a
SequenceType and a Value</h5>
<ul>
<li>
<p>The SequenceType <code>empty()</code> matches a value that is the empty
sequence.</p>
</li>
<li>
<p>An ItemType with no OccurrenceIndicator matches any value that contains
exactly one item if the ItemType matches that item (see <a href=
"#id-matching-item"><b>2.4.4.2 Matching an ItemType and an Item</b></a>).</p>
</li>
<li>
<p>An ItemType with an OccurrenceIndicator matches a value if the number of
items in the value matches the OccurrenceIndicator and the ItemType matches
each of the items in the value.</p>
</li>
</ul>
<p>An OccurrenceIndicator specifies the number of items in a sequence, as
follows:</p>
<ul>
<li>
<p><code>?</code> matches zero or one items</p>
</li>
<li>
<p><code>*</code> matches zero or more items</p>
</li>
<li>
<p><code>+</code> matches one or more items</p>
</li>
</ul>
<p>As a consequence of these rules, any SequenceType whose
OccurrenceIndicator is <code>*</code> or <code>?</code> matches a value that
is an empty sequence.</p>
</div>
<div class="div4">
<h5><a id="id-matching-item" name="id-matching-item"></a>2.4.4.2 Matching an
ItemType and an Item</h5>
<ul>
<li>
<p>An ItemType consisting simply of a QName is interpreted as an
<b>AtomicType</b>. An AtomicType <em>AtomicType</em> matches an atomic value
whose actual type is <em>AT</em> if <code>type-matches(</code><em>AtomicType,
AT</em><code>)</code> is <code>true</code>.</p>
<p>Example: The AtomicType <code>xs:decimal</code> matches the value
<code>12.34</code> (a decimal literal). <code>xs:decimal</code> also matches
a value whose type is <code>shoesize</code>, if <code>shoesize</code> is an
atomic type derived by restriction from <code>xs:decimal</code>.</p>
<p>A named atomic type may be a generic type such as
<code>xdt:anyAtomicType</code>. Note that the names of non-atomic types such
as <code>xs:IDREFS</code> are not accepted in this context, but can often be
replaced by an atomic type with an occurrence indicator, such as
<code>xs:IDREF*</code>.</p>
</li>
<li>
<p><code>item()</code> matches any single item.</p>
<p>Example: <code>item()</code> matches the atomic value <code>1</code> or
the element <code>&lt;a/&gt;</code>.</p>
</li>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>processing-instruction()</code> matches any processing-instruction
node.</p>
</li>
<li>
<p><code>processing-instruction(</code><em>N</em><code>)</code> matches any
processing-instruction node whose name (called its "PITarget" in XML) is
equal to <em>N</em>, where <em>N</em> is an NCName.</p>
<p>Example: <code>processing-instruction(xml-stylesheet)</code> matches any
processing instruction whose PITarget is <code>xml-stylesheet</code>.</p>
<p>For backward compatibility with XPath 1.0, the PITarget of a processing
instruction may also be expressed as a string literal, as in this example:
<code>processing-instruction("xml-stylesheet")</code>.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(</code><em>E</em><code>)</code> matches any document
node that contains zero or more comments and processing instructions and
contains exactly one element node, if <em>E</em> is an ElementTest that
matches the element node (see <a href="#id-matching-elem"><b>2.4.4.3 Matching
an ElementTest and an Element Node</b></a>).</p>
<p>Example: <code>document-node(element(book))</code> matches any document
node containing zero or more comments and processing instructions and exactly
one element node that is matched by the ElementTest
<code>element(book)</code>.</p>
</li>
<li>
<p>An ItemType that is an <a title="ElementTest" href=
"#dt-element-test">ElementTest</a> or <a title="AttributeTest" href=
"#dt-attribute-test">AttributeTest</a> matches an element or attribute node
as described in the following sections.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a id="id-matching-elem" name="id-matching-elem"></a>2.4.4.3 Matching an
ElementTest and an Element Node</h5>
<p>[<a title="ElementTest" id="dt-element-test" name=
"dt-element-test">Definition</a>: An <b>ElementTest</b> is used to match an
element node by its name and/or type.]</p>
<p>In the following rules, <em>ElementName</em> and <em>TypeName</em> are
names that match the corresponding productions in the grammar, where
<em>TypeName</em> is optionally followed by the keyword
<code>nillable</code>. The pair <em>SchemaContextPath ElementName</em>
represents a path that matches the corresponding productions in the grammar.
Note that the <em>SchemaContextPath ElementName</em> pair is just one path;
for instance, the path <code>hospital/staff/person</code> is an example of
such a pair, where <code>hospital/staff/</code> is the
<em>SchemaContextPath</em> and <code>person</code> is the
<em>ElementName</em>. Two QNames "match" if their expanded forms (URIs and
local names) are identical.</p>
<p>An <a title="ElementTest" href="#dt-element-test">ElementTest</a> may take
one of the following forms:</p>
<ol class="enumar">
<li>
<p><code>element()</code>, <code>element(*)</code>, and
<code>element(*,*)</code> match any single element node, regardless of its
name or type.</p>
</li>
<li>
<p><code>element(</code><em>ElementName</em><code>,</code>
<em>TypeName</em><code>)</code> matches a given element node if:</p>
<ol class="enumla">
<li>
<p>the name of the element node matches <em>ElementName</em> or matches the
name of an element in a substitution group headed by an element with the name
<em>ElementName</em>, and:</p>
</li>
<li>
<p><code>type-matches(</code><em>TypeName, AT</em><code>)</code> is
<code>true</code>, where <em>AT</em> is the type of the given element node.
However, if the given element node has the <code>nilled</code> property, then
this rule is satisfied only if <em>TypeName</em> is followed by the keyword
<code>nillable</code>.</p>
</li>
</ol>
<p>For this form, there is no requirement that <em>ElementName</em> be
defined in the <b>in-scope element declarations</b>.</p>
<p>Example: <code>element(person, surgeon)</code> matches an non-nilled
element node whose name is <code>person</code> and whose type annotation is
<code>surgeon</code>.</p>
<p>Example: <code>element(person, surgeon nillable)</code> matches an element
node whose name is <code>person</code> and whose type annotation is
<code>surgeon</code>, and permits the element node to have the
<code>nilled</code> property.</p>
</li>
<li>
<p><code>element(</code><em>ElementName</em><code>)</code> matches an element
node if:</p>
<ol class="enumla">
<li>
<p>the name of the element node matches <em>ElementName</em> or matches the
name of an element in a substitution group headed by an element with the name
<em>ElementName</em>, and:</p>
</li>
<li>
<p><code>type-matches(</code><em>ST, AT</em><code>)</code> is
<code>true</code>, where <em>ST</em> is the simple or complex type of element
<em>ElementName</em> in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, and <em>AT</em> is the type
of the given element node. However, if the given element node has the
<code>nilled</code> property, then this rule is satisfied only if <em>ST</em>
includes the <code>nillable</code> option.</p>
</li>
</ol>
<p>Example: <code>element(person)</code> matches an element node whose name
is <code>person</code> and whose type matches the type of the top-level
<code>person</code> element declaration in the <a title=
"in-scope element declarations" href="#dt-is-elems">in-scope element
declarations</a>.</p>
</li>
<li>
<p><code>element(</code><em>ElementName</em><code>, *)</code> matches an
element node of any type if the name of the element matches
<em>ElementName</em> or matches the name of an element in a substitution
group headed by an element with the name <em>ElementName</em>.</p>
<p>For this form, there is no requirement that <em>ElementName</em> be
defined in the <b>in-scope element declarations</b>.</p>
<p>Example: <code>element(person, *)</code> matches any element node whose
name is <code>person</code>, regardless of its type.</p>
</li>
<li>
<p><code>element(*,</code> <em>TypeName</em><code>)</code> matches a given
element node regardless of its name, if
<code>type-matches(</code><em>TypeName, AT</em><code>)</code> is
<code>true</code>, where <em>AT</em> is the type of the given element node.
However, if the given element node has the <code>nilled</code> property, then
this rule is satisfied only if <em>TypeName</em> is followed by the keyword
<code>nillable</code>.</p>
<p>Example: <code>element(*, surgeon)</code> matches any non-nilled element
node whose type annotation is <code>surgeon</code>, regardless of its
name.</p>
<p>Example: <code>element(*, surgeon nillable)</code> matches any element
node whose type annotation is <code>surgeon</code>, regardless of its name,
and permits the element to have the <code>nilled</code> property.</p>
</li>
<li>
<p><code>element(</code><em>SchemaContextPath ElementName</em><code>)</code>
matches a given element node if:</p>
<ol class="enumla">
<li>
<p>the name of the given element node matches the <em>ElementName</em>,
and:</p>
</li>
<li>
<p><code>type-matches(</code><em>ST, AT</em><code>)</code> is
<code>true</code>, where <em>ST</em> is the type of the element declaration
that would be associated with an element named <em>ElementName</em> in the
context identified by <em>SchemaContextPath</em>. (This may be either a
locally declared element or a top-level element.) However, if the given
element node has the <code>nilled</code> property, then this rule is
satisfied only if <em>ST</em> includes the <code>nillable</code> option. If
<em>SchemaContextPath</em> and <em>ElementName</em> together do not identify
a valid schema path in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>, a <a title="static error" href=
"#dt-static-error">static error</a> is raised.[<a title="err:XP0055" href=
"#ERRXP0055">err:XP0055</a>]</p>
</li>
</ol>
<p>Example: <code>element(hospital/staff/person)</code> matches an element
node whose name is <code>person</code> and whose type matches the type of the
element identified by the schema path <code>hospital/staff/person</code>.</p>
<p>Example: <code>element(type(schedule)/person)</code> matches an element
node whose name is <code>person</code> and whose type matches the type of a
<code>person</code> element within the named type <code>schedule</code>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a id="id-matching-attr" name="id-matching-attr"></a>2.4.4.4 Matching an
AttributeTest and an Attribute Node</h5>
<p>[<a title="AttributeTest" id="dt-attribute-test" name=
"dt-attribute-test">Definition</a>: An <b>AttributeTest</b> is used to match
an attribute node by its name and/or type.]</p>
<p>In the following rules, <em>AttributeName</em> and <em>TypeName</em> are
names that match the corresponding productions in the grammar. The pair
<em>SchemaContextPath AttributeName</em> represents a path that matches the
corresponding productions in the grammar. Note that the <em>SchemaContextPath
AttributeName</em> pair is just one path; for instance, the path
<code>catalog/product/price</code> is an example of such a pair, where
<code>catalog/product/</code> is the <em>SchemaContextPath</em> and
<code>price</code> is the <em>AttributeName</em>. Two QNames "match" if their
expanded forms (URIs and local names) are identical.</p>
<p>An AttributeTest may take one of the following forms:</p>
<ol class="enumar">
<li>
<p><code>attribute()</code>, <code>attribute(*)</code>, and
<code>attribute(*,*)</code> match any single attribute node, regardless of
its name or type.</p>
</li>
<li>
<p><code>attribute(</code><em>AttributeName</em><code>,</code>
<em>TypeName</em><code>)</code> matches a given attribute node if:</p>
<ol class="enumla">
<li>
<p>the name of the given attribute node matches <em>AttributeName</em>,
and:</p>
</li>
<li>
<p><code>type-matches(</code><em>TypeName, AT</em><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the given
attribute node.</p>
</li>
</ol>
<p>For this form, there is no requirement that <em>AttributeName</em> be
defined in the <b>in-scope attribute declarations</b>.</p>
<p>Example: <code>attribute(price, currency)</code> matches an attribute node
whose name is <code>price</code> and whose type annotation is
<code>currency</code>.</p>
</li>
<li>
<p><code>attribute(</code><em>AttributeName</em><code>)</code> matches a
given attribute node if:</p>
<ol class="enumla">
<li>
<p>the name of the given attribute node matches <em>AttributeName</em>,
and:</p>
</li>
<li>
<p><code>type-matches(</code><em>ST, AT</em><code>)</code> is
<code>true</code>, where <em>ST</em> is the simple or complex type of
attribute <em>AttributeName</em> in the <a title=
"in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute
declarations</a>, and <em>AT</em> is the type of the given attribute
node.</p>
</li>
</ol>
<p>Example: <code>attribute(price)</code> matches an attribute node whose
name is <code>price</code> and whose type annotation matches the top-level
attribute declaration for a <code>price</code> attribute.</p>
</li>
<li>
<p><code>attribute(</code><em>AttributeName</em><code>, *)</code> matches an
attribute node of any type if the name of the node matches
<em>AttributeName</em>.</p>
<p>For this form, there is no requirement that <em>AttributeName</em> be
defined in the <b>in-scope attribute declarations</b>.</p>
<p>Example: <code>attribute(price, *)</code> matches any attribute node whose
name is <code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*,</code> <em>TypeName</em><code>)</code> matches a given
attribute node if <code>type-matches(</code><em>TypeName,
AT</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type
annotation of the given attribute node.</p>
<p>Example: <code>attribute(*, currency)</code> matches any attribute node
whose type annotation is <code>currency</code>, regardless of its name.</p>
</li>
<li>
<p><code>attribute(</code><em>SchemaContextPath
AttributeName</em><code>)</code> matches a given attribute node if:</p>
<ol class="enumla">
<li>
<p>the name of the given attribute node matches the <em>AttributeName</em>,
and:</p>
</li>
<li>
<p><code>type-matches(</code><em>ST, AT</em><code>)</code> is
<code>true</code>, where <em>ST</em> is the type of the attribute declaration
that would be associated with an attribute named <em>AttributeName</em> in
the context identified by <em>SchemaContextPath</em>. (This may be either a
locally declared attribute or a top-level attribute.)</p>
</li>
</ol>
<p>Example: <code>attribute(catalog/product/price)</code> matches an
attribute node whose name is <code>price</code> and whose type matches the
type of the attribute identified by the schema path
<code>catalog/product/price</code>.</p>
<p>Example: <code>attribute(type(plan)/price)</code> matches an attribute
node whose name is <code>price</code> and whose type matches the type of a
<code>price</code> attribute within the globally defined type
<code>plan</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="div2">
<h3><a id="errors" name="errors"></a>2.5 Error Handling</h3>
<div class="div3">
<h4><a id="id-kinds-of-errors" name="id-kinds-of-errors"></a>2.5.1 Kinds of
Errors</h4>
<p>As described in <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>, XPath defines an <a title="static analysis phase" href=
"#dt-static-analysis">analysis phase</a>, which does not depend on input
data, and an <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">evaluation phase</a>, which does depend on input
data. Errors may be raised during each phase.</p>
<p>[<a title="static error" id="dt-static-error" name=
"dt-static-error">Definition</a>: A <b>static error</b> is an error that must
be detected during the analysis phase. A syntax error is an example of a
<a title="static error" href="#dt-static-error">static error</a>. The means
by which <a title="static error" href="#dt-static-error">static errors</a>
are reported during the analysis phase is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>. ]</p>
<p>[<a title="dynamic error" id="dt-dynamic-error" name=
"dt-dynamic-error">Definition</a>: A <b>dynamic error</b> is an error that
must be detected during the evaluation phase and may be detected during the
analysis phase. Numeric overflow is an example of a dynamic error. ]</p>
<p>[<a title="type error" id="dt-type-error" name=
"dt-type-error">Definition</a>: A <b>type error</b> may be raised during the
analysis or evaluation phase. During the analysis phase, a <a title=
"type error" href="#dt-type-error">type error</a> occurs when the <a title=
"static type" href="#dt-static-type">static type</a> of an expression does
not match the expected type of the context in which the expression occurs.
During the evaluation phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the dynamic type of a value does
not match the expected type of the context in which the value occurs. ]</p>
<p>The outcome of the <a title="static analysis phase" href=
"#dt-static-analysis">analysis phase</a> is either success or one or more
<a title="type error" href="#dt-type-error">type errors</a> and/or <a title=
"static error" href="#dt-static-error">static errors</a>. The result of the
<a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">evaluation
phase</a> is either a result value, a <a title="type error" href=
"#dt-type-error">type error</a>, or a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
<p>If any expression (at any level) can be evaluated during the analysis
phase (because all its explicit operands are known and it has no dependencies
on the dynamic context), then any error in performing this evaluation may be
reported as a static error. However, the <code>fn:error()</code> function
must not be evaluated during the analysis phase. For example, an
implementation is allowed (but not required) to treat the following
expression as a static error, because it calls a constructor function with a
constant string that is not in the lexical space of the target type:</p>
<div class="exampleInner">
<pre>
xs:date("Next Tuesday")
</pre></div>
<p>In addition to <a title="static error" href="#dt-static-error">static
errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a>, and <a title="type error" href="#dt-type-error">type errors</a>,
an XPath implementation may raise <b>warnings</b>, either during the analysis
phase or the evaluation phase. The circumstances in which warnings are
raised, and the ways in which warnings are handled, are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>In addition to the errors defined in this specification, an implementation
may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if insufficient resources are available for processing a given
expression. For example, an implementation may specify limitations on the
maximum numbers or sizes of various objects. These limitations, and the
consequences of exceeding them, are <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<div class="div3">
<h4><a id="id-handling-dynamic" name="id-handling-dynamic"></a>2.5.2 Handling
Dynamic Errors</h4>
<p>Except as noted in this document, if any operand of an expression raises a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, the
expression also raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>. If an expression can validly return a
value or raise a dynamic error, the implementation may choose to return the
value or raise the <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>. For example, the logical expression <code>expr1 and expr2</code>
may return the value <code>false</code> if either operand returns
<code>false</code>, or may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if either operand raises a dynamic
error.</p>
<p>If more than one operand of an expression raises an error, the
implementation may choose which error is raised by the expression. For
example, in this expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
</div>
<p>both the sub-expressions <code>($x div $y)</code> and
<code>xs:decimal($z)</code> may raise an error. The implementation may choose
which error is raised by the "<code>+</code>" expression. Once one operand
raises an error, the implementation is not required, but is permitted, to
evaluate any other operands.</p>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
carries an <a title="error value" href="#dt-error-value">error value</a>.
[<a title="error value" id="dt-error-value" name=
"dt-error-value">Definition</a>: An <b>error value</b> is a single item or
the empty sequence.] For example, an error value might be an integer, a
string, a QName, or an element. An implementation may provide a mechanism
whereby an application-defined error handler can process error values and
produce diagnostics; in the absence of such an error handler, the string
value of the error value may be used directly as an error message.</p>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> may
be raised by a built-in function or operator. For example, the
<code>div</code> operator raises an error if its second operand equals
zero.</p>
<p>An error can be raised explicitly by calling the <code>fn:error</code>
function, which only raises an error and never returns a value. This function
is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>. The <code>fn:error</code> function takes an
optional item as its parameter, which is the <a title="error value" href=
"#dt-error-value">error value</a>. For example, the following function call
raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
whose error value is a string:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:error(fn:concat("Unexpected value ", fn:string($v)))
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-errors-and-opt" name="id-errors-and-opt"></a>2.5.3 Errors and
Optimization</h4>
<p>Because different implementations may choose to evaluate or optimize an
expression in different ways, the detection and reporting of <a title=
"dynamic error" href="#dt-dynamic-error">dynamic errors</a> is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>When an implementation is able to evaluate an expression without
evaluating some subexpression, the implementation is never required to
evaluate that subexpression solely to determine whether it raises a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>. For example, if a
function parameter is never used in the body of the function, an
implementation may choose whether to evaluate the expression bound to that
parameter in a function call.</p>
<p>Similarly, in evaluating an expression, an implementation is not required
to search for data whose only possible effect on the result would be to raise
an error, as illustrated in the following examples.</p>
<ul>
<li>
<p>If an implementation can find (for example, by using an index) that at
least one item returned by <code>$expr1</code> in the following example has
the value <code>47</code>, it is allowed to return <code>true</code> as the
result of the <code>some</code> expression, without searching for another
item returned by <code>$expr1</code> that would raise an error because it is
not an integer.</p>
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</li>
<li>
<p>In the following example, if an implementation can find (for example, by
using an index) the <code>product</code> element-nodes that have an
<code>id</code> child with the value <code>47</code>, it is allowed to return
these nodes as the result of the path expression, without searching for
another <code>product</code> node that would raise an error because it has an
<code>id</code> child whose value is not an integer.</p>
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</li>
</ul>
<p>In some cases, an optimizer may be able to achieve substantial performance
improvements by rearranging an expression so that the underlying operations
are performed in a different order than that in which they are written. In
such cases, errors may be raised that would not have been raised if the
expression were evaluated as written. However, an expression must not be
rearranged in a way that changes its result value in the absence of
errors.</p>
<ul>
<li>
<p>The expression in the following example cannot raise a casting error if it
is evaluated exactly as written (i.e., left to right). An implementation is
permitted, however, to reorder the predicates to achieve better performance
(for example, by taking advantage of an index). This reordering could cause
the expression to raise an error.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
</div>
</li>
</ul>
<p>To avoid unexpected errors caused by reordering of expressions, tests that
are designed to prevent dynamic errors should be expressed using conditional
expressions. Conditional expressions raise only dynamic errors that occur in
the branch that is actually selected.</p>
<ul>
<li>
<p>Unlike the previous example, the following example cannot raise a dynamic
error if <code>@x</code> is not castable into an <code>xs:date</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-optional-features" name="id-optional-features"></a>2.6 Optional
Features</h3>
<div class="xpath">
<p class="xpath">[<a title="Static Typing Feature" id=
"dt-static-typing-feature" name="dt-static-typing-feature">Definition</a>:
XPath 2.0 defines an optional feature called the <b>Static Typing
Feature</b>.] An implementation that includes this feature is required to
detect type errors during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. If an expression contains
one or more static errors or type errors, then a Static Typing implementation
must raise at least one of these errors during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a id="id-expressions" name="id-expressions"></a>3 Expressions</h2>
<p>This section discusses each of the basic kinds of expression. Each kind of
expression has a name such as <code>PathExpr</code>, which is introduced on
the left side of the grammar production that defines the expression. Since
XPath is a composable language, each kind of expression is defined in terms
of other expressions whose operators have a higher precedence. In this way,
the precedence of operators is represented explicitly in the grammar.</p>
<p>The order in which expressions are discussed in this document does not
reflect the order of operator precedence. In general, this document
introduces the simplest kinds of expressions first, followed by more complex
expressions. For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A
XPath Grammar</b></a>].</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-XPath" name=
"doc-xpath-XPath"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Expr" name=
"doc-xpath-Expr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ExprSingle" name=
"doc-xpath-ExprSingle"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a><br />
| <a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xpath-IfExpr">IfExpr</a><br />
| <a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p><span class="xpath"><span class="xpath">The highest-level symbol in the
XPath grammar is XPath.</span></span></p>
<p>The XPath operator that has lowest precedence is the comma operator
(described in <a href="#construct_seq"><b>3.3.1 Constructing
Sequences</b></a>), which is used to concatenate two operands to form a
sequence. As shown in the grammar, a general expression (Expr) can consist of
two operands (ExprSingle) separated by a comma. The name ExprSingle denotes
an expression that does not contain a top-level comma operator (despite its
name, an ExprSingle may evaluate to a sequence containing more than one
item.)</p>
<p>The symbol ExprSingle is used in various places in the grammar where an
expression is not allowed to contain a top-level comma. For example, each of
the arguments of a function call must be an ExprSingle, because commas are
used to separate the arguments of a function call.</p>
<p>After the comma, the expressions that have next lowest precedence are
<span class="xpath"><span class="xpath">ForExpr,</span></span>
QuantifiedExpr, IfExpr, and OrExpr. Each of these expressions is described in
a separate section of this document.</p>
<div class="div2">
<h3><a id="id-primary-expressions" name="id-primary-expressions"></a>3.1
Primary Expressions</h3>
<p>[<a title="primary expression" id="dt-primary-expression" name=
"dt-primary-expression">Definition</a>: <b>Primary expressions</b> are the
basic primitives of the language. They include literals, variable references,
context item expressions, and function calls. A primary expression may also
be created by enclosing any expression in parentheses, which is sometimes
helpful in controlling the precedence of operators.]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PrimaryExpr" name=
"doc-xpath-PrimaryExpr"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a> | <a href=
"#doc-xpath-VarRef">VarRef</a> | <a href=
"#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#doc-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#doc-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a id="id-literals" name="id-literals"></a>3.1.1 Literals</h4>
<p>[<a title="literal" id="dt-literal" name="dt-literal">Definition</a>: A
<b>literal</b> is a direct syntactic representation of an atomic value.]
XPath supports two kinds of literals: numeric literals and string
literals.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Literal" name=
"doc-xpath-Literal"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a> | <a href=
"#doc-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NumericLiteral" name=
"doc-xpath-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a> | <a href=
"#doc-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IntegerLiteral" name=
"doc-xpath-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DecimalLiteral" name=
"doc-xpath-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DoubleLiteral" name=
"doc-xpath-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> ("." [0-9]*)?)) ("e" | "E") ("+" | "-")?
<a href="#doc-xpath-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-StringLiteral" name=
"doc-xpath-StringLiteral"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (('"' '"') | [^"])* '"') | ("'" (("'" "'") | [^'])*
"'")</code></td>
<td><i>/* <a href="#ws-significant">ws: significant</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Digits" name=
"doc-xpath-Digits"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p>The value of a <b>numeric literal</b> containing no "<code>.</code>" and
no <code>e</code> or <code>E</code> character is an atomic value of type
<code>xs:integer</code>. The value of a numeric literal containing
"<code>.</code>" but no <code>e</code> or <code>E</code> character is an
atomic value of type <code>xs:decimal</code>. The value of a numeric literal
containing an <code>e</code> or <code>E</code> character is an atomic value
of type <code>xs:double</code>. Values of numeric literals are interpreted
according to the rules in <a href="#XMLSchema">[XML Schema]</a>.</p>
<p>The value of a <b>string literal</b> is an atomic value whose type is
<code>xs:string</code> and whose value is the string denoted by the
characters between the delimiting apostrophes or quotation marks. If the
literal is delimited by apostrophes, two adjacent apostrophes within the
literal are interpreted as a single apostrophe. Similarly, if the literal is
delimited by quotation marks, two adjacent quotation marks within the literal
are interpreted as one quotation mark.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a string literal is used in an XPath expression contained within the
value of an XML attribute, the characters used to delimit the literal must be
different from the characters that are used to delimit the attribute.</p>
</div>
<p>Here are some examples of literal expressions:</p>
<ul>
<li>
<p><code>"12.5"</code> denotes the string containing the characters '1', '2',
'.', and '5'.</p>
</li>
<li>
<p><code>12</code> denotes the integer value twelve.</p>
</li>
<li>
<p><code>12.5</code> denotes the decimal value twelve and one half.</p>
</li>
<li>
<p><code>125E2</code> denotes the double value twelve thousand, five
hundred.</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code> denotes a string containing
two quotation marks and one apostrophe.</p>
</li>
</ul>
<p>The boolean values <code>true</code> and <code>false</code> can be
represented by calls to the built-in functions <code>fn:true()</code> and
<code>fn:false()</code>, respectively.</p>
<p>Values of other atomic types can be constructed by calling the constructor
for the given type. The constructors for XML Schema built-in types are
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>. In general, the name of a constructor function
for a given type is the same as the name of the type (including its
namespace). For example:</p>
<ul>
<li>
<p><code>xs:integer("12")</code> returns the integer value twelve.</p>
</li>
<li>
<p><code>xs:date("2001-08-25")</code> returns an item whose type is
<code>xs:date</code> and whose value represents the date 25th August
2001.</p>
</li>
<li>
<p><code>xdt:dayTimeDuration("PT5H")</code> returns an item whose type is
<code>xdt:dayTimeDuration</code> and whose value represents a duration of
five hours.</p>
</li>
</ul>
<p>It is also possible to construct values of various types by using a
<code>cast</code> expression. For example:</p>
<ul>
<li>
<p><code>9 cast as hatsize</code> returns the atomic value <code>9</code>
whose type is <code>hatsize</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-variables" name="id-variables"></a>3.1.2 Variable
References</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-VarRef" name=
"doc-xpath-VarRef"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-VarName" name=
"doc-xpath-VarName"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>variable reference</b> is a QName preceded by a $-sign. Two variable
references are equivalent if their local names are the same and their
namespace prefixes are bound to the same namespace URI in the <a title=
"in-scope namespaces" href="#dt-is-namespaces">in-scope namespaces</a>. An
unprefixed variable reference is in no namespace.</p>
<p>Every variable reference must match a name in the <a title=
"in-scope variables" href="#dt-is-vars">in-scope variables</a>, which include
variables from the following sources:</p>
<ol class="enumar">
<li>
<p>A variable may be added to the in-scope variables by the host language
environment.</p>
</li>
<li>
<p>A variable may be bound by an XPath expression. <span class=
"xpath"><span class="xpath">The kinds of expressions that can bind variables
are <code>for</code> expressions (<a href="#id-for-expressions"><b>3.7 For
Expressions</b></a>) and quantified expressions (<a href=
"#id-quantified-expressions"><b>3.9 Quantified
Expressions</b></a>).</span></span></p>
</li>
</ol>
<p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur. It is a <a title="static error"
href="#dt-static-error">static error</a> [<a title="err:XP0008" href=
"#ERRXP0008">err:XP0008</a>] to reference a variable that is not in scope. If
a variable is bound in the <a title="static context" href=
"#dt-static-context">static context</a> for an expression, that variable is
in scope for the entire expression.</p>
<p>If a variable reference matches two or more bindings that are in scope,
then the reference is taken as referring to the inner binding, that is, the
one whose scope is smaller. At evaluation time, the value of a variable
reference is the value of the expression to which the relevant variable is
bound. The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p>
</div>
<div class="div3">
<h4><a id="id-paren-expressions" name="id-paren-expressions"></a>3.1.3
Parenthesized Expressions</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ParenthesizedExpr" name=
"doc-xpath-ParenthesizedExpr"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>Parentheses may be used to enforce a particular evaluation order in
expressions that contain multiple operators. For example, the expression
<code>(2 + 4) * 5</code> evaluates to thirty, since the parenthesized
expression <code>(2 + 4)</code> is evaluated first and its result is
multiplied by five. Without parentheses, the expression <code>2 + 4 *
5</code> evaluates to twenty-two, because the multiplication operator has
higher precedence than the addition operator.</p>
<p>Empty parentheses are used to denote an empty sequence, as described in
<a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a>.</p>
</div>
<div class="div3">
<h4><a id="id-context-item-expression" name=
"id-context-item-expression"></a>3.1.4 Context Item Expression</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ContextItemExpr" name=
"doc-xpath-ContextItemExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p>A <b>context item expression</b> evaluates to the <a title="context item"
href="#dt-context-item">context item</a>, which may be either a node (as in
the expression <code>fn:doc("bib.xml")//book[fn:count(./author)&gt;1]</code>)
or an atomic value (as in the expression <code>(1 to 100)[. mod 5 eq
0]</code>).</p>
<p>If the <a title="context item" href="#dt-context-item">context item</a> is
undefined, a context item expression raises a dynamic error.[<a title=
"err:XP0002" href="#ERRXP0002">err:XP0002</a>]</p>
</div>
<div class="div3">
<h4><a id="id-function-calls" name="id-function-calls"></a>3.1.5 Function
Calls</h4>
<p>A <b>function call</b> consists of a QName followed by a parenthesized
list of zero or more expressions, called <b>arguments</b>. If the QName in
the function call has no namespace prefix, it is considered to be in the
<a title="default function namespace" href="#dt-def-fn-ns">default function
namespace.</a></p>
<p>If the expanded QName and number of arguments in a function call do not
match the name and arity of an <a title="in-scope functions" href=
"#dt-is-funcs">in-scope function</a> in the <a title="static context" href=
"#dt-static-context">static context</a>, <span class="xpath"><span class=
"xpath">an error is raised (the host language environment may define this
error as either a static or a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>).</span></span>[<a title="err:XP0017"
href="#ERRXP0017">err:XP0017</a>]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-FunctionCall" name=
"doc-xpath-FunctionCall"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>XPath allows functions to be called. A core library of functions is
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>. <span class="xpath"><span class=
"xpath">Additional functions may be provided in the <a title="static context"
href="#dt-static-context">static context</a>. XPath per se does not provide a
way to declare functions, but a host language may provide such a
mechanism.</span></span></p>
<p>A function call is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>Argument expressions are evaluated, producing argument values. The order
of argument evaluation is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> and a function
need not evaluate an argument if the function can evaluate its body without
evaluating that argument.</p>
</li>
<li>
<p>Each argument value is converted by applying the function conversion rules
listed below.</p>
</li>
<li class="xpath">
<p>The function is evaluated using the converted argument values. The result
is a value of the function's declared return type.</p>
</li>
</ol>
<p>The <b>function conversion rules</b> are used to convert an argument value
to its expected type; that is, to the declared type of the function
parameter. The expected type is expressed as a <a title="SequenceType" href=
"#dt-sequence-type">SequenceType</a>. The function conversion rules are
applied to a given value as follows:</p>
<ul>
<li class="xpath">
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code> and the
argument is not of the expected type, then one of the following conversions
is applied:</p>
<ol class="enumar">
<li>
<p>If the expected type is <code>xs:string</code> or <code>xs:string?</code>,
then the given value <code>V</code> is effectively replaced by
<code>fn:string(V[1])</code>.</p>
</li>
<li>
<p>If the expected type is a numeric type, then the given value
<code>V</code> is effectively replaced by <code>fn:number(V[1])</code>.</p>
</li>
<li>
<p>If the expected type is <code>node()</code>, <code>node()?</code>,
<code>item()</code>, or <code>item()?</code>, then the given value
<code>V</code> is effectively replaced by <code>V[1]</code> .</p>
</li>
<li>
<p>Otherwise, the given value is unchanged and the remaining function
conversion rules are applied.</p>
</li>
</ol>
</li>
<li>
<p>If the expected type is a sequence of an atomic type (possibly with an
occurrence indicator <code>*</code>, <code>+</code>, or <code>?</code>), the
following conversions are applied:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied
to the given value, resulting in a sequence of atomic values.</p>
</li>
<li>
<p>Each item in the atomic sequence that is of type
<code>xdt:untypedAtomic</code> is cast to the expected atomic type.</p>
</li>
<li>
<p>For each numeric item in the atomic sequence that can be <b>promoted</b>
to the expected atomic type using the promotion rules in <a href=
"#promotion"><b>B.1 Type Promotion</b></a>, the promotion is done.</p>
</li>
</ol>
</li>
<li>
<p>If, after the above conversions, the resulting value does not match the
expected type according to the rules for <a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType Matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised. [<a title=
"err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>] If the function call takes place in a module
other than the module in which the function is defined, this rule must be
satisfied in both the module where the function is called and the module
where the function is defined (the test is repeated because the two modules
may have different <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>.) Note that the rules for
<a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a> permit a value of a
derived type to be substituted for a value of its base type.</p>
</li>
</ul>
<p>Since the arguments of a function call are separated by commas, any
argument expression that contains a top-level comma operator must be enclosed
in parentheses. Here are some illustrative examples of function calls:</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2, 3)</code> denotes a function call
with three arguments.</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2), 3)</code> denotes a function call
with two arguments, the first of which is a sequence of two values.</p>
</li>
<li>
<p><code>my:two-argument-function(1, ())</code> denotes a function call with
two arguments, the second of which is an empty sequence.</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2, 3))</code> denotes a function call
with one argument that is a sequence of three values.</p>
</li>
<li>
<p><code>my:one-argument-function(( ))</code> denotes a function call with
one argument that is an empty sequence.</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code> denotes a function call with
zero arguments.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="comments" name="comments"></a>3.1.6 XPath Comments</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ExprComment" name=
"doc-xpath-ExprComment"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprComment">ExprComment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#doc-xpath-ExprCommentContent">ExprCommentContent</a> | <a href=
"#doc-xpath-ExprComment">ExprComment</a>)* ":)"</code></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ExprCommentContent" name=
"doc-xpath-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ExprCommentContent">ExprCommentContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Char">Char</a></code></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
</table>
<p>XPath comments can be used to provide informative annotation. These
comments are lexical constructs only, and do not affect the processing of an
expression. Comments are delimited by the symbols <code>(:</code> and
<code>:)</code>. Comments may be nested.</p>
<p>Comments may be used anywhere ignorable whitespace is allowed. See
<a href="#lexical-structure"><b>A.2 Lexical structure</b></a> for the exact
lexical states where comments are recognized.</p>
<p>The following is an example of a comment:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a id="id-path-expressions" name="id-path-expressions"></a>3.2 Path
Expressions</h3>
<p>A <b>path expression</b> can be used to locate nodes within trees.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PathExpr" name=
"doc-xpath-PathExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">gn: leading-lone-slash</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-RelativePathExpr" name=
"doc-xpath-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a> (("/" | "//") <a href=
"#doc-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A path expression consists of a series of one or more <b>steps</b>,
separated by "<code>/</code>" or "<code>//</code>", and optionally beginning
with "<code>/</code>" or "<code>//</code>". An initial "<code>/</code>" or
"<code>//</code>" is an abbreviation for one or more initial steps that are
implicitly added to the beginning of the path expression, as described
below.</p>
<p>A path expression consisting of a single step is evaluated as described in
<a href="#id-axis-steps"><b>3.2.1 Steps</b></a>.</p>
<p>Each occurrence of <code>//</code> in a path expression is expanded as
described in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>, leaving a
sequence of steps separated by <code>/</code>. This sequence of steps is then
evaluated from left to right. Each operation <code>E1/E2</code> is evaluated
as follows: Expression <code>E1</code> is evaluated, and if the result is not
a sequence of nodes, a <a title="type error" href="#dt-type-error">type
error</a> is raised.[<a title="err:XP0019" href="#ERRXP0019">err:XP0019</a>]
Each node resulting from the evaluation of <code>E1</code> then serves in
turn to provide an <b>inner focus</b> for an evaluation of <code>E2</code>,
as described in <a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>.
Each evaluation of <code>E2</code> must result in a (possibly empty) sequence
of nodes; otherwise, a <a title="type error" href="#dt-type-error">type
error</a> is raised.[<a title="err:XP0019" href="#ERRXP0019">err:XP0019</a>]
The sequences of nodes resulting from all the evaluations of <code>E2</code>
are combined, eliminating duplicate nodes based on node identity and sorting
the result in document order.</p>
<p>As an example of a path expression, <code>child::div1/child::para</code>
selects the <code>para</code> element children of the <code>div1</code>
element children of the context node, or, in other words, the
<code>para</code> element grandchildren of the context node that have
<code>div1</code> parents.</p>
<p>A "<code>/</code>" at the beginning of a path expression is an
abbreviation for the initial step <code>fn:root(self::node()) treat as
document-node()</code> (this is true even if the "<code>/</code>" is the
entire path expression). The effect of this initial step is to begin the path
at the root node of the tree that contains the context node. If the context
item is not a node, a <a title="type error" href="#dt-type-error">type
error</a> is raised.[<a title="err:XP0020" href="#ERRXP0020">err:XP0020</a>]
At evaluation time, if the root node above the context node is not a document
node, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
is raised.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>
<p>The "<code>/</code>" character is used, with different meanings, both as
an operator or an operand. This causes lexical difficulties when it appears
in leading position in an expression. For instance, "<code>/*</code>" is an
expression with a wildcard, and "<code>/*5</code>" is a parse error. In
general, it is best to use parentheses when "<code>/</code>" is used as the
first operand of an operator, e.g. <code>(/) * 5</code>.</p>
<p>A "<code>//</code>" at the beginning of a path expression is an
abbreviation for the initial steps <code>fn:root(self::node()) treat as
document-node()/descendant-or-self::node()</code>. The effect of these
initial steps is to establish an initial node sequence that contains the root
of the tree in which the context node is found, plus all nodes descended from
this root. This node sequence is used as the input to subsequent steps in the
path expression. If the context item is not a node, a <a title="type error"
href="#dt-type-error">type error</a> is raised.[<a title="err:XP0020" href=
"#ERRXP0020">err:XP0020</a>] At evaluation time, if the root node above the
context node is not a document node, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0050" href=
"#ERRXP0050">err:XP0050</a>]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The descendants of a node do not include attribute nodes or namespace
nodes.</p>
</div>
<div class="div3">
<h4><a id="id-axis-steps" name="id-axis-steps"></a>3.2.1 Steps</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-StepExpr" name=
"doc-xpath-StepExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AxisStep">AxisStep</a> | <a href=
"#doc-xpath-FilterStep">FilterStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AxisStep" name=
"doc-xpath-AxisStep"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ForwardStep">ForwardStep</a> | <a href=
"#doc-xpath-ReverseStep">ReverseStep</a>) <a href=
"#doc-xpath-Predicates">Predicates</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-FilterStep" name=
"doc-xpath-FilterStep"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-FilterStep">FilterStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a> <a href=
"#doc-xpath-Predicates">Predicates</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForwardStep" name=
"doc-xpath-ForwardStep"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ForwardAxis">ForwardAxis</a> <a href=
"#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ReverseStep" name=
"doc-xpath-ReverseStep"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ReverseAxis">ReverseAxis</a> <a href=
"#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>step</b> generates a sequence of items and then filters the sequence
by zero or more <b>predicates</b>. The value of the step consists of those
items that satisfy the predicates. Predicates are described in <a href=
"#id-predicates"><b>3.2.2 Predicates</b></a>. XPath provides two kinds of
steps, called <b>filter steps</b> and <b>axis steps</b>.</p>
<p>A <b>filter step</b> consists simply of a <b>primary expression</b>
followed by zero or more predicates. The result of the filter step consists
of all the items returned by the primary expression for which all the
predicates are true. If no predicates are specified, the result is simply the
result of the primary expression. This result may contain nodes, atomic
values, or any combination of these. The ordering of the items returned by a
filter step is the same as their order in the result of the primary
expression. Context positions are assigned to items based on their ordinal
position in the result sequence. The first context position is 1.</p>
<p>The result of an <b>axis step</b> is always a sequence of zero or more
nodes, and these nodes are always returned in document order. An axis step
may be either a <b>forward step</b> or a <b>reverse step</b>, followed by
zero or more predicates. An axis step might be thought of as beginning at the
<b>context node</b> and navigating to those nodes that are reachable from the
context node via a specified <b>axis</b>. Such a step has two parts: an
<b>axis</b>, which defines the "direction of movement" for the step, and a
<b>node test</b>, which selects nodes based on their kind, name, and/or type.
If the context item is not a node, a <a title="type error" href=
"#dt-type-error">type error</a> is raised.[<a title="err:XP0020" href=
"#ERRXP0020">err:XP0020</a>]</p>
<p>In the <b>abbreviated syntax</b> for a step, the axis can be omitted and
other shorthand notations can be used as described in <a href=
"#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<p>The unabbreviated syntax for an axis step consists of the axis name and
node test separated by a double colon. The result of the step consists of the
nodes reachable from the context node via the specified axis that have the
node kind, name, and/or type specified by the node test. For example, the
step <code>child::para</code> selects the <code>para</code> element children
of the context node: <code>child</code> is the name of the axis, and
<code>para</code> is the name of the element nodes to be selected on this
axis. The available axes are described in <a href="#axes"><b>3.2.1.1
Axes</b></a>. The available node tests are described in <a href=
"#node-tests"><b>3.2.1.2 Node Tests</b></a>. Examples of steps are provided
in <a href="#unabbrev"><b>3.2.3 Unabbreviated Syntax</b></a> and <a href=
"#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<div class="div4">
<h5><a id="axes" name="axes"></a>3.2.1.1 Axes</h5>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForwardAxis" name=
"doc-xpath-ForwardAxis"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ReverseAxis" name=
"doc-xpath-ReverseAxis"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"parent" "::"<br />
| "ancestor" "::"<br />
| "preceding-sibling" "::"<br />
| "preceding" "::"<br />
| "ancestor-or-self" "::"</code></td>
</tr>
</tbody>
</table>
<div class="xpath">
<p class="xpath">XPath defines a set of full set of <b>axes</b> for
traversing documents, but a <b>host language</b> may define a subset of these
axes. The following axes are defined:</p>
</div>
<ul>
<li>
<p>The <code>child</code> axis contains the children of the context node,
which are the nodes returned by the <code>dm:children</code> accessor in
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only document nodes and element nodes have children. If the context node
is any other kind of node, or if the context node is an empty document or
element node, then the child axis is an empty sequence. The children of a
document node or element node may be element, processing instruction,
comment, or text nodes. Attribute, namespace, and document nodes can never
appear as children.</p>
</div>
</li>
<li>
<p>the <code>descendant</code> axis is defined as the transitive closure of
the child axis; it contains the descendants of the context node (the
children, the children of the children, and so on)</p>
</li>
<li>
<p>the <code>parent</code> axis contains the sequence returned by the
<code>dm:parent</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath
2.0 Data Model]</a>, which returns the parent of the context node, or an
empty sequence if the context node has no parent</p>
</li>
<li>
<p>the <code>ancestor</code> axis is defined as the transitive closure of the
parent axis; it contains the ancestors of the context node (the parent, the
parent of the parent, and so on)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ancestor axis includes the root node of the tree in which the context
node is found, unless the context node is the root node.</p>
</div>
</li>
<li>
<p>the <code>following-sibling</code> axis contains the context node's
following siblings, those children of the context node's parent that occur
after the context node in document order; if the context node is an attribute
node or namespace node, the <code>following-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>preceding-sibling</code> axis contains the context node's
preceding siblings, those children of the context node's parent that occur
before the context node in document order; if the context node is an
attribute node or namespace node, the <code>following-sibling</code> axis is
empty</p>
</li>
<li>
<p>the <code>following</code> axis contains all nodes that are descendants of
the root of the tree in which the context node is found, are not descendants
of the context node, and occur after the context node in document order</p>
</li>
<li>
<p>the <code>preceding</code> axis contains all nodes that are descendants of
the root of the tree in which the context node is found, are not ancestors of
the context node, and occur before the context node in document order</p>
</li>
<li>
<p>the <code>attribute</code> axis contains the attributes of the context
node, which are the nodes returned by the <code>dm:attributes</code> accessor
in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>; the axis
will be empty unless the context node is an element</p>
</li>
<li>
<p>the <code>self</code> axis contains just the context node itself</p>
</li>
<li>
<p>the <code>descendant-or-self</code> axis contains the context node and the
descendants of the context node</p>
</li>
<li>
<p>the <code>ancestor-or-self</code> axis contains the context node and the
ancestors of the context node; thus, the ancestor-or-self axis will always
include the root node</p>
</li>
<li class="xpath">
<p>the <code>namespace</code> axis contains the namespace nodes of the
context node, which are the nodes returned by the <code>dm:namespaces</code>
accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>;
this axis is empty unless the context node is an element node. The
<code>namespace</code> axis is deprecated in XPath 2.0. Whether an
implementation supports the <code>namespace</code> axis is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An implementation
that does not support the <code>namespace</code> axis must raise a <a title=
"static error" href="#dt-static-error">static error</a> [<a title=
"err:XP0021" href="#ERRXP0021">err:XP0021</a>] if it is used. Applications
needing information about the namespaces of an element should use the
functions <code>fn:get-in-scope-namespaces</code> and
<code>fn:get-namespace-uri-for-prefix</code> defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
</li>
</ul>
<p>Axes can be categorized as <b>forward axes</b> and <b>reverse axes</b>. An
axis that only ever contains the context node or nodes that are after the
context node in document order is a forward axis. An axis that only ever
contains the context node or nodes that are before the context node in
document order is a reverse axis.</p>
<p>The <code>parent</code>, <code>ancestor</code>,
<code>ancestor-or-self</code>, <code>preceding</code>, and
<code>preceding-sibling</code> axes are reverse axes; all other axes are
forward axes. The <code>ancestor</code>, <code>descendant</code>,
<code>following</code>, <code>preceding</code> and <code>self</code> axes
partition a document (ignoring attribute and namespace nodes): they do not
overlap and together they contain all the nodes in the document.</p>
<p>In a sequence of nodes selected by an axis step, each node is assigned a
context position that corresponds to its position in the sequence. If the
axis is a forward axis, context positions are assigned to the nodes in
document order, starting with 1. If the axis is a reverse axis, context
positions are assigned to the nodes in reverse document order, starting with
1. This makes it possible to select a node from the sequence by specifying
its position.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>One example of an expression that uses the context position is a numeric
predicate. The expression <code>child::para[1]</code> selects the first
paragraph that is a child of the context node.</p>
</div>
</div>
<div class="div4">
<h5><a id="node-tests" name="node-tests"></a>3.2.1.2 Node Tests</h5>
<p>A <b>node test</b> is a condition that must be true for each node selected
by a step. The condition may be based on the kind of the node (element,
attribute, text, document, comment, processing instruction, or namespace),
the name of the node, or (in the case of element, attribute, and document
nodes), the type of the node.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NodeTest" name=
"doc-xpath-NodeTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | <a href=
"#doc-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NameTest" name=
"doc-xpath-NameTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#doc-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Wildcard" name=
"doc-xpath-Wildcard"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
</table>
<p>Every axis has a <b>principal node kind</b>. If an axis can contain
elements, then the principal node kind is element; otherwise, it is the kind
of nodes that the axis can contain. Thus:</p>
<ul>
<li>
<p>For the attribute axis, the principal node kind is attribute.</p>
</li>
<li class="xpath">
<p>For the namespace axis, the principal node kind is namespace.</p>
</li>
<li>
<p>For all other axes, the principal node kind is element.</p>
</li>
</ul>
<p>A node test that consists only of a QName or a Wildcard is called a
<b>name test</b>. A name test is true if and only if the <b>kind</b> of the
node is the principal node kind and the expanded-QName of the node is equal
to the expanded-QName specified by the name test. For example,
<code>child::para</code> selects the <code>para</code> element children of
the context node; if the context node has no <code>para</code> children, it
selects an empty set of nodes. <code>attribute::abc:href</code> selects the
attribute of the context node with the QName <code>abc:href</code>; if the
context node has no such attribute, it selects an empty set of nodes.</p>
<p>A QName in a name test is expanded into an expanded-QName using the
<a title="in-scope namespaces" href="#dt-is-namespaces">in-scope
namespaces</a> in the expression context. It is a <a title="static error"
href="#dt-static-error">static error</a> [<a title="err:XP0008" href=
"#ERRXP0008">err:XP0008</a>] if the QName has a prefix that does not
correspond to any in-scope namespace. An unprefixed QName, when used as a
name test on an axis whose principal node kind is element, has the namespace
URI of the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> in the expression
context; otherwise, it has no namespace URI.</p>
<p>A name test is not satisfied by an element node whose name does not match
the QName of the name test, even if it is in a substitution group whose head
is the named element.</p>
<p>A node test <code>*</code> is true for any node of the principal node
kind. For example, <code>child::*</code> will select all element children of
the context node, and <code>attribute::*</code> will select all attributes of
the context node.</p>
<p>A node test can have the form <code>NCName:*</code>. In this case, the
prefix is expanded in the same way as with a QName, using the <a title=
"in-scope namespaces" href="#dt-is-namespaces">in-scope namespaces</a> in the
<a title="static context" href="#dt-static-context">static context</a>. If
the prefix is not found in the in-scope namespaces, a <a title="static error"
href="#dt-static-error">static error</a> is raised.[<a title="err:XP0008"
href="#ERRXP0008">err:XP0008</a>] The node test is true for any node of the
principal node kind whose expanded-QName has the namespace URI to which the
prefix is bound, regardless of the local part of the name.</p>
<p>A node test can also have the form <code>*:NCName</code>. In this case,
the node test is true for any node of the principal node kind whose local
name matches the given NCName, regardless of its namespace.</p>
<p>An alternative form of a node test is called a <b>KindTest</b>, which can
select nodes based on their kind, name, and type annotation. The syntax and
semantics of a KindTest are described in <a href="#id-types"><b>2.4
Types</b></a>. When a KindTest is used in a node test, only those nodes on
the designated axis that match the KindTest are selected. Shown below are
several examples of KindTests that might be used in path expressions:</p>
<ul>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>element()</code> matches any element node.</p>
</li>
<li>
<p><code>element(person)</code> matches any element node whose name is
<code>person</code> (or is in the substitution group headed by
<code>person</code>), and whose type annotation conforms to the top-level
element declaration for a <code>person</code> element.</p>
</li>
<li>
<p><code>element(person, *)</code> matches any element node whose name is
<code>person</code> (or is in the substitution group headed by
<code>person</code>), without any restriction on type annotation.</p>
</li>
<li>
<p><code>element(person, surgeon)</code> matches any element node whose name
is <code>person</code> (or is in the substitution group headed by
<code>person</code>), and whose type annotation is <code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*, surgeon)</code> matches any element node whose type
annotation is <code>surgeon</code>, regardless of its name.</p>
</li>
<li>
<p><code>element(hospital/staff/person)</code> matches any element node whose
name and type annotation conform to the schema declaration of a
<code>person</code> element in a <code>staff</code> element in a
<code>hospital</code> element whose declaration is a top-level element
declaration.</p>
</li>
<li>
<p><code>attribute()</code> matches any attribute node.</p>
</li>
<li>
<p><code>attribute(price, *)</code> matches any attribute whose name is
<code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*, xs:decimal)</code> matches any attribute whose type
annotation is <code>xs:decimal</code>, regardless of its name.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(element(book))</code> matches any document node whose
content consists of a single element node that satisfies the KindTest
<code>element(book)</code>, mixed with zero or more comments and processing
instructions.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a id="id-predicates" name="id-predicates"></a>3.2.2 Predicates</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Predicates" name=
"doc-xpath-Predicates"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Predicates">Predicates</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("[" <a href="#doc-xpath-Expr">Expr</a> "]")*</code></td>
</tr>
</tbody>
</table>
<p>A predicate consists of an expression, called a <b>predicate
expression</b>, enclosed in square brackets. A predicate serves to filter a
sequence, retaining some items and discarding others. For each item in the
sequence to be filtered, the predicate expression is evaluated using an
<b>inner focus</b> derived from that item, as described in <a href=
"#eval_context"><b>2.1.2 Dynamic Context</b></a>. The result of the predicate
expression is coerced to a <code>xs:boolean</code> value, called the
<b>predicate truth value</b>, as described below. Those items for which the
predicate truth value is <code>true</code> are retained, and those for which
the predicate truth value is <code>false</code> are discarded.</p>
<p>The predicate truth value is derived by applying the following rules, in
order:</p>
<ol class="enumar">
<li>
<p>If the value of the predicate expression is an atomic value of a numeric
type, the predicate truth value is <code>true</code> if the value of the
predicate expression is equal to the <b>context position</b>, and is
<code>false</code> otherwise.</p>
</li>
<li>
<p>Otherwise, the predicate truth value is the <a title=
"effective boolean value" href="#dt-ebv">effective boolean value</a> of the
predicate expression.</p>
</li>
</ol>
<p>Here are some examples of <b>axis steps</b> that contain predicates:</p>
<ul>
<li>
<p>This example selects the second <code>chapter</code> element that is a
child of the context node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the descendants of the context node that are
elements named <code>"toy"</code> and whose <code>color</code> attribute has
the value <code>"red"</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the <code>employee</code> children of the context
node that have a <code>secretary</code> child element:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::employee[secretary]
</pre></div>
</div>
</li>
</ul>
<p>When using predicates with a sequence of nodes selected using a <b>reverse
axis</b>, it is important to remember that the the context positions for such
a sequence are assigned in <b>reverse document order</b>. For example,
<code>preceding::foo[1]</code> returns the first <code>foo</code> element in
reverse document order, because the axis that applies to the <code>[1]</code>
predicate is the <code>preceding</code> axis. By contrast,
<code>(preceding::foo)[1]</code> returns the first <code>foo</code> element
in document order, because the axis that applies to the <code>[1]</code>
predicate is the <code>child</code> axis. Similarly,
<code>ancestor::*[1]</code> returns the nearest ancestor element, because the
<code>ancestor</code> axis is a reverse axis.</p>
<p>Here are some examples of <b>filter steps</b> that contain predicates:</p>
<ul>
<li>
<p>List all the integers from 1 to 100 that are divisible by 5. (See <a href=
"#construct_seq"><b>3.3.1 Constructing Sequences</b></a> for an explanation
of the <code>to</code> operator.)</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</div>
</li>
<li>
<p>The result of the following expression is the integer 25:</p>
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="unabbrev" name="unabbrev"></a>3.2.3 Unabbreviated Syntax</h4>
<p>This section provides a number of examples of path expressions in which
the axis is explicitly specified in each step. The syntax used in these
examples is called the <b>unabbreviated syntax</b>. In many common cases, it
is possible to write path expressions more concisely using an <b>abbreviated
syntax</b>, as explained in <a href="#abbrev"><b>3.2.4 Abbreviated
Syntax</b></a>.</p>
<ul>
<li>
<p><code>child::para</code> selects the <code>para</code> element children of
the context node</p>
</li>
<li>
<p><code>child::*</code> selects all element children of the context node</p>
</li>
<li>
<p><code>child::text()</code> selects all text node children of the context
node</p>
</li>
<li>
<p><code>child::node()</code> selects all the children of the context node,
whatever their node type</p>
</li>
<li>
<p><code>attribute::name</code> selects the <code>name</code> attribute of
the context node</p>
</li>
<li>
<p><code>attribute::*</code> selects all the attributes of the context
node</p>
</li>
<li>
<p><code>parent::node()</code> selects the parent of the context node. If the
context node is an attribute node, this expression returns the element node
(if any) to which the attribute node is attached.</p>
</li>
<li>
<p><code>descendant::para</code> selects the <code>para</code> element
descendants of the context node</p>
</li>
<li>
<p><code>ancestor::div</code> selects all <code>div</code> ancestors of the
context node</p>
</li>
<li>
<p><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors
of the context node and, if the context node is a <code>div</code> element,
the context node as well</p>
</li>
<li>
<p><code>descendant-or-self::para</code> selects the <code>para</code>
element descendants of the context node and, if the context node is a
<code>para</code> element, the context node as well</p>
</li>
<li>
<p><code>self::para</code> selects the context node if it is a
<code>para</code> element, and otherwise selects nothing</p>
</li>
<li>
<p><code>child::chapter/descendant::para</code> selects the <code>para</code>
element descendants of the <code>chapter</code> element children of the
context node</p>
</li>
<li>
<p><code>child::*/child::para</code> selects all <code>para</code>
grandchildren of the context node</p>
</li>
<li>
<p><code>/</code> selects the root of the tree that contains the context
node, but raises a dynamic error if this root is not a document node</p>
</li>
<li>
<p><code>/descendant::para</code> selects all the <code>para</code> elements
in the same document as the context node</p>
</li>
<li>
<p><code>/descendant::list/child::member</code> selects all the
<code>member</code> elements that have a <code>list</code> parent and that
are in the same document as the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = 1]</code> selects the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()]</code> selects the last
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()-1]</code> selects the last but
one <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() &gt; 1]</code> selects all the
<code>para</code> children of the context node other than the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() = 1]</code>selects the next
<code>chapter</code> sibling of the context node</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() = 1]</code>selects the
previous <code>chapter</code> sibling of the context node</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() = 42]</code> selects the
forty-second <code>figure</code> element in the document containing the
context node</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() = 2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains the context
node</p>
</li>
<li>
<p><code>child::para[attribute::type="warning"]</code>selects all
<code>para</code> children of the context node that have a <code>type</code>
attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[attribute::type='warning'][fn:position() =
5]</code>selects the fifth <code>para</code> child of the context node that
has a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[fn:position() =
5][attribute::type="warning"]</code>selects the fifth <code>para</code> child
of the context node if that child has a <code>type</code> attribute with
value <code>warning</code></p>
</li>
<li>
<p><code>child::chapter[child::title='Introduction']</code>selects the
<code>chapter</code> children of the context node that have one or more
<code>title</code> children whose typed value is equal to the string
<code>Introduction</code></p>
</li>
<li>
<p><code>child::chapter[child::title]</code> selects the <code>chapter</code>
children of the context node that have one or more <code>title</code>
children</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix]</code> selects the
<code>chapter</code> and <code>appendix</code> children of the context
node</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code> selects the last <code>chapter</code> or
<code>appendix</code> child of the context node</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="abbrev" name="abbrev"></a>3.2.4 Abbreviated Syntax</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AbbrevForwardStep" name=
"doc-xpath-AbbrevForwardStep"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href="#doc-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AbbrevReverseStep" name=
"doc-xpath-AbbrevReverseStep"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>The abbreviated syntax permits the following abbreviations:</p>
<ol class="enumar">
<li>
<p>The most important abbreviation is that the axis name can be omitted from
an <b>axis step</b>. If the axis name is omitted from an axis step, the
default axis is <code>child</code> unless the axis step contains an <a title=
"AttributeTest" href="#dt-attribute-test">AttributeTest</a>; in that case,
the default axis is <code>attribute</code>. For example, the path expression
<code>section/para</code> is an abbreviation for
<code>child::section/child::para</code>, and the path expression
<code>section/@id</code> is an abbreviation for
<code>child::section/attribute::id</code>. Similarly,
<code>section/attribute(id)</code> is an abbreviation for
<code>child::section/attribute::attribute(id)</code>. Note that the latter
expression contains both an axis specification and a node test.</p>
</li>
<li>
<p>There is also an abbreviation for the attribute axis:
<code>attribute::</code> can be abbreviated by <code>@</code>. For example, a
path expression <code>para[@type="warning"]</code> is short for
<code>child::para[attribute::type="warning"]</code> and so selects
<code>para</code> children with a <code>type</code> attribute with value
equal to <code>warning</code>.</p>
</li>
<li>
<p><code>//</code> is effectively replaced by
<code>/descendant-or-self::node()/</code> during processing of a path
expression. For example, <code>//para</code> is an abbreviation for
<code>/descendant-or-self::node()/child::para</code> and so will select any
<code>para</code> element in the document (even a <code>para</code> element
that is a document element will be selected by <code>//para</code> since the
document element node is a child of the root node); <code>div1//para</code>
is short for <code>child::div1/descendant-or-self::node()/child::para</code>
and so will select all <code>para</code> descendants of <code>div1</code>
children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The path expression <code>//para[1]</code> does <em>not</em> mean the same
as the path expression <code>/descendant::para[1]</code>. The latter selects
the first descendant <code>para</code> element; the former selects all
descendant <code>para</code> elements that are the first <code>para</code>
children of their parents.</p>
</div>
</li>
<li>
<p>A step consisting of <code>..</code> is short for
<code>parent::node()</code>. For example, <code>../title</code> is short for
<code>parent::node()/child::title</code> and so will select the
<code>title</code> children of the parent of the context node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The expression <code>.</code>, known as a <b>context item expression</b>,
is a <a title="primary expression" href="#dt-primary-expression">primary
expression</a>, and is described in <a href=
"#id-context-item-expression"><b>3.1.4 Context Item Expression</b></a>.</p>
</div>
</li>
</ol>
<p>Here are some examples of path expressions that use the abbreviated
syntax:</p>
<ul>
<li>
<p><code>para</code> selects the <code>para</code> element children of the
context node</p>
</li>
<li>
<p><code>*</code> selects all element children of the context node</p>
</li>
<li>
<p><code>text()</code> selects all text node children of the context node</p>
</li>
<li>
<p><code>@name</code> selects the <code>name</code> attribute of the context
node</p>
</li>
<li>
<p><code>@*</code> selects all the attributes of the context node</p>
</li>
<li>
<p><code>para[1]</code> selects the first <code>para</code> child of the
context node</p>
</li>
<li>
<p><code>para[fn:last()]</code> selects the last <code>para</code> child of
the context node</p>
</li>
<li>
<p><code>*/para</code> selects all <code>para</code> grandchildren of the
context node</p>
</li>
<li>
<p><code>/book/chapter[5]/section[2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains the context
node</p>
</li>
<li>
<p><code>chapter//para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the context
node</p>
</li>
<li>
<p><code>//para</code> selects all the <code>para</code> descendants of the
root document node and thus selects all <code>para</code> elements in the
same document as the context node</p>
</li>
<li>
<p><code>//@version</code> selects all the <code>version</code> attribute
nodes that are in the same document as the context node</p>
</li>
<li>
<p><code>//list/member</code> selects all the <code>member</code> elements in
the same document as the context node that have a <code>list</code>
parent</p>
</li>
<li>
<p><code>.//para</code> selects the <code>para</code> element descendants of
the context node</p>
</li>
<li>
<p><code>..</code> selects the parent of the context node</p>
</li>
<li>
<p><code>../@lang</code> selects the <code>lang</code> attribute of the
parent of the context node</p>
</li>
<li>
<p><code>para[@type="warning"]</code> selects all <code>para</code> children
of the context node that have a <code>type</code> attribute with value
<code>warning</code></p>
</li>
<li>
<p><code>para[@type="warning"][5]</code> selects the fifth <code>para</code>
child of the context node that has a <code>type</code> attribute with value
<code>warning</code></p>
</li>
<li>
<p><code>para[5][@type="warning"]</code> selects the fifth <code>para</code>
child of the context node if that child has a <code>type</code> attribute
with value <code>warning</code></p>
</li>
<li>
<p><code>chapter[title="Introduction"]</code> selects the
<code>chapter</code> children of the context node that have one or more
<code>title</code> children whose typed value is equal to the string
<code>Introduction</code></p>
</li>
<li>
<p><code>chapter[title]</code> selects the <code>chapter</code> children of
the context node that have one or more <code>title</code> children</p>
</li>
<li>
<p><code>employee[@secretary and @assistant]</code> selects all the
<code>employee</code> children of the context node that have both a
<code>secretary</code> attribute and an <code>assistant</code> attribute</p>
</li>
<li>
<p><code>book/(chapter|appendix)/section</code> selects every
<code>section</code> element that has a parent that is either a
<code>chapter</code> or an <code>appendix</code> element, that in turn is a
child of a <code>book</code> element that is a child of the context node.</p>
</li>
<li>
<p>If <code>E</code> is any expression that returns a sequence of nodes, then
the expression <code>E/.</code> returns the same nodes in document order,
with duplicates eliminated based on node identity.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-sequence-expressions" name="id-sequence-expressions"></a>3.3
Sequence Expressions</h3>
<p>XPath supports operators to construct and combine <a title="sequence"
href="#dt-sequence">sequences</a> of <a title="item" href=
"#dt-item">items</a>. Sequences are never nested&#8212;for example, combining
the values 1, (2, 3), and ( ) into a single sequence results in the sequence
(1, 2, 3).</p>
<div class="div3">
<h4><a id="construct_seq" name="construct_seq"></a>3.3.1 Constructing
Sequences</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="noid_N123doc-xpath-Expr" name=
"noid_N123doc-xpath-Expr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-RangeExpr" name=
"doc-xpath-RangeExpr"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> ( "to" <a href=
"#doc-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
</table>
<p>One way to construct a sequence is by using the comma operator, which
evaluates each of its operands and concatenates the resulting values, in
order, into a single result sequence.</p>
<p>A sequence may contain duplicate values or nodes, but a sequence is never
an item in another sequence. When a new sequence is created by concatenating
two or more input sequences, the new sequence contains all the items of the
input sequences and its length is the sum of the lengths of the input
sequences.</p>
<p>In places where the grammar calls for ExprSingle, such as the arguments of
a function call, any expression that contains a top-level comma operator must
be enclosed in parentheses. Empty parentheses can be used to denote an empty
sequence.</p>
<p>Here are some examples of expressions that construct sequences:</p>
<ul>
<li>
<p>The result of this expression is a sequence of five integers:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</div>
</li>
<li>
<p>This expression combines four sequences of length one, two, zero, and two,
respectively, into a single sequence of length five. The result of this
expression is the sequence <code>10, 1, 2, 3, 4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</div>
</li>
<li>
<p>The result of this expression is a sequence containing all
<code>salary</code> children of the context node followed by all
<code>bonus</code> children.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</div>
</li>
<li>
<p>Assuming that <code>$price</code> is bound to the value
<code>10.50</code>, the result of this expression is the sequence
<code>10.50, 10.50</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</div>
</li>
</ul>
<p>A <b>range expression</b> can be used to construct a sequence of
consecutive integers. Each of the operands of the <code>to</code> operator is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer</code>. A <a title="type error" href=
"#dt-type-error">type error</a> [<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>] is raised if either operand cannot be converted
to a single integer. If the integer derived from the first operand is greater
than the integer derived from the second operand, the result of the range
expression is an empty sequence. Otherwise, the result is a sequence
containing the two integer operands and every integer between the two
operands, in increasing order.</p>
<ul>
<li>
<p>This example uses a range expression as one operand in constructing a
sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</div>
</li>
<li>
<p>This example constructs a sequence of length one containing the single
integer <code>10</code>.</p>
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</li>
<li>
<p>The result of this example is a sequence of length zero.</p>
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</li>
<li>
<p>This example uses the <code>fn:reverse</code> function to construct a
sequence of six integers in decreasing order. It evaluates to the sequence
<code>15, 14, 13, 12, 11, 10</code>.</p>
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="combining_seq" name="combining_seq"></a>3.3.2 Combining Node
Sequences</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-UnionExpr" name=
"doc-xpath-UnionExpr"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IntersectExceptExpr" name=
"doc-xpath-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueExpr">ValueExpr</a> ( ("intersect" |
"except") <a href="#doc-xpath-ValueExpr">ValueExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ValueExpr" name=
"doc-xpath-ValueExpr"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
</table>
<p>XPath provides several operators for combining sequences of nodes. The
<code>union</code> and <code>|</code> operators are equivalent. They take two
node sequences as operands and return a sequence containing all the nodes
that occur in either of the operands. The <code>intersect</code> operator
takes two node sequences as operands and returns a sequence containing all
the nodes that occur in both operands. The <code>except</code> operator takes
two node sequences as operands and returns a sequence containing all the
nodes that occur in the first operand but not in the second operand. All of
these operators return their result sequences in document order without
duplicates based on node identity. If an operand of <code>union</code>,
<code>intersect</code>, or <code>except</code> contains an item that is not a
node, a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
<p>Here are some examples of expressions that combine sequences. Assume the
existence of three element nodes that we will refer to by symbolic names A,
B, and C. Assume that the variables <code>$seq1</code>, <code>$seq2</code>
and <code>$seq3</code> are bound to the following sequences of these
nodes:</p>
<ul>
<li>
<p><code>$seq1</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq2</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq3</code> is bound to (B, C)</p>
</li>
</ul>
<p>Then:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code> evaluates to the sequence (A, B).</p>
</li>
<li>
<p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B, C).</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A, B).</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code> evaluates to the sequence containing B
only.</p>
</li>
<li>
<p><code>$seq1 except $seq2</code> evaluates to the empty sequence.</p>
</li>
<li>
<p><code>$seq2 except $seq3</code> evaluates to the sequence containing A
only.</p>
</li>
</ul>
<p>In addition to the sequence operators described here,<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of items in a
sequence, and for removing duplicate values or nodes from a sequence.</p>
</div>
</div>
<div class="div2">
<h3><a id="id-arithmetic" name="id-arithmetic"></a>3.4 Arithmetic
Expressions</h3>
<p>XPath provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AdditiveExpr" name=
"doc-xpath-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> (
("+" | "-") <a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-MultiplicativeExpr" name=
"doc-xpath-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a> ( ("*" | "div" |
"idiv" | "mod") <a href="#doc-xpath-UnaryExpr">UnaryExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-UnaryExpr" name=
"doc-xpath-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#doc-xpath-UnionExpr">UnionExpr</a></code></td>
</tr>
</tbody>
</table>
<p>A subtraction operator must be preceded by whitespace if it could
otherwise be interpreted as part of the previous token. For example,
<code>a-b</code> will be interpreted as a name, but <code>a - b</code> and
<code>a -b</code> will be interpreted as arithmetic operations.</p>
<p>An arithmetic expression is evaluated by applying the following rules, in
order, until an error is raised or a value is computed:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied
to each operand.</p>
</li>
<li>
<p>If either operand is now an empty sequence, the result of the operation is
an empty sequence.</p>
</li>
<li>
<p>If either operand is now a sequence of length greater than one,
<span class="xpath"><span class="xpath">then:</span></span></p>
<div class="xpath">
<ol class="enumla">
<li>
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code>, any items
after the first item in the sequence are discarded.</p>
</li>
<li>
<p>Otherwise, a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</div>
</li>
<li>
<p>If either operand is now of type <code>xdt:untypedAtomic</code>, it is
cast to the default type for the given operator. The default type for the
<code>idiv</code> operator is <code>xs:integer</code>; the default type for
all other arithmetic operators is <code>xs:double</code>. If the cast fails,
a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised.[<a title="err:XP0021" href="#ERRXP0021">err:XP0021</a>]</p>
</li>
<li>
<p>If the operand types are now valid for the given operator, the operator is
applied to the operands, resulting in an atomic value or a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> (for example, an
error might result from dividing by zero.) The combinations of atomic types
that are accepted by the various arithmetic operators, and their respective
result types, are listed in <a href="#mapping"><b>B.2 Operator
Mapping</b></a> together with the functions in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a> that define the semantics of the operation for each type.</p>
</li>
<li class="xpath">
<p>If the operand types are not valid for the given operator, and <b>XPath
1.0 compatibility mode</b> is <code>true</code>, and the operator is not
<code>idiv</code>, then each operand is further converted according to the
rules in <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a> as if
it were a function argument with the expected type <code>xs:double</code>.
The operator is then applied to the operands, resulting in an atomic value or
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title=
"err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If the operand types are still not valid for the given operator, a
<a title="type error" href="#dt-type-error">type error</a> is raised.</p>
</li>
</ol>
<p>XPath supports two division operators named <code>div</code> and
<code>idiv</code>. When invoked with two integer operands, <code>div</code>
returns a value of type <code>xs:decimal</code>, but <code>idiv</code>
returns a value of type <code>xs:integer</code>.</p>
<p>Here are some examples of arithmetic expressions:</p>
<ul>
<li>
<p>The first expression below returns the <code>xs:decimal</code> value
<code>-1.5</code>, and the second expression returns the
<code>xs:integer</code> value <code>-1</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</div>
</li>
<li>
<p>Subtraction of two date values results in a value of type
<code>xdt:dayTimeDuration</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</div>
</li>
<li>
<p>This example illustrates the difference between a subtraction operator and
a hyphen:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</div>
</li>
<li>
<p>Unary operators have higher precedence than binary operators, subject of
course to the use of parentheses. Therefore, the following two examples have
different meanings:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-comparisons" name="id-comparisons"></a>3.5 Comparison
Expressions</h3>
<p>Comparison expressions allow two values to be compared. XPath provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ComparisonExpr" name=
"doc-xpath-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#doc-xpath-ValueComp">ValueComp</a><br />
| <a href="#doc-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xpath-NodeComp">NodeComp</a>) <a href=
"#doc-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ValueComp" name=
"doc-xpath-ValueComp"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-GeneralComp" name=
"doc-xpath-GeneralComp"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td>
<td><i>/* <a href="#parse-note-lt">gn: lt</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NodeComp" name=
"doc-xpath-NodeComp"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<div class="xpath">
<p class="xpath">When an XPath expression is written within an XML document,
the XML escaping rules for special characters must be followed; thus
"<code>&lt;</code>" must be written as "<code>&amp;lt;</code>".</p>
</div>
</div>
<div class="div3">
<h4><a id="id-value-comparisons" name="id-value-comparisons"></a>3.5.1 Value
Comparisons</h4>
<p>The value comparison operators are <code>eq</code>, <code>ne</code>,
<code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value
comparisons are used for comparing single values. The result of a value
comparison is defined by applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied
to each operand. If the result, called an <b>atomized operand</b>, does not
contain exactly one atomic value, a <a title="type error" href=
"#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>Any atomized operand that has the dynamic type
<code>xdt:untypedAtomic</code> is cast to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>The result of the comparison is <code>true</code> if the value of the
first operand is (equal, not equal, less than, less than or equal, greater
than, greater than or equal) to the value of the second operand; otherwise
the result of the comparison is <code>false</code>. <a href="#mapping"><b>B.2
Operator Mapping</b></a> defines which combinations of atomic types are
comparable, and how the comparison operators are mapped into supporting
functions. If the value of the first atomized operand is not comparable with
the value of the second atomized operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
<p>Here are some examples of value comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if <code>$book1</code> has exactly
one <code>author</code> subelement and its typed value is "Kennedy" as an
instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>. If
<code>$book1</code> does not have exactly one <code>author</code> subelement,
a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title=
"err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true if <code>my:hatsize</code> and
<code>my:shoesize</code> are both user-defined types that are derived by
restriction from a primitive numeric type:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-general-comparisons" name="id-general-comparisons"></a>3.5.2
General Comparisons</h4>
<p>The general comparison operators are <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and
<code>&gt;=</code>. General comparisons are existentially quantified
comparisons that may be applied to operand sequences of any length. The
result of a general comparison that does not raise an error is always
<code>true</code> or <code>false</code>.</p>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied
to each operand of a general comparison. The result of the comparison is
<code>true</code> if and only if there is a pair of atomic values, one
belonging to the result of atomization of the first operand and the other
belonging to the result of atomization of the second operand, that have the
required <b>magnitude relationship</b>. Otherwise the result of the general
comparison is <code>false</code>. The <b>magnitude relationship</b> between
two atomic values is determined as follows:</p>
<ol class="enumar">
<li>
<p>If either atomic value has the dynamic type
<code>xdt:untypedAtomic</code>, that value is cast to a required type, which
is determined as follows:</p>
<ol class="enumla">
<li>
<p>If the dynamic type of the other atomic value is a numeric type, the
required type is <code>xs:double</code>.</p>
</li>
<li>
<p>If the dynamic type of the other atomic value is
<code>xdt:untypedAtomic</code>, the required type is
<code>xs:string</code>.</p>
</li>
<li>
<p>Otherwise, the required type is the dynamic type of the other atomic
value.</p>
</li>
</ol>
<p>If the cast to the required type fails, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0021" href=
"#ERRXP0021">err:XP0021</a>]</p>
</li>
<li class="xpath">
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code>, and at least
one of the atomic values has a numeric type, then both atomic values are cast
to to the type <code>xs:double</code>.</p>
</li>
<li>
<p>After any necessary casting, the atomic values are compared using one of
the value comparison operators <code>eq</code>, <code>ne</code>,
<code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>,
depending on whether the general comparison operator was <code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if the result of this value comparison is
<code>true</code>.</p>
</li>
</ol>
<p>When evaluating a general comparison in which either operand is a sequence
of items, an implementation may return <code>true</code> as soon as it finds
an item in the first operand and an item in the second operand for which the
underlying value comparison is <code>true</code>. Similarly, a general
comparison may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> as soon as it encounters an error in
evaluating either operand, or in comparing a pair of items from the two
operands. As a result of these rules, the result of a general comparison is
not deterministic in the presence of errors.</p>
<p>Here are some examples of general comparisons:</p>
<ul>
<li>
<p>The following comparison is true if the typed value of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an
instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following example contains three general comparisons. The value of the
first two comparisons is <code>true</code>, and the value of the third
comparison is <code>false</code>. This example illustrates the fact that
general comparisons are not transitive.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are
bound to element nodes with type annotation <code>xdt:untypedAtomic</code>,
with string values "<code>1</code>", "<code>2</code>", and "<code>2.0</code>"
respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns
<code>false</code>, because <code>$b</code> and <code>$c</code> are compared
as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns
<code>true</code>, because <code>$b</code> and <code>2.0</code> are compared
as numbers.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-node-comparisons" name="id-node-comparisons"></a>3.5.3 Node
Comparisons</h4>
<p>Node comparisons are used to compare two nodes, by their identity or by
their document order. The result of a node comparison is defined by applying
the following rules, in order:</p>
<ol class="enumar">
<li>
<p>Each operand must be either a single node or an empty sequence; otherwise
a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title=
"err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If either operand is an empty sequence, the result of the comparison is an
empty sequence.</p>
</li>
<li>
<p>A comparison with the <code>is</code> operator is <code>true</code> if the
two operands have the same identity, and are thus the same node; otherwise it
is <code>false</code>. See <a href="#datamodel">[XQuery 1.0 and XPath 2.0
Data Model]</a> for a definition of node identity.</p>
</li>
<li>
<p>A comparison with the <code>&lt;&lt;</code> operator returns
<code>true</code> if the first operand node precedes the second operand node
in document order; otherwise it returns <code>false</code>.</p>
</li>
<li>
<p>A comparison with the <code>&gt;&gt;</code> operator returns
<code>true</code> if the first operand node follows the second operand node
in document order; otherwise it returns <code>false</code>.</p>
</li>
</ol>
<p>Here are some examples of node comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//book[isbn="1558604820"] is //book[call="QA76.9 C3845"]
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document
order:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//purchase[parcel="28-451"] &lt;&lt; //sale[parcel="33-870"]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-logical-expressions" name="id-logical-expressions"></a>3.6
Logical Expressions</h3>
<p>A <b>logical expression</b> is either an <b>and-expression</b> or an
<b>or-expression</b>. If a logical expression does not raise an error, its
value is always one of the boolean values <code>true</code> or
<code>false</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-OrExpr" name=
"doc-xpath-OrExpr"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#doc-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AndExpr" name=
"doc-xpath-AndExpr"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> ( "and"
<a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>The first step in evaluating a logical expression is to find the <a title=
"effective boolean value" href="#dt-ebv">effective boolean value</a> of each
of its operands (see <a href="#id-ebv"><b>2.3.3 Effective Boolean
Value</b></a>).</p>
<p>The value of an and-expression is determined by the effective boolean
values (EBV's) of its operands. If an error is raised during computation of
one of the effective boolean values, an and-expression <em>may</em> raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, as shown
in the following table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary=
"AND EBV">
<tbody>
<tr>
<td rowspan="1" colspan="1">AND:</td>
<td rowspan="1" colspan="1">EBV<sub>2</sub> = true</td>
<td rowspan="1" colspan="1">EBV<sub>2</sub> = false</td>
<td rowspan="1" colspan="1">error in EBV<sub>2</sub></td>
</tr>
<tr>
<td rowspan="1" colspan="1">EBV<sub>1</sub> = true</td>
<td rowspan="1" colspan="1">true</td>
<td rowspan="1" colspan="1">false</td>
<td rowspan="1" colspan="1">error</td>
</tr>
<tr>
<td rowspan="1" colspan="1">EBV<sub>1</sub> = false</td>
<td rowspan="1" colspan="1">false</td>
<td rowspan="1" colspan="1">false</td>
<td rowspan="1" colspan="1">false or error</td>
</tr>
<tr>
<td rowspan="1" colspan="1">error in EBV<sub>1</sub></td>
<td rowspan="1" colspan="1">error</td>
<td rowspan="1" colspan="1">false or error</td>
<td rowspan="1" colspan="1">error</td>
</tr>
</tbody>
</table>
<p>The value of an or-expression is determined by the effective boolean
values (EBV's) of its operands. If an error is raised during computation of
one of the effective boolean values, an or-expression <em>may</em> raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, as shown
in the following table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary=
"OR EBV">
<tbody>
<tr>
<td rowspan="1" colspan="1">OR:</td>
<td rowspan="1" colspan="1">EBV<sub>2</sub> = true</td>
<td rowspan="1" colspan="1">EBV<sub>2</sub> = false</td>
<td rowspan="1" colspan="1">error in EBV<sub>2</sub></td>
</tr>
<tr>
<td rowspan="1" colspan="1">EBV<sub>1</sub> = true</td>
<td rowspan="1" colspan="1">true</td>
<td rowspan="1" colspan="1">true</td>
<td rowspan="1" colspan="1">true or error</td>
</tr>
<tr>
<td rowspan="1" colspan="1">EBV<sub>1</sub> = false</td>
<td rowspan="1" colspan="1">true</td>
<td rowspan="1" colspan="1">false</td>
<td rowspan="1" colspan="1">error</td>
</tr>
<tr>
<td rowspan="1" colspan="1">error in EBV<sub>1</sub></td>
<td rowspan="1" colspan="1">true or error</td>
<td rowspan="1" colspan="1">error</td>
<td rowspan="1" colspan="1">error</td>
</tr>
</tbody>
</table>
<p>The order in which the operands of a logical expression are evaluated is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. The tables above
are defined in such a way that an or-expression can return <code>true</code>
if the first expression evaluated is true, and it can raise an error if
evaluation of the first expression raises an error. Similarly, an
and-expression can return <code>false</code> if the first expression
evaluated is false, and it can raise an error if evaluation of the first
expression raises an error. As a result of these rules, a logical expression
is not deterministic in the presence of errors, as described in <a href=
"#id-errors-and-opt"><b>2.5.3 Errors and Optimization</b></a>. This is
illustrated in the examples below.</p>
<p>Here are some examples of logical expressions:</p>
<ul>
<li>
<p>The following expressions return <code>true</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
</div>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>false</code> or raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>true</code> or raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression must raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
</ul>
<p>In addition to and- and or-expressions, XPath provides a function named
<code>fn:not</code> that takes a general sequence as parameter and returns a
boolean value. The <code>fn:not</code> function is defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>. The <code>fn:not</code> function reduces its parameter to an
<a title="effective boolean value" href="#dt-ebv">effective boolean
value</a>. It then returns <code>true</code> if the effective boolean value
of its parameter is <code>false</code>, and <code>false</code> if the
effective boolean value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<code>fn:not</code> raises the same <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="xpath">
<div class="div2">
<h3><a id="id-for-expressions" name="id-for-expressions"></a>3.7 For
Expressions</h3>
<p>XPath provides an iteration facility called a <b>for expression</b>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForExpr" name=
"doc-xpath-ForExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr" class="xpath">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a> "return"
<a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SimpleForClause" name=
"doc-xpath-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause" class=
"xpath">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" "$" <a href="#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A <code>for</code> expression is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>for</code> expression uses multiple variables, it is first
expanded to a set of nested <code>for</code> expressions, each of which uses
only one variable. For example, the expression <code>for $x in X, $y in Y
return $x + $y</code> is expanded to <code>for $x in X return for $y in Y
return $x + $y</code>.</p>
</li>
<li>
<p>In a single-variable <code>for</code> expression, the variable is called
the <b>range variable</b>, the value of the expression that follows the
<code>in</code> keyword is called the <b>input sequence</b>, and the
expression that follows the <code>return</code> keyword is called the
<b>return expression</b>. The result of the <code>for</code> expression is
obtained by evaluating the <code>return</code> expression once for each item
in the input sequence, with the range variable bound to that item. The
resulting sequences are concatenated in the order of the items in the input
sequence from which they were derived.</p>
</li>
</ol>
<div class="xpath">
<p class="xpath">The following example illustrates the use of a
<code>for</code> expression in restructuring an input document. The example
is based on the following input:</p>
</div>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Unix Programming&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>The following example transforms the input document into a list in which
each author's name appears only once, followed by a list of titles of books
written by that author. This example assumes that the context item is the
<code>bib</code> element in the input document.</p>
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">for $a in fn:distinct-values(//author)
return ($a,
        for $b in //book[author = $a]
        return $b/title)</span></span>
</pre></div>
<p>The result of the above expression consists of the following sequence of
elements. The titles of books written by a given author are listed after the
name of the author. The ordering of <code>author</code> elements in the
result is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> due to the
semantics of the <code>fn:distinct-values</code> function.</p>
<div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre></div>
<p>The following example illustrates a <code>for</code> expression containing
more than one variable:</p>
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span>
</pre></div>
<p>The result of the above expression, expressed as a sequence of numbers, is
as follows: <code>11, 12, 21, 22</code></p>
<p>The scope of a variable bound in a <code>for</code> expression comprises
all subexpressions of the <code>for</code> expression that appear after the
variable binding. The scope does not include the expression to which the
variable is bound. The following example illustrates how a variable binding
may reference another variable bound earlier in the same <code>for</code>
expression:</p>
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></span>
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The focus for evaluation of the <code>return</code> clause of a
<code>for</code> expression is the same as the focus for evaluation of the
<code>for</code> expression itself. The following example, which attempts to
find the total value of a set of order-items, is therefore incorrect:</p>
<div class="error">
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return @price *
@qty)
</pre></div>
</div>
<p>Instead, the expression must be written to use the variable bound in the
<code>for</code> clause:</p>
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a id="id-conditionals" name="id-conditionals"></a>3.8 Conditional
Expressions</h3>
<p>XPath supports a conditional expression based on the keywords
<code>if</code>, <code>then</code>, and <code>else</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IfExpr" name=
"doc-xpath-IfExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xpath-Expr">Expr</a> ")" "then" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The expression following the <code>if</code> keyword is called the <b>test
expression</b>, and the expressions following the <code>then</code> and
<code>else</code> keywords are called the <b>then-expression</b> and
<b>else-expression</b>, respectively.</p>
<p>The first step in processing a conditional expression is to find the
<a title="effective boolean value" href="#dt-ebv">effective boolean value</a>
of the test expression, as defined in <a href="#id-ebv"><b>2.3.3 Effective
Boolean Value</b></a>.</p>
<p>The value of a conditional expression is defined as follows: If the
effective boolean value of the test expression is <code>true</code>, the
value of the then-expression is returned. If the effective boolean value of
the test expression is <code>false</code>, the value of the else-expression
is returned.</p>
<p>Conditional expressions have a special rule for propagating <a title=
"dynamic error" href="#dt-dynamic-error">dynamic errors</a>. If the effective
value of the test expression is <code>true</code>, the conditional expression
ignores (does not raise) any dynamic errors encountered in the
else-expression. In this case, since the else-expression can have no
observable effect, it need not be evaluated. Similarly, if the effective
value of the test expression is <code>false</code>, the conditional
expression ignores any <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> encountered in the then-expression,
and the then-expression need not be evaluated.</p>
<p>Here are some examples of conditional expressions:</p>
<ul>
<li>
<p>In this example, the test expression is a comparison expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre></div>
</div>
</li>
<li>
<p>In this example, the test expression tests for the existence of an
attribute named <code>discounted</code>, independently of its value:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-quantified-expressions" name=
"id-quantified-expressions"></a>3.9 Quantified Expressions</h3>
<p>Quantified expressions support existential and universal quantification.
The value of a quantified expression is always <code>true</code> or
<code>false</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-QuantifiedExpr" name=
"doc-xpath-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("some" "$") | ("every" "$")) <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>quantified expression</b> begins with a <b>quantifier</b>, which is
the keyword <code>some</code> or <code>every</code>, followed by one or more
in-clauses that are used to bind variables, followed by the keyword
<code>satisfies</code> and a test expression. Each in-clause associates a
variable with an expression that returns a sequence of values. The in-clauses
generate tuples of variable bindings, using values drawn from the Cartesian
product of the sequences returned by the binding expressions. Conceptually,
the test expression is evaluated for each tuple of variable bindings. Results
depend on the <b>effective boolean values</b> of the test expressions, as
defined in <a href="#id-ebv"><b>2.3.3 Effective Boolean Value</b></a>. The
value of the quantified expression is defined by the following rules:</p>
<ol class="enumar">
<li>
<p>If the quantifier is <code>some</code>, the quantified expression is
<code>true</code> if at least one evaluation of the test expression has the
<b>effective boolean value</b> <code>true</code>; otherwise the quantified
expression is <code>false</code>. This rule implies that, if the in-clauses
generate zero binding tuples, the value of the quantified expression is
<code>false</code>.</p>
</li>
<li>
<p>If the quantifier is <code>every</code>, the quantified expression is
<code>true</code> if every evaluation of the test expression has the
<b>effective boolean value</b> <code>true</code>; otherwise the quantified
expression is <code>false</code>. This rule implies that, if the in-clauses
generate zero binding tuples, the value of the quantified expression is
<code>true</code>.</p>
</li>
</ol>
<p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable
binding. The scope does not include the expression to which the variable is
bound.</p>
<p>The order in which test expressions are evaluated for the various binding
tuples is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. If the
quantifier is <code>some</code>, an implementation may return
<code>true</code> as soon as it finds one binding tuple for which the test
expression has an <b>effective boolean value</b> of <code>true</code>, and it
may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> as soon as it finds one binding tuple for which the test expression
raises an error. Similarly, if the quantifier is <code>every</code>, an
implementation may return <code>false</code> as soon as it finds one binding
tuple for which the test expression has an effective boolean value of
<code>false</code>, and it may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple
for which the test expression raises an error. As a result of these rules,
the value of a quantified expression is not deterministic in the presence of
errors, as illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ul>
<li>
<p>This expression is <code>true</code> if every <code>part</code> element
has a <code>discounted</code> attribute (regardless of the values of these
attributes):</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $part in //part satisfies $part/@discounted
</pre></div>
</div>
</li>
<li>
<p>This expression is <code>true</code> if at least one <code>employee</code>
element satisfies the given comparison expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $emp in //employee satisfies ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</div>
</li>
<li>
<p>In the following examples, each quantified expression evaluates its test
expression over nine tuples of variable bindings, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>.
The expression beginning with <code>some</code> evaluates to
<code>true</code>, and the expression beginning with <code>every</code>
evaluates to <code>false</code>.</p>
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
</li>
<li>
<p>This quantified expression may either return <code>true</code> or raise a
<a title="type error" href="#dt-type-error">type error</a>, since its test
expression returns <code>true</code> for one variable binding and raises a
<a title="type error" href="#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
<li>
<p>This quantified expression may either return <code>false</code> or raise a
<a title="type error" href="#dt-type-error">type error</a>, since its test
expression returns <code>false</code> for one variable binding and raises a
<a title="type error" href="#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-expressions-on-datatypes" name=
"id-expressions-on-datatypes"></a>3.10 Expressions on SequenceTypes</h3>
<p><a title="SequenceType" href="#dt-sequence-type">SequenceTypes</a> are
used in <code>instance of</code>, <code>cast</code>, <code>castable</code>,
and <code>treat</code> expressions.</p>
<div class="div3">
<h4><a id="id-instance-of" name="id-instance-of"></a>3.10.1 Instance Of</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-InstanceofExpr" name=
"doc-xpath-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a> ( "instance" "of"
<a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>The boolean operator <code>instance of</code> returns <code>true</code> if
the value of its first operand matches the SequenceType in its second
operand, according to the rules for <b>SequenceType Matching</b>; otherwise
it returns <code>false</code>. For example:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>This example returns <code>true</code> because the given value is an
instance of the given type.</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>This example returns <code>true</code> because the given value is an
integer literal, and <code>xs:integer</code> is derived by restriction from
<code>xs:decimal</code>.</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>This example returns <code>true</code> if the context item is an element
node. If the context item is undefined, a dynamic error is raised.[<a title=
"err:XP0002" href="#ERRXP0002">err:XP0002</a>]</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-cast" name="id-cast"></a>3.10.2 Cast</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CastExpr" name=
"doc-xpath-CastExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> ( "cast"
"as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SingleType" name=
"doc-xpath-SingleType"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a> "?"?</code></td>
</tr>
</tbody>
</table>
<p>Occasionally it is necessary to convert a value to a specific datatype.
For this purpose, XPath provides a <code>cast</code> expression that creates
a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <b>input expression</b>
and a <b>target type</b>. The type of the input expression is called the
<b>input type</b>. The target type must be a named atomic type, represented
by a QName, optionally followed by the occurrence indicator <code>?</code> if
an empty sequence is permitted. If the target type has no namespace prefix,
it is considered to be in the <b>default element/type namespace</b>. The
semantics of the <code>cast</code> expression are as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is performed
on the input expression.</p>
</li>
<li>
<p>If the result of atomization is a sequence of more than one atomic value,
a <a title="type error" href="#dt-type-error">type error</a> is
raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title=
"err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If the result of atomization is an empty sequence:</p>
<ol class="enumla">
<li>
<p>If <code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p>
</li>
<li>
<p>If <code>?</code> is not specified after the target type, a <a title=
"type error" href="#dt-type-error">type error</a> is raised.[<a title=
"err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is a single atomic value, the result of the
cast expression depends on the input type and the target type. In general,
the cast expression attempts to create a new value of the target type based
on the input value. Only certain combinations of input type and target type
are supported. A summary of the rules are listed below&#8212; the normative
definition of these rules is given in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>. For the purpose of these rules, we use the terms
<b>subtype</b> and <b>supertype</b> in the following sense: if type B is
derived from type A by restriction, then B is a <b>subtype</b> of A, and A is
a <b>supertype</b> of B. An implementation may determine that one type is a
subtype of another either by examining the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>
or by using an alternative, <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> mechanism such as
a data dictionary.</p>
<ol class="enumla">
<li>
<p><code>cast</code> is supported for the combinations of input type and
target type listed in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators]</a>. For each of these combinations, both the
input type and the target type are primitive schema types. For example, a
value of type <code>xs:string</code> can be cast into the type
<code>xs:decimal</code>. For each of these built-in combinations, the
semantics of casting are specified in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported if the input type is a non-primitive atomic
type and the target type is a supertype of the input type. In this case, the
input value is mapped into the value space of the target type, unchanged
except for its type. For example, if <code>shoesize</code> is derived by
restriction from <code>xs:integer</code>, a value of type
<code>shoesize</code> can be cast into the type <code>xs:integer</code>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a non-primitive
atomic type and the input type is <code>xs:string</code> or
<code>xdt:untypedAtomic</code>. The input value is first converted to a value
in the lexical space of the target type by applying the whitespace
normalization rules for the target type; a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a title="err:XP0029" href=
"#ERRXP0029">err:XP0029</a>] is raised if the resulting lexical value does
not satisfy the pattern facet of the target type. The lexical value is then
converted to the value space of the target type using the schema-defined
rules for the target type; a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>[<a title="err:XP0029" href=
"#ERRXP0029">err:XP0029</a>] is raised if the resulting value does not
satisfy all the facets of the target type.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a non-primitive
atomic type and the input type is a supertype of the target type. The input
value must satisfy all the facets of the target type (in the case of the
pattern facet, this is checked by generating a string representation of the
input value, using the rules for casting to <code>xs:string</code>). The
resulting value is the same as the input value, but with a different dynamic
type.</p>
</li>
<li>
<p>If a primitive type P1 can be cast into a primitive type P2, then any
subtype of P1 can be cast into any subtype of P2, provided that the facets of
the target type are satisfied. First the input value is cast to P1 using rule
(b) above. Next, the value of type P1 is cast to the type P2, using rule (a)
above. Finally, the value of type P2 is cast to the target type, using rule
(d) above.</p>
</li>
<li>
<p>For any combination of input type and target type that is not in the above
list, a <code>cast</code> expression raises a <a title="type error" href=
"#dt-type-error">type error</a>.[<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</li>
</ol>
<p>If casting from the input type to the target type is supported but
nevertheless it is not possible to cast the input value into the value space
of the target type, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0021" href=
"#ERRXP0021">err:XP0021</a>] This includes the case when any facet of the
target type is not satisfied. For example, the expression <code>"2003-02-31"
cast as xs:date</code> would raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="div3">
<h4><a id="id-castable" name="id-castable"></a>3.10.3 Castable</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CastableExpr" name=
"doc-xpath-CastableExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a> ( "castable" "as"
<a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides a form of Boolean expression that tests whether a given
value is castable into a given target type. The expression <code>V castable
as T</code> returns <code>true</code> if the value <code>V</code> can be
successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns <code>false</code>. The
<code>castable</code> predicate can be used to avoid errors at evaluation
time. It can also be used to select an appropriate type for processing of a
given value, as illustrated in the following example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-constructor-functions" name=
"id-constructor-functions"></a>3.10.4 Constructor Functions</h4>
<p>Constructor functions provide an alternative syntax for casting.</p>
<p>A built-in constructor function is provided for each atomic type in the
static context. The signature of the built-in constructor function for type
<em>T</em> is as follows:</p>
<div class="exampleInner">
<pre>
<em>T</em>($x as item) as <em>T</em>
</pre></div>
<p>The constructor function for type <em>T</em> accepts any single item
(either a node or an atomic value) as input, and returns a value of type
<em>T</em> (or raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>). Its semantics are exactly the same as
a <code>cast</code> expression with target type <em>T</em>. The built-in
constructor functions are defined in <a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>. The following are examples of
built-in constructor functions:</p>
<ul>
<li>
<p>This example is equivalent to <code>"2000-01-01" cast as
xs:date</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</div>
</li>
<li>
<p>This example is equivalent to <code>($floatvalue * 0.2E-5) cast as
xs:decimal</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:decimal($floatvalue *
0.2E-5)
</pre></div>
</div>
</li>
<li>
<p>This example returns a <code>xdt:dayTimeDuration</code> value equal to 21
days. It is equivalent to <code>"P21D" cast as
xdt:dayTimeDuration</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xdt:dayTimeDuration("P21D")
</pre></div>
</div>
</li>
</ul>
<p>For each user-defined named atomic type definition <em>T</em> in the
<a title="in-scope type definitions" href="#dt-is-types">in-scope type
definitions</a> that is in a namespace, a constructor function is defined.
Like the built-in constructor functions, the constructor functions for
user-defined types have the same name (including namespace) as the type,
accept any item as input, and have semantics identical to a <code>cast</code>
expression with the user-defined type as target type. For example, if
<code>usa:zipcode</code> is a user-defined atomic type in the <a title=
"in-scope type definitions" href="#dt-is-types">in-scope type
definitions</a>, then the expression <code>usa:zipcode("12345")</code> is
equivalent to the expression <code>"12345" cast as usa:zipcode</code>.</p>
<p>User-defined atomic types that are not in a namespace do not have implicit
constructor functions. To construct an instance of such a type, it is
necessary to use a <code>cast</code> expression. For example, if the
user-defined type <code>apple</code> is derived from <code>xs:integer</code>
but is not in a namespace, an instance of this type can be constructed as
follows:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-treat" name="id-treat"></a>3.10.5 Treat</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TreatExpr" name=
"doc-xpath-TreatExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a> ( "treat" "as"
<a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides an expression called <code>treat</code> that can be used to
modify the <a title="static type" href="#dt-static-type">static type</a> of
its operand.</p>
<p>Like <code>cast</code>, the <code>treat</code> expression takes two
operands: an expression and a <a title="SequenceType" href=
"#dt-sequence-type">SequenceType</a>. Unlike <code>cast</code>, however,
<code>treat</code> does not change the dynamic type or value of its operand.
Instead, the purpose of <code>treat</code> is to ensure that an expression
has an expected type at evaluation time.</p>
<p>The semantics of <em><code>expr1</code></em> <code>treat as</code>
<em><code>type1</code></em> are as follows:</p>
<ul>
<li>
<p>During static analysis:</p>
<p>The <a title="static type" href="#dt-static-type">static type</a> of the
<code>treat</code> expression is <em><code>type1</code></em>. This enables
the expression to be used as an argument of a function that requires a
parameter of <em><code>type1</code></em>.</p>
</li>
<li>
<p>During expression evaluation:</p>
<p>If <em><code>expr1</code></em> matches <em><code>type1</code></em>, using
the SequenceType Matching rules in <a href="#id-types"><b>2.4 Types</b></a>,
the <code>treat</code> expression returns the value of
<em><code>expr1</code></em>; otherwise, it raises a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>.[<a title="err:XP0006" href=
"#ERRXP0006">err:XP0006</a>] If the value of <em><code>expr1</code></em> is
returned, its identity is preserved. The <code>treat</code> expression
ensures that the value of its expression operand conforms to the expected
type at run-time.</p>
</li>
<li>
<p>Example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
</div>
<p>The <a title="static type" href="#dt-static-type">static type</a> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a less
specific type than <code>element(*, USAddress)</code>. However, at run-time,
the value of <code>$myaddress</code> must match the type <code>element(*,
USAddress)</code> using SequenceType Matching rules; otherwise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a id="nt-bnf" name="nt-bnf"></a>A XPath Grammar</h2>
<div class="div2">
<h3><a id="id-grammar" name="id-grammar"></a>A.1 EBNF</h3>
<p>The following grammar uses the same Basic Extended Backus-Naur Form (EBNF)
notation as <a href="#XML">[XML 1.0]</a>, except that grammar symbols always
have initial capital letters. The notation "&lt; ... &gt;" is used to
indicate a grouping of terminals that together may help disambiguate the
individual symbols. To help readability, this "&lt; ... &gt;" notation is
absent in the EBNF in the main body of this document. This appendix should be
regarded as the normative version of the EBNF.</p>
<p>Comments on grammar productions are between '/*' and '*/' symbols - please
note that these comments are normative. A 'gn:' prefix means a 'Grammar
Note', and is meant as a clarification for parsing rules, and is explained in
<a href="#notes-on-parsing"><b>A.1.1 Grammar Notes</b></a>. A 'ws:' prefix
explains the white space rules for the production, the details of which are
explained in <a href="#whitespace-rules"><b>A.2.1 White Space
Rules</b></a></p>
<h5><a id="N1286C" name="N1286C"></a>Named Terminals</h5>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ExprComment" name=
"prod-xpath-ExprComment"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprComment">ExprComment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xpath-ExprCommentContent">ExprCommentContent</a> | <a href=
"#prod-xpath-ExprComment">ExprComment</a>)* ":)"</code></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ExprCommentContent" name=
"prod-xpath-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ExprCommentContent">ExprCommentContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Char">Char</a></code></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IntegerLiteral" name=
"prod-xpath-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DecimalLiteral" name=
"prod-xpath-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href=
"#prod-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DoubleLiteral" name=
"prod-xpath-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href=
"#prod-xpath-Digits">Digits</a> ("." [0-9]*)?)) ("e" | "E") ("+" | "-")?
<a href="#prod-xpath-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-StringLiteral" name=
"prod-xpath-StringLiteral"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (('"' '"') | [^"])* '"') | ("'" (("'" "'") | [^'])*
"'")</code></td>
<td><i>/* <a href="#ws-significant">ws: significant</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaGlobalTypeName" name=
"prod-xpath-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"type" "(" <a href="#prod-xpath-QName">QName</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaGlobalContext" name=
"prod-xpath-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaGlobalContext">SchemaGlobalContext</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#prod-xpath-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaContextStep" name=
"prod-xpath-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaContextStep">SchemaContextStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Digits" name=
"prod-xpath-Digits"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NCName" name=
"prod-xpath-NCName"></a>[11]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup>
<small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-VarName" name=
"prod-xpath-VarName"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-QName" name=
"prod-xpath-QName"></a>[13]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup>
<small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Char" name=
"prod-xpath-Char"></a>[14]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup>
<small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
</table>
<h5><a id="BNF-Grammar" name="BNF-Grammar"></a>Non-Terminals</h5>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-XPath" name=
"prod-xpath-XPath"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Expr" name=
"prod-xpath-Expr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ExprSingle" name=
"prod-xpath-ExprSingle"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForExpr" name=
"prod-xpath-ForExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause">SimpleForClause</a> "return"
<a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SimpleForClause" name=
"prod-xpath-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SimpleForClause">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"for" "$"&gt; <a href="#prod-xpath-VarName">VarName</a> "in"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-QuantifiedExpr" name=
"prod-xpath-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(&lt;"some" "$"&gt; | &lt;"every" "$"&gt;) <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IfExpr" name=
"prod-xpath-IfExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"if" "("&gt; <a href="#prod-xpath-Expr">Expr</a> ")" "then"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-OrExpr" name=
"prod-xpath-OrExpr"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#prod-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AndExpr" name=
"prod-xpath-AndExpr"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> ( "and"
<a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-InstanceofExpr" name=
"prod-xpath-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a> ( &lt;"instance"
"of"&gt; <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TreatExpr" name=
"prod-xpath-TreatExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a> ( &lt;"treat"
"as"&gt; <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CastableExpr" name=
"prod-xpath-CastableExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a> ( &lt;"castable"
"as"&gt; <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CastExpr" name=
"prod-xpath-CastExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> (
&lt;"cast" "as"&gt; <a href="#prod-xpath-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ComparisonExpr" name=
"prod-xpath-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#prod-xpath-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath-NodeComp">NodeComp</a>) <a href=
"#prod-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-RangeExpr" name=
"prod-xpath-RangeExpr"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> ( "to" <a href=
"#prod-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AdditiveExpr" name=
"prod-xpath-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> (
("+" | "-") <a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-MultiplicativeExpr" name=
"prod-xpath-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a> ( ("*" | "div" |
"idiv" | "mod") <a href="#prod-xpath-UnaryExpr">UnaryExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-UnaryExpr" name=
"prod-xpath-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xpath-UnionExpr">UnionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-UnionExpr" name=
"prod-xpath-UnionExpr"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IntersectExceptExpr" name=
"prod-xpath-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueExpr">ValueExpr</a> ( ("intersect" |
"except") <a href="#prod-xpath-ValueExpr">ValueExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ValueExpr" name=
"prod-xpath-ValueExpr"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PathExpr" name=
"prod-xpath-PathExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">gn: leading-lone-slash</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-RelativePathExpr" name=
"prod-xpath-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a> (("/" | "//") <a href=
"#prod-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-StepExpr" name=
"prod-xpath-StepExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AxisStep">AxisStep</a> | <a href=
"#prod-xpath-FilterStep">FilterStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AxisStep" name=
"prod-xpath-AxisStep"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ForwardStep">ForwardStep</a> | <a href=
"#prod-xpath-ReverseStep">ReverseStep</a>) <a href=
"#prod-xpath-Predicates">Predicates</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-FilterStep" name=
"prod-xpath-FilterStep"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-FilterStep">FilterStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a> <a href=
"#prod-xpath-Predicates">Predicates</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ContextItemExpr" name=
"prod-xpath-ContextItemExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PrimaryExpr" name=
"prod-xpath-PrimaryExpr"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a> | <a href=
"#prod-xpath-VarRef">VarRef</a> | <a href=
"#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#prod-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#prod-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-VarRef" name=
"prod-xpath-VarRef"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Predicates" name=
"prod-xpath-Predicates"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicates">Predicates</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("[" <a href="#prod-xpath-Expr">Expr</a> "]")*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-GeneralComp" name=
"prod-xpath-GeneralComp"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td>
<td><i>/* <a href="#parse-note-lt">gn: lt</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ValueComp" name=
"prod-xpath-ValueComp"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NodeComp" name=
"prod-xpath-NodeComp"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForwardStep" name=
"prod-xpath-ForwardStep"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ForwardAxis">ForwardAxis</a> <a href=
"#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ReverseStep" name=
"prod-xpath-ReverseStep"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ReverseAxis">ReverseAxis</a> <a href=
"#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AbbrevForwardStep" name=
"prod-xpath-AbbrevForwardStep"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href="#prod-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AbbrevReverseStep" name=
"prod-xpath-AbbrevReverseStep"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForwardAxis" name=
"prod-xpath-ForwardAxis"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"child" "::"&gt;<br />
| &lt;"descendant" "::"&gt;<br />
| &lt;"attribute" "::"&gt;<br />
| &lt;"self" "::"&gt;<br />
| &lt;"descendant-or-self" "::"&gt;<br />
| &lt;"following-sibling" "::"&gt;<br />
| &lt;"following" "::"&gt;<br />
| &lt;"namespace" "::"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ReverseAxis" name=
"prod-xpath-ReverseAxis"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"parent" "::"&gt;<br />
| &lt;"ancestor" "::"&gt;<br />
| &lt;"preceding-sibling" "::"&gt;<br />
| &lt;"preceding" "::"&gt;<br />
| &lt;"ancestor-or-self" "::"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NodeTest" name=
"prod-xpath-NodeTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | <a href=
"#prod-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NameTest" name=
"prod-xpath-NameTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#prod-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Wildcard" name=
"prod-xpath-Wildcard"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| &lt;<a href="#prod-xpath-NCName">NCName</a> ":" "*"&gt;<br />
| &lt;"*" ":" <a href="#prod-xpath-NCName">NCName</a>&gt;</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Literal" name=
"prod-xpath-Literal"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a> | <a href=
"#prod-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NumericLiteral" name=
"prod-xpath-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a> | <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ParenthesizedExpr" name=
"prod-xpath-ParenthesizedExpr"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-FunctionCall" name=
"prod-xpath-FunctionCall"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;<a href="#prod-xpath-QName">QName</a> "("&gt; (<a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SingleType" name=
"prod-xpath-SingleType"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a> "?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SequenceType" name=
"prod-xpath-SequenceType"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ItemType">ItemType</a> <a href=
"#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />
| &lt;"empty" "(" ")"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AtomicType" name=
"prod-xpath-AtomicType"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ItemType" name=
"prod-xpath-ItemType"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a> | <a href=
"#prod-xpath-KindTest">KindTest</a> | &lt;"item" "(" ")"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-KindTest" name=
"prod-xpath-KindTest"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath-AttributeTest">AttributeTest</a><br />
| <a href="#prod-xpath-PITest">PITest</a><br />
| <a href="#prod-xpath-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath-TextTest">TextTest</a><br />
| <a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementTest" name=
"prod-xpath-ElementTest"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"element" "("&gt; ((<a href=
"#prod-xpath-SchemaContextPath">SchemaContextPath</a> <a href=
"#prod-xpath-ElementName">ElementName</a>)<br />
| (<a href="#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#prod-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a>
"nillable"?)?))? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttributeTest" name=
"prod-xpath-AttributeTest"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"attribute" "("&gt; ((<a href=
"#prod-xpath-SchemaContextPath">SchemaContextPath</a> <a href=
"#prod-xpath-AttributeName">AttributeName</a>)<br />
| (<a href="#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a>)?))?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementName" name=
"prod-xpath-ElementName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttributeName" name=
"prod-xpath-AttributeName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TypeName" name=
"prod-xpath-TypeName"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementNameOrWildcard" name=
"prod-xpath-ElementNameOrWildcard"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttribNameOrWildcard" name=
"prod-xpath-AttribNameOrWildcard"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TypeNameOrWildcard" name=
"prod-xpath-TypeNameOrWildcard"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-TypeNameOrWildcard">TypeNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TypeName">TypeName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PITest" name=
"prod-xpath-PITest"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"processing-instruction" "("&gt; (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DocumentTest" name=
"prod-xpath-DocumentTest"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"document-node" "("&gt; <a href=
"#prod-xpath-ElementTest">ElementTest</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CommentTest" name=
"prod-xpath-CommentTest"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"comment" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TextTest" name=
"prod-xpath-TextTest"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"text" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AnyKindTest" name=
"prod-xpath-AnyKindTest"></a>[78]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"node" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaContextPath" name=
"prod-xpath-SchemaContextPath"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaContextPath">SchemaContextPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;<a href=
"#prod-xpath-SchemaGlobalContext">SchemaGlobalContext</a> "/"&gt;
&lt;<a href="#prod-xpath-SchemaContextStep">SchemaContextStep</a>
"/"&gt;*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-OccurrenceIndicator" name=
"prod-xpath-OccurrenceIndicator"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a id="notes-on-parsing" name="notes-on-parsing"></a>A.1.1 Grammar
Notes</h4>
<p>This section contains general notes on the EBNF productions, which may be
helpful in understanding how to create a parser based on this EBNF, how to
read the EBNF, and generally call out issues with the syntax. The notes below
are referenced from the right side of the production, with the notation:
<em>/* gn: &lt;id&gt; */</em>.</p>
<dl>
<dt class="label"><a id="parse-note-parens" name=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p>A look-ahead of one character is required to distinguish function patterns
from a QName followed by a comment. For example: <code>address (: this may be
empty :)</code> may be mistaken for a call to a function named "address"
unless this lookahead is employed.</p>
</dd>
<dt class="label"><a id="parse-note-lt" name=
"parse-note-lt"></a>grammar-note: lt</dt>
<dd>
<p>Token disambiguation of the overloaded "&lt;" pattern is defined in terms
of positional <a href="#lexical-structure">lexical states</a>. The "&lt;"
comparison operator can not occur in the same places as a "&lt;" tag open
pattern. The "&lt;" comparison operator can only occur in the <a href=
"#OPERATOR">OPERATOR</a> state and the "&lt;" tag open pattern can only occur
in the <a href="#DEFAULT">DEFAULT</a> <span class="xpath"><span class=
"xpath">state.</span></span> (These states are only a specification tool, and
do not mandate an implementation strategy for this same effect.)</p>
</dd>
<dt class="label"><a id="parse-note-leading-lone-slash" name=
"parse-note-leading-lone-slash"></a>grammar-note: leading-lone-slash</dt>
<dd>
<p>The "/" presents an issue because it occurs both in a leading position and
an operator position in expressions. Thus, expressions such as "/ * 5" can
easily be confused with the path expression "/*". Therefore, a stand-alone
slash, in a leading position, that is followed by an operator, will need to
be parenthesized in order to stand alone, as in "(/) * 5". "5 * /", on the
other hand, is fine.</p>
</dd>
<dt class="label"><a id="parse-note-comments" name=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>Expression comments are allowed inside expressions everywhere that
ignorable white space is allowed.</p>
</dd>
<dt class="label"><a id="parse-note-xml-version" name=
"parse-note-xml-version"></a>grammar-note: xml-version</dt>
<dd>
<p>The general rules for <a href="#XML1.1">[XML 1.1]</a> vs. <a href=
"#XML">[XML 1.0]</a>, as described in the <a href="#lexical-structure"><b>A.2
Lexical structure</b></a> section, should be applied to this production.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a id="lexical-structure" name="lexical-structure"></a>A.2 Lexical
structure</h3>
<div class="xpath">
<p class="xpath">A <b>host language</b> may choose whether legal characters
in an XPath expression are those characters allowed in <a href="#XML">[XML
1.0]</a> or the larger set of characters allowed in <a href="#XML1.1">[XML
1.1]</a>.</p>
</div>
<p>When patterns are simple string matches, the strings are embedded directly
into the EBNF. In other cases, named terminals are used.</p>
<p>It is up to an implementation to decide on the exact tokenization
strategy, which may be different depending on the parser construction. In the
EBNF, the notation "&lt; ... &gt;" is used to indicate a grouping of
terminals that together may help disambiguate the individual symbols.</p>
<p>This document uses <b>lexical states</b> to assist with terminal symbol
recognition. The states specify lexical constraints and transitions based on
grammatical positioning. The rules for calculating these states are given in
the <a href="#id-lexical-states"><b>A.2.2 Lexical Rules</b></a> section. The
specification of these states in this document does not imply any
tokenization strategy on the part of implementations.</p>
<p>When tokenizing, the longest possible match that is valid in the current
lexical state is preferred .</p>
<p>All keywords are case sensitive. Keywords are not reserved&#8212;that is,
any QName may duplicate a keyword except as noted in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<div class="div3">
<h4><a id="whitespace-rules" name="whitespace-rules"></a>A.2.1 White Space
Rules</h4>
<p>For readability, white space may be used in most expressions even though
not explicitly notated in the EBNF. White space is tolerated before the first
token and after the last token. White space is optional between terminals,
except a few cases where white space is needed to disambiguate the token. For
instance, in XML, "-" is a valid character in an element or attribute name.
When used as an operator after the characters of a name, it must be separated
from the name, e.g. by using white space or parentheses.</p>
<p>Special white space notation is specified with the EBNF productions, when
it is different from the default rules, as follows.</p>
<dl>
<dt class="label"><a id="ws-explicit" name="ws-explicit"></a>Whitespace:
explicit</dt>
<dd>
<p>"ws: explicit" means that the EBNF notation explicitly notates where white
space is allowed, and whitespace is otherwise not allowed.</p>
</dd>
<dt class="label"><a id="ws-significant" name=
"ws-significant"></a>Whitespace: significant</dt>
<dd>
<p>"ws: significant" means that white space is significant as value
content.</p>
</dd>
</dl>
<p>For other usage of white space, one or more white space characters are
required to separate "words". Zero or more white space characters may
optionally be used around punctuation and non-word symbols.</p>
</div>
<div class="div3">
<h4><a id="id-lexical-states" name="id-lexical-states"></a>A.2.2 Lexical
Rules</h4>
<p>The lexical contexts and transitions between lexical contexts is described
in terms of a series of states and transitions between those states.</p>
<p>The tables below define the complete lexical rules for XPath. Each table
corresponds to a lexical state and shows that the tokens listed are
recognized when in that state. When a given token is recognized in the given
state, the transition to the next state is given. In some cases, a transition
will "push" the current state or a specific state onto an abstract stack, and
will later restore that state by a "pop" when another lexical event
occurs.</p>
<p>The lexical states have, in many cases, close connection to the parser
productions. However, just because a token is recognized in a certain lexical
state, does not mean it will be legal in the current EBNF production.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no requirement for a lexer/parser to be implemented in terms of
lexical states&#8212;these are only a declarative way to specify the
behavior. The only requirement is to produce results that are consistent with
the results of these tables.</p>
</div>
<dl>
<dt class="label"><a id="DEFAULT" name="DEFAULT"></a>The DEFAULT State</dt>
<dd>
<p>This state is for patterns that occur at the beginning of an expression or
subexpression.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1"><a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, "..", ".", <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, &lt;<a href=
"#prod-xpath-NCName">NCName</a> ":" "*"&gt;, <a href=
"#prod-xpath-QName">QName</a>, "]", ")", &lt;"*" ":" <a href=
"#prod-xpath-NCName">NCName</a>&gt;, "*", <a href=
"#prod-xpath-StringLiteral">StringLiteral</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OPERATOR</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"$", &lt;"for" "$"&gt;, &lt;"some" "$"&gt;,
&lt;"every" "$"&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">VARNAME</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"element" "("&gt;, &lt;"attribute" "("&gt;,
&lt;"comment" "("&gt;, &lt;"text" "("&gt;, &lt;"node" "("&gt;,
&lt;"document-node" "("&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTEST</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState(OPERATOR)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"processing-instruction" "("&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTESTFORPI</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState(OPERATOR)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"(:"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">EXPR_COMMENT</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"@", &lt;"ancestor-or-self" "::"&gt;,
&lt;"ancestor" "::"&gt;, &lt;"attribute" "::"&gt;, &lt;"child" "::"&gt;,
&lt;"descendant-or-self" "::"&gt;, &lt;"descendant" "::"&gt;,
&lt;"following-sibling" "::"&gt;, &lt;"following" "::"&gt;, &lt;"namespace"
"::"&gt;, &lt;"parent" "::"&gt;, &lt;"preceding-sibling" "::"&gt;,
&lt;"preceding" "::"&gt;, &lt;"self" "::"&gt;, ",", &lt;"if" "("&gt;, "[",
"(", "-", "+", &lt;<a href="#prod-xpath-QName">QName</a> "("&gt;, "//",
"/"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="OPERATOR" name="OPERATOR"></a>The OPERATOR
State</dt>
<dd>
<p>This state is for patterns that are defined for operators.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">"and", ",", "div", "else", "=", "except", "eq",
"ge", "gt", "le", "lt", "ne", "&gt;=", "&gt;&gt;", "&gt;", "idiv",
"intersect", "in", "is", "[", "(", "&lt;=", "&lt;&lt;", "&lt;", "-", "mod",
"*", "!=", "or", "+", "return", "satisfies", "//", "/", "then", "to",
"union", "|", SchemaModeForDeclareValidate</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">DEFAULT</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"instance" "of"&gt;, &lt;"castable" "as"&gt;,
&lt;"cast" "as"&gt;, &lt;"treat" "as"&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">ITEMTYPE</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"$", &lt;"for" "$"&gt;, &lt;"some" "$"&gt;,
&lt;"every" "$"&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">VARNAME</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"(:"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">EXPR_COMMENT</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"]", <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, ")", <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>, <a href=
"#prod-xpath-QName">QName</a>, &lt;<a href="#prod-xpath-NCName">NCName</a>
":" "*"&gt;, &lt;"*" ":" <a href="#prod-xpath-NCName">NCName</a>&gt;, ".",
".."</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="ITEMTYPE" name="ITEMTYPE"></a>The ITEMTYPE
State</dt>
<dd>
<p>This state distinguishes tokens that can occur only inside the ItemType
production.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">"$"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">VARNAME</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"empty" "(" ")"&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OPERATOR</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"(:"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">EXPR_COMMENT</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"element" "("&gt;, &lt;"attribute" "("&gt;,
&lt;"comment" "("&gt;, &lt;"text" "("&gt;, &lt;"node" "("&gt;,
&lt;"document-node" "("&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTEST</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState(OCCURRENCEINDICATOR)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"processing-instruction" "("&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTESTFORPI</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState(OPERATOR)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><a href="#prod-xpath-QName">QName</a>, &lt;"item"
"(" ")"&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OCCURRENCEINDICATOR</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="KINDTEST" name="KINDTEST"></a>The KINDTEST
State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">&lt;<a href=
"#prod-xpath-SchemaGlobalContext">SchemaGlobalContext</a> "/"&gt;, <a href=
"#prod-xpath-SchemaGlobalTypeName">SchemaGlobalTypeName</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">SCHEMACONTEXTSTEP</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">")"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">popState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"*", <a href="#prod-xpath-QName">QName</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">CLOSEKINDTEST</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">&lt;"element" "("&gt;</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTEST</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState(KINDTEST)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"@", <a href=
"#prod-xpath-StringLiteral">StringLiteral</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="KINDTESTFORPI" name="KINDTESTFORPI"></a>The
KINDTESTFORPI State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">")"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">popState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><a href="#prod-xpath-NCName">NCName</a>, <a href=
"#prod-xpath-StringLiteral">StringLiteral</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="CLOSEKINDTEST" name="CLOSEKINDTEST"></a>The
CLOSEKINDTEST State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">")"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">popState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">","</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">KINDTEST</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"nillable"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="OCCURRENCEINDICATOR" name=
"OCCURRENCEINDICATOR"></a>The OCCURRENCEINDICATOR State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">NotOccurrenceIndicator</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OPERATOR</td>
</tr>
<tr>
<td rowspan="1" colspan="1">input_stream.backup(1)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"?", "*", "+"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OPERATOR</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="SCHEMACONTEXTSTEP" name="SCHEMACONTEXTSTEP"></a>The
SCHEMACONTEXTSTEP State</dt>
<dd>
<p>This state distinguishes the SchemaContextStep from the
SchemaGlobalContext.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">&lt;<a href=
"#prod-xpath-SchemaContextStep">SchemaContextStep</a> "/"&gt;, "@"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><a href="#prod-xpath-QName">QName</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">CLOSEKINDTEST</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="VARNAME" name="VARNAME"></a>The VARNAME State</dt>
<dd>
<p>This state differentiates variable names from qualified names. This allows
only the pattern of a QName to be recognized when otherwise ambiguities could
occur.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1"><a href="#prod-xpath-VarName">VarName</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">OPERATOR</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"(:"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">EXPR_COMMENT</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
<dt class="label"><a id="EXPR_COMMENT" name="EXPR_COMMENT"></a>The
EXPR_COMMENT State</dt>
<dd>
<p>The "(:" token marks the beginning of an expression Comment, and the ":)"
token marks the end. This allows no special interpretation of other
characters in this state.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th rowspan="1" colspan="1">Pattern</th>
<th rowspan="1" colspan="1">Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">":)"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">popState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1">"(:"</td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">EXPR_COMMENT</td>
</tr>
<tr>
<td rowspan="1" colspan="1">pushState()</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><a href=
"#prod-xpath-ExprCommentContent">ExprCommentContent</a></td>
<td rowspan="1" colspan="1">
<table summary="Transition table">
<tbody>
<tr>
<td rowspan="1" colspan="1">(maintain state)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a id="id-reserved-fn-names" name="id-reserved-fn-names"></a>A.3 Reserved
Function Names</h3>
<p>The following is a list of names that must not be used as user function
names, in an unprefixed form, because these functions could be confused with
expression syntax.</p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>type</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the keyword typeswitch is not used in XPath, it is considered a
reserved function name for compatibility with XQuery.</p>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-precedence-order" name="id-precedence-order"></a>A.4 Precedence
Order</h3>
<p>The grammar defines built-in precedence, which is summarised here. In the
cases where a number of operators are a choice at the same production level,
the expressions are always evaluated from left to right. The operators in
order of increasing precedence are:</p>
<table border="1">
<tbody>
<tr>
<td rowspan="1" colspan="1">1</td>
<td rowspan="1" colspan="1">(comma)</td>
</tr>
<tr>
<td rowspan="1" colspan="1">2</td>
<td rowspan="1" colspan="1"><span class="xpath"><span class="xpath"><a href=
"#doc-xpath-ForExpr">ForExpr</a>,</span></span> <a href=
"#doc-xpath-QuantifiedExpr">some, every</a>, <a href=
"#doc-xpath-IfExpr">IfExpr</a>, <a href="#doc-xpath-OrExpr">or</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">3</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-AndExpr">and</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">4</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-InstanceofExpr">instance
of</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">5</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-TreatExpr">treat</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">6</td>
<td rowspan="1" colspan="1"><a href=
"#doc-xpath-CastableExpr">castable</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">7</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-CastExpr">cast</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">8</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-ValueComp">eq, ne, lt, le,
gt, ge</a>, <a href="#doc-xpath-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xpath-NodeComp">is</a>, <a href=
"#doc-xpath-NodeComp">&lt;&lt;, &gt;&gt;</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">9</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-RangeExpr">to</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">10</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-AdditiveExpr">+, -</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">11</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-MultiplicativeExpr">*, div,
idiv, mod</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">12</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-UnaryExpr">unary -, unary
+</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">13</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-UnionExpr">union, |</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">14</td>
<td rowspan="1" colspan="1"><a href=
"#doc-xpath-IntersectExceptExpr">intersect, except</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">15</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-PathExpr">/, //</a></td>
</tr>
<tr>
<td rowspan="1" colspan="1">16</td>
<td rowspan="1" colspan="1"><a href="#doc-xpath-Predicates">[ ]</a></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a id="N133DF" name="N133DF"></a>B Type Promotion and Operator
Mapping</h2>
<div class="div2">
<h3><a id="promotion" name="promotion"></a>B.1 Type Promotion</h3>
<p>Under certain circumstances, an atomic value can be promoted from one type
to another. <b>Type promotion</b> is used in function calls (see <a href=
"#id-function-calls"><b>3.1.5 Function Calls</b></a>) and in processing of
operators that accept <b>numeric</b> operands (listed in the tables below).
The following type promotions are permitted:</p>
<ol class="enumar">
<li>
<p>A value of type <code>xs:float</code> (or any type derived by restriction
from <code>xs:float</code>) can be promoted to the type
<code>xs:double</code>. The result is the <code>xs:double</code> value that
is the same as the original value. This kind of promotion may cause loss of
precision.</p>
</li>
<li>
<p>A value of type <code>xs:decimal</code> (or any type derived by
restriction from <code>xs:decimal</code>) can be promoted to either of the
types <code>xs:float</code> or <code>xs:double</code>. The result of this
promotion is created by casting the original value to the required type.</p>
</li>
</ol>
<p>Note that <b>promotion</b> is different from <b>subtype substitution</b>.
For example:</p>
<ul>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:float</code> can be invoked with a value of type
<code>xs:decimal</code>. This is an example of <b>promotion</b>. The value is
actually converted to the expected type. Within the body of the function,
<code>$p instance of xs:decimal</code> returns <code>false</code>.</p>
</li>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:decimal</code> can be invoked with a value of type
<code>xs:integer</code>. This is an example of <b>subtype substitution</b>.
The value retains its original type. Within the body of the function,
<code>$p instance of xs:integer</code> returns <code>true</code>.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="mapping" name="mapping"></a>B.2 Operator Mapping</h3>
<p>The tables in this section list the combinations of types for which the
various operators of XPath are defined in terms of functions that are defined
in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>. The <code>and</code> and <code>or</code> operators are
defined directly in the main body of this document, and do not occur in this
table. For each valid combination of types, the table indicates the
function(s) that are used to implement the operator and the type of the
result. Note that in some cases the function does not implement the full
semantics of the given operator. For the definition of each operator
(including its behavior for empty sequences or sequences of length greater
than one), see the descriptive material in the main part of this
document.</p>
<p>Any operator listed in the tables may be validly applied to an operand of
type <em>AT</em> if the table calls for an operand of type <em>ET</em> and
<code>type-matches(</code><em>ET, AT</em><code>)</code> is <code>true</code>
(see <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType
Matching</b></a>). For example, a table entry indicates that the
<code>gt</code> operator may be applied to two <code>xs:date</code> operands,
returning <code>xs:boolean</code>. Therefore, the <code>gt</code> operator
may also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p>
<p>In the operator tables, the term <b>numeric</b> refers to the types
<code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, and
<code>xs:double</code>. An operator whose operands and result are designated
as <b>numeric</b> might be thought of as representing four operators, one for
each of the numeric types. For example, the numeric <code>+</code> operator
might be thought of as representing the following four operators:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center" rowspan="1" colspan="1">Operator</td>
<td align="center" rowspan="1" colspan="1">First operand type</td>
<td align="center" rowspan="1" colspan="1">Second operand type</td>
<td align="center" rowspan="1" colspan="1">Result type</td>
</tr>
<tr>
<td align="center" rowspan="1" colspan="1"><code>+</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center" rowspan="1" colspan="1"><code>+</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center" rowspan="1" colspan="1"><code>+</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:float</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:float</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:float</code></td>
</tr>
<tr>
<td align="center" rowspan="1" colspan="1"><code>+</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:double</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:double</code></td>
<td align="center" rowspan="1" colspan="1"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p>A numeric operator may be validly applied to an operand of type
<em>AT</em> if <code>type-matches(</code><em>ET, AT</em><code>)</code> is
true where <em>ET</em> is any of the four numeric types. If the result type
of an operator is listed as numeric, it means "the first type in the ordered
list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which
all operands can be converted by subtype substitution and promotion." As an
example, suppose that the type <code>hatsize</code> is derived from
<code>xs:integer</code> and the type <code>shoesize</code> is derived from
<code>xs:float</code>. Then if the <code>+</code> operator is invoked with
operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a
result of type <code>xs:float</code>. Similarly, if <code>+</code> is invoked
with two operands of type <code>hatsize</code> it returns a result of type
<code>xs:integer</code>.</p>
<p>In the following tables, the term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
<code>xs:gDay</code>, and <code>xs:gMonth</code>. For binary operators that
accept two Gregorian-type operands, both operands must have the same type
(for example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>
<div class="small">
<table border="1" summary="Binary operators" class="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Type(A)</th>
<th rowspan="1" colspan="1">Type(B)</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-add(A, B)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td>
<td rowspan="1" colspan="1">xs:time</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td>
<td rowspan="1" colspan="1">xs:time</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A + B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:subtract-dates(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A,
B)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td>
<td rowspan="1" colspan="1">xs:date</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">op:subtract-times(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td>
<td rowspan="1" colspan="1">xs:time</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">fn:subtract-dateTimes-yielding-dayTimeDuration(A,
B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A,
B)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xs:datetime</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A,
B)</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A - B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A * B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A * B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A * B</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A * B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A * B</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A idiv B</td>
<td rowspan="1" colspan="1">xs:integer</td>
<td rowspan="1" colspan="1">xs:integer</td>
<td rowspan="1" colspan="1">op:integer-div(A, B)</td>
<td rowspan="1" colspan="1">xs:integer</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A div B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-divide(A, B)</td>
<td rowspan="1" colspan="1">numeric; but xs:decimal if both operands are
xs:integer</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A div B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A div B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xs:double</td>
<td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A mod B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-mod(A, B)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">op:boolean-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 1)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:date-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">op:time-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">op:datetime-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:yearMonthDuration-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:dayTimeDuration-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">Gregorian</td>
<td rowspan="1" colspan="1">Gregorian</td>
<td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:hexBinary</td>
<td rowspan="1" colspan="1">xs:hexBinary</td>
<td rowspan="1" colspan="1">op:hex-binary-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:base64Binary</td>
<td rowspan="1" colspan="1">xs:base64Binary</td>
<td rowspan="1" colspan="1">op:base64-binary-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:anyURI</td>
<td rowspan="1" colspan="1">xs:anyURI</td>
<td rowspan="1" colspan="1">op:anyURI-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:QName</td>
<td rowspan="1" colspan="1">xs:QName</td>
<td rowspan="1" colspan="1">op:QName-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A eq B</td>
<td rowspan="1" colspan="1">xs:NOTATION</td>
<td rowspan="1" colspan="1">xs:NOTATION</td>
<td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B),
1))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">fn:not(op:datetime-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-equal(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">Gregorian</td>
<td rowspan="1" colspan="1">Gregorian</td>
<td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:hexBinary</td>
<td rowspan="1" colspan="1">xs:hexBinary</td>
<td rowspan="1" colspan="1">fn:not(op:hex-binary-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:base64Binary</td>
<td rowspan="1" colspan="1">xs:base64Binary</td>
<td rowspan="1" colspan="1">fn:not(op:base64-binary-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:anyURI</td>
<td rowspan="1" colspan="1">xs:anyURI</td>
<td rowspan="1" colspan="1">fn:not(op:anyURI-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:QName</td>
<td rowspan="1" colspan="1">xs:QName</td>
<td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ne B</td>
<td rowspan="1" colspan="1">xs:NOTATION</td>
<td rowspan="1" colspan="1">xs:NOTATION</td>
<td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:date-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">op:time-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">op:datetime-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A gt B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">op:date-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">op:time-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">op:datetime-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A lt B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">fn:not(op:numeric-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td>
<td rowspan="1" colspan="1"></td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B),
-1)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">fn:not(op:datetime-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A ge B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">fn:not(op:numeric-greater-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">xs:boolean</td>
<td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td>
<td rowspan="1" colspan="1"></td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">xs:string</td>
<td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">xs:date</td>
<td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">xs:time</td>
<td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">xs:dateTime</td>
<td rowspan="1" colspan="1">fn:not(op:datetime-greater-than(A, B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">xdt:yearMonthDuration</td>
<td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A,
B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A le B</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">xdt:dayTimeDuration</td>
<td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A,
B))</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A is B</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">op:is-same-node(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A &lt;&lt; B</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">op:node-before(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A &gt;&gt; B</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">node()</td>
<td rowspan="1" colspan="1">op:node-after(A, B)</td>
<td rowspan="1" colspan="1">xs:boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A union B</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">op:union(A, B)</td>
<td rowspan="1" colspan="1">node()*</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A | B</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">op:union(A, B)</td>
<td rowspan="1" colspan="1">node()*</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A intersect B</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">op:intersect(A, B)</td>
<td rowspan="1" colspan="1">node()*</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A except B</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">node()*</td>
<td rowspan="1" colspan="1">op:except(A, B)</td>
<td rowspan="1" colspan="1">node()*</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A to B</td>
<td rowspan="1" colspan="1">xs:integer</td>
<td rowspan="1" colspan="1">xs:integer</td>
<td rowspan="1" colspan="1">op:to(A, B)</td>
<td rowspan="1" colspan="1">xs:integer+</td>
</tr>
<tr>
<td rowspan="1" colspan="1">A , B</td>
<td rowspan="1" colspan="1">item()*</td>
<td rowspan="1" colspan="1">item()*</td>
<td rowspan="1" colspan="1">op:concatenate(A, B)</td>
<td rowspan="1" colspan="1">item()*</td>
</tr>
</tbody>
</table>
</div>
<div class="small">
<table border="1" summary="Unary operators" class="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Operand type</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>
<tr>
<td rowspan="1" colspan="1">+ A</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
<tr>
<td rowspan="1" colspan="1">- A</td>
<td rowspan="1" colspan="1">numeric</td>
<td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td>
<td rowspan="1" colspan="1">numeric</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="id-xp-context-components" name="id-xp-context-components"></a>C
Context Components</h2>
<p>The tables in this section describe the scope (range of applicability) of
the various components in the static context and dynamic context.</p>
<div class="div2">
<h3><a id="id-xp-static-context-components" name=
"id-xp-static-context-components"></a>C.1 Static Context Components</h3>
<p>The following table describes the components of the <b>static context</b>.
For each component, "global" indicates that the value of the component
applies throughout an XPath expression, whereas "lexical" indicates that the
value of the component applies only within the subexpression in which it is
defined.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class="small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Component</th>
<th rowspan="1" colspan="1">Scope</th>
</tr>
<tr>
<td rowspan="1" colspan="1">XPath 1.0 Compatability Mode</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope namespaces</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Default element/type namespace</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Default function namespace</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope type definitions</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope element declarations</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope attribute declarations</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope variables</td>
<td rowspan="1" colspan="1">lexical; for-expressions and quantified
expressions can bind new variables</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope functions</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">In-scope collations</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Default collation</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Base URI</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Statically-known documents</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Statically-known collections</td>
<td rowspan="1" colspan="1">global</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div2">
<h3><a id="id-xp-evaluation-context-components" name=
"id-xp-evaluation-context-components"></a>C.2 Dynamic Context Components</h3>
<p>The following table describes how values are assigned to the various
components of the <b>dynamic context</b>. All these components are
initialized by mechanisms defined by the host language. For each component,
"global" indicates that the value of the component remains constant
throughout the XPath expression, whereas "dynamic" indicates that the value
of the component can be modified by the evaluation of subexpressions.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class="small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Component</th>
<th rowspan="1" colspan="1">Scope</th>
</tr>
<tr>
<td rowspan="1" colspan="1">Context item</td>
<td rowspan="1" colspan="1">dynamic; changes during evaluation of path
expressions and predicates</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Context position</td>
<td rowspan="1" colspan="1">dynamic; changes during evaluation of path
expressions and predicates</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Context size</td>
<td rowspan="1" colspan="1">dynamic; changes during evaluation of path
expressions and predicates</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Dynamic variables</td>
<td rowspan="1" colspan="1">dynamic; for-expressions and quantified
expressions can bind new variables</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Current date and time</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Implicit timezone</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Available documents</td>
<td rowspan="1" colspan="1">global</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Available collections</td>
<td rowspan="1" colspan="1">global</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a id="id-references" name="id-references"></a>D References</h2>
<div class="div2">
<h3><a id="id-normative-references" name="id-normative-references"></a>D.1
Normative References</h3>
<dl>
<dt class="label"><a id="FunctionsAndOperators" name=
"FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Functions and
Operators</em> W3C Working Draft, 12 Nov. 2003. See <a href=
"http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a></dd>
<dt class="label"><a id="XQueryFormalSemantics" name=
"XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal Semantics</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal
Semantics</em>. W3C Working Draft, 12 Nov. 2003. See <a href=
"http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>
<dt class="label"><a id="XMLSchema" name="XMLSchema"></a>XML Schema</dt>
<dd>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2</em>. W3C
Recommendation, 2 May 2001. See <a href=
"http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/</a>,
<a href=
"http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a>,
and <a href=
"http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>.</dd>
<dt class="label"><a id="datamodel" name="datamodel"></a>XQuery 1.0 and XPath
2.0 Data Model</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Data Model</em>.
W3C Working Draft, 12 Nov. 2003. See <a href=
"http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>
<dt class="label"><a id="serialization" name="serialization"></a>XSLT 2.0 and
XQuery 1.0 Serialization</dt>
<dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery 1.0
Serialization</em>. W3C Working Draft, 12 Nov. 2003. See <a href=
"http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>
<dt class="label"><a id="XML" name="XML"></a>XML 1.0</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.0.</em>
W3C Recommendation. See <a href=
"http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a></dd>
<dt class="label"><a id="XML1.1" name="XML1.1"></a>XML 1.1</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.1.</em>
W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></dd>
<dt class="label"><a id="XMLNAMES" name="XMLNAMES"></a>XML Names</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>
<dt class="label"><a id="ISO10646" name="ISO10646"></a>ISO/IEC 10646</dt>
<dd>ISO (International Organization for Standardization). <em>ISO/IEC
10646-1993 (E). Information technology&#8212;Universal Multiple-Octet Coded
Character Set (UCS)&#8212;Part 1: Architecture and Basic Multilingual
Plane.</em> [Geneva]: International Organization for Standardization, 1993
(plus amendments AM 1 through AM 7).</dd>
<dt class="label"><a id="ISO10646-2000" name="ISO10646-2000"></a>ISO/IEC
10646-2000</dt>
<dd>ISO (International Organization for Standardization). <em>ISO/IEC
10646-1:2000. Information technology&#8212;Universal Multiple-Octet Coded
Character Set (UCS)&#8212;Part 1: Architecture and Basic Multilingual
Plane.</em> [Geneva]: International Organization for Standardization,
2000.</dd>
<dt class="label"><a id="Unicode" name="Unicode"></a>Unicode</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard, Version 2.0.</em>
Reading, Mass.: Addison-Wesley Developers Press, 1996.</dd>
<dt class="label"><a id="Unicode3" name="Unicode3"></a>Unicode3</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard, Version 3.0.</em>
Reading, Mass.: Addison-Wesley Developers Press, 2000. ISBN
0-201-61633-5.</dd>
</dl>
</div>
<div class="div2">
<h3><a id="id-non-normative-references" name=
"id-non-normative-references"></a>D.2 Non-normative References</h3>
<dl>
<dt class="label"><span class="xpath"><a id="XPath-Requirements" name=
"XPath-Requirements"></a>XPath 2.0 Requirements</span></dt>
<dd>
<div class="xpath">World Wide Web Consortium. <em>XPath Requirements Version
2.0</em>. W3C Working Draft 22 August 2003. See <a href=
"http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.</div>
</dd>
<dt class="label"><span class="xpath"><a id="xquery" name=
"xquery"></a>XQuery</span></dt>
<dd>
<div class="xpath">World Wide Web Consortium. <em>XQuery 1.0: An XML Query
Language</em>. W3C Working Draft, 12 Nov. 2003. See <a href=
"http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a></div>
</dd>
<dt class="label"><a id="XSLT" name="XSLT"></a>XSLT 2.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT) 2.0.</em> W3C
Working Draft. See <a href=
"http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>
<dt class="label"><a id="ISO8601" name="ISO8601"></a>ISO 8601</dt>
<dd>International Organization for Standardization (ISO). <em>Representations
of Dates and Times, 2000-08-03.</em> Available from <a href=
"http://www.iso.ch/">http://www.iso.ch/</a></dd>
</dl>
</div>
<div class="div2">
<h3><a id="id-informative-material" name="id-informative-material"></a>D.3
Non-normative Informative Material</h3>
<dl>
<dt class="label"><a id="RFC2396" name="RFC2396"></a>RFC2396</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform Resource
Identifiers (URI): Generic Syntax</em>. IETF RFC 2396. See <a href=
"http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>
<dt class="label"><a id="CHARMOD" name="CHARMOD"></a>Character Model</dt>
<dd>World Wide Web Consortium. <em>Character Model for the World Wide
Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a></dd>
<dt class="label"><a id="XINFO" name="XINFO"></a>XML Infoset</dt>
<dd>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>
<dt class="label"><a id="XPath" name="XPath"></a>XPath 1.0</dt>
<dd>World Wide Web Consortium. <em>XML Path Language (XPath) Version
1.0</em>. W3C Recommendation, Nov. 16, 1999. See <a href=
"http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
<dt class="label"><a id="XPTR" name="XPTR"></a>XPointer</dt>
<dd>World Wide Web Consortium. <em>XML Pointer Language (XPointer).</em> W3C
Last Call Working Draft 8 January 2001. See <a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>
<dt class="label"><a id="XSLT1" name="XSLT1"></a>XSLT 1.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT) 1.0.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a id="id-glossary" name="id-glossary"></a>E Glossary</h2>
<dl>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic value</dt>
<dd>
<p>An <b>atomic value</b> is a value in the value space of an XML Schema
<b>atomic type</b>, as defined in <a href="#XMLSchema">[XML Schema]</a> (that
is, a simple type that is not a list type or a union type).</p>
</dd>
<dt><a name="GLdt-atomization" id="GLdt-atomization"></a>atomization</dt>
<dd>
<p><b>Atomization</b> is applied to a value when the value is used in a
context in which a sequence of atomic values is required. The result of
atomization is either a sequence of atomic values or a <a title="type error"
href="#dt-type-error">type error</a>. Atomization of a sequence is defined as
the result of invoking the <code>fn:data</code> function on the sequence, as
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>.</p>
</dd>
<dt><a name="GLdt-attribute-test" id=
"GLdt-attribute-test"></a>AttributeTest</dt>
<dd>
<p>An <b>AttributeTest</b> is used to match an attribute node by its name
and/or type.</p>
</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available collections</dt>
<dd>
<p><b>Available collections.</b> This is a mapping of strings onto sequences
of nodes. The string represents the absolute URI of a resource. The sequence
of nodes represents the result of the <code>fn:collection</code> function
when that URI is supplied as the argument.</p>
</dd>
<dt><a name="GLdt-available-docs" id="GLdt-available-docs"></a>available
documents</dt>
<dd>
<p><b>Available documents.</b> This is a mapping of strings onto document
nodes. The string represents the absolute URI of a resource. The document
node is the root of a tree that represents that resource using the <a title=
"data model" href="#dt-datamodel">data model</a>. The document node is
returned by the <code>fn:doc</code> function when applied to that URI.</p>
</dd>
<dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base URI</dt>
<dd>
<p><b>Base URI.</b> This is an absolute URI, used when necessary in the
resolution of relative URIs (for example, by the <code>fn:resolve-uri</code>
function.)</p>
</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context item</dt>
<dd>
<p>The <b>context item</b> is the item currently being processed in a path
expression. An item is either an atomic value or a node.</p>
</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context node</dt>
<dd>
<p>When the context item is a node, it can also be referred to as the
<b>context node</b>.</p>
</dd>
<dt><a name="GLdt-context-position" id="GLdt-context-position"></a>context
position</dt>
<dd>
<p>The <b>context position</b> is the position of the context item within the
sequence of items currently being processed in a path expression.</p>
</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context size</dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence of items
currently being processed in a path expression.</p>
</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current date and
time</dt>
<dd>
<p><b>Current date and time.</b> This information represents an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point in time
during processing of a query or transformation. It can be retrieved by the
<code>fn:current-date</code>, <code>fn:current-time</code>, and
<code>fn:current-dateTime</code> functions. If invoked multiple times during
the execution of a query or transformation, these functions always return the
same result.</p>
</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data model</dt>
<dd>
<p>XPath operates on the abstract, logical structure of an XML document,
rather than its surface syntax. This logical structure is known as the
<b>data model</b>, which is defined in the <a href="#datamodel">[XQuery 1.0
and XPath 2.0 Data Model]</a> document.</p>
</dd>
<dt><a name="GLdt-data-model-schema" id="GLdt-data-model-schema"></a>data
model schema</dt>
<dd>
<p>For a given node in the <a title="data model" href="#dt-datamodel">data
model</a>, the <b>data model schema</b> is defined as the schema from which
the type annotation of that node was derived.</p>
</dd>
<dt><a name="GLdt-def-collation" id="GLdt-def-collation"></a>default
collation</dt>
<dd>
<p><b>Default collation.</b> This collation is used by string comparison
functions and operators when no explicit collation is specified.</p>
</dd>
<dt><a name="GLdt-def-elemtype-ns" id="GLdt-def-elemtype-ns"></a>default
element/type namespace</dt>
<dd>
<p><b>Default element/type namespace.</b> This is a namespace URI. This
namespace is used for any unprefixed QName appearing in a position where an
element or type name is expected.</p>
</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default function
namespace</dt>
<dd>
<p><b>Default function namespace.</b> This is a namespace URI. This namespace
URI is used for any unprefixed QName appearing as the function name in a
function call. The initial default function namespace may be provided by the
external environment.</p>
</dd>
<dt><a name="GLdt-dynamic-context" id="GLdt-dynamic-context"></a>dynamic
context</dt>
<dd>
<p>The <b>dynamic context</b> of an expression is defined as information that
is available at the time the expression is evaluated.</p>
</dd>
<dt><a name="GLdt-dynamic-error" id="GLdt-dynamic-error"></a>dynamic
error</dt>
<dd>
<p>A <b>dynamic error</b> is an error that must be detected during the
evaluation phase and may be detected during the analysis phase. Numeric
overflow is an example of a dynamic error.</p>
</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd>
<p>The <b>dynamic evaluation phase</b> occurs after completion of the
<a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a>. During the dynamic evaluation phase, the value of the <span class=
"xpath"><span class="xpath">expression</span></span> is computed.</p>
</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic type</dt>
<dd>
<p>A <b>dynamic type</b> is associated with each value as it is computed. The
dynamic type of a value may be either a structural description (such as
"sequence of integers") or a named type.</p>
</dd>
<dt><a name="GLdt-dyn-vars" id="GLdt-dyn-vars"></a>Dynamic variables</dt>
<dd>
<p><b>Dynamic variables</b>. This is a set of (QName, value) pairs. It
contains the same QNames as the <a title="in-scope variables" href=
"#dt-is-vars">in-scope variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> for the expression. The QName is the
name of the variable and the value is the dynamic value of the variable.</p>
</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean value</dt>
<dd>
<p>The <b>effective boolean value</b> of a value is defined as the result of
applying the <code>fn:boolean</code> function to the value, as defined in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
</dd>
<dt><a name="GLdt-element-test" id="GLdt-element-test"></a>ElementTest</dt>
<dd>
<p>An <b>ElementTest</b> is used to match an element node by its name and/or
type.</p>
</dd>
<dt><a name="GLdt-empty-sequence" id="GLdt-empty-sequence"></a>empty
sequence</dt>
<dd>
<p>A sequence containing zero items is called an <b>empty sequence</b>.</p>
</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error value</dt>
<dd>
<p>An <b>error value</b> is a single item or the empty sequence.</p>
</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>
<p>The <b>expression context</b> for a given expression consists of all the
information that can affect the result of the expression.</p>
</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd>
<p>The first three components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (context item, context position,
and context size) are called the <b>focus</b> of the expression.</p>
</dd>
<dt><a name="GLdt-functional-language" id=
"GLdt-functional-language"></a>functional langauge</dt>
<dd>
<p>XPath is a <b>functional language</b>, which means that expressions can be
nested with full generality.</p>
</dd>
<dt><a name="GLdt-function-implementation" id=
"GLdt-function-implementation"></a>function implementation</dt>
<dd>
<p><b>Function implementations</b>. Each function in <a title=
"in-scope functions" href="#dt-is-funcs">in-scope functions</a> has a
function implementation that enables the function to map instances of its
parameter types into an instance of its result type.</p>
</dd>
<dt><a name="GLdt-function-signature" id=
"GLdt-function-signature"></a>function signature</dt>
<dd>
<p>Each function has a <b>function signature</b> that specifies the name of
the function and the <a title="static type" href="#dt-static-type">static
types</a> of its parameters and its result.</p>
</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may differ between
implementations, but must be specified by the implementor for each particular
implementation.</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C specification,
and is not required to be specified by the implementor for any particular
implementation.</p>
</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit timezone</dt>
<dd>
<p><b>Implicit timezone.</b> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a comparison
or in any other operation. This value is an instance of
<code>xdt:dayTimeDuration</code> that is <span class="xpath"><span class=
"xpath">determined by the host language</span></span>. See <a href=
"#ISO8601">[ISO 8601]</a> for the range of legal values of a timezone.</p>
</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope attribute
declarations</dt>
<dd>
<p><b>In-scope attribute declarations.</b> Each attribute declaration is
identified either by a QName (for a top-level attribute declaration) or by an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> attribute
identifier (for a local attribute declaration).</p>
</dd>
<dt><a name="GLdt-is-collations" id="GLdt-is-collations"></a>in-scope
collations</dt>
<dd>
<p><b>In-scope collations.</b> This is a set of (URI, collation) pairs. It
defines the names of the collations that are available for use in function
calls that take a collation name as an argument.</p>
</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd>
<p><b>In-scope element declarations.</b> Each element declaration is
identified either by a QName (for a top-level element declaration) or by an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). An element declaration includes
information about the <b>substitution groups</b> to which this element
belongs.</p>
</dd>
<dt><a name="GLdt-is-funcs" id="GLdt-is-funcs"></a>in-scope functions</dt>
<dd>
<p><b>In-scope functions.</b> This component defines the set of functions
that are available to be called from within an expression. Each function is
uniquely identified by its expanded QName and its arity (number of
parameters).</p>
</dd>
<dt><a name="GLdt-is-namespaces" id="GLdt-is-namespaces"></a>in-scope
namespaces</dt>
<dd>
<p><b>In-scope namespaces.</b> This is a set of (prefix, URI) pairs. The
in-scope namespaces are used for resolving prefixes used in QNames within the
expression.</p>
</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema definitions</dt>
<dd>
<p><b>In-scope schema definitions.</b> This is a generic term for all the
element, attribute, and type definitions that are in scope during processing
of an expression.</p>
</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope type
definitions</dt>
<dd>
<p><b>In-scope type definitions.</b> Each named type definition is identified
either by a QName (for a <b>named type</b>) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type identifier
(for an <b>anonymous type</b>). The in-scope type definitions include the
predefined types as described in <a href="#id-predefined-types"><b>2.4.1
Predefined Types</b></a>.</p>
</dd>
<dt><a name="GLdt-is-vars" id="GLdt-is-vars"></a>in-scope variables</dt>
<dd>
<p><b>In-scope variables.</b> This is a set of (QName, type) pairs. It
defines the set of variables that are available for reference within an
expression. The QName is the name of the variable, and the type is the
<a title="static type" href="#dt-static-type">static type</a> of the
variable.</p>
</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd>
<p>An <b>item</b> is either an <a title="atomic value" href=
"#dt-atomic-value">atomic value</a> or a <a title="node" href=
"#dt-node">node</a>.</p>
</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd>
<p>A <b>literal</b> is a direct syntactic representation of an atomic
value.</p>
</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd>
<p>A <b>node</b> is an instance of one of the seven <b>node kinds</b> defined
in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p>
</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd>
<p><b>Primary expressions</b> are the basic primitives of the language. They
include literals, variable references, context item expressions, and function
calls. A primary expression may also be created by enclosing any expression
in parentheses, which is sometimes helpful in controlling the precedence of
operators.</p>
</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd>
<p>A <b>sequence</b> is an ordered collection of zero or more <a title="item"
href="#dt-item">items</a>.</p>
</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>SequenceType</dt>
<dd>
<p>When it is necessary to refer to a type in an XPath expression, the
<b>SequenceType</b> syntax is used. The name <b>SequenceType</b> suggests
that this syntax is used to describe the type of an XPath value, which is
always a sequence.</p>
</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>
<p>During evaluation of an expression, it is sometimes necessary to determine
whether a value with a known type "matches" an expected type, expressed in
the SequenceType syntax. This process is known as <b>SequenceType
matching</b>.</p>
</dd>
<dt><a name="GLdt-serialization" id=
"GLdt-serialization"></a>serialization</dt>
<dd>
<p><b>Serialization</b> is the process of converting a set of nodes from the
<a title="data model" href="#dt-datamodel">data model</a> into a sequence of
octets (step DM4 in Figure 1.)</p>
</dd>
<dt><a name="GLdt-singleton-sequence" id=
"GLdt-singleton-sequence"></a>singleton sequence</dt>
<dd>
<p>A sequence containing exactly one item is called a <b>singleton
sequence</b>.</p>
</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically-known collections</dt>
<dd>
<p><b>Statically-known collections.</b> This is a mapping from strings onto
types. The string represents the absolute URI of a resource that is
potentially available using the <code>fn:collection</code> function. The type
is the type of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its argument.</p>
</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically-known
documents</dt>
<dd>
<p><b>Statically-known documents.</b> This is a mapping from strings onto
types. The string represents the absolute URI of a resource that is
potentially available using the <code>fn:doc</code> function. The type is the
type of the document node that would result from calling the
<code>fn:doc</code> function with this URI as its argument.</p>
</dd>
<dt><a name="GLdt-static-analysis" id="GLdt-static-analysis"></a>static
analysis phase</dt>
<dd>
<p>The <b>static analysis phase</b> depends on the expression itself and on
the <a title="static context" href="#dt-static-context">static context</a>.
The <b>static analysis phase</b> does not depend on input data (other than
schemas).</p>
</dd>
<dt><a name="GLdt-static-context" id="GLdt-static-context"></a>static
context</dt>
<dd>
<p>The <b>static context</b> of an expression is the information that is
available during static analysis of the expression, prior to its
evaluation.</p>
</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static error</dt>
<dd>
<p>A <b>static error</b> is an error that must be detected during the
analysis phase. A syntax error is an example of a <a title="static error"
href="#dt-static-error">static error</a>. The means by which <a title=
"static error" href="#dt-static-error">static errors</a> are reported during
the analysis phase is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static type</dt>
<dd>
<p>The <b>static type</b> of an expression may be either a named type or a
structural description&#8212;for example, <code>xs:boolean?</code> denotes an
optional occurrence of the <code>xs:boolean</code> type. The rules for
inferring the <a title="static type" href="#dt-static-type">static types</a>
of various expressions are described in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
</dd>
<dt><a name="GLdt-static-typing-feature" id=
"GLdt-static-typing-feature"></a>Static Typing Feature</dt>
<dd>
<p>XPath 2.0 defines an optional feature called the <b>Static Typing
Feature</b>.</p>
</dd>
<dt><a name="GLdt-strongly-typed" id="GLdt-strongly-typed"></a>strongly
typed</dt>
<dd>
<p>XPath is also a <b>strongly-typed language</b> in which the operands of
various expressions, operators, and functions must conform to the expected
types.</p>
</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type error</dt>
<dd>
<p>A <b>type error</b> may be raised during the analysis or evaluation phase.
During the analysis phase, a <a title="type error" href="#dt-type-error">type
error</a> occurs when the <a title="static type" href=
"#dt-static-type">static type</a> of an expression does not match the
expected type of the context in which the expression occurs. During the
evaluation phase, a <a title="type error" href="#dt-type-error">type
error</a> occurs when the dynamic type of a value does not match the expected
type of the context in which the value occurs.</p>
</dd>
<dt><a name="GLdt-xpath-compat-mode" id="GLdt-xpath-compat-mode"></a>XPath
1.0 compatibility mode</dt>
<dd>
<p><b>XPath 1.0 compatibility mode.</b> <span class="xpath"><span class=
"xpath">This value is <code>true</code> if rules for backward compatibility
with XPath Version 1.0 are in effect; otherwise it is
<code>false</code>.</span></span></p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a id="id-errors" name="id-errors"></a>F Summary of Error Conditions</h2>
<dl>
<dt><a name="ERRXP0001" id="ERRXP0001"></a>err:XP0001</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if analysis of an expression relies on some component of the <a title=
"static context" href="#dt-static-context">static context</a> that has not
been assigned a value.</p>
</dd>
<dt><a name="ERRXP0002" id="ERRXP0002"></a>err:XP0002</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if evaluation of an expression relies on some part of the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a> that has not
been assigned a value.</p>
</dd>
<dt><a name="ERRXP0003" id="ERRXP0003"></a>err:XP0003</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if an expression is not a valid instance of the grammar defined in <a href=
"#id-grammar"><b>A.1 EBNF</b></a>.</p>
</dd>
<dt><a name="ERRXP0004" id="ERRXP0004"></a>err:XP0004</dt>
<dd>
<p>During the analysis phase, it is a <a title="type error" href=
"#dt-type-error">type error</a> if the static typing feature is in effect and
an expression is found to have a static type that is not appropriate for the
context in which the expression occurs.</p>
</dd>
<dt><a name="ERRXP0005" id="ERRXP0005"></a>err:XP0005</dt>
<dd>
<p>During the analysis phase, it is a <a title="type error" href=
"#dt-type-error">type error</a> if the static typing feature is in effect and
the static type assigned to an expression other than the expression
<code>()</code> is the empty type.</p>
</dd>
<dt><a name="ERRXP0006" id="ERRXP0006"></a>err:XP0006</dt>
<dd>
<p>During the evaluation phase, it is a <a title="type error" href=
"#dt-type-error">type error</a> if a value does not match a required type as
specified by the matching rules in <a href=
"#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</dd>
<dt><a name="ERRXP0007" id="ERRXP0007"></a>err:XP0007</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if the
<code>fn:data</code> function is applied to a node whose type annotation
denotes a complex type with non-mixed complex content.</p>
</dd>
<dt><a name="ERRXP0008" id="ERRXP0008"></a>err:XP0008</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if an expression refers to a type name, function name, namespace prefix, or
variable name that is not defined in the <a title="static context" href=
"#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXP0017" id="ERRXP0017"></a>err:XP0017</dt>
<dd>
<p>It is <span class="xpath"><span class="xpath">It is an error (the host
language environment may define this error as either a static or a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>)</span></span> if
the expanded QName and number of arguments in a function call do not match
the name and arity of an <a title="in-scope functions" href=
"#dt-is-funcs">in-scope function</a> in the <a title="static context" href=
"#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXP0018" id="ERRXP0018"></a>err:XP0018</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
for an expression to depend on the focus when the focus is undefined.</p>
</dd>
<dt><a name="ERRXP0019" id="ERRXP0019"></a>err:XP0019</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if the
result of a step expression (StepExpr) is not a sequence of nodes.</p>
</dd>
<dt><a name="ERRXP0020" id="ERRXP0020"></a>err:XP0020</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if in
an axis expression, the context item is not a node.</p>
</dd>
<dt><a name="ERRXP0021" id="ERRXP0021"></a>err:XP0021</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if a value in a cast expression cannot be cast to the required
type.</p>
</dd>
<dt><a name="ERRXP0029" id="ERRXP0029"></a>err:XP0029</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> in a cast expression if the input value does not satisfy the facets
of the target type.</p>
</dd>
<dt><a name="ERRXP0050" id="ERRXP0050"></a>err:XP0050</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if dynamic type of the operand of a <code>treat</code> expression
does not match the type specified by the <code>treat</code> expression.</p>
</dd>
<dt><a name="ERRXP0051" id="ERRXP0051"></a>err:XP0051</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if a QName that is used as an <b>AtomicType</b> in a <b>SequenceType</b> is
not defined in the <a title="in-scope type definitions" href=
"#dt-is-types">in-scope type definitions</a> as an atomic type.</p>
</dd>
<dt><a name="ERRXP0055" id="ERRXP0055"></a>err:XP0055</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if an <a title="ElementTest" href="#dt-element-test">ElementTest</a>
specifies a schema path that is not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>.</p>
</dd>
</dl>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="N141EC" name="N141EC"></a>G Conformance</h2>
<p>XPath is intended primarily as a component that can be used by other
specifications. Therefore, XPath relies on specifications that use it (such
as <a href="#XPTR">[XPointer]</a> and <a href="#XSLT">[XSLT 2.0]</a>) to
specify conformance criteria for XPath in their respective environments.
Specifications that set conformance criteria for their use of XPath must not
change the syntactic or semantic definitions of XPath as given in this
specification, except by subsetting and/or compatible extensions.</p>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="id-backwards-compatibility" name=
"id-backwards-compatibility"></a>H Backwards Compatibility with XPath 1.0
(Non-Normative)</h2>
<p>This section provides a summary of the main areas of incompatibility
between XPath 2.0 and <a href="#XPath">[XPath 1.0]</a>.</p>
<p>Three separate cases are considered:</p>
<ol class="enumar">
<li>
<p>Incompatibilities that exist when source documents have no schema, and
when running with XPath 1.0 compatibility mode set to true. This
specification has been designed to reduce the number of incompatibilities in
this situation to an absolute minumum, but some differences remain and are
listed individually.</p>
</li>
<li>
<p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to
false. In this case, the number of expressions where compatibility is lost is
rather greater.</p>
</li>
<li>
<p>Incompatibilities that arise when the source document is processed using a
schema (whether or not XPath 1.0 compatibility mode is set to true).
Processing the document with a schema changes the way that the values of
nodes are interpreted, and this can cause an XPath expression to return
different results.</p>
</li>
</ol>
<div class="div2">
<h3><a id="N1420E" name="N1420E"></a>H.1 Incompatibilities when Compatibility
Mode is true</h3>
<p>The list below contains all known areas, within the scope of this
specification, where an XPath 2.0 processor running with compatibility mode
set to true will produce different results from an XPath 1.0 processor
evaluating the same expression, assuming that the expression was valid in
XPath 1.0, and that the nodes in the source document have no type annotations
other than <code>xdt:untypedAny</code> and
<code>xdt:untypedAtomic</code>.</p>
<p>Incompatibilities in the behavior of individual functions are not listed
here, but are included in an appendix of <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>.</p>
<p>In the description below, the terms <em>node-set</em> and <em>number</em>
are used with their XPath 1.0 meanings, that is, to describe expressions
which according to the rules of XPath 1.0 would have generated a node-set or
a number respectively.</p>
<ol class="enumar">
<li>
<p>The rules for comparing a node-set to a boolean have changed. In XPath
1.0, an expression such as <code>$nodeset=true()</code> was evaluated by
converting the node-set to a boolean and then performing a boolean
comparison: so this expression would return <code>true</code> if
<code>$nodeset</code> was non-empty. In XPath 2.0, this expression is handled
in the same way as other comparisons between a sequence and a singleton: it
is <code>true</code> if <code>$nodeset</code> contains at least one node
whose value, after casting to a boolean, is <code>true</code>.</p>
<p>This means that if <code>$nodeset</code> is empty, the result under XPath
2.0 will be <code>false</code> regardless of the value of the boolean
operand, and regardless of which operator is used. If <code>$nodeset</code>
is non-empty, then in most cases the cast to a boolean is likely to fail,
giving a dynamic error. But if a node has the value "0", "1", "true", or
"false", evaluation of the expression may succeed.</p>
</li>
<li>
<p>The rules for comparing an integer to a boolean have changed. In XPath
1.0, the expression <code>(4 = true())</code> is evaluated by converting the
number 4 to boolean (yielding <code>true</code>). The expression returns
<code>true</code>. In XPath 2.0, running in compatibility mode, the same
expression is evaluated by converting both operands to double (yielding
<code>4e0 = 1e0</code>). The expression returns <code>false</code>.</p>
</li>
<li>
<p>The rules for comparing a string to a boolean have changed. In XPath 1.0,
the expression <code>("x" = true())</code> is evaluated by converting the
string to a boolean, and performing a boolean comparison. In XPath 2.0 a
comparison between a boolean and a string raises a type error, even when
compatibility mode is true.</p>
</li>
<li>
<p>Additional numeric types have been introduced, with the effect that
arithmetic may now be done as an integer, decimal, or single- or
double-precision floating point calculation where previously it was always
performed as double-precision floating point. The result of the
<code>div</code> operator when dividing two integers is now a value of type
decimal rather than double. The expression <code>10 div 0</code> raises an
error rather than returning positive infinity.</p>
</li>
<li>
<p>The rules for converting numbers to strings have changed. These may affect
the way numbers are displayed in the output of a stylesheet. For numbers
whose absolute value is in the range 1E-6 to 1E+6, the result should be the
same, but outside this range, scientific format is used for
<code>xs:float</code> and <code>xs:double</code> values.</p>
</li>
<li>
<p>The rules for converting strings to numbers have changed. The
representation of special values such as Infinity has been aligned with XML
Schema. Strings containing a leading plus sign, or numbers in scientific
notation, may now be converted to ordinary numeric values, whereas in XPath
1.0 they were converted to <code>NaN</code>.</p>
</li>
<li>
<p>Many operations in XPath 2.0 produce an empty sequence as their result
when one of the arguments or operands is an empty sequence. With XPath 1.0,
the result of such an operation was typically a zero-length string or the
numeric value <code>NaN</code>. An example of an expression whose value will
change as a result of this rule is <code>string(@a+0) = "NaN"</code>, in the
case where <code>@a</code> returns an empty node-set. With XPath 1.0, this
would produce the value <code>true</code>. With XPath 2.0, it produces the
value <code>false</code>.</p>
</li>
<li>
<p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when
applied to two strings, attempted to convert both the strings to numbers and
then made a numeric comparison between the results. In XPath 2.0, these
operators perform a string comparison using the default collating sequence.
(If either value is numeric, however, the results are compatible with XPath
1.0)</p>
</li>
<li>
<p>In XPath 1.0, functions and operators that compared strings (for example,
the <code>=</code> operator) worked on the basis of character-by-character
equality of Unicode codepoints, allowing Unicode normalization at the
discretion of the implementor. In XPath 2.0, these comparisons are done using
the default collating sequence. The host language from which XPath is invoked
may define mechanisms allowing codepoint comparison to be selected as the
default collating sequence, but there is no such mechanism defined in XPath
itself.</p>
</li>
<li>
<p>In XPath 1.0, it was defined that with an expression of the form <code>A
and B</code>, B would not be evaluated if A was false. Similarly in the case
of <code>A or B</code>, B would not be evaluated if A was true. This is no
longer guaranteed with XPath 2.0: the implementation is free to evaluate the
two operands in either order or in parallel. This change has been made to
give more scope for optimization in situations where XPath expressions are
evaluated against large data collections supported by indexes.
Implementations may choose to retain backwards compatibility in this area,
but they are not obliged to do so.</p>
</li>
<li>
<p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were
supported in XPath 1.0, but are not permitted by the XPath 2.0 grammar. Such
comparisons in XPath 1.0 did not have the intuitive meaning, so it is
unlikely that they have been widely used in practice.</p>
</li>
<li>
<p>The namespace axis is deprecated in XPath 2.0. Implementations may support
the namespace axis for backward compatibility with XPath 1.0, but they are
not required to do so.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a id="N142AA" name="N142AA"></a>H.2 Incompatibilities when Compatibility
Mode is false</h3>
<p>Even when the setting of the XPath 1.0 compatibility mode is false, many
XPath expressions will still produce the same results under XPath 2.0 as
under XPath 1.0. However, there are exceptions.</p>
<p>The main additional incompatibilities are as follows:</p>
<ol class="enumar">
<li>
<p>When a node-set containing more than one node is supplied as an argument
to a function or operator that expects a single node or value, the rule that
all nodes after the first are discarded no longer applies. Instead, a type
error occurs if there is more than one node. The XPath 1.0 behavior can
always be restored by using the predicate <code>[1]</code> to explicitly
select the first node in the node-set.</p>
</li>
<li>
<p>When an empty node-set is supplied as an argument to a function or
operator that expects a number, the value is no longer converted implicitly
to NaN. The XPath 1.0 behavior can always be restored by using the
<code>number</code> function to perform an explicit conversion.</p>
</li>
<li>
<p>More generally, the supplied arguments to a function or operator are no
longer implicitly converted to the required type, except in the case where
the supplied argument is of type <code>xdt:untypedAtomic</code> (which will
commonly be the case when a node in a schema-less document is supplied as the
argument). For example, the function call <code>concat("chapter", $nr)</code>
raises a type error if the variable <code>$nr</code> is numeric, because the
arguments to the <code>concat</code> function must be strings rather than
numbers. The XPath 1.0 behavior can be restored by performing an explicit
conversion to the required type using a constructor function or cast.</p>
</li>
</ol>
<p>It is <em>not</em> the case that these differences will always result in
XPath 2.0 raising an error. In some cases, XPath 2.0 will return different
results for the same expression. For example, the expression <code>"4" &lt;
"4.0"</code>. This returns <code>false</code> in XPath 1.0, and
<code>true</code> in XPath 2.0.</p>
</div>
<div class="div2">
<h3><a id="N142DB" name="N142DB"></a>H.3 Incompatibilities when using a
Schema</h3>
<p>An XPath expression applied to a document that has been processed against
a schema will not always give the same results as the same expression applied
to the same document in the absence of a schema. Since schema processing had
no effect on the result of an XPath 1.0 expression, this may give rise to
further incompatibilities.</p>
<p>Suppose that the context node is an element node derived from the
following markup: <code>&lt;background color="red green blue"/&gt;</code>. In
XPath 1.0, the predicate <code>[@color="blue"]</code> would return
<code>false</code>. In XPath 2.0, if the <code>color</code> attribute is
defined in a schema to be of type <code>xs:NMTOKENS</code>, the same
predicate will return <code>true</code>.</p>
<p>Similarly, consider the expression <code>@birth &lt; @death</code> applied
to the element <code>&lt;person birth="1901-06-06"
death="1991-05-09"/&gt;</code>. With XPath 1.0, this expression would return
false, because both attributes are converted to numbers, which returns
<code>NaN</code> in each case. With XPath 2.0, in the presence of a schema
that annotates these attributes as dates, the expression returns
<code>true</code>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a id="id-issues" name="id-issues"></a>I XPath 2.0 and XQuery 1.0 Issues
(Non-Normative)</h2>
<p>The XPath 2.0 and XQuery 1.0 Issues List that records pre-Last Call issues
can be found at <a href=
"http://www.w3.org/XML/2003/11/xpath-xquery-issues">http://www.w3.org/XML/2003/11/xpath-xquery-issues</a>.</p>
</div>
<div class="div1">
<h2><a id="id-revisions-log" name="id-revisions-log"></a>J Revision Log
(Non-Normative)</h2>
<div class="div2">
<h3><a id="N14314" name="N14314"></a>J.1 12 November 2003</h3>
<ul>
<li>
<p>The section entitled "SequenceType Matching" has been rewritten and
includes new material on handling of unrecognized types. An implementation is
allowed (but is not required) to provide an implementation-dependant
mechanism for determining whether an unknown type is compatible with an
expected type.</p>
</li>
<li>
<p>A new concrete type, <code>xdt:untypedAny</code>, has been introduced and
used as the type annotation of a skip-validated element node. A new figure
has been added to illustrate the relationships among the generic types such
as <code>xdt:untypedAny</code> and <code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p>The <code>isnot</code> comparison operator has been removed, and the
sections titled "Node Comparisons" and "Order Comparisons" have been
merged.</p>
</li>
<li>
<p>Some material has been reorganized, notably in the "Types" and "Documents"
(formerly "Important Concepts") sections.</p>
</li>
<li>
<p>The sequence construction expression <code>M to N</code> has been modified
to return an empty sequence if <code>M &gt; N</code>.</p>
</li>
<li>
<p>Casting an instance of <code>xs:QName</code> into <code>xs:string</code>
is no longer supported.</p>
</li>
<li>
<p>Typed values of comments and processing instructions are now considered to
have type <code>xs:string</code> (formerly
<code>xdt:untypedAtomic</code>).</p>
</li>
<li>
<p>The difference between static and dynamic implementation is clarified. If
the static typing feature is in effect, type errors must be detected during
the static analysis phase and serve to inhibit the evaluation phase. If the
static typing feature is not in effect, an implementation may raise
type-related warnings during the static analysis phase, but these warnings do
not serve to inhibit the evaluation phase.</p>
</li>
<li>
<p>Several small grammar changes have been made. <span class=
"xpath"><span class="xpath">For example, an</span></span> "@" symbol is no
longer used in a KindTest where the attribute axis is explicitly identified.
See the BNF grammar for details.</p>
</li>
</ul>
</div>
</div>
</div>
</body>
</html>
