<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<title>XML Path Language (XPath) 2.0</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
      
table.small    { font-size: x-small; }
/*]]>*/
</style>
<link type="text/css" rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="http://www.w3.org/Icons/w3c_home" /></a></p>
<h1><a id="title" name="title"></a>XML Path Language (XPath) 2.0</h1>
<h2><a id="w3c-doctype" name="w3c-doctype"></a>W3C Working Draft 23 July 2004</h2>
<dl>
<dt>This version:</dt>
<dd><span class="xpath"><a href="http://www.w3.org/TR/2004/WD-xpath20-20040723">http://www.w3.org/TR/2004/WD-xpath20-20040723</a></span></dd>
<dt>Latest version:</dt>
<dd><span class="xpath"><a href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></dd>
<dt>Previous versions:</dt>
<dd><span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20031112/">http://www.w3.org/TR/2003/WD-xpath20-20031112/</a></span> <span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20030822/">http://www.w3.org/TR/2003/WD-xpath20-20030822/</a></span> <span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20030502/">http://www.w3.org/TR/2003/WD-xpath20-20030502/</a></span></dd>
<dt>Editors:</dt>
<dd class="xpath">Anders Berglund (XSL WG), IBM Research <a href="mailto:%20alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd>
<dd>Scott Boag (XSL WG), IBM Research <a href="mailto:%20scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>
<dd>Don Chamberlin (XML Query WG), IBM Almaden Research Center <a href="mailto:%20chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>
<dd>Mary F. Fernández (XML Query WG), AT&amp;T Labs <a href="mailto:%20mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>
<dd class="xpath">Michael Kay (XSL WG), Invited Expert, via <a href="http://www.saxonica.com/">http://www.saxonica.com/</a></dd>
<dd>Jonathan Robie (XML Query WG), DataDirect Technologies <a href="mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>
<dd>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center <a href="mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd>
</dl>
<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2004&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>),
All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-software">software licensing</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a id="abstract" name="abstract"></a>Abstract</h2>
<div class="xpath">
<p class="xpath">XPath 2.0 is an expression language that allows the processing of values conforming to the data model defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The data model provides a tree representation of XML documents as well as atomic values such as integers, strings, and booleans, and sequences that may contain both references to nodes in an XML document and atomic values. The result of an XPath expression may be a selection of nodes from the input documents, or an
atomic value, or more generally, any sequence allowed by the data model. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. XPath 2.0 is a superset of <a href="#XPath">[XPath 1.0]</a>, with the added capability to support a richer set of data types, and to take advantage of the type information that becomes available when documents are validated using XML Schema. A backwards compatibility mode
is provided to ensure that nearly all XPath 1.0 expressions continue to deliver the same result with XPath 2.0; exceptions to this policy are noted in [<a href="#id-backwards-compatibility"><b>H Backwards Compatibility with XPath 1.0</b></a>].</p>
</div>
</div>
<div>
<h2><a id="status" name="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>
<p>This is a public W3C Working Draft for review by W3C Members and other interested parties. Publication as a Working Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</p>
<p>XPath 2.0 has been defined jointly by the <a href="http://www.w3.org/XML/Query">XML Query Working Group</a> and the <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a> (both part of the <a href="http://www.w3.org/XML/Activity.html">XML Activity</a>). The XPath 2.0 and XQuery 1.0 Working Drafts are generated from a common source. These languages are closely related, sharing much of the same expression syntax and semantics, and much of the text found in the two Working Drafts is identical.</p>
<p>This working draft includes a number of changes made in response to comments received during the Last Call period that ended on Feb. 15, 2004. The working group is continuing to process these comments, and additional changes are expected. A list of changes introduced by this draft can be found in <a href="#id-revisions-log"><b>J Revision Log</b></a>.</p>
<p>This document reflects decisions taken up to and including the face-to-face meeting in Cambridge, MA during the week of June 21, 2004. These decisions are recorded in the Last Call <span class="xpath"><span class="xpath"><a href="http://www.w3.org/2004/07/xpath-issues.html">issues list</a> (http://www.w3.org/2004/07/xpath-issues.html).</span></span> However, some of these decisions may not yet have been made in this document.</p>
<p>Public comments on this document and its open issues are invited. Comments should be sent to the W3C XPath/XQuery mailing list, <a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a> (archived at <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>), <span class="xpath"><span class="xpath">with &#8220;[XPath]&#8221;</span></span> at the beginning of the subject field.</p>
<p>The patent policy for this document is expected to become the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>, pending the Advisory Committee review of the renewal of the XML Query Working Group. Patent disclosures relevant to this specification may be found on the <a href="http://www.w3.org/2002/08/xmlquery-IPR-statements">XML Query Working Group's patent disclosure page</a> and the <a href="http://www.w3.org/Style/XSL/Disclosures">XSL Working
Group's patent disclosure page</a>. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) with respect to this specification should disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a id="contents" name="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">Introduction</a><br />
2 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#context">Expression Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href="#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href="#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#id-processing-model">Processing Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href="#id-data-model-generation">Data Model Generation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href="#id-schema-import-processing">Schema Import Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href="#id-expression-processing">Expression Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1 <a href="#id-static-analysis">Static Analysis Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2 <a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href="#id-serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href="#id-consistency-constraints">Consistency Constraints</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#id-important-concepts">Documents</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href="#N1081F">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href="#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href="#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href="#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;2.4 <a href="#id-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href="#id-predefined-types">Predefined Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href="#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href="#id-sequencetype-syntax">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href="#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.1 <a href="#id-matching-value">Matching a SequenceType and a Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.2 <a href="#id-matching-item">Matching an ItemType and an Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.3 <a href="#id-element-test">Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.4 <a href="#id-schema-element-test">Schema Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.5 <a href="#id-attribute-test">Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.6 <a href="#id-schema-attribute-test">Schema Attribute Test</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#errors">Error Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href="#id-kinds-of-errors">Kinds of Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href="#id-handling-dynamic">Handling Dynamic Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href="#id-errors-and-opt">Errors and Optimization</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#id-optional-features">Optional Features</a><br />
&#160;&#160;&#160;&#160;2.7 <a href="#comments">Comments</a><br />
3 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#id-primary-expressions">Primary Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href="#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href="#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href="#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href="#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href="#id-function-calls">Function Calls</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#id-path-expressions">Path Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href="#id-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.1 <a href="#axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.2 <a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href="#id-predicates">Predicates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href="#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href="#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#id-sequence-expressions">Sequence Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href="#construct_seq">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href="#id-filter-expr">Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.3 <a href="#combining_seq">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#id-arithmetic">Arithmetic Expressions</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#id-comparisons">Comparison Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href="#id-value-comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href="#id-general-comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href="#id-node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#id-logical-expressions">Logical Expressions</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#id-for-expressions">For Expressions</a><br />
&#160;&#160;&#160;&#160;3.8 <a href="#id-conditionals">Conditional Expressions</a><br />
&#160;&#160;&#160;&#160;3.9 <a href="#id-quantified-expressions">Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;3.10 <a href="#id-expressions-on-datatypes">Expressions on SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href="#id-instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href="#id-cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href="#id-castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a href="#id-constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a href="#id-treat">Treat</a><br /></p>
<h3><a id="appendices" name="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XPath Grammar</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#id-grammar">EBNF</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href="#notes-on-parsing">Grammar Notes</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#lexical-structure">Lexical structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href="#N132F9">Terminal Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href="#whitespace-rules">Whitespace Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2.1 <a href="#DefaultWhitespaceHandling">Default Whitespace Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2.2 <a href="#ExplicitWhitespaceHandling">ExplicitSpecial Whitespace Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3 <a href="#CommentsPragmasExtensions">Comments</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4 <a href="#id-lexical-states">Lexical Rules</a><br />
&#160;&#160;&#160;&#160;A.3 <a href="#id-reserved-fn-names">Reserved Function Names</a><br />
&#160;&#160;&#160;&#160;A.4 <a href="#id-precedence-order">Precedence Order</a><br />
B <a href="#N13BF6">Type Promotion and Operator Mapping</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type Promotion</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator Mapping</a><br />
C <a href="#id-xp-context-components">Context Components</a><br />
&#160;&#160;&#160;&#160;C.1 <a href="#id-xp-static-context-components">Static Context Components</a><br />
&#160;&#160;&#160;&#160;C.2 <a href="#id-xp-evaluation-context-components">Dynamic Context Components</a><br />
D <a href="#id-references">References</a><br />
&#160;&#160;&#160;&#160;D.1 <a href="#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;D.2 <a href="#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;D.3 <a href="#id-informative-material">Non-normative Informative Material</a><br />
E <a href="#N14916">Conformance</a><br />
F <a href="#id-glossary">Glossary</a><br />
G <a href="#id-errors">Summary of Error Conditions</a> (Non-Normative)<br />
H <a href="#id-backwards-compatibility">Backwards Compatibility with XPath 1.0</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;H.1 <a href="#N14A6B">Incompatibilities when Compatibility Mode is true</a><br />
&#160;&#160;&#160;&#160;H.2 <a href="#N14B07">Incompatibilities when Compatibility Mode is false</a><br />
&#160;&#160;&#160;&#160;H.3 <a href="#N14B38">Incompatibilities when using a Schema</a><br />
I <a href="#id-issues">XPath 2.0 and XQuery 1.0 Issues</a> (Non-Normative)<br />
J <a href="#id-revisions-log">Revision Log</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href="#N14B73">23 July 2004</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a id="id-introduction" name="id-introduction"></a>1 Introduction</h2>
<div class="xpath">
<p class="xpath">The primary purpose of XPath is to address the nodes of <a href="#XML">[XML 1.0]</a> trees. XPath gets its name from its use of a path notation for navigating through the hierarchical structure of an XML document. XPath uses a compact, non-XML syntax to facilitate use of XPath within URIs and XML attribute values.</p>
</div>
<p>[<a title="data model" id="dt-datamodel" name="dt-datamodel">Definition</a>: XPath operates on the abstract, logical structure of an XML document, rather than its surface syntax. This logical structure is known as the <b>data model</b>, which is defined in the <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> document.]</p>
<div class="xpath">
<p class="xpath">XPath is designed to be embedded in a <b>host language</b> such as <a href="#XSLT">[XSLT 2.0]</a> or <a href="#xquery">[XQuery]</a>. XPath has a natural subset that can be used for matching (testing whether or not a node matches a pattern); this use of XPath is described in <a href="#XSLT">[XSLT 2.0]</a>.</p>
</div>
<p>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression that is syntactically valid and executes successfully in both XPath 2.0 and XQuery 1.0 will return the same result in both languages. Since these languages are so closely related, their grammars and language descriptions are generated from a common source to ensure consistency, and the editors of these specifications work together closely.</p>
<p>XPath also depends on and is closely related to the following specifications:</p>
<ul>
<li>
<p><a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> defines the data model that underlies all XPath expressions.</p>
</li>
<li>
<p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> defines the static semantics of XPath and also contains a formal but non-normative description of the dynamic semantics that may be useful for implementors and others who require a formal definition.</p>
</li>
<li>
<p>The type system of XPath is based on <a href="#XMLSchema">[XML Schema]</a>.</p>
</li>
<li>
<p>The default function library and the operators supported by XPath are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
</li>
</ul>
<p>This document specifies a grammar for XPath, using the same Basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical structure</b></a>), whitespace is not significant in the grammar. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A XPath Grammar</b></a>]. The appendix is the normative version.</p>
<p>In the grammar productions in this document, nonterminal symbols are underlined and literal text is enclosed in double quotes. Certain productions (including the productions that define DecimalLiteral, DoubleLiteral, and StringLiteral) employ a regular-expression notation. The following example production describes the syntax of a function call:</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="fakeid_doc-xpath-FunctionCall" name="fakeid_doc-xpath-FunctionCall"></a>[47]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>The production should be read as follows: A function call consists of a QName followed by an open-parenthesis. The open-parenthesis is followed by an optional argument list. The argument list (if present) consists of one or more expressions, separated by commas. The optional argument list is followed by a close-parenthesis.</p>
<p>Certain aspects of language processing are described in this specification as <b>implementation-defined</b> or <b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a title="implementation defined" id="dt-implementation-defined" name="dt-implementation-defined">Definition</a>: <b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.]</p>
</li>
<li>
<p>[<a title="implementation dependent" id="dt-implementation-dependent" name="dt-implementation-dependent">Definition</a>: <b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.]</p>
</li>
</ul>
<div class="xpath">
<p class="xpath">A language aspect described in this specification as <b>implementation-defined</b> or <b>implementation dependent</b> may be further constrained by the specifications of a host language in which XPath is embedded.</p>
</div>
<p>This document normatively defines the dynamic semantics of XPath. The static semantics of XPath are normatively defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>. In this document, examples and material labeled as "Note" are provided for explanatory purposes and are not normative.</p>
</div>
<div class="div1">
<h2><a id="id-basics" name="id-basics"></a>2 Basics</h2>
<p>The basic building block of XPath is the <b>expression</b>, which is a string of Unicode characters. This specification makes no assumptions or requirements regarding the character set encoding of strings of Unicode characters. The language provides several kinds of expressions which may be constructed from keywords, symbols, and operands. In general, the operands of an expression are other expressions. [<a title="functional langauge" id="dt-functional-language" name=
"dt-functional-language">Definition</a>: XPath is a <b>functional language</b>, which means that expressions can be nested with full generality. ] [<a title="strongly typed" id="dt-strongly-typed" name="dt-strongly-typed">Definition</a>: XPath is also a <b>strongly-typed language</b> in which the operands of various expressions, operators, and functions must conform to the expected types.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification contains no assumptions or requirements regarding the character set encoding of strings of Unicode characters.</p>
</div>
<p>Like XML, XPath is a case-sensitive language. Keywords in XPath use lower-case characters and are not reserved&#8212;that is, names in XPath expressions are allowed to be the same as language keywords&#8212;except for the list of reserved function-names in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<p>The value of an expression is always a <a title="sequence" href="#dt-sequence">sequence</a>. [<a title="sequence" id="dt-sequence" name="dt-sequence">Definition</a>: A <b>sequence</b> is an ordered collection of zero or more <a title="item" href="#dt-item">items</a>.] [<a title="item" id="dt-item" name="dt-item">Definition</a>: An <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a> or a <a title="node" href="#dt-node">node</a>.] [<a title="atomic value" id=
"dt-atomic-value" name="dt-atomic-value">Definition</a>: An <b>atomic value</b> is a value in the value space of an <b>atomic type</b>, including all the atomic types defined in <a href="#XMLSchema">[XML Schema]</a> and <a title="xdt:untypedAtomic" href="#dt-untypedAtomic">xdt:untypedAtomic</a>.] [<a title="node" id="dt-node" name="dt-node">Definition</a>: A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.] Each node has a
unique <b>node identity</b>. Some kinds of nodes have typed values, string values, and names, which can be extracted from the node. The <b>typed value</b> of a node is a sequence of zero or more atomic values. The <b>string value</b> of a node is a value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.</p>
<p>[<a title="singleton sequence" id="dt-singleton-sequence" name="dt-singleton-sequence">Definition</a>: A sequence containing exactly one item is called a <b>singleton sequence</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested&#8212;for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a title="empty sequence" id="dt-empty-sequence" name="dt-empty-sequence">Definition</a>: A sequence containing
zero items is called an <b>empty sequence</b>.]</p>
<p>Names in XPath are called <b>QNames</b>, and conform to the syntax in <a href="#XMLNAMES">[XML Names]</a>. [<a title="QName" id="dt-qname" name="dt-qname">Definition</a>: Lexically, a <b>QName</b> consists of an optional namespace prefix and a local name.] A lexical QName can be converted into an <b>expanded QName</b> by resolving its namespace prefix, using algorithms described later in this document. [<a title="expanded QName" id="dt-expanded-qname" name="dt-expanded-qname">Definition</a>: An
<b>expanded QName</b> consists of an optional namespace URI and a local name.] Two QNames are considered equal if their namespace URIs are equal and their local names are equal (even if the prefixes in their lexical forms are not equal). Namespace URIs and local names are compared on a codepoint basis, without normalization.</p>
<p>This document uses the following <span class="xpath"><span class="xpath">namespace prefixes (these prefix bindings are illustrative rather than normative):</span></span></p>
<ul>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2004/07/xpath-functions</code></p>
</li>
<li>
<p><code>xdt = http://www.w3.org/2004/07/xpath-datatypes</code></p>
</li>
</ul>
<p>In some cases, where the meaning is clear and namespaces are not important to the discussion, built-in XML Schema typenames such as <code>integer</code> and <code>string</code> are used without a namespace prefix.</p>
<p>Element nodes have a property called <b>in-scope namespaces</b>. [<a title="in-scope namespaces" id="dt-in-scope-namespaces" name="dt-in-scope-namespaces">Definition</a>: The <b>in-scope namespaces</b> property of an element node is a set of <b>namespace bindings</b>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting QNames within the scope of the element. For a given element, one namespace binding may have an empty
prefix; the URI of this namespace binding is the default namespace within the scope of the element.]</p>
<div class="xpath">
<p class="xpath">In <a href="#XPath">[XPath 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>. In XPath Version 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</p>
</div>
<div class="div2">
<h3><a id="context" name="context"></a>2.1 Expression Context</h3>
<p>[<a title="expression context" id="dt-expression-context" name="dt-expression-context">Definition</a>: The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.] This information is organized into two categories called the <a title="static context" href="#dt-static-context">static context</a> and the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>.</p>
<div class="div3">
<h4><a id="static_context" name="static_context"></a>2.1.1 Static Context</h4>
<p>[<a title="static context" id="dt-static-context" name="dt-static-context">Definition</a>: The <b>static context</b> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.] This information can be used to decide whether the expression contains a <a title="static error" href="#dt-static-error">static error</a>. If analysis of an expression relies on some component of the <a title="static context" href="#dt-static-context">static
context</a> that has not been assigned a value, a <a title="static error" href="#dt-static-error">static error</a> is raised.[<a title="err:XP0001" href="#ERRXP0001">err:XP0001</a>]</p>
<p>The individual components of the <a title="static context" href="#dt-static-context">static context</a> are summarized below. Further rules governing the semantics of these components can be found in <a href="#id-xp-static-context-components"><b>C.1 Static Context Components</b></a>.</p>
<ul>
<li>
<p>[<a title="XPath 1.0 compatibility mode" id="dt-xpath-compat-mode" name="dt-xpath-compat-mode">Definition</a>: <b>XPath 1.0 compatibility mode.</b> <span class="xpath"><span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</span></span>]</p>
</li>
<li>
<p>[<a title="statically known namespaces" id="dt-static-namespaces" name="dt-static-namespaces">Definition</a>: <b>Statically known namespaces.</b> This is a set of (prefix, URI) pairs that define all the namespaces that are known during static processing of a given expression.] Note the difference between <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression.</p>
</li>
<li>
<p>[<a title="default element/type namespace" id="dt-def-elemtype-ns" name="dt-def-elemtype-ns">Definition</a>: <b>Default element/type namespace.</b> This is a namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where an element or type name is expected.] The initial default element/type namespace may be provided by the external environment.</p>
</li>
<li>
<p>[<a title="default function namespace" id="dt-def-fn-ns" name="dt-def-fn-ns">Definition</a>: <b>Default function namespace.</b> This is a namespace URI that is used for any unprefixed QName appearing as the function name in a function call. The initial default function namespace may be provided by the external environment.]</p>
</li>
<li>
<p>[<a title="in-scope schema definitions" id="dt-issd" name="dt-issd">Definition</a>: <b>In-scope schema definitions.</b> This is a generic term for all the element, attribute, and type definitions that are in scope during processing of an expression.] It includes the following three parts:</p>
<ul>
<li>
<p>[<a title="in-scope type definitions" id="dt-is-types" name="dt-is-types">Definition</a>: <b>In-scope type definitions.</b> Each named type definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope type definitions include the predefined types described in
<a href="#id-predefined-types"><b>2.4.1 Predefined Types</b></a>. ]</p>
</li>
<li>
<p>[<a title="in-scope element declarations" id="dt-is-elems" name="dt-is-elems">Definition</a>: <b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). ] An element declaration includes information about
the element's <a title="substitution group" href="#dt-substitution-group">substitution group</a> affiliation.</p>
<p>[<a title="substitution group" id="dt-substitution-group" name="dt-substitution-group">Definition</a>: <b>Substitution groups</b> are defined in <a href="#XMLSchema">[XML Schema]</a> Part 1, Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.]</p>
</li>
<li>
<p>[<a title="in-scope attribute declarations" id="dt-is-attrs" name="dt-is-attrs">Definition</a>: <b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration). ]</p>
</li>
</ul>
</li>
<li>
<p>[<a title="in-scope variables" id="dt-in-scope-variables" name="dt-in-scope-variables">Definition</a>: <b>In-scope variables.</b> This is a set of (expanded QName, type) pairs. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" href="#dt-static-type">static type</a> of the variable.]</p>
<p>An expression that binds a variable (such as a <code>for</code>, <code>some</code>, or <code>every</code> expression) extends the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of its subexpressions with the new bound variable and its type.</p>
</li>
<li>
<p><b>Context item static type.</b> This component defines the static type of the context item within the scope of a given expression.</p>
</li>
<li>
<p>[<a title="function signature" id="dt-function-signature" name="dt-function-signature">Definition</a>: <b>Function signatures.</b> This component defines the set of functions that are available to be called from within an expression. Each function is uniquely identified by its <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and its arity (number of parameters).] In addition to the name and arity, each function signature specifies the <a title="static type" href=
"#dt-static-type">static types</a> of the function parameters and result.</p>
<p>The <a title="function signature" href="#dt-function-signature">function signatures</a> include the signatures of constructor functions, which are discussed in <a href="#id-constructor-functions"><b>3.10.4 Constructor Functions</b></a>.</p>
</li>
<li>
<p>[<a title="statically known collations" id="dt-static-collations" name="dt-static-collations">Definition</a>: <b>Statically known collations.</b> This is a set of (URI, collation) pairs. It defines the names of the collations that are available for use in function calls that take a collation name as an argument.] A collation may be regarded as an object that supports two functions: a function that given a set of strings, returns a sequence containing those strings in sorted order; and a function that
given two strings, returns true if they are considered equal, and false if not.</p>
</li>
<li>
<p>[<a title="default collation" id="dt-def-collation" name="dt-def-collation">Definition</a>: <b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the collation to be used by string comparison functions and operators when no explicit collation is specified.]</p>
</li>
<li>
<p>[<a title="base URI" id="dt-base-uri" name="dt-base-uri">Definition</a>: <b>Base URI.</b> This is an absolute URI, used when necessary in the resolution of relative URIs (for example, by the <code>fn:resolve-uri</code> function.)]</p>
</li>
<li>
<p>[<a title="statically known documents" id="dt-known-docs" name="dt-known-docs">Definition</a>: <b>Statically known documents.</b> This is a mapping from strings onto types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:doc</code> function. The type is the static type of a call to <code>fn:doc</code> with the given URI as its literal argument. ] If the argument to <code>fn:doc</code> is not a string literal that is present in statically known
documents, then the <a title="static type" href="#dt-static-type">static type</a> of <code>fn:doc</code> is <code>document-node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known documents</b> is to provide static type information, not to determine which documents are available. A URI need not be found in the <b>statically known documents</b> to be accessed using <code>fn:doc</code>.</p>
</div>
</li>
<li>
<p>[<a title="statically known collections" id="dt-known-collections" name="dt-known-collections">Definition</a>: <b>Statically known collections.</b> This is a mapping from strings onto types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:collection</code> function. The type is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with this URI as its argument.] If the argument to
<code>fn:collection</code> is not a string literal that is present in statically known collections, then the <a title="static type" href="#dt-static-type">static type</a> of <code>fn:collection</code> is <code>node()*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known collections</b> is to provide static type information, not to determine which collections are available. A URI need not be found in the <b>statically known collections</b> to be accessed using <code>fn:collection</code>.</p>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="eval_context" name="eval_context"></a>2.1.2 Dynamic Context</h4>
<p>[<a title="dynamic context" id="dt-dynamic-context" name="dt-dynamic-context">Definition</a>: The <b>dynamic context</b> of an expression is defined as information that is available at the time the expression is evaluated.] If evaluation of an expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that has not been assigned a value, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0002" href=
"#ERRXP0002">err:XP0002</a>]</p>
<p>The individual components of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> are summarized below. Further rules governing the semantics of these components can be found in <a href="#id-xp-evaluation-context-components"><b>C.2 Dynamic Context Components</b></a>.</p>
<p>The <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> consists of all the components of the <a title="static context" href="#dt-static-context">static context</a>, and the additional components listed below.</p>
<p>[<a title="focus" id="dt-focus" name="dt-focus">Definition</a>: The first three components of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (context item, context position, and context size) are called the <b>focus</b> of the expression. ] The focus enables the processor to keep track of which nodes are being processed by the expression.</p>
<p>Certain language constructs, notably the path expression <code>E1/E2</code> and the filter expression <code>E1[E2]</code>, create a new focus for the evaluation of a sub-expression. In these constructs, <code>E2</code> is evaluated once for each item in the sequence that results from evaluating <code>E1</code>. Each time <code>E2</code> is evaluated, it is evaluated with a different focus. The focus for evaluating <code>E2</code> is referred to below as the <b>inner focus</b>, while the focus for
evaluating <code>E1</code> is referred to as the <b>outer focus</b>. The inner focus exists only while <code>E2</code> is being evaluated. When this evaluation is complete, evaluation of the containing expression continues with its original focus unchanged.</p>
<ul>
<li>
<p>[<a title="context item" id="dt-context-item" name="dt-context-item">Definition</a>: The <b>context item</b> is the item currently being processed. An item is either an atomic value or a node.][<a title="context node" id="dt-context-node" name="dt-context-node">Definition</a>: When the context item is a node, it can also be referred to as the <b>context node</b>.] The context item is returned by the expression "<code>.</code>". When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated,
each item in the sequence obtained by evaluating <code>E1</code> becomes the context item in the inner focus for an evaluation of <code>E2</code>.</p>
</li>
<li>
<p>[<a title="context position" id="dt-context-position" name="dt-context-position">Definition</a>: The <b>context position</b> is the position of the context item within the sequence of items currently being processed.] It changes whenever the context item changes. Its value is always an integer greater than zero. The context position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in the inner focus
for an evaluation of <code>E2</code> is the position of the context item in the sequence obtained by evaluating <code>E1</code>. The position of the first item in a sequence is always 1 (one). The context position is always less than or equal to the context size.</p>
</li>
<li>
<p>[<a title="context size" id="dt-context-size" name="dt-context-size">Definition</a>: The <b>context size</b> is the number of items in the sequence of items currently being processed.] Its value is always an integer greater than zero. The context size is returned by the expression <code>fn:last()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the inner focus for an evaluation of <code>E2</code> is the number of items in the sequence obtained by
evaluating <code>E1</code>.</p>
</li>
<li>
<p>[<a title="variable values" id="dt-variable-values" name="dt-variable-values">Definition</a>: <b>Variable values</b>. This is a set of (expanded QName, value) pairs. It contains the same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" href="#dt-static-context">static context</a> for the expression. The QName is the name of the variable and the value is the
dynamic value of the variable.]</p>
</li>
<li>
<p>[<a title="function implementation" id="dt-function-implementation" name="dt-function-implementation">Definition</a>: <b>Function implementations</b>. Each function in <a title="function signature" href="#dt-function-signature">function signatures</a> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type. ]</p>
</li>
<li>
<p>[<a title="current date and time" id="dt-date-time" name="dt-date-time">Definition</a>: <b>Current date and time.</b> This information represents an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during processing of a query or transformation. It can be retrieved by the <code>fn:current-date</code>, <code>fn:current-time</code>, and <code>fn:current-dateTime</code> functions. If invoked multiple times during the execution of a query or
transformation, these functions always return the same result.]</p>
</li>
<li>
<p>[<a title="implicit timezone" id="dt-timezone" name="dt-timezone">Definition</a>: <b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or in any other operation. This value is an instance of <code>xdt:dayTimeDuration</code> that is <span class="xpath"><span class="xpath">determined by the host language</span></span>. See <a href="#ISO8601">[ISO 8601]</a> for the range of legal values of a timezone.]</p>
</li>
<li>
<p>[<a title="available documents" id="dt-available-docs" name="dt-available-docs">Definition</a>: <b>Available documents.</b> This is a mapping of strings onto document nodes. The string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.] The set of available documents is not
constrained by the set of <a title="statically known documents" href="#dt-known-docs">statically known documents</a>, and it may be empty.</p>
</li>
<li>
<p>[<a title="available collections" id="dt-available-collections" name="dt-available-collections">Definition</a>: <b>Available collections.</b> This is a mapping of strings onto sequences of nodes. The string represents the absolute URI of a resource. The sequence of nodes represents the result of the <code>fn:collection</code> function when that URI is supplied as the argument. ] The set of available collections is not constrained by the set of <a title="statically known collections" href=
"#dt-known-collections">statically known collections</a>, and it may be empty.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-processing-model" name="id-processing-model"></a>2.2 Processing Model</h3>
<p>XPath is defined in terms of the <a title="data model" href="#dt-datamodel">data model</a> and in terms of the <a title="expression context" href="#dt-expression-context">expression context</a>.</p>
<img src="ProcMod-XPath.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>Figure 1 provides a schematic overview of the processing steps that are discussed in detail below. Some of these steps are completely outside the domain of XPath; in Figure 1, these are depicted outside the line that represents the boundaries of the language, an area labeled the <b>external processing domain</b>. The external processing domain includes generation of the <a title="data model" href="#dt-datamodel">data model</a> (see <a href="#id-data-model-generation"><b>2.2.1 Data Model
Generation</b></a>), schema import processing (see <a href="#id-schema-import-processing"><b>2.2.2 Schema Import Processing</b></a>) and serialization (see <a href="#id-serialization"><b>2.2.4 Serialization</b></a>). The area inside the boundaries of the language is known as the <span class="xpath"><span class="xpath"><b>XPath processing domain</b></span></span>, which includes the static analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>). Consistency constraints on the <span class="xpath"><span class="xpath">XPath</span></span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p>
<div class="div3">
<h4><a id="id-data-model-generation" name="id-data-model-generation"></a>2.2.1 Data Model Generation</h4>
<p>Before an expression can be processed, the input documents to be accessed by the expression must be represented in the <a title="data model" href="#dt-datamodel">data model</a>. This process occurs outside the domain of XPath, which is why Figure 1 represents it in the external processing domain. Here are some steps by which an XML document might be converted to the <a title="data model" href="#dt-datamodel">data model</a>:</p>
<ol class="enumar">
<li>
<p>A document may be parsed using an XML parser that generates an <b>XML Information Set</b> (see <a href="#XINFO">[XML Infoset]</a>). The parsed document may then be validated against one or more schemas. This process, which is described in <a href="#XMLSchema">[XML Schema]</a>, results in an abstract information structure called the <b>Post-Schema Validation Infoset</b> (PSVI). If a document has no associated schema, its Information Set is preserved. (See DM1 in Fig. 1.)</p>
</li>
<li>
<p>The Information Set or PSVI may be transformed into the <a title="data model" href="#dt-datamodel">data model</a> by a process described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. (See DM2 in Fig. 1.)</p>
</li>
</ol>
<p>The above steps provide an example of how a document in the <a title="data model" href="#dt-datamodel">data model</a> might be constructed. A document or fragment might also be synthesized directly from a relational database, or constructed in some other way (see DM3 in Fig. 1.) XPath is defined in terms of operations on the <a title="data model" href="#dt-datamodel">data model</a>, but it does not place any constraints on how documents and instances in the <a title="data model" href=
"#dt-datamodel">data model</a> are constructed.</p>
<p>Each atomic value, element node, and attribute node in the <a title="data model" href="#dt-datamodel">data model</a> is annotated with its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>. The dynamic type specifies a range of values&#8212;for example, an attribute named <code>version</code> might have the dynamic type <code>xs:decimal</code>, indicating that it contains a decimal value. For example, if the <a title="data model" href="#dt-datamodel">data model</a> was derived from an
input XML document, the dynamic types of the elements and attributes are derived from schema validation.</p>
<p>The value of an attribute is represented directly within the attribute node. An attribute node whose type is unknown (such as might occur in a schemaless document) is annotated with the dynamic type <code>xdt:untypedAtomic</code>.</p>
<p>The value of an element is represented by the children of the element node, which may include text nodes and other element nodes. The dynamic type of an element node indicates how the values in its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated with the type <code>xdt:untyped</code>. An element that has been validated and found to be partially valid is annotated with the type <code>xs:anyType</code>. If an
element node is annotated <code>xdt:untyped</code>, all its descendant element nodes are also annotated <code>xdt:untyped</code>. However, if an element node is annotated <code>xs:anyType</code>, some of its descendant element nodes may have a more specific type annotation.</p>
<p>An atomic value of unknown type is annotated with the type <code>xdt:untypedAtomic</code>.</p>
</div>
<div class="div3">
<h4><a id="id-schema-import-processing" name="id-schema-import-processing"></a>2.2.2 Schema Import Processing</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> in the <a title="static context" href="#dt-static-context">static context</a> are provided by the host language (see step SI1 in Figure 1) and must satisfy the consistency constraints defined in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-expression-processing" name="id-expression-processing"></a>2.2.3 Expression Processing</h4>
<p>XPath defines two phases of processing called the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a> and the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1). An implementation is free to use any strategy or algorithm whose result conforms to these specifications.</p>
<div class="div4">
<h5><a id="id-static-analysis" name="id-static-analysis"></a>2.2.3.1 Static Analysis Phase</h5>
<p>[<a title="static analysis phase" id="dt-static-analysis" name="dt-static-analysis">Definition</a>: The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).]</p>
<p>During the static analysis phase, the <span class="xpath"><span class="xpath">XPath expression</span></span> is parsed into an internal representation called the <b>operation tree</b> (step SQ1 in Figure 1). A parse error is raised as a <a title="static error" href="#dt-static-error">static error</a>.[<a title="err:XP0003" href="#ERRXP0003">err:XP0003</a>] The <a title="static context" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2). The <a title=
"static context" href="#dt-static-context">static context</a> is used to resolve type names, function names, namespace prefixes and variable names (step SQ4). If a name in the <b>operation tree</b> is not found in the <a title="static context" href="#dt-static-context">static context</a>, a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>] is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>2.4.4.3 Element
Test</b></a> and <a href="#id-attribute-test"><b>2.4.4.5 Attribute Test</b></a>.</p>
<p>The <b>operation tree</b> is then <b>normalized</b> by making explicit the implicit operations such as <a title="atomization" href="#dt-atomization">atomization</a>, <a title="type promotion" href="#dt-type-promotion">type promotion</a>, and extraction of <a title="effective boolean value" href="#dt-ebv">Effective Boolean Values</a> (step SQ5). The normalization process is described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
<p>If the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is supported, each expression is assigned a <a title="static type" href="#dt-static-type">static type</a> (step SQ6). [<a title="static type" id="dt-static-type" name="dt-static-type">Definition</a>: The <b>static type</b> of an expression may be either a named type or a structural description&#8212;for example, <code>xs:boolean?</code> denotes an optional occurrence of the <code>xs:boolean</code> type.
The rules for inferring the <a title="static type" href="#dt-static-type">static types</a> of various expressions are described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.] In some cases, the <a title="static type" href="#dt-static-type">static type</a> is derived from the lexical form of the expression; for example, the <a title="static type" href="#dt-static-type">static type</a> of the literal <code>5</code> is <code>xs:integer</code>. In other cases, the
<a title="static type" href="#dt-static-type">static type</a> of an expression is inferred according to rules based on the static types of its operands; for example, the <a title="static type" href="#dt-static-type">static type</a> of the expression <code>5 + 1.2</code> is <code>xs:decimal</code>.</p>
<p>During the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, if the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect and an operand of an expression is found to have a <a title="static type" href="#dt-static-type">static type</a> that is not appropriate for that operand, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>] If static type
checking raises no errors and assigns a <a title="static type" href="#dt-static-type">static type</a> T to an expression, then execution of the expression on valid input data is guaranteed either to produce a value of type T or to raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>During the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, if the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect and the <a title="static type" href="#dt-static-type">static type</a> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty()</code>, a <a title="static error" href="#dt-static-error">static error</a> is raised.[<a title="err:XP0005" href=
"#ERRXP0005">err:XP0005</a>] This catches cases in which a query refers to an element or attribute that is not present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, possibly because of a spelling error.</p>
<p>The purpose of type-checking during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a> is to provide early detection of <a title="type error" href="#dt-type-error">type errors</a> and to infer type information that may be useful in optimizing the evaluation of an expression.</p>
</div>
<div class="div4">
<h5><a id="id-dynamic-evaluation" name="id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase</h5>
<p>[<a title="dynamic evaluation phase" id="dt-dynamic-evaluation" name="dt-dynamic-evaluation">Definition</a>: The <b>dynamic evaluation phase</b> occurs after completion of the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. During the dynamic evaluation phase, the value of the <span class="xpath"><span class="xpath">expression</span></span> is computed.]</p>
<p>The dynamic evaluation phase can occur only if no errors were detected during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. If the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, all <a title="type error" href="#dt-type-error">type errors</a> are detected during static analysis and serve to inhibit the dynamic evaluation phase. If the <a title="Static Typing Feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is not in effect, an implementation is allowed to raise type-related warnings during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. It may then proceed with the dynamic evaluation phase; in this case, <a title="type error" href="#dt-type-error">type errors</a> must be detected and raised during dynamic evaluation.</p>
<p>The dynamic evaluation phase depends on the <b>operation tree</b> of the expression being evaluated (step DQ1), on the input data (step DQ4), and on the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn draws information from the external environment (step DQ3) and the <a title="static context" href="#dt-static-context">static context</a> (step DQ2). Execution of the evaluation phase may create new data-model values (step DQ4) and it may extend the
<a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5)&#8212;for example, by binding values to variables.</p>
<p>[<a title="dynamic type" id="dt-dynamic-type" name="dt-dynamic-type">Definition</a>: A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may be either a structural description (such as "sequence of integers") or a named type.] The dynamic type of a value may be more specific than the <a title="static type" href="#dt-static-type">static type</a> of the expression that computed it (for example, the <a title="static type" href="#dt-static-type">static type</a>
of an expression might be "zero or more integers or strings," but at evaluation time its value may have the dynamic type "integer.")</p>
<p>If an operand of an expression is found to have a <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not appropriate for that operand, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
<p>Even though static typing can catch many <a title="type error" href="#dt-type-error">type errors</a> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
will result. Similarly, an expression may apply an arithmetic operator to a value whose <a title="static type" href="#dt-static-type">static type</a> is <code>xdt:untypedAtomic</code>. This is not a <a title="static error" href="#dt-static-error">static error</a>, but at run time, if the value cannot be successfully cast to a numeric type, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> will be raised.</p>
<p>When the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, it is also possible for static analysis of an expression to raise a <a title="type error" href="#dt-type-error">type error</a>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <a title="static type" href=
"#dt-static-type">static type</a> of the function parameter to be an optional element. This case is treated as a <a title="type error" href="#dt-type-error">type error</a> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-serialization" name="id-serialization"></a>2.2.4 Serialization</h4>
<p>[<a title="serialization" id="dt-serialization" name="dt-serialization">Definition</a>: <b>Serialization</b> is the process of converting a sequence of nodes and atomic values from the <a title="data model" href="#dt-datamodel">data model</a> into a sequence of octets (step DM4 in Figure 1.) ] The general framework for serialization of the <a title="data model" href="#dt-datamodel">data model</a> is described in <a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>.</p>
<div class="xpath">
<p class="xpath">The host language may provide a serialization option based on this framework.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-consistency-constraints" name="id-consistency-constraints"></a>2.2.5 Consistency Constraints</h4>
<p>In order for XPath to be well defined, the <a title="data model" href="#dt-datamodel">data model</a>, the <a title="static context" href="#dt-static-context">static context</a>, and the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> must be mutually consistent. The consistency constraints listed below are prerequisites for correct functioning of an XPath implementation. Enforcement of these consistency constraints is beyond the scope of this specification. This specification
does not define the result of <span class="xpath"><span class="xpath">an expression</span></span> under any condition in which one or more of these constraints is not satisfied.</p>
<p>Some of the consistency constraints use the term <b>data model schema</b>. [<a title="data model schema" id="dt-data-model-schema" name="dt-data-model-schema">Definition</a>: For a given node in the <a title="data model" href="#dt-datamodel">data model</a>, the <b>data model schema</b> is defined as the schema from which the type annotation of that node was derived.] For a node that was constructed by some process other than schema validation, the <b>data model schema</b> consists simply of the type
definition that is represented by the type annotation of the node.</p>
<ul>
<li>
<p>For every data model node that has a type annotation, if that type annotation is found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be the same as its definition in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a>. Furthermore, all types that are derived by extension from the given type in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a> must
also be known by equivalent definitions in the ISSD.</p>
</li>
<li>
<p>For every element name <em>EN</em> that is found both in a data model node and in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD), all elements that are known in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a> to be in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <em>EN</em> must also be known in the ISSD to be in the <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> headed by <em>EN</em>.</p>
</li>
<li>
<p>Every item type (i.e., every element, attribute, or type name) referenced in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> or <a title="function signature" href="#dt-function-signature">function signatures</a> must be in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>.</p>
</li>
<li>
<p>For each mapping of a string to a document node in <a title="available documents" href="#dt-available-docs">available documents</a>, if there exists a mapping of the same string to a document type in <a title="statically known documents" href="#dt-known-docs">statically known documents</a>, the document node must match the document type, using the matching rules in <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each mapping of a string to a sequence of nodes in <a title="available collections" href="#dt-available-collections">available collections</a>, if there exists a mapping of the same string to a type in <a title="statically known collections" href="#dt-known-collections">statically known collections</a>, the sequence of nodes must match the type, using the matching rules in <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each (variable, type) pair in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> and the corresponding (variable, value) pair in <a title="variable values" href="#dt-variable-values">variable values</a> such that the variable names are equal, the value must match the type, using the matching rules in <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-important-concepts" name="id-important-concepts"></a>2.3 Documents</h3>
<p>XPath is generally used to process <b>documents</b>. The representation of a document is normatively defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The functions used to access documents and collections are normatively defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. Because documents are centrally important in XPath processing, we provide a summary of some key concepts here.</p>
<div class="div3">
<h4><a id="N1081F" name="N1081F"></a>2.3.1 Document Order</h4>
<p>An ordering called <b>document order</b> is defined among all the nodes used during a given query or transformation, which may consist of one or more <b>trees</b> (documents or fragments). Document order is defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, and its definition is repeated here for convenience. [<a title="reverse document order" id="dt-reverse-document-order" name="dt-reverse-document-order">Definition</a>: The node ordering that is the reverse of document order is
called <b>reverse document order</b>.]</p>
<p>Document order is a total ordering, although the relative order of some nodes is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>. [<a title="document order" id="dt-document-order" name="dt-document-order">Definition</a>: Informally, <b>document order</b> is the order defined by a pre-order, depth-first traversal of the nodes in the data model.] Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the
processing of a given query or transformation, even if this order is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>Within a tree, document order satisfies the following constraints:</p>
<ol class="enumar">
<li>
<p>The root node is the first node.</p>
</li>
<li>
<p>The relative order of siblings is determined by their order in the XML representation of the tree. A node N1 occurs before a node N2 in document order if and only if the start of N1 occurs before the start of N2 in the XML representation.</p>
</li>
<li class="xpath">
<p>Namespace nodes immediately follow the element node with which they are associated. The relative order of namespace nodes is stable but <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Attribute nodes immediately follow the <span class="xpath"><span class="xpath">namespace nodes of the</span></span> element node with which they are associated. The relative order of attribute nodes is stable but <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Element nodes occur before their children; children occur before following-siblings.</p>
</li>
</ol>
<p>The relative order of nodes in distinct trees is stable but <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>, subject to the following constraint: If any node in tree T1 is before any node in tree T2, then all nodes in tree T1 are before all nodes in tree T2.</p>
</div>
<div class="div3">
<h4><a id="id-atomization" name="id-atomization"></a>2.3.2 Atomization</h4>
<p>The semantics of some XPath operators depend on a process called <a title="atomization" href="#dt-atomization">atomization</a>. [<a title="atomization" id="dt-atomization" name="dt-atomization">Definition</a>: <b>Atomization</b> is applied to a value when the value is used in a context in which a sequence of atomic values is required. The result of atomization is either a sequence of atomic values or a <a title="type error" href="#dt-type-error">type error</a>. Atomization of a sequence is defined as
the result of invoking the <code>fn:data</code> function on the sequence, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.]</p>
<p>The semantics of <code>fn:data</code> are repeated here for convenience. The result of <code>fn:data</code> is the sequence of atomic values produced by applying the following rules to each item in the input sequence:</p>
<ul>
<li>
<p>If the item is an atomic value, it is returned.</p>
</li>
<li>
<p>If the item is a node, its typed value is returned.</p>
</li>
</ul>
<p>Atomization is used in processing the following types of expressions:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Comparison expressions</p>
</li>
<li>
<p>Function calls and returns</p>
</li>
<li>
<p>Cast expressions</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-ebv" name="id-ebv"></a>2.3.3 Effective Boolean Value</h4>
<p>Under certain circumstances (listed below), it is necessary to find the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a value. [<a title="effective boolean value" id="dt-ebv" name="dt-ebv">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.]</p>
<p>The semantics of <code>fn:boolean</code> are repeated here for convenience. <code>fn:boolean</code> returns <code>false</code> if its operand is any of the following:</p>
<ul>
<li>
<p>An empty sequence</p>
</li>
<li>
<p>The boolean value <code>false</code></p>
</li>
<li>
<p>A zero-length value of type <code>xs:string</code> or <code>xdt:untypedAtomic</code></p>
</li>
<li>
<p>A numeric value that is equal to zero</p>
</li>
<li>
<p>The <code>xs:double</code> or <code>xs:float</code> value <code>NaN</code></p>
</li>
</ul>
<p>Otherwise, <code>fn:boolean</code> returns <code>true</code>.</p>
<p>The <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during processing of the following types of expressions:</p>
<ul>
<li>
<p>Logical expressions (<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p>The <code>fn:not</code> function</p>
</li>
<li>
<p>Certain types of predicates, such as <code>a[b]</code></p>
</li>
<li>
<p>Conditional expressions (<code>if</code>)</p>
</li>
<li>
<p>Quantified expressions (<code>some</code>, <code>every</code>)</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note that the definition of <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> is not used when casting a value to the type <code>xs:boolean</code>.</p>
</div>
</div>
<div class="div3">
<h4><a id="id-input-sources" name="id-input-sources"></a>2.3.4 Input Sources</h4>
<p>XPath has a set of functions that provide access to input data. These functions are of particular importance because they provide a way in which an expression can reference a document or a collection of documents. The input functions are described informally here; they are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
<p>An expression can access input data either by calling one of the input functions or by referencing some part of the expression context that is initialized by the external environment, such as a <b>variable</b> or a <a title="context item" href="#dt-context-item">context item</a>.</p>
<p>The input functions supported by XPath are as follows:</p>
<ul>
<li>
<p>The <code>fn:doc</code> function takes a string containing a URI that refers to an XML document, and returns a document node whose content is the <a title="data model" href="#dt-datamodel">data model</a> representation of the given document.</p>
</li>
<li>
<p>The <code>fn:collection</code> function takes a string containing a URI, and returns the data model representation of the collection identified by the URI. A collection may be any sequence of nodes. For example, the expression <code>fn:collection("http://example.org")//customer</code> identifies all the <code>customer</code> elements that are descendants of nodes found in the collection whose URI is <code>http://example.org</code>.</p>
</li>
</ul>
<p>If a given input function is invoked repeatedly with arguments that resolve to the same absolute URI during the scope of a single query or transformation, each invocation returns the same result.</p>
</div>
</div>
<div class="div2">
<h3><a id="id-types" name="id-types"></a>2.4 Types</h3>
<p>XPath is a strongly typed language with a type system based on <a href="#XMLSchema">[XML Schema]</a>. The XPath type system is formally defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
<div class="div3">
<h4><a id="id-predefined-types" name="id-predefined-types"></a>2.4.1 Predefined Types</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope type definitions" href="#dt-is-types">in-scope type definitions</a> in the <a title="static context" href="#dt-static-context">static context</a> are initialized with a set of predefined types that is determined by the host language. This set may include some or all of the types defined by <a href="#XMLSchema">[XML Schema]</a> in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, represented in this document by the namespace prefix <code>xs</code>. It may
also include the types defined in the namespace <code>http://www.w3.org/2004/07/xpath-datatypes</code>, represented in this document by the namespace prefix <code>xdt</code>. The types in this namespace are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> and are summarized below.</p>
</div>
<ol class="enumar">
<li>
<p>[<a title="xdt:untyped" id="dt-untyped" name="dt-untyped">Definition</a>: <code>xdt:untyped</code> is used to denote the dynamic type of an element node that has not been validated, or has been validated in <code>skip</code> mode.] It has no subtypes.</p>
</li>
<li>
<p>[<a title="xdt:untypedAtomic" id="dt-untypedAtomic" name="dt-untypedAtomic">Definition</a>: <code>xdt:untypedAtomic</code> is used to denote untyped atomic data, such as text that has not been assigned a more specific type.] It has no subtypes. An attribute that has been validated in <code>skip</code> mode, or that has a PSVI property of <code>xs:anySimpleType</code>, is represented in the Data Model by an attribute node with the type <code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p>[<a title="xdt:dayTimeDuration" id="dt-dayTimeDuration" name="dt-dayTimeDuration">Definition</a>: <code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code> whose lexical representation is restricted to contain only day, hour, minute, and second components.]</p>
</li>
<li>
<p>[<a title="xdt:yearMonthDuration" id="dt-yearMonthDuration" name="dt-yearMonthDuration">Definition</a>: <code>xdt:yearMonthDuration</code> is a subtype of <code>xs:duration</code> whose lexical representation is restricted to contain only year and month components.]</p>
</li>
<li>
<p>[<a title="xdt:anyAtomicType" id="dt-anyAtomicType" name="dt-anyAtomicType">Definition</a>: <code>xdt:anyAtomicType</code> includes all atomic values (and no values that are not atomic).] It is a subtype of <code>xs:anySimpleType</code>, which is the base type for all simple types, including atomic, list, and union types. All specific atomic types such as <code>xs:integer</code>, <code>xs:string</code>, and <code>xdt:untypedAtomic</code>, are subtypes of <code>xdt:anyAtomicType</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xdt:anyAtomicType</code> will not appear as the type of an actual value in the Data Model.</p>
</div>
</li>
</ol>
<p>The relationships among the types in the <code>xs</code> and <code>xdt</code> namespaces are illustrated in Figure 2. A more complete description of the XPath type hierarchy can be found in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>Figure 2: Summary of XPath Type Hierarchy</p>
</div>
<div class="div3">
<h4><a id="id-typed-value" name="id-typed-value"></a>2.4.2 Typed Value and String Value</h4>
<p>In the <a title="data model" href="#dt-datamodel">data model</a>, every node has a <b>typed value</b> and a <b>string value</b>. The <b>typed value</b> of a node is a sequence of atomic values and can be extracted by applying the <code>fn:data</code> function to the node. The typed value for each kind of node is defined by the <code>dm:typed-value</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The <b>string value</b> of a node is a string and can be extracted by
applying the <code>fn:string</code> function to the node. The string value for each kind of node is defined by the <code>dm:string-value</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. Element and attribute nodes have a <b>type annotation</b>, which represents (in an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> way) the <a title="dynamic type" href="#dt-dynamic-type">dynamic (run-time) type</a> of the node. In the
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, type annotation is defined by the <code>dm:type-name</code> accessor; however, XPath does not provide a way to directly access the type annotation of an element or attribute node.</p>
<p>The relationship between the typed value and the string value for various kinds of nodes is described and illustrated by examples below.</p>
<ol class="enumar">
<li>
<p>For text and document nodes, the typed value of the node is the same as its string value, as an instance of the type <code>xdt:untypedAtomic</code>. (The string value of a document node is formed by concatenating the string values of all its descendant text nodes, in <a title="document order" href="#dt-document-order">document order</a>.)</p>
</li>
<li>
<p>The typed value of a comment<span class="xpath"><span class="xpath">, namespace,</span></span> or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p>
</li>
<li>
<p>The typed value of an attribute node with the type annotation <code>xdt:untypedAtomic</code> is the same as its string value, as an instance of <code>xdt:untypedAtomic</code>. The typed value of an attribute node with any other type annotation is derived from its string value and type annotation using the lexical-to-value-space mapping defined in <a href="#XMLSchema">[XML Schema]</a> Part 2 for the relevant type.</p>
<p>Example: A1 is an attribute having string value <code>"3.14E-2"</code> and type annotation <code>xs:double</code>. The typed value of A1 is the <code>xs:double</code> value whose lexical representation is <code>3.14E-2</code>.</p>
<p>Example: A2 is an attribute with type annotation <code>xs:IDREFS</code>, which is a list datatype derived from the atomic datatype <code>xs:IDREF</code>. Its string value is "<code>bar baz faz</code>". The typed value of A2 is a sequence of three atomic values ("<code>bar</code>", "<code>baz</code>", "<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed value of a node is never treated as an instance of a named list type. Instead, if the type annotation of a node is a list type (such as
<code>xs:IDREFS</code>), its typed value is treated as a sequence of the atomic type from which it is derived (such as <code>xs:IDREF</code>).</p>
</li>
<li>
<p>For an element node, the relationship between typed value and string value depends on the node's type annotation, as follows:</p>
<ol class="enumla">
<li>
<p>If the type annotation is <code>xdt:untyped</code> or denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the node is equal to its string value, as an instance of <code>xdt:untypedAtomic</code>.</p>
<p>Example: E1 is an element node having type annotation <code>xdt:untyped</code> and string value "<code>1999-05-31</code>". The typed value of E1 is "<code>1999-05-31</code>", as an instance of <code>xdt:untypedAtomic</code>.</p>
<p>Example: E2 is an element node with the type annotation <code>formula</code>, which is a complex type with mixed content. The content of E2 consists of the character "<code>H</code>", a child element named <code>subscript</code> with string value "<code>2</code>", and the character "<code>O</code>". The typed value of E2 is "<code>H2O</code>" as an instance of <code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p>If the type annotation denotes a simple type or a complex type with simple content, then the typed value of the node is derived from its string value and its type annotation in a way that is consistent with schema validation.</p>
<p>Example: E3 is an element node with the type annotation <code>cost</code>, which is a complex type that has several attributes and a simple content type of <code>xs:decimal</code>. The string value of E3 is "<code>74.95</code>". The typed value of E3 is <code>74.95</code>, as an instance of <code>xs:decimal</code>.</p>
<p>Example: E4 is an element node with the type annotation <code>hatsizelist</code>, which is a simple type derived from the atomic type <code>hatsize</code>, which in turn is derived from <code>xs:integer</code>. The string value of E4 is "<code>7 8 9</code>". The typed value of E4 is a sequence of three values (<code>7</code>, <code>8</code>, <code>9</code>), each of type <code>hatsize</code>.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with empty content, then the typed value of the node is the empty sequence and its string value is the zero-length string.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with element-only content, then the typed value of the node is undefined. The <code>fn:data</code> function raises a <a title="type error" href="#dt-type-error">type error</a> [<a title="err:XP0007" href="#ERRXP0007">err:XP0007</a>] when applied to such a node.</p>
<p>Example: E5 is an element node with the type annotation <code>weather</code>, which is a complex type whose content type specifies <code>element-only</code>. E5 has two child elements named <code>temperature</code> and <code>precipitation</code>. The typed value of E5 is undefined, and the <code>fn:data</code> function applied to E5 raises an error.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a id="id-sequencetype-syntax" name="id-sequencetype-syntax"></a>2.4.3 SequenceType Syntax</h4>
<p>[<a title="SequenceType" id="dt-sequence-type" name="dt-sequence-type">Definition</a>: When it is necessary to refer to a type in an XPath expression, the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax is used. The name <a href="#doc-xpath-SequenceType">SequenceType</a> suggests that this syntax is used to describe the type of an XPath value, which is always a sequence.]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SequenceType" name="doc-xpath-SequenceType"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ItemType">ItemType</a> <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />
| ("empty" "(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ItemType" name="doc-xpath-ItemType"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a> | <a href="#doc-xpath-KindTest">KindTest</a> | ("item" "(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-OccurrenceIndicator" name="doc-xpath-OccurrenceIndicator"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AtomicType" name="doc-xpath-AtomicType"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-KindTest" name="doc-xpath-KindTest"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xpath-ElementTest">ElementTest</a><br />
| <a href="#doc-xpath-AttributeTest">AttributeTest</a><br />
| <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xpath-PITest">PITest</a><br />
| <a href="#doc-xpath-CommentTest">CommentTest</a><br />
| <a href="#doc-xpath-TextTest">TextTest</a><br />
| <a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DocumentTest" name="doc-xpath-DocumentTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href="#doc-xpath-ElementTest">ElementTest</a> | <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementTest" name="doc-xpath-ElementTest"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href="#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> ("," <a href="#doc-xpath-TypeName">TypeName</a> "?"?)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaElementTest" name="doc-xpath-SchemaElementTest"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href="#doc-xpath-ElementDeclaration">ElementDeclaration</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementDeclaration" name="doc-xpath-ElementDeclaration"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttributeTest" name="doc-xpath-AttributeTest"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href="#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> ("," <a href="#doc-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SchemaAttributeTest" name="doc-xpath-SchemaAttributeTest"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href="#doc-xpath-AttributeDeclaration">AttributeDeclaration</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttributeDeclaration" name="doc-xpath-AttributeDeclaration"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementNameOrWildcard" name="doc-xpath-ElementNameOrWildcard"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ElementName" name="doc-xpath-ElementName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttribNameOrWildcard" name="doc-xpath-AttribNameOrWildcard"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AttributeName" name="doc-xpath-AttributeName"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TypeName" name="doc-xpath-TypeName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PITest" name="doc-xpath-PITest"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href="#prod-xpath-NCName">NCName</a> | <a href="#doc-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CommentTest" name="doc-xpath-CommentTest"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TextTest" name="doc-xpath-TextTest"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AnyKindTest" name="doc-xpath-AnyKindTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p>Here are some examples of <a href="#doc-xpath-SequenceType">SequenceTypes</a> that might be used in XPath expressions:</p>
<ul>
<li>
<p><code>xs:date</code> refers to the built-in atomic Schema type named <code>xs:date</code></p>
</li>
<li>
<p><code>attribute()?</code> refers to an optional attribute</p>
</li>
<li>
<p><code>element()</code> refers to any element</p>
</li>
<li>
<p><code>element(po:shipto, po:address)</code> refers to an element that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p>
</li>
<li>
<p><code>element(*, po:address)</code> refers to an element of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p>
</li>
<li>
<p><code>element(customer)</code> refers to an element named <code>customer</code> of any type</p>
</li>
<li>
<p><code>schema-element(customer)</code> refers to an element named <code>customer</code> whose type annotation matches the type declared for a <code>customer</code> element in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a></p>
</li>
<li>
<p><code>node()*</code> refers to a sequence of zero or more nodes of any type</p>
</li>
<li>
<p><code>item()+</code> refers to a sequence of one or more nodes or atomic values</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-sequencetype-matching" name="id-sequencetype-matching"></a>2.4.4 SequenceType Matching</h4>
<p>[<a title="SequenceType matching" id="dt-sequencetype-matching" name="dt-sequencetype-matching">Definition</a>: During evaluation of an expression, it is sometimes necessary to determine whether a value with a known type "matches" an expected type, expressed in the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax. This process is known as <b>SequenceType matching</b>.] For example, an <code>instance of</code> expression returns <code>true</code> if the actual type of a given value matches a
given type, or <code>false</code> if it does not.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this specification, the word "type", when used without modification, represents a type that can be expressed using the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax. When we refer specifically to XML Schema simple or complex types, appropriate modifiers are used to make this clear.</p>
</div>
<p>QNames appearing in a <a href="#doc-xpath-SequenceType">SequenceType</a> have their prefixes expanded to namespace URIs by means of the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> and the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>. As usual, two QNames are considered to be equal if their local parts are the same and their namespace URI's are the same.</p>
<p>[<a title="subtype substitution" id="dt-subtype-substitution" name="dt-subtype-substitution">Definition</a>: The use of a value whose actual type is derived from the expected type is known as <b>subtype substitution</b>.] Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p>
<p>The rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> compare the actual type of a value with an expected type. These rules are a subset of the formal rules that match a value with an expected type defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, because the Formal Semantics must be able to match a value with any XML Schema type, whereas the rules below only match values against those types expressible by the
<a href="#doc-xpath-SequenceType">SequenceType</a> syntax.</p>
<p>Some of the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> require determining whether a given type name is the same as or derived from an expected type name. The given type name may be "known" (defined in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>), or "unknown" (not defined in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>). An unknown type name might be
encountered, for example, if a source document has been validated using a schema that was not imported into the <a title="static context" href="#dt-static-context">static context</a>. In this case, an implementation is allowed (but is not required) to provide an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism for determining whether the unknown type name is derived from the expected type name. For example, an implementation might maintain a
data dictionary containing information about type hierarchies.</p>
<p>The definition of <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> relies on a pseudo-function named <code>derives-from(</code><em>AT, ET</em><code>)</code>, which takes an an actual simple or complex type name <em>AT</em> and an expected simple or complex type name <em>ET</em>, and either returns a boolean value or raises a type error. [<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>] The
pseudo-function <code>derives-from</code> is defined below and is defined formally in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
<ul>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> returns <code>true</code> if any of the following three conditions is true:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a type name found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and is the same as <em>ET</em> or is derived by restriction or extension from <em>ET</em></p>
</li>
<li>
<p><em>AT</em> is a type name not found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism is able to determine that <em>AT</em> is derived by restriction from <em>ET</em></p>
</li>
<li>
<p>There exists some type name <em>IT</em> such that <code>derives-from(</code><em>IT, ET</em><code>)</code> and <code>derives-from(</code><em>AT, IT</em><code>)</code> are true.</p>
</li>
</ol>
</li>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> returns <code>false</code> if either the first and third or the second and third of the following conditions are true:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a type name found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and is not the same as <em>ET</em>, and is not is derived by restriction or extension from <em>ET</em></p>
</li>
<li>
<p><em>AT</em> is a type name not found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism is able to determine that <em>AT</em> is not derived by restriction from <em>ET</em></p>
</li>
<li>
<p>No type name <em>IT</em> exists such that <code>derives-from(</code><em>IT, ET</em><code>)</code> and <code>derives-from(</code><em>AT, IT</em><code>)</code> are true.</p>
</li>
</ol>
</li>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> raises a <a title="type error" href="#dt-type-error">type error</a> [<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>] if:</p>
<ol class="enumar">
<li>
<p><em>ET</em> is an unknown type, or</p>
</li>
<li>
<p><em>AT</em> is an unknown type, and the implementation is not able to determine whether <em>AT</em> is derived by restriction from <em>ET</em>.</p>
</li>
</ol>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>derives-from</code> pseudo-function cannot be written as a real XQuery function, because types are not valid function parameters.</p>
</div>
<p>The rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> are given below, with examples (the examples are for purposes of illustration, and do not cover all possible cases).</p>
<div class="div4">
<h5><a id="id-matching-value" name="id-matching-value"></a>2.4.4.1 Matching a SequenceType and a Value</h5>
<ul>
<li>
<p>The SequenceType <code>empty()</code> matches a value that is the empty sequence.</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> with no <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xpath-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>2.4.4.2 Matching an ItemType and an Item</b></a>).</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> with an <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xpath-ItemType">ItemType</a> matches each of the items in the value.</p>
</li>
</ul>
<p>An <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in a sequence, as follows:</p>
<ul>
<li>
<p><code>?</code> matches zero or one items</p>
</li>
<li>
<p><code>*</code> matches zero or more items</p>
</li>
<li>
<p><code>+</code> matches one or more items</p>
</li>
</ul>
<p>As a consequence of these rules, any SequenceType whose <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is an empty sequence.</p>
</div>
<div class="div4">
<h5><a id="id-matching-item" name="id-matching-item"></a>2.4.4.2 Matching an ItemType and an Item</h5>
<ul>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> consisting simply of a QName is interpreted as an <a href="#doc-xpath-AtomicType">AtomicType</a>. An AtomicType <em>AtomicType</em> matches an atomic value whose actual type is <em>AT</em> if <code>derives-from(</code><em>AT, AtomicType</em><code>)</code> is <code>true</code>. If a QName that is used as an <a href="#doc-xpath-AtomicType">AtomicType</a> is not defined as an atomic type in the <a title="in-scope type definitions" href="#dt-is-types">in-scope
type definitions</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised. [<a title="err:XP0051" href="#ERRXP0051">err:XP0051</a>]</p>
<p>Example: The <a href="#doc-xpath-AtomicType">AtomicType</a> <code>xs:decimal</code> matches the value <code>12.34</code> (a decimal literal). <code>xs:decimal</code> also matches a value whose type is <code>shoesize</code>, if <code>shoesize</code> is an atomic type derived by restriction from <code>xs:decimal</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names of non-atomic types such as <code>xs:IDREFS</code> are not accepted in this context, but can often be replaced by an atomic type with an occurrence indicator, such as <code>xs:IDREF*</code>.</p>
</div>
</li>
<li>
<p><code>item()</code> matches any single item.</p>
<p>Example: <code>item()</code> matches the atomic value <code>1</code> or the element <code>&lt;a/&gt;</code>.</p>
</li>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>processing-instruction()</code> matches any processing-instruction node.</p>
</li>
<li>
<p><code>processing-instruction(</code><em>N</em><code>)</code> matches any processing-instruction node whose name (called its "PITarget" in XML) is equal to <em>N</em>, where <em>N</em> is an NCName.</p>
<p>Example: <code>processing-instruction(xml-stylesheet)</code> matches any processing instruction whose PITarget is <code>xml-stylesheet</code>.</p>
<p>For backward compatibility with XPath 1.0, the PITarget of a processing instruction may also be expressed as a string literal, as in this example: <code>processing-instruction("xml-stylesheet")</code>.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(</code><em>E</em><code>)</code> matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if <em>E</em> is an <a href="#doc-xpath-ElementTest">ElementTest</a> or <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> that matches the element node (see <a href="#id-element-test"><b>2.4.4.3 Element Test</b></a> and <a href="#id-schema-element-test"><b>2.4.4.4 Schema Element Test</b></a>).</p>
<p>Example: <code>document-node(element(book))</code> matches a document node containing exactly one element node that is matched by the ElementTest <code>element(book)</code>.</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> that is an <a href="#doc-xpath-ElementTest">ElementTest</a>, <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>, <a href="#doc-xpath-AttributeTest">AttributeTest</a>, or <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an element or attribute node as described in the following sections.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a id="id-element-test" name="id-element-test"></a>2.4.4.3 Element Test</h5>
<p>An <a href="#doc-xpath-ElementTest">ElementTest</a> is used to match an element node by its name and/or type. An <a href="#doc-xpath-ElementTest">ElementTest</a> any take any of the following forms. In these forms, <a href="#doc-xpath-ElementName">ElementName</a> and <a href="#doc-xpath-TypeName">TypeName</a> may be any QNames, and need not be present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>. Note that <a title="substitution group" href=
"#dt-substitution-group">substitution groups</a> do not affect the semantics of <a href="#doc-xpath-ElementTest">ElementTest</a>.</p>
<ol class="enumar">
<li>
<p><code>element()</code> and <code>element(*)</code> match any single element node, regardless of its name or type.</p>
</li>
<li>
<p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>)</code> matches any element node whose name is <a href="#doc-xpath-ElementName">ElementName</a>, regardless of its type or <code>nilled</code> property.</p>
<p>Example: <code>element(person)</code> matches any element node whose name is <code>person</code>.</p>
</li>
<li>
<p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>,</code> <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an element node whose name is <a href="#doc-xpath-ElementName">ElementName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p>
<p>Example: <code>element(person, surgeon)</code> matches a non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code>.</p>
</li>
<li>
<p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a>, <a href="#doc-xpath-TypeName">TypeName</a> <code>?)</code> matches an element node whose name is <a href="#doc-xpath-ElementName">ElementName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> is <code>true</code>, where <em>AT</em> is the type of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*,</code> <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an element node regardless of its name, if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p>
<p>Example: <code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code>, regardless of its name.</p>
</li>
<li>
<p><code>element(*,</code> <a href="#doc-xpath-TypeName">TypeName</a> <code>?)</code> matches an element node regardless of its name, if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(*, surgeon?)</code> matches any nilled or non-nilled element node whose type annotation is <code>surgeon</code>, regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a id="id-schema-element-test" name="id-schema-element-test"></a>2.4.4.4 Schema Element Test</h5>
<p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> matches an element node against a corresponding element declaration found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>. It takes the following form:</p>
<p><code>schema-element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>)</code></p>
<p>If the <a href="#doc-xpath-ElementName">ElementName</a> specified in the <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> is not found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised. [<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>]</p>
<p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> matches a candidate element node if all three of the following conditions are satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href="#doc-xpath-ElementName">ElementName</a> or matches the name of an element in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by an element named <a href="#doc-xpath-ElementName">ElementName</a>.</p>
</li>
<li>
<p><code>derives-from(</code><em>AT, ET</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type of the candidate node and <em>ET</em> is the type declared for element <a href="#doc-xpath-ElementName">ElementName</a> in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.</p>
</li>
<li>
<p>Either the <code>nilled</code> property of the candidate node is <code>false</code>, or the element declaration for <a href="#doc-xpath-ElementName">ElementName</a> in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a> is <code>nillable</code>.</p>
</li>
</ol>
<p>Example: The <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> <code>schema-element(customer)</code> matches a candidate element node if <code>customer</code> is a top-level element declaration in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, the name of the candidate node is <code>customer</code> or is in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <code>customer</code>, the type of the
candidate node is the same as or derived from the type declared for the <code>customer</code> element, and either the candidate node is not <code>nilled</code> or <code>customer</code> is declared to be <code>nillable</code>.</p>
</div>
<div class="div4">
<h5><a id="id-attribute-test" name="id-attribute-test"></a>2.4.4.5 Attribute Test</h5>
<p>An <a href="#doc-xpath-AttributeTest">AttributeTest</a> is used to match an attribute node by its name and/or type. An <a href="#doc-xpath-AttributeTest">AttributeTest</a> any take any of the following forms. In these forms, <a href="#doc-xpath-AttributeName">AttributeName</a> and <a href="#doc-xpath-TypeName">TypeName</a> may be any QNames, and need not be present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>.</p>
<ol class="enumar">
<li>
<p><code>attribute()</code> and <code>attribute(*)</code> match any single attribute node, regardless of its name or type.</p>
</li>
<li>
<p><code>attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a><code>)</code> matches any attribute node whose name is <a href="#doc-xpath-AttributeName">AttributeName</a>, regardless of its type or <code>nilled</code> property.</p>
<p>Example: <code>attribute(price)</code> matches any attribute node whose name is <code>price</code>.</p>
</li>
<li>
<p><code>attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an attribute node whose name is <a href="#doc-xpath-AttributeName">AttributeName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type of the attribute node.</p>
<p>Example: <code>attribute(price, currency)</code> matches an attribute node whose name is <code>price</code> and whose type annotation is <code>currency</code>.</p>
</li>
<li>
<p><code>attribute(*,</code> <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an attribute node regardless of its name, if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> is <code>true</code>, where <em>AT</em> is the type of the attribute node.</p>
<p>Example: <code>attribute(*, currency)</code> matches any attribute node whose type annotation is <code>currency</code>, regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a id="id-schema-attribute-test" name="id-schema-attribute-test"></a>2.4.4.6 Schema Attribute Test</h5>
<p>A <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an attribute node against a corresponding attribute declaration found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>. It takes the following form:</p>
<p><code>schema-attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a><code>)</code></p>
<p>If the <a href="#doc-xpath-AttributeName">AttributeName</a> specified in the <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> is not found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised. [<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>]</p>
<p>A <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches a candidate attribute node if both of the following conditions are satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href="#doc-xpath-AttributeName">AttributeName</a>.</p>
</li>
<li>
<p><code>derives-from(</code><em>AT, ET</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type of the candidate node and <em>ET</em> is the type declared for attribute <a href="#doc-xpath-AttributeName">AttributeName</a> in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>.</p>
</li>
</ol>
<p>Example: The <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> <code>schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, the name of the candidate node is <code>color</code>, and the type of the candidate node is the same as or derived from the type declared for the <code>color</code> attribute.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a id="errors" name="errors"></a>2.5 Error Handling</h3>
<div class="div3">
<h4><a id="id-kinds-of-errors" name="id-kinds-of-errors"></a>2.5.1 Kinds of Errors</h4>
<p>As described in <a href="#id-expression-processing"><b>2.2.3 Expression Processing</b></a>, XPath defines an <a title="static analysis phase" href="#dt-static-analysis">analysis phase</a>, which does not depend on input data, and an <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">evaluation phase</a>, which does depend on input data. Errors may be raised during each phase.</p>
<p>[<a title="static error" id="dt-static-error" name="dt-static-error">Definition</a>: A <b>static error</b> is an error that must be detected during the analysis phase. A syntax error is an example of a <a title="static error" href="#dt-static-error">static error</a>. The means by which <a title="static error" href="#dt-static-error">static errors</a> are reported during the analysis phase is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. ]</p>
<p>[<a title="dynamic error" id="dt-dynamic-error" name="dt-dynamic-error">Definition</a>: A <b>dynamic error</b> is an error that must be detected during the evaluation phase and may be detected during the analysis phase. Numeric overflow is an example of a dynamic error. ]</p>
<p>[<a title="type error" id="dt-type-error" name="dt-type-error">Definition</a>: A <b>type error</b> may be raised during the analysis or evaluation phase. During the analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the evaluation phase, a <a title="type error" href="#dt-type-error">type error</a>
occurs when the dynamic type of a value does not match the expected type of the context in which the value occurs. ]</p>
<p>The outcome of the <a title="static analysis phase" href="#dt-static-analysis">analysis phase</a> is either success or one or more <a title="type error" href="#dt-type-error">type errors</a> and/or <a title="static error" href="#dt-static-error">static errors</a>. The result of the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">evaluation phase</a> is either a result value, a <a title="type error" href="#dt-type-error">type error</a>, or a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
<p>If any expression (at any level) can be evaluated during the analysis phase (because all its explicit operands are known and it has no dependencies on the dynamic context), then any error in performing this evaluation may be reported as a static error. However, the <code>fn:error()</code> function must not be evaluated during the analysis phase. For example, an implementation is allowed (but not required) to treat the following expression as a static error, because it calls a constructor function with a
constant string that is not in the lexical space of the target type:</p>
<div class="exampleInner">
<pre>
xs:date("Next Tuesday")
</pre></div>
<p>If the <a title="Static Typing Feature" href="#dt-static-typing-feature">Static Typing Feature</a> is not in effect but an implementation can nevertheless determine during the analysis phase that an expression will necessarily raise a type error, the implementation may report that error during the analysis phase.</p>
<p>In addition to <a title="static error" href="#dt-static-error">static errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" href="#dt-type-error">type errors</a>, an XPath implementation may raise <b>warnings</b>, either during the analysis phase or the evaluation phase. The circumstances in which warnings are raised, and the ways in which warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>In addition to the errors defined in this specification, an implementation may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if insufficient resources are available for processing a given expression. For example, an implementation may specify limitations on the maximum numbers or sizes of various objects. These limitations, and the consequences of exceeding them, are <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<div class="div3">
<h4><a id="id-handling-dynamic" name="id-handling-dynamic"></a>2.5.2 Handling Dynamic Errors</h4>
<p>Except as noted in this document, if any operand of an expression raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, the expression also raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. If an expression can validly return a value or raise a dynamic error, the implementation may choose to return the value or raise the <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. For example, the logical expression <code>expr1 and expr2</code>
may return the value <code>false</code> if either operand returns <code>false</code>, or may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if either operand raises a dynamic error.</p>
<p>If more than one operand of an expression raises an error, the implementation may choose which error is raised by the expression. For example, in this expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
</div>
<p>both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may raise an error. The implementation may choose which error is raised by the "<code>+</code>" expression. Once one operand raises an error, the implementation is not required, but is permitted, to evaluate any other operands.</p>
<p>[<a title="error value" id="dt-error-value" name="dt-error-value">Definition</a>: A <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> carries an <b>error value</b>, which may be a single item or an empty sequence.] For example, an error value might be an integer, a string, a QName, or an element. An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostics; in the absence of such an error handler, the string
value of the error value may be used directly as an error message.</p>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> may be raised by a built-in function or operator. For example, the <code>div</code> operator raises an error if its second operand equals zero.</p>
<p>An error can be raised explicitly by calling the <code>fn:error</code> function, which only raises an error and never returns a value. This function is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. The <code>fn:error</code> function takes an optional item as its parameter, which is the <a title="error value" href="#dt-error-value">error value</a>. For example, the following function call raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> whose error value is a string:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:error(fn:concat("Unexpected value ", fn:string($v)))
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-errors-and-opt" name="id-errors-and-opt"></a>2.5.3 Errors and Optimization</h4>
<p>Because different implementations may choose to evaluate or optimize an expression in different ways, the detection and reporting of <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>When an implementation is able to evaluate an expression without evaluating some subexpression, the implementation is never required to evaluate that subexpression solely to determine whether it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. For example, if a function parameter is never used in the body of the function, an implementation may choose whether to evaluate the expression bound to that parameter in a function call.</p>
<p>Similarly, in evaluating an expression, an implementation is not required to search for data whose only possible effect on the result would be to raise an error, as illustrated in the following examples.</p>
<ul>
<li>
<p>If an implementation can find (for example, by using an index) that at least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to return <code>true</code> as the result of the <code>some</code> expression, without searching for another item returned by <code>$expr1</code> that would raise an error because it is not an integer.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</div>
</li>
<li>
<p>In the following example, if an implementation can find (for example, by using an index) the <code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the result of the path expression, without searching for another <code>product</code> node that would raise an error because it has an <code>id</code> child whose value is not an integer.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</div>
</li>
</ul>
<p>In some cases, an optimizer may be able to achieve substantial performance improvements by rearranging an expression so that the underlying operations are performed in a different order than that in which they are written. In such cases, errors may be raised that would not have been raised if the expression were evaluated as written. However, an expression must not be rearranged in a way that changes its result value in the absence of errors.</p>
<ul>
<li>
<p>The expression in the following example cannot raise a casting error if it is evaluated exactly as written (i.e., left to right). An implementation is permitted, however, to reorder the predicates to achieve better performance (for example, by taking advantage of an index). This reordering could cause the expression to raise an error.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
</div>
</li>
</ul>
<p>To avoid unexpected errors caused by reordering of expressions, tests that are designed to prevent dynamic errors should be expressed using conditional expressions. Conditional expressions raise only dynamic errors that occur in the branch that is actually selected.</p>
<ul>
<li>
<p>Unlike the previous example, the following example cannot raise a dynamic error if <code>@x</code> is not castable into an <code>xs:date</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-optional-features" name="id-optional-features"></a>2.6 Optional Features</h3>
<div class="xpath">
<p class="xpath">[<a title="Static Typing Feature" id="dt-static-typing-feature" name="dt-static-typing-feature">Definition</a>: XPath 2.0 defines an optional feature called the <b>Static Typing Feature</b>. An implementation that includes this feature is required to detect type errors during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.] If an expression contains one or more static errors or type errors, then a Static Typing implementation must raise at least
one of these errors during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.</p>
</div>
</div>
<div class="div2">
<h3><a id="comments" name="comments"></a>2.7 Comments</h3>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Comment" name="doc-xpath-Comment"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href="#doc-xpath-CommentContents">CommentContents</a> | <a href="#doc-xpath-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CommentContents" name="doc-xpath-CommentContents"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ':)' Char*))</code></td>
</tr>
</tbody>
</table>
<p>Comments may be used to provide informative annotation for <span class="xpath"><span class="xpath">an expression</span></span>. Comments are lexical constructs only, and do not affect <span class="xpath"><span class="xpath">expression</span></span> processing.</p>
<p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p>
<p>A comment may be used anywhere <a title="Ignorable whitespace" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed. See <a href="#lexical-structure"><b>A.2 Lexical structure</b></a> for the exact lexical states where comments are recognized.</p>
<p>The following is an example of a comment:</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a id="id-expressions" name="id-expressions"></a>3 Expressions</h2>
<p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XPath is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p>
<p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions. For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A XPath Grammar</b></a>].</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-XPath" name="doc-xpath-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Expr" name="doc-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ExprSingle" name="doc-xpath-ExprSingle"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a><br />
| <a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xpath-IfExpr">IfExpr</a><br />
| <a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p><span class="xpath"><span class="xpath">The highest-level symbol in the XPath grammar is XPath.</span></span></p>
<p>The XPath operator that has lowest precedence is the comma operator (described in <a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a>), which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<a href="#doc-xpath-Expr">Expr</a>) can consist of two operands (<a href="#doc-xpath-ExprSingle">ExprSingle</a>) separated by a comma. The name <a href="#doc-xpath-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level comma
operator (despite its name, an <a href="#doc-xpath-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)</p>
<p>The symbol <a href="#doc-xpath-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <a href="#doc-xpath-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.</p>
<p>After the comma, the expressions that have next lowest precedence are <span class="xpath"><span class="xpath">ForExpr,</span></span> QuantifiedExpr, IfExpr, and OrExpr. Each of these expressions is described in a separate section of this document.</p>
<div class="div2">
<h3><a id="id-primary-expressions" name="id-primary-expressions"></a>3.1 Primary Expressions</h3>
<p>[<a title="primary expression" id="dt-primary-expression" name="dt-primary-expression">Definition</a>: <b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context item expressions, and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PrimaryExpr" name="doc-xpath-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a> | <a href="#doc-xpath-VarRef">VarRef</a> | <a href="#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#doc-xpath-ContextItemExpr">ContextItemExpr</a> | <a href="#doc-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a id="id-literals" name="id-literals"></a>3.1.1 Literals</h4>
<p>[<a title="literal" id="dt-literal" name="dt-literal">Definition</a>: A <b>literal</b> is a direct syntactic representation of an atomic value.] XPath supports two kinds of literals: numeric literals and string literals.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Literal" name="doc-xpath-Literal"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a> | <a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NumericLiteral" name="doc-xpath-NumericLiteral"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a> | <a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a> | <a href="#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IntegerLiteral" name="doc-xpath-IntegerLiteral"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DecimalLiteral" name="doc-xpath-DecimalLiteral"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href="#doc-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-DoubleLiteral" name="doc-xpath-DoubleLiteral"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href="#doc-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href="#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-StringLiteral" name="doc-xpath-StringLiteral"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (('"' '"') | [^"])* '"') | ("'" (("'" "'") | [^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Digits" name="doc-xpath-Digits"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p>The value of a <b>numeric literal</b> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. Values of numeric literals are
interpreted according to the rules in <a href="#XMLSchema">[XML Schema]</a>.</p>
<p>The value of a <b>string literal</b> is an atomic value whose type is <code>xs:string</code> and whose value is the string denoted by the characters between the delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In an XML document, if a string literal is used in an XPath expression contained within the value of an XML attribute, the characters used to delimit the literal must be different from the characters that are used to delimit the attribute.</p>
</div>
<p>Here are some examples of literal expressions:</p>
<ul>
<li>
<p><code>"12.5"</code> denotes the string containing the characters '1', '2', '.', and '5'.</p>
</li>
<li>
<p><code>12</code> denotes the integer value twelve.</p>
</li>
<li>
<p><code>12.5</code> denotes the decimal value twelve and one half.</p>
</li>
<li>
<p><code>125E2</code> denotes the double value twelve thousand, five hundred.</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p>
</li>
</ul>
<p>The boolean values <code>true</code> and <code>false</code> can be represented by calls to the built-in functions <code>fn:true()</code> and <code>fn:false()</code>, respectively.</p>
<p>Values of other atomic types can be constructed by calling the constructor for the given type. The constructors for XML Schema built-in types are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For example:</p>
<ul>
<li>
<p><code>xs:integer("12")</code> returns the integer value twelve.</p>
</li>
<li>
<p><code>xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p>
</li>
<li>
<p><code>xdt:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xdt:dayTimeDuration</code> and whose value represents a duration of five hours.</p>
</li>
</ul>
<p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p>
<ul>
<li>
<p><code>9 cast as hatsize</code> returns the atomic value <code>9</code> whose type is <code>hatsize</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-variables" name="id-variables"></a>3.1.2 Variable References</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-VarRef" name="doc-xpath-VarRef"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-VarName" name="doc-xpath-VarName"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>variable reference</b> is a QName preceded by a $-sign. Two variable references are equivalent if their local names are the same and their namespace prefixes are bound to the same namespace URI in the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. An unprefixed variable reference is in no namespace.</p>
<p>Every variable reference must match a name in the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>, which include variables from the following sources:</p>
<ol class="enumar">
<li>
<p>A variable may be added to the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> by the host language environment.</p>
</li>
<li>
<p>A variable may be bound by an XPath expression. <span class="xpath"><span class="xpath">The kinds of expressions that can bind variables are <code>for</code> expressions (<a href="#id-for-expressions"><b>3.7 For Expressions</b></a>) and quantified expressions (<a href="#id-quantified-expressions"><b>3.9 Quantified Expressions</b></a>).</span></span></p>
</li>
</ol>
<p>Every variable binding has a static scope. The scope defines where references to the variable can validly occur. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>] to reference a variable that is not in scope. If a variable is bound in the <a title="static context" href="#dt-static-context">static context</a> for an expression, that variable is in scope for the entire expression.</p>
<p>If a variable reference matches two or more variable bindings that are in scope, then the reference is taken as referring to the inner binding, that is, the one whose scope is smaller. At evaluation time, the value of a variable reference is the value of the expression to which the relevant variable is bound. The scope of a variable binding is defined separately for each kind of expression that can bind variables.</p>
</div>
<div class="div3">
<h4><a id="id-paren-expressions" name="id-paren-expressions"></a>3.1.3 Parenthesized Expressions</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ParenthesizedExpr" name="doc-xpath-ParenthesizedExpr"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>Parentheses may be used to enforce a particular evaluation order in expressions that contain multiple operators. For example, the expression <code>(2 + 4) * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher precedence than the addition operator.</p>
<p>Empty parentheses are used to denote an empty sequence, as described in <a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a>.</p>
</div>
<div class="div3">
<h4><a id="id-context-item-expression" name="id-context-item-expression"></a>3.1.4 Context Item Expression</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ContextItemExpr" name="doc-xpath-ContextItemExpr"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p>A <b>context item expression</b> evaluates to the <a title="context item" href="#dt-context-item">context item</a>, which may be either a node (as in the expression <code>fn:doc("bib.xml")//book[fn:count(./author)&gt;1]</code>) or an atomic value (as in the expression <code>(1 to 100)[. mod 5 eq 0]</code>).</p>
<p>If the <a title="context item" href="#dt-context-item">context item</a> is undefined, a context item expression raises a dynamic error.[<a title="err:XP0002" href="#ERRXP0002">err:XP0002</a>]</p>
</div>
<div class="div3">
<h4><a id="id-function-calls" name="id-function-calls"></a>3.1.5 Function Calls</h4>
<p>A <b>function call</b> consists of a QName followed by a parenthesized list of zero or more expressions, called <b>arguments</b>. If the QName in the function call has no namespace prefix, it is considered to be in the <a title="default function namespace" href="#dt-def-fn-ns">default function namespace.</a></p>
<p>If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and number of arguments in a function call do not match the name and arity of a <a title="function signature" href="#dt-function-signature">function signature</a> in the <a title="static context" href="#dt-static-context">static context</a>, <span class="xpath"><span class="xpath">an error is raised (the host language environment may define this error as either a static or a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>).</span></span>[<a title="err:XP0017" href="#ERRXP0017">err:XP0017</a>]</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-FunctionCall" name="doc-xpath-FunctionCall"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>XPath allows functions to be called. A core library of functions is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. <span class="xpath"><span class="xpath">Additional functions may be provided in the <a title="static context" href="#dt-static-context">static context</a>. XPath per se does not provide a way to declare functions, but a host language may provide such a mechanism.</span></span></p>
<p>A function call is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>Argument expressions are evaluated, producing argument values. The order of argument evaluation is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> and a function need not evaluate an argument if the function can evaluate its body without evaluating that argument.</p>
</li>
<li>
<p>Each argument value is converted by applying the function conversion rules listed below.</p>
</li>
<li class="xpath">
<p>The function is evaluated using the converted argument values. The result is a value of the function's declared return type.</p>
</li>
</ol>
<p>The <b>function conversion rules</b> are used to convert an argument value to its expected type; that is, to the declared type of the function parameter. The expected type is expressed as a <a title="SequenceType" href="#dt-sequence-type">SequenceType</a>. The function conversion rules are applied to a given value as follows:</p>
<ul>
<li class="xpath">
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code> and an argument is not of the expected type, then the following conversions are applied sequentially to the argument value V:</p>
<ol class="enumar">
<li>
<p>If the expected type calls for a single item or optional single item (examples: <code>xs:string</code>, <code>xs:string?</code>, <code>xdt:untypedAtomic</code>, <code>xdt:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>), then the value V is effectively replaced by V[1].</p>
</li>
<li>
<p>If the expected type is <code>xs:string</code> or <code>xs:string?</code>, then the value <code>V</code> is effectively replaced by <code>fn:string(V)</code>.</p>
</li>
<li>
<p>If the expected type is a (possibly optional) numeric type, then the value <code>V</code> is effectively replaced by <code>fn:number(V)</code>.</p>
</li>
</ol>
</li>
<li>
<p>If the expected type is a sequence of an atomic type (possibly with an occurrence indicator <code>*</code>, <code>+</code>, or <code>?</code>), the following conversions are applied:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the given value, resulting in a sequence of atomic values.</p>
</li>
<li>
<p>Each item in the atomic sequence that is of type <code>xdt:untypedAtomic</code> is cast to the expected atomic type. For built-in functions where the expected type is specified as <code>numeric</code>, arguments of type <code>xdt:untypedAtomic</code> are cast to <code>xs:double</code>.</p>
</li>
<li>
<p>For each numeric item in the atomic sequence that can be <a title="type promotion" href="#dt-type-promotion">promoted</a> to the expected atomic type using the promotion rules in <a href="#promotion"><b>B.1 Type Promotion</b></a>, the promotion is done.</p>
</li>
</ol>
</li>
<li>
<p>If, after the above conversions, the resulting value does not match the expected type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType Matching</a>, a <a title="type error" href="#dt-type-error">type error</a> is raised. [<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>] Note that the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType Matching</a>
permit a value of a derived type to be substituted for a value of its base type.</p>
</li>
</ul>
<p>Since the arguments of a function call are separated by commas, any argument expression that contains a top-level comma operator must be enclosed in parentheses. Here are some illustrative examples of function calls:</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2, 3)</code> denotes a function call with three arguments.</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2), 3)</code> denotes a function call with two arguments, the first of which is a sequence of two values.</p>
</li>
<li>
<p><code>my:two-argument-function(1, ())</code> denotes a function call with two arguments, the second of which is an empty sequence.</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2, 3))</code> denotes a function call with one argument that is a sequence of three values.</p>
</li>
<li>
<p><code>my:one-argument-function(( ))</code> denotes a function call with one argument that is an empty sequence.</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code> denotes a function call with zero arguments.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-path-expressions" name="id-path-expressions"></a>3.2 Path Expressions</h3>
<p>A <b>path expression</b> can be used to locate nodes within trees.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PathExpr" name="doc-xpath-PathExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-RelativePathExpr" name="doc-xpath-RelativePathExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a> (("/" | "//") <a href="#doc-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A path expression consists of a series of one or more <b>steps</b>, separated by "<code>/</code>" or "<code>//</code>", and optionally beginning with "<code>/</code>" or "<code>//</code>". An initial "<code>/</code>" or "<code>//</code>" is an abbreviation for one or more initial steps that are implicitly added to the beginning of the path expression, as described below.</p>
<p>A path expression consisting of a single step is evaluated as described in <a href="#id-steps"><b>3.2.1 Steps</b></a>.</p>
<p>Each occurrence of "<code>//</code>" in a path expression is expanded as described in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>, leaving a sequence of steps separated by "<code>/</code>". This sequence of steps is then evaluated from left to right. Each operation <code>E1/E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated, and if the result is not a (possibly empty) sequence of nodes, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title=
"err:XP0019" href="#ERRXP0019">err:XP0019</a>] Each node resulting from the evaluation of <code>E1</code> then serves in turn to provide an <b>inner focus</b> for an evaluation of <code>E2</code>, as described in <a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. Each evaluation of <code>E2</code> must result in a (possibly empty) sequence of nodes; otherwise, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0019" href="#ERRXP0019">err:XP0019</a>] The sequences
of nodes resulting from all the evaluations of <code>E2</code> are combined, and duplicate nodes are eliminated based on node identity. <span class="xpath"><span class="xpath">The resulting node sequence is returned in <a title="document order" href="#dt-document-order">document order</a>.</span></span></p>
<p>As an example of a path expression, <code>child::div1/child::para</code> selects the <code>para</code> element children of the <code>div1</code> element children of the context node, or, in other words, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents.</p>
<p>A "<code>/</code>" at the beginning of a path expression is an abbreviation for the initial step <code>fn:root(self::node()) treat as document-node()</code> (this is true even if the "<code>/</code>" is the entire path expression). The effect of this initial step is to begin the path at the root node of the tree that contains the context node. If the context item is not a node, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0020" href="#ERRXP0020">err:XP0020</a>]
At evaluation time, if the root node above the context node is not a document node, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>
<p>A "<code>//</code>" at the beginning of a path expression is an abbreviation for the initial steps <code>fn:root(self::node()) treat as document-node()/descendant-or-self::node()</code>. The effect of these initial steps is to establish an initial node sequence that contains the root of the tree in which the context node is found, plus all nodes descended from this root. This node sequence is used as the input to subsequent steps in the path expression. If the context item is not a node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0020" href="#ERRXP0020">err:XP0020</a>] At evaluation time, if the root node above the context node is not a document node, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The descendants of a node do not include attribute nodes<span class="xpath"><span class="xpath">or namespace nodes</span></span>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">The "<code>/</code>" character can be used either as an individual token or as part of a pattern such as "<code>/*</code>". This can cause parsing difficulties when "<code>/</code>" appears on the left hand side of an operator. For example, "<code>/*</code>" is a valid path expression with a wildcard, but "<code>/*5</code>" and "<code>/ * 5</code>" raise parsing errors. Parentheses must be used when "<code>/</code>" is used as the first operand of an operator, as in "<code>(/) *
5</code>". Similarly, "<code>4 + / * 5</code>" raises a parsing error, but "<code>4 + (/) * 5</code>" is a valid expression. The expression <code>4 + /</code>" is also valid, because <code>/</code> does not occur on the left hand side of the operator.</p>
</div>
<div class="div3">
<h4><a id="id-steps" name="id-steps"></a>3.2.1 Steps</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-StepExpr" name="doc-xpath-StepExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AxisStep">AxisStep</a> | <a href="#doc-xpath-FilterExpr">FilterExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AxisStep" name="doc-xpath-AxisStep"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ForwardStep">ForwardStep</a> | <a href="#doc-xpath-ReverseStep">ReverseStep</a>) <a href="#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForwardStep" name="doc-xpath-ForwardStep"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ForwardAxis">ForwardAxis</a> <a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href="#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ReverseStep" name="doc-xpath-ReverseStep"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ReverseAxis">ReverseAxis</a> <a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href="#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-PredicateList" name="doc-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>A <b>step</b> generates a sequence of items and then filters the sequence by zero or more <b>predicates</b>. The value of the step consists of those items that satisfy the predicates. Predicates are described in <a href="#id-predicates"><b>3.2.2 Predicates</b></a>. A step may be either an <b>axis step</b> or a <b>filter expression</b>. Filter expressions are described in <a href="#id-filter-expr"><b>3.3.2 Filter Expressions</b></a>.</p>
<p>The result of an <b>axis step</b> is always a sequence of zero or more nodes, and these nodes are always returned in <a title="document order" href="#dt-document-order">document order</a>. An axis step may be either a <b>forward step</b> or a <b>reverse step</b>, followed by zero or more predicates. An axis step might be thought of as beginning at the <b>context node</b> and navigating to those nodes that are reachable from the context node via a specified <b>axis</b>. Such a step has two parts: an
<b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or type. If the context item is not a node, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0020" href="#ERRXP0020">err:XP0020</a>]</p>
<p>In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<p>The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the nodes reachable from the context node via the specified axis that have the node kind, name, and/or type specified by the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be
selected on this axis. The available axes are described in <a href="#axes"><b>3.2.1.1 Axes</b></a>. The available node tests are described in <a href="#node-tests"><b>3.2.1.2 Node Tests</b></a>. Examples of steps are provided in <a href="#unabbrev"><b>3.2.3 Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<div class="div4">
<h5><a id="axes" name="axes"></a>3.2.1.1 Axes</h5>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForwardAxis" name="doc-xpath-ForwardAxis"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ReverseAxis" name="doc-xpath-ReverseAxis"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<div class="xpath">
<p class="xpath">XPath defines a set of full set of <b>axes</b> for traversing documents, but a <b>host language</b> may define a subset of these axes. The following axes are defined:</p>
</div>
<ul>
<li>
<p>The <code>child</code> axis contains the children of the context node, which are the nodes returned by the <code>dm:children</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only document nodes and element nodes have children. If the context node is any other kind of node, or if the context node is an empty document or element node, then the child axis is an empty sequence. The children of a document node or element node may be element, processing instruction, comment, or text nodes. Attribute<span class="xpath"><span class="xpath">, namespace,</span></span> and document nodes can never appear as children.</p>
</div>
</li>
<li>
<p>the <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the children, the children of the children, and so on)</p>
</li>
<li>
<p>the <code>parent</code> axis contains the sequence returned by the <code>dm:parent</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, which returns the parent of the context node, or an empty sequence if the context node has no parent</p>
</li>
<li>
<p>the <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the context node (the parent, the parent of the parent, and so on)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ancestor axis includes the root node of the tree in which the context node is found, unless the context node is the root node.</p>
</div>
</li>
<li>
<p>the <code>following-sibling</code> axis contains the context node's following siblings, those children of the context node's parent that occur after the context node in <a title="document order" href="#dt-document-order">document order</a>; if the context node is an attribute node<span class="xpath"><span class="xpath">or namespace node</span></span>, the <code>following-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>preceding-sibling</code> axis contains the context node's preceding siblings, those children of the context node's parent that occur before the context node in <a title="document order" href="#dt-document-order">document order</a>; if the context node is an attribute node<span class="xpath"><span class="xpath">or namespace node</span></span>, the <code>preceding-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>following</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not descendants of the context node, and occur after the context node in <a title="document order" href="#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>preceding</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not ancestors of the context node, and occur before the context node in <a title="document order" href="#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>attribute</code> axis contains the attributes of the context node, which are the nodes returned by the <code>dm:attributes</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>; the axis will be empty unless the context node is an element</p>
</li>
<li>
<p>the <code>self</code> axis contains just the context node itself</p>
</li>
<li>
<p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context node</p>
</li>
<li>
<p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node</p>
</li>
<li class="xpath">
<p>the <code>namespace</code> axis contains the namespace nodes of the context node, which are the nodes returned by the <code>dm:namespaces</code> accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>; this axis is empty unless the context node is an element node. The <code>namespace</code> axis is deprecated in XPath 2.0. Whether an implementation supports the <code>namespace</code> axis is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An implementation that does not support the <code>namespace</code> axis must raise a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XP0021" href="#ERRXP0021">err:XP0021</a>] if it is used. Applications needing information about the in-scope namespaces of an element should use the functions <code>fn:get-in-scope-prefixes</code> and <code>fn:get-namespace-uri-for-prefix</code> defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
</li>
</ul>
<p>Axes can be categorized as <b>forward axes</b> and <b>reverse axes</b>. An axis that only ever contains the context node or nodes that are after the context node in <a title="document order" href="#dt-document-order">document order</a> is a forward axis. An axis that only ever contains the context node or nodes that are before the context node in <a title="document order" href="#dt-document-order">document order</a> is a reverse axis.</p>
<p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <span class="xpath"><span class="xpath">and namespace</span></span> nodes): they do not overlap and together they contain all the nodes in the
document.</p>
<p>In a sequence of nodes selected by an axis step, each node is assigned a context position that corresponds to its position in the sequence. If the axis is a forward axis, context positions are assigned to the nodes in <a title="document order" href="#dt-document-order">document order</a>, starting with 1. If the axis is a reverse axis, context positions are assigned to the nodes in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>, starting with 1. This makes
it possible to select a node from the sequence by specifying its position.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>One example of an expression that uses the context position is a numeric predicate. The expression <code>child::para[1]</code> selects the first <code>para</code> element that is a child of the context node.</p>
</div>
</div>
<div class="div4">
<h5><a id="node-tests" name="node-tests"></a>3.2.1.2 Node Tests</h5>
<p>[<a title="node test" id="dt-node-test" name="dt-node-test">Definition</a>: A <b>node test</b> is a condition that must be true for each node selected by a step.] The condition may be based on the kind of the node (element, attribute, text, document, comment, or processing instruction), the name of the node, or (in the case of element, attribute, and document nodes), the type of the node.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NodeTest" name="doc-xpath-NodeTest"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | <a href="#doc-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NameTest" name="doc-xpath-NameTest"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href="#doc-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Wildcard" name="doc-xpath-Wildcard"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a title="principal node kind" id="dt-principal-node-kind" name="dt-principal-node-kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.] Thus:</p>
<ul>
<li>
<p>For the attribute axis, the principal node kind is attribute.</p>
</li>
<li class="xpath">
<p>For the namespace axis, the principal node kind is namespace.</p>
</li>
<li>
<p>For all other axes, the principal node kind is element.</p>
</li>
</ul>
<p>[<a title="name test" id="dt-name-test" name="dt-name-test">Definition</a>: A node test that consists only of a QName or a Wildcard is called a <b>name test</b>.] A name test is true if and only if the <b>kind</b> of the node is the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> and the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the node is equal (on a codepoint basis) to the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> specified by the name test. For example, <code>child::para</code> selects the <code>para</code> element children of the context node; if the context node has no <code>para</code> children, it selects an empty set of nodes. <code>attribute::abc:href</code> selects the attribute of the context node with the QName <code>abc:href</code>; if the context node has no such attribute, it selects an empty set of nodes.</p>
<p>A QName in a name test is resolved into an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> in the expression context. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>] if the QName has a prefix that does not correspond to any statically known namespace. An unprefixed QName, when used as a name
test on an axis whose <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> is element, has the namespace URI of the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> in the expression context; otherwise, it has no namespace URI.</p>
<p>A name test is not satisfied by an element node whose name does not match the QName of the name test, even if it is in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> whose head is the named element.</p>
<p>A node test <code>*</code> is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a>. For example, <code>child::*</code> will select all element children of the context node, and <code>attribute::*</code> will select all attributes of the context node.</p>
<p>A node test can have the form <code>NCName:*</code>. In this case, the prefix is expanded in the same way as with a QName, using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> in the <a title="static context" href="#dt-static-context">static context</a>. If the prefix is not found in the statically known namespaces, a <a title="static error" href="#dt-static-error">static error</a> is raised.[<a title="err:XP0008" href="#ERRXP0008">err:XP0008</a>]
The node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> whose <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> has the namespace URI to which the prefix is bound, regardless of the local part of the name.</p>
<p>A node test can also have the form <code>*:NCName</code>. In this case, the node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> whose local name matches the given NCName, regardless of its namespace.</p>
<p>[<a title="kind test" id="dt-kind-test" name="dt-kind-test">Definition</a>: An alternative form of a node test called a <b>kind test</b> can select nodes based on their kind, name, and type annotation.] The syntax and semantics of a kind test are described in <a href="#id-types"><b>2.4 Types</b></a>. When a kind test is used in a <a title="node test" href="#dt-node-test">node test</a>, only those nodes on the designated axis that match the kind test are selected. Shown below are several examples of kind
tests that might be used in path expressions:</p>
<ul>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>element()</code> matches any element node.</p>
</li>
<li>
<p><code>element(person)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), and whose type annotation conforms to the top-level element declaration for a <code>person</code> element.</p>
</li>
<li>
<p><code>element(person, *)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), without any restriction on type annotation.</p>
</li>
<li>
<p><code>element(person, surgeon)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), and whose type annotation is <code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*, surgeon)</code> matches any element node whose type annotation is <code>surgeon</code>, regardless of its name.</p>
</li>
<li>
<p><code>element(hospital/staff/person)</code> matches any element node whose name and type annotation conform to the schema declaration of a <code>person</code> element in a <code>staff</code> element in a <code>hospital</code> element whose declaration is a top-level element declaration.</p>
</li>
<li>
<p><code>attribute()</code> matches any attribute node.</p>
</li>
<li>
<p><code>attribute(price, *)</code> matches any attribute whose name is <code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*, xs:decimal)</code> matches any attribute whose type annotation is <code>xs:decimal</code>, regardless of its name.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(element(book))</code> matches any document node whose content consists of a single element node that satisfies the <a title="kind test" href="#dt-kind-test">kind test</a> <code>element(book)</code>, mixed with zero or more comments and processing instructions.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a id="id-predicates" name="id-predicates"></a>3.2.2 Predicates</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-Predicate" name="doc-xpath-Predicate"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>A predicate consists of an expression, called a <b>predicate expression</b>, enclosed in square brackets. A predicate serves to filter a sequence, retaining some items and discarding others. For each item in the sequence to be filtered, the predicate expression is evaluated using an <b>inner focus</b> derived from that item, as described in <a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The result of the predicate expression is coerced to a <code>xs:boolean</code> value, called the
<b>predicate truth value</b>, as described below. Those items for which the predicate truth value is <code>true</code> are retained, and those for which the predicate truth value is <code>false</code> are discarded.</p>
<p>The predicate truth value is derived by applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p>If the value of the predicate expression is an atomic value of a numeric type, the predicate truth value is <code>true</code> if the value of the predicate expression is equal (by the <code>eq</code> operator) to the <b>context position</b>, and is <code>false</code> otherwise.</p>
</li>
<li>
<p>Otherwise, the predicate truth value is the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the predicate expression.</p>
</li>
</ol>
<p>Here are some examples of <b>axis steps</b> that contain predicates:</p>
<ul>
<li>
<p>This example selects the second <code>chapter</code> element that is a child of the context node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the descendants of the context node that are elements named <code>"toy"</code> and whose <code>color</code> attribute has the value <code>"red"</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the <code>employee</code> children of the context node that have a <code>secretary</code> child element:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::employee[secretary]
</pre></div>
</div>
</li>
</ul>
<p>When using predicates with a sequence of nodes selected using a <b>reverse axis</b>, it is important to remember that the the context positions for such a sequence are assigned in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>. For example, <code>preceding::foo[1]</code> returns the first qualifying <code>foo</code> element in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>, because the predicate is part of an
<b>axis step</b> using a reverse axis. By contrast, <code>(preceding::foo)[1]</code> returns the first qualifying <code>foo</code> element in <a title="document order" href="#dt-document-order">document order</a>, because the parentheses cause <code>(preceding::foo)</code> to be parsed as a <a title="primary expression" href="#dt-primary-expression">primary expression</a> in which context positions are assigned in document order. Similarly, <code>ancestor::*[1]</code> returns the nearest ancestor element,
because the <code>ancestor</code> axis is a reverse axis, whereas <code>(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p>
</div>
<div class="div3">
<h4><a id="unabbrev" name="unabbrev"></a>3.2.3 Unabbreviated Syntax</h4>
<p>This section provides a number of examples of path expressions in which the axis is explicitly specified in each step. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<ul>
<li>
<p><code>child::para</code> selects the <code>para</code> element children of the context node</p>
</li>
<li>
<p><code>child::*</code> selects all element children of the context node</p>
</li>
<li>
<p><code>child::text()</code> selects all text node children of the context node</p>
</li>
<li>
<p><code>child::node()</code> selects all the children of the context node, whatever their node type</p>
</li>
<li>
<p><code>attribute::name</code> selects the <code>name</code> attribute of the context node</p>
</li>
<li>
<p><code>attribute::*</code> selects all the attributes of the context node</p>
</li>
<li>
<p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p>
</li>
<li>
<p><code>descendant::para</code> selects the <code>para</code> element descendants of the context node</p>
</li>
<li>
<p><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node</p>
</li>
<li>
<p><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</p>
</li>
<li>
<p><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</p>
</li>
<li>
<p><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise selects nothing</p>
</li>
<li>
<p><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p>
</li>
<li>
<p><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</p>
</li>
<li>
<p><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</p>
</li>
<li>
<p><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</p>
</li>
<li>
<p><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() = 1]</code>selects the next <code>chapter</code> sibling of the context node</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() = 1]</code>selects the previous <code>chapter</code> sibling of the context node</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p>
</li>
<li>
<p><code>child::para[attribute::type="warning"]</code>selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[attribute::type='warning'][fn:position() = 5]</code>selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type="warning"]</code>selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::chapter[child::title='Introduction']</code>selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose typed value is equal to the string <code>Introduction</code></p>
</li>
<li>
<p><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() = fn:last()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="abbrev" name="abbrev"></a>3.2.4 Abbreviated Syntax</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AbbrevForwardStep" name="doc-xpath-AbbrevForwardStep"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href="#doc-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AbbrevReverseStep" name="doc-xpath-AbbrevReverseStep"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>The abbreviated syntax permits the following abbreviations:</p>
<ol class="enumar">
<li>
<p>The attribute axis <code>attribute::</code> can be abbreviated by <code>@</code>. For example, a path expression <code>para[@type="warning"]</code> is short for <code>child::para[attribute::type="warning"]</code> and so selects <code>para</code> children with a <code>type</code> attribute with value equal to <code>warning</code>.</p>
</li>
<li>
<p>If the axis name is omitted from an axis step, the default axis is <code>child</code> unless the axis step contains an <a href="#doc-xpath-AttributeTest">AttributeTest</a>; in that case, the default axis is <code>attribute</code>. For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>. Similarly,
<code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <a title="node test" href="#dt-node-test">node test</a>.</p>
</li>
<li>
<p><code>//</code> is effectively replaced by <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code>//para</code> is an abbreviation for <code>/descendant-or-self::node()/child::para</code> and so will select any <code>para</code> element in the document (even a <code>para</code> element that is a document element will be selected by <code>//para</code> since the document element node is a child of the root node); <code>div1//para</code> is short for
<code>child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The path expression <code>//para[1]</code> does <em>not</em> mean the same as the path expression <code>/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p>
</div>
</li>
<li>
<p>A step consisting of <code>..</code> is short for <code>parent::node()</code>. For example, <code>../title</code> is short for <code>parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The expression <code>.</code>, known as a <b>context item expression</b>, is a <a title="primary expression" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-item-expression"><b>3.1.4 Context Item Expression</b></a>.</p>
</div>
</li>
</ol>
<p>Here are some examples of path expressions that use the abbreviated syntax:</p>
<ul>
<li>
<p><code>para</code> selects the <code>para</code> element children of the context node</p>
</li>
<li>
<p><code>*</code> selects all element children of the context node</p>
</li>
<li>
<p><code>text()</code> selects all text node children of the context node</p>
</li>
<li>
<p><code>@name</code> selects the <code>name</code> attribute of the context node</p>
</li>
<li>
<p><code>@*</code> selects all the attributes of the context node</p>
</li>
<li>
<p><code>para[1]</code> selects the first <code>para</code> child of the context node</p>
</li>
<li>
<p><code>para[fn:last()]</code> selects the last <code>para</code> child of the context node</p>
</li>
<li>
<p><code>*/para</code> selects all <code>para</code> grandchildren of the context node</p>
</li>
<li>
<p><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p>
</li>
<li>
<p><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p>
</li>
<li>
<p><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</p>
</li>
<li>
<p><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</p>
</li>
<li>
<p><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</p>
</li>
<li>
<p><code>.//para</code> selects the <code>para</code> element descendants of the context node</p>
</li>
<li>
<p><code>..</code> selects the parent of the context node</p>
</li>
<li>
<p><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node</p>
</li>
<li>
<p><code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose typed value is equal to the string <code>Introduction</code></p>
</li>
<li>
<p><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p>
</li>
<li>
<p><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute</p>
</li>
<li>
<p><code>book/(chapter|appendix)/section</code> selects every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p>
</li>
<li>
<p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-sequence-expressions" name="id-sequence-expressions"></a>3.3 Sequence Expressions</h3>
<p>XPath supports operators to construct, filter, and combine <a title="sequence" href="#dt-sequence">sequences</a> of <a title="item" href="#dt-item">items</a>. Sequences are never nested&#8212;for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3).</p>
<div class="div3">
<h4><a id="construct_seq" name="construct_seq"></a>3.3.1 Constructing Sequences</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="noid_N126doc-xpath-Expr" name="noid_N126doc-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-RangeExpr" name="doc-xpath-RangeExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> ( "to" <a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
</table>
<p>One way to construct a sequence is by using the comma operator, which evaluates each of its operands and concatenates the resulting values, in order, into a single result sequence.</p>
<p>A sequence may contain duplicate values or nodes, but a sequence is never an item in another sequence. When a new sequence is created by concatenating two or more input sequences, the new sequence contains all the items of the input sequences and its length is the sum of the lengths of the input sequences.</p>
<p>In places where the grammar calls for <a href="#doc-xpath-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses. Empty parentheses can be used to denote an empty sequence.</p>
<p>Here are some examples of expressions that construct sequences:</p>
<ul>
<li>
<p>The result of this expression is a sequence of five integers:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</div>
</li>
<li>
<p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</div>
</li>
<li>
<p>The result of this expression is a sequence containing all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</div>
</li>
<li>
<p>Assuming that <code>$price</code> is bound to the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</div>
</li>
</ul>
<p>A <b>range expression</b> can be used to construct a sequence of consecutive integers. Each of the operands of the <code>to</code> operator is converted as though it was an argument of a function with the expected parameter type <code>xs:integer</code>. A <a title="type error" href="#dt-type-error">type error</a> [<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>] is raised if either operand cannot be converted to a single integer. If the integer derived from the first operand is greater than the
integer derived from the second operand, the result of the range expression is an empty sequence. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order.</p>
<ul>
<li>
<p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</div>
</li>
<li>
<p>This example constructs a sequence of length one containing the single integer <code>10</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</div>
</li>
<li>
<p>The result of this example is a sequence of length zero.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</div>
</li>
<li>
<p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-filter-expr" name="id-filter-expr"></a>3.3.2 Filter Expressions</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-FilterExpr" name="doc-xpath-FilterExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-FilterExpr">FilterExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a> <a href="#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="noid_N126doc-xpath-PredicateList" name="noid_N126doc-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>A <b>filter expression</b> consists simply of a <b>primary expression</b> followed by zero or more predicates. The result of the filter expression consists of all the items returned by the primary expression for which all the predicates are true. If no predicates are specified, the result is simply the result of the primary expression. This result may contain nodes, atomic values, or any combination of these. The ordering of the items returned by a filter expression is the same as their order in the
result of the primary expression. Context positions are assigned to items based on their ordinal position in the result sequence. The first context position is 1.</p>
<p>Here are some examples of filter expressions:</p>
<ul>
<li>
<p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</div>
</li>
<li>
<p>List all the integers from 1 to 100 that are divisible by 5. (See <a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a> for an explanation of the <code>to</code> operator.)</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</div>
</li>
<li>
<p>The result of the following expression is the integer 25:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</div>
</li>
<li>
<p>The following example illustrates the use of a filter expression as a step in a path expression. It returns the element node within the specified document whose ID value is "tiger":</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:doc("zoo.xml")/fn:id('tiger')
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="combining_seq" name="combining_seq"></a>3.3.3 Combining Node Sequences</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-UnionExpr" name="doc-xpath-UnionExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union" | "|") <a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IntersectExceptExpr" name="doc-xpath-IntersectExceptExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> ( ("intersect" | "except") <a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XPath provides the following operators for combining sequences of nodes:</p>
<ul>
<li>
<p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and return a sequence containing all the nodes that occur in either of the operands.</p>
</li>
<li>
<p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in both operands.</p>
</li>
<li>
<p>The <code>except</code> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in the first operand but not in the second operand.</p>
</li>
</ul>
<p>All these operators eliminate duplicate nodes from their result sequences based on node identity. <span class="xpath"><span class="xpath">The resulting sequence is returned in <a title="document order" href="#dt-document-order">document order</a>.</span></span></p>
<p>If an operand of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
<p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. Assume that the variables <code>$seq1</code>, <code>$seq2</code> and <code>$seq3</code> are bound to the following sequences of these nodes:</p>
<ul>
<li>
<p><code>$seq1</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq2</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq3</code> is bound to (B, C)</p>
</li>
</ul>
<p>Then:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code> evaluates to the sequence (A, B).</p>
</li>
<li>
<p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B, C).</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A, B).</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code> evaluates to the sequence containing B only.</p>
</li>
<li>
<p><code>$seq1 except $seq2</code> evaluates to the empty sequence.</p>
</li>
<li>
<p><code>$seq2 except $seq3</code> evaluates to the sequence containing A only.</p>
</li>
</ul>
<p>In addition to the sequence operators described here, <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> includes functions for indexed access to items or sub-sequences of a sequence, for indexed insertion or removal of items in a sequence, and for removing duplicate items from a sequence.</p>
</div>
</div>
<div class="div2">
<h3><a id="id-arithmetic" name="id-arithmetic"></a>3.4 Arithmetic Expressions</h3>
<p>XPath provides arithmetic operators for addition, subtraction, multiplication, division, and modulus, in their usual binary and unary forms.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AdditiveExpr" name="doc-xpath-AdditiveExpr"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" | "-") <a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-MultiplicativeExpr" name="doc-xpath-MultiplicativeExpr"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a> ( ("*" | "div" | "idiv" | "mod") <a href="#doc-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-UnaryExpr" name="doc-xpath-UnaryExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ValueExpr" name="doc-xpath-ValueExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
</table>
<p>A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic operations.</p>
<p>An arithmetic expression is evaluated by applying the following rules, in order, until an error is raised or a value is computed:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand.</p>
</li>
<li>
<p>If either operand is now an empty sequence, the result of the operation is an empty sequence.</p>
</li>
<li>
<p>If either operand is now a sequence of length greater than one, <span class="xpath"><span class="xpath">then:</span></span></p>
<div class="xpath">
<ol class="enumla">
<li>
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code>, any items after the first item in the sequence are discarded.</p>
</li>
<li>
<p>Otherwise, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</div>
</li>
<li>
<p>If either operand is now of type <code>xdt:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0021" href="#ERRXP0021">err:XP0021</a>]</p>
</li>
<li>
<p>If the operand types are now valid for the given operator, the operator is applied to the operands, resulting in an atomic value or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> (for example, an error might result from dividing by zero.) The combinations of atomic types that are accepted by the various arithmetic operators, and their respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a> together with the functions in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> that define the semantics of the operation for each type.</p>
</li>
<li class="xpath">
<p>If the operand types are not valid for the given operator and <b>XPath 1.0 compatibility mode</b> is <code>true</code>, each operand is further converted according to the rules in <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a> as if it were a function argument with the expected type <code>xs:double</code>. The operator is then applied to the operands, resulting in an atomic value or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.[<a title="err:XP0004" href=
"#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If the operand types are still not valid for the given operator, a <a title="type error" href="#dt-type-error">type error</a> is raised.</p>
</li>
</ol>
<p>XPath supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any numeric type. As described in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>, <code>$arg1 idiv $arg2</code> is equivalent to <code>($arg1 div $arg2) cast as xs:integer</code> except for error cases.</p>
<p>Here are some examples of arithmetic expressions:</p>
<ul>
<li>
<p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:</p>
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</li>
<li>
<p>Subtraction of two date values results in a value of type <code>xdt:dayTimeDuration</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</div>
</li>
<li>
<p>This example illustrates the difference between a subtraction operator and a hyphen:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</div>
</li>
<li>
<p>Unary operators have higher precedence than binary operators, subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted by XPath for compatability with <a href="#XPath">[XPath 1.0]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a id="id-comparisons" name="id-comparisons"></a>3.5 Comparison Expressions</h3>
<p>Comparison expressions allow two values to be compared. XPath provides three kinds of comparison expressions, called value comparisons, general comparisons, and node comparisons.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ComparisonExpr" name="doc-xpath-ComparisonExpr"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a> ( (<a href="#doc-xpath-ValueComp">ValueComp</a><br />
| <a href="#doc-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xpath-NodeComp">NodeComp</a>) <a href="#doc-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ValueComp" name="doc-xpath-ValueComp"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-GeneralComp" name="doc-xpath-GeneralComp"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-NodeComp" name="doc-xpath-NodeComp"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<div class="xpath">
<p class="xpath">When an XPath expression is written within an XML document, the XML escaping rules for special characters must be followed; thus "<code>&lt;</code>" must be written as "<code>&amp;lt;</code>".</p>
</div>
</div>
<div class="div3">
<h4><a id="id-value-comparisons" name="id-value-comparisons"></a>3.5.1 Value Comparisons</h4>
<p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values. The result of a value comparison is defined by applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand. If the result, called an <b>atomized operand</b>, contains more than one atomic value, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If either atomized operand is an empty sequence, the result of the value comparison is an empty sequence.</p>
</li>
<li>
<p>Any atomized operand that has the dynamic type <code>xdt:untypedAtomic</code> is cast to the type <code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this rule is to make value comparisons transitive. It is recognized that the general comparison operators have a different rule for casting of <code>xdt:untypedAtomic</code> operands. It is also recognized that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two <code>int</code> values that differ slightly may both be considered equal to the same <code>float</code> value because <code>float</code> has less precision than
<code>int</code>).</p>
</div>
</li>
<li>
<p>If both atomized operands consist of exactly one atomic value, then the result of the comparison is <code>true</code> if the value of the first operand is (equal, not equal, less than, less than or equal, greater than, greater than or equal) to the value of the second operand; otherwise the result of the comparison is <code>false</code>. <a href="#mapping"><b>B.2 Operator Mapping</b></a> defines which combinations of atomic types are comparable, and how the comparison operators are mapped into
supporting functions. If the value of the first atomized operand is not comparable with the value of the second atomized operand, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
<p>Here are some examples of value comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if <code>$book1</code> has exactly one <code>author</code> subelement and its typed value is "Kennedy" as an instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>. If <code>$book1</code> has more than one <code>author</code> subelement, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>] If <code>$book1</code> has no
<code>author</code> subelement, the result of the expression is the empty sequence.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following path expression contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive numeric type:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-general-comparisons" name="id-general-comparisons"></a>3.5.2 General Comparisons</h4>
<p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is always <code>true</code> or <code>false</code>.</p>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand of a general comparison. The result of the comparison is <code>true</code> if and only if there is a pair of atomic values, one belonging to the result of atomization of the first operand and the other belonging to the result of atomization of the second operand, that have the required <b>magnitude relationship</b>. Otherwise the result of the general comparison is <code>false</code>. The <b>magnitude
relationship</b> between two atomic values is determined as follows:</p>
<ol class="enumar">
<li>
<p>If either atomic value has the dynamic type <code>xdt:untypedAtomic</code>, that value is cast to a required type, which is determined as follows:</p>
<ol class="enumla">
<li>
<p>If the dynamic type of the other atomic value is a numeric type, the required type is <code>xs:double</code>.</p>
</li>
<li>
<p>If the dynamic type of the other atomic value is <code>xdt:untypedAtomic</code>, the required type is <code>xs:string</code>.</p>
</li>
<li>
<p>Otherwise, the required type is the dynamic type of the other atomic value.</p>
</li>
</ol>
<p>If the cast to the required type fails, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0021" href="#ERRXP0021">err:XP0021</a>]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this rule is to preserve backward compatability with XPath 1.0, in which (for example) <code>x &lt; 17</code> is a numeric comparison if <code>x</code> is an untyped value. It is recognized that the value comparison operators have a different rule for casting of <code>xdt:untypedAtomic</code> operands.</p>
</div>
</li>
<li class="xpath">
<p>If <b>XPath 1.0 compatibility mode</b> is <code>true</code>, and at least one of the atomic values has a numeric type, then both atomic values are cast to to the type <code>xs:double</code>.</p>
</li>
<li>
<p>After any necessary casting, the atomic values are compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if the result of this value comparison is <code>true</code>.</p>
</li>
</ol>
<p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <b>magnitude relationship</b>. Similarly, a general comparison may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a
result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p>
<p>Here are some examples of general comparisons:</p>
<ul>
<li>
<p>The following comparison is true if the typed value of any <code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xdt:untypedAtomic</code>, with string values "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as
numbers.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-node-comparisons" name="id-node-comparisons"></a>3.5.3 Node Comparisons</h4>
<p>Node comparisons are used to compare two nodes, by their identity or by their <a title="document order" href="#dt-document-order">document order</a>. The result of a node comparison is defined by applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p>Each operand must be either a single node or an empty sequence; otherwise a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If either operand is an empty sequence, the result of the comparison is an empty sequence.</p>
</li>
<li>
<p>A comparison with the <code>is</code> operator is <code>true</code> if the two operands have the same identity, and are thus the same node; otherwise it is <code>false</code>. See <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> for a definition of node identity.</p>
</li>
<li>
<p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the first operand node precedes the second operand node in <a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p>
</li>
<li>
<p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the first operand node follows the second operand node in <a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p>
</li>
</ol>
<p>Here are some examples of node comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if the left and right sides each evaluate to exactly the same single node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//book[isbn="1558604820"] is //book[call="QA76.9 C3845"]
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true only if the node identified by the left side occurs before the node identified by the right side in document order:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//purchase[parcel="28-451"] &lt;&lt; //sale[parcel="33-870"]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a id="id-logical-expressions" name="id-logical-expressions"></a>3.6 Logical Expressions</h3>
<p>A <b>logical expression</b> is either an <b>and-expression</b> or an <b>or-expression</b>. If a logical expression does not raise an error, its value is always one of the boolean values <code>true</code> or <code>false</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-OrExpr" name="doc-xpath-OrExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a> ( "or" <a href="#doc-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-AndExpr" name="doc-xpath-AndExpr"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> ( "and" <a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>The first step in evaluating a logical expression is to find the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of each of its operands (see <a href="#id-ebv"><b>2.3.3 Effective Boolean Value</b></a>).</p>
<p>The value of an and-expression is determined by the effective boolean values (EBV's) of its operands. If an error is raised during computation of one of the effective boolean values, an and-expression <em>may</em> raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, as shown in the following table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = true</td>
<td>EBV<sub>2</sub> = false</td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = true</td>
<td>true</td>
<td>false</td>
<td>error</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = false</td>
<td>false</td>
<td>false</td>
<td>false or error</td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td>error</td>
<td>false or error</td>
<td>error</td>
</tr>
</tbody>
</table>
<p>The value of an or-expression is determined by the effective boolean values (EBV's) of its operands. If an error is raised during computation of one of the effective boolean values, an or-expression <em>may</em> raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, as shown in the following table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = true</td>
<td>EBV<sub>2</sub> = false</td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = true</td>
<td>true</td>
<td>true</td>
<td>true or error</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = false</td>
<td>true</td>
<td>false</td>
<td>error</td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td>true or error</td>
<td>error</td>
<td>error</td>
</tr>
</tbody>
</table>
<p>The order in which the operands of a logical expression are evaluated is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>. The tables above are defined in such a way that an or-expression can return <code>true</code> if the first expression evaluated is true, and it can raise an error if evaluation of the first expression raises an error. Similarly, an and-expression can return <code>false</code> if the first expression evaluated is false, and it can
raise an error if evaluation of the first expression raises an error. As a result of these rules, a logical expression is not deterministic in the presence of errors, as described in <a href="#id-errors-and-opt"><b>2.5.3 Errors and Optimization</b></a>. This is illustrated in the examples below.</p>
<p>Here are some examples of logical expressions:</p>
<ul>
<li>
<p>The following expressions return <code>true</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
</div>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>false</code> or raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>true</code> or raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression must raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
</ul>
<p>In addition to and- and or-expressions, XPath provides a function named <code>fn:not</code> that takes a general sequence as parameter and returns a boolean value. The <code>fn:not</code> function is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. The <code>fn:not</code> function reduces its parameter to an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a>. It then returns <code>true</code> if the effective boolean value of
its parameter is <code>false</code>, and <code>false</code> if the effective boolean value of its parameter is <code>true</code>. If an error is encountered in finding the effective boolean value of its operand, <code>fn:not</code> raises the same <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="xpath">
<div class="div2">
<h3><a id="id-for-expressions" name="id-for-expressions"></a>3.7 For Expressions</h3>
<p>XPath provides an iteration facility called a <b>for expression</b>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-ForExpr" name="doc-xpath-ForExpr"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr" class="xpath">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a> "return" <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SimpleForClause" name="doc-xpath-SimpleForClause"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause" class="xpath">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" "$" <a href="#doc-xpath-VarName">VarName</a> "in" <a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href="#doc-xpath-VarName">VarName</a> "in" <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A <code>for</code> expression is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>for</code> expression uses multiple variables, it is first expanded to a set of nested <code>for</code> expressions, each of which uses only one variable. For example, the expression <code>for $x in X, $y in Y return $x + $y</code> is expanded to <code>for $x in X return for $y in Y return $x + $y</code>.</p>
</li>
<li>
<p>In a single-variable <code>for</code> expression, the variable is called the <b>range variable</b>, the value of the expression that follows the <code>in</code> keyword is called the <b>input sequence</b>, and the expression that follows the <code>return</code> keyword is called the <b>return expression</b>. The result of the <code>for</code> expression is obtained by evaluating the <code>return</code> expression once for each item in the input sequence, with the range variable bound to that item. The
resulting sequences are concatenated in the order of the items in the input sequence from which they were derived.</p>
</li>
</ol>
<div class="xpath">
<p class="xpath">The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following input:</p>
</div>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>The following example transforms the input document into a list in which each author's name appears only once, followed by a list of titles of books written by that author. This example assumes that the context item is the <code>bib</code> element in the input document.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">for $a in fn:distinct-values(//author)
return ($a, //book[author = $a]/title)</span></span>
</pre></div>
</div>
<p>The result of the above expression consists of the following sequence of elements. The titles of books written by a given author are listed after the name of the author. The ordering of <code>author</code> elements in the result is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> due to the semantics of the <code>fn:distinct-values</code> function.</p>
<div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre></div>
<p>The following example illustrates a <code>for</code> expression containing more than one variable:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span>
</pre></div>
</div>
<p>The result of the above expression, expressed as a sequence of numbers, is as follows: <code>11, 12, 21, 22</code></p>
<p>The scope of a variable bound in a <code>for</code> expression comprises all subexpressions of the <code>for</code> expression that appear after the variable binding. The scope does not include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same <code>for</code> expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></span>
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression is the same as the focus for evaluation of the <code>for</code> expression itself. The following example, which attempts to find the total value of a set of order-items, is therefore incorrect:</p>
<div class="error">
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return @price *
@qty)
</pre></div>
</div>
<p>Instead, the expression must be written to use the variable bound in the <code>for</code> clause:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre></div>
</div>
</div>
</div>
</div>
<div class="div2">
<h3><a id="id-conditionals" name="id-conditionals"></a>3.8 Conditional Expressions</h3>
<p>XPath supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-IfExpr" name="doc-xpath-IfExpr"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xpath-Expr">Expr</a> ")" "then" <a href="#doc-xpath-ExprSingle">ExprSingle</a> "else" <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The expression following the <code>if</code> keyword is called the <b>test expression</b>, and the expressions following the <code>then</code> and <code>else</code> keywords are called the <b>then-expression</b> and <b>else-expression</b>, respectively.</p>
<p>The first step in processing a conditional expression is to find the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the test expression, as defined in <a href="#id-ebv"><b>2.3.3 Effective Boolean Value</b></a>.</p>
<p>The value of a conditional expression is defined as follows: If the effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the effective boolean value of the test expression is <code>false</code>, the value of the else-expression is returned.</p>
<p>Conditional expressions have a special rule for propagating <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered in the else-expression. In this case, since the else-expression can have no observable effect, it need not be evaluated. Similarly, if the effective value of the test expression is <code>false</code>, the conditional expression
ignores any <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> encountered in the then-expression, and the then-expression need not be evaluated.</p>
<p>Here are some examples of conditional expressions:</p>
<ul>
<li>
<p>In this example, the test expression is a comparison expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre></div>
</div>
</li>
<li>
<p>In this example, the test expression tests for the existence of an attribute named <code>discounted</code>, independently of its value:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-quantified-expressions" name="id-quantified-expressions"></a>3.9 Quantified Expressions</h3>
<p>Quantified expressions support existential and universal quantification. The value of a quantified expression is always <code>true</code> or <code>false</code>.</p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-QuantifiedExpr" name="doc-xpath-QuantifiedExpr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("some" "$") | ("every" "$")) <a href="#doc-xpath-VarName">VarName</a> "in" <a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href="#doc-xpath-VarName">VarName</a> "in" <a href="#doc-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>quantified expression</b> begins with a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables, followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an expression that returns a sequence of values. The in-clauses generate tuples of variable bindings, using values drawn from the Cartesian product of the sequences returned by the binding expressions.
Conceptually, the test expression is evaluated for each tuple of variable bindings. Results depend on the <b>effective boolean values</b> of the test expressions, as defined in <a href="#id-ebv"><b>2.3.3 Effective Boolean Value</b></a>. The value of the quantified expression is defined by the following rules:</p>
<ol class="enumar">
<li>
<p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <b>effective boolean value</b> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding tuples, the value of the quantified expression is <code>false</code>.</p>
</li>
<li>
<p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <b>effective boolean value</b> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding tuples, the value of the quantified expression is <code>true</code>.</p>
</li>
</ol>
<p>The scope of a variable bound in a quantified expression comprises all subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.</p>
<p>The order in which test expressions are evaluated for the various binding tuples is <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one binding tuple for which the test expression has an <b>effective boolean value</b> of <code>true</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds
one binding tuple for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has an effective boolean value of <code>false</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for which the test expression raises an error. As a result of these rules, the value of a
quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ul>
<li>
<p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $part in //part satisfies $part/@discounted
</pre></div>
</div>
</li>
<li>
<p>This expression is <code>true</code> if at least one <code>employee</code> element satisfies the given comparison expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $emp in //employee satisfies ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</div>
</li>
<li>
<p>In the following examples, each quantified expression evaluates its test expression over nine tuples of variable bindings, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
</div>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
</div>
</li>
<li>
<p>This quantified expression may either return <code>true</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one variable binding and raises a <a title="type error" href="#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
<li>
<p>This quantified expression may either return <code>false</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one variable binding and raises a <a title="type error" href="#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-expressions-on-datatypes" name="id-expressions-on-datatypes"></a>3.10 Expressions on SequenceTypes</h3>
<p><a title="SequenceType" href="#dt-sequence-type">SequenceTypes</a> are used in <code>instance of</code>, <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions.</p>
<div class="div3">
<h4><a id="id-instance-of" name="id-instance-of"></a>3.10.1 Instance Of</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-InstanceofExpr" name="doc-xpath-InstanceofExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a> ( "instance" "of" <a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>The boolean operator <code>instance of</code> returns <code>true</code> if the value of its first operand matches the SequenceType in its second operand, according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a>; otherwise it returns <code>false</code>. For example:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>This example returns <code>true</code> because the given value is an instance of the given type.</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>This example returns <code>true</code> if the context item is an element node. If the context item is undefined, a dynamic error is raised.[<a title="err:XP0002" href="#ERRXP0002">err:XP0002</a>]</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-cast" name="id-cast"></a>3.10.2 Cast</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CastExpr" name="doc-xpath-CastExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a> ( "cast" "as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-SingleType" name="doc-xpath-SingleType"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a> "?"?</code></td>
</tr>
</tbody>
</table>
<p>Occasionally it is necessary to convert a value to a specific datatype. For this purpose, XPath provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the input expression is called the <b>input type</b>. The target type must be a named atomic type, represented by a QName, optionally followed by the occurrence indicator
<code>?</code> if an empty sequence is permitted. If the target type has no namespace prefix, it is considered to be in the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>. The semantics of the <code>cast</code> expression are as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is performed on the input expression.</p>
</li>
<li>
<p>If the result of atomization is a sequence of more than one atomic value, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
<li>
<p>If the result of atomization is an empty sequence:</p>
<ol class="enumla">
<li>
<p>If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is an empty sequence.</p>
</li>
<li>
<p>If <code>?</code> is not specified after the target type, a <a title="type error" href="#dt-type-error">type error</a> is raised.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is a single atomic value, the result of the cast expression depends on the input type and the target type. In general, the cast expression attempts to create a new value of the target type based on the input value. Only certain combinations of input type and target type are supported. A summary of the rules are listed below&#8212; the normative definition of these rules is given in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. For
the purpose of these rules, an implementation may determine that one type is derived by restriction from another type either by examining the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary.</p>
<ol class="enumla">
<li>
<p><code>cast</code> is supported for the combinations of input type and target type listed in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. For each of these combinations, both the input type and the target type are primitive schema types. For example, a value of type <code>xs:string</code> can be cast into the type <code>xs:decimal</code>. For each of these built-in combinations, the semantics of casting are specified in <a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported if the input type is a non-primitive atomic type that is derived by restriction from the target type. In this case, the input value is mapped into the value space of the target type, unchanged except for its type. For example, if <code>shoesize</code> is derived by restriction from <code>xs:integer</code>, a value of type <code>shoesize</code> can be cast into the type <code>xs:integer</code>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a non-primitive atomic type and the input type is <code>xs:string</code> or <code>xdt:untypedAtomic</code>. The input value is first converted to a value in the lexical space of the target type by applying the whitespace normalization rules for the target type; a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [<a title="err:XP0029" href="#ERRXP0029">err:XP0029</a>] is raised if the resulting lexical value does not satisfy the
pattern facet of the target type. The lexical value is then converted to the value space of the target type using the schema-defined rules for the target type; a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>[<a title="err:XP0029" href="#ERRXP0029">err:XP0029</a>] is raised if the resulting value does not satisfy all the facets of the target type.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a non-primitive atomic type that is derived by restriction from the input type. The input value must satisfy all the facets of the target type (in the case of the pattern facet, this is checked by generating a string representation of the input value, using the rules for casting to <code>xs:string</code>). The resulting value is the same as the input value, but with a different dynamic type.</p>
</li>
<li>
<p>If a primitive type P1 can be cast into a primitive type P2, then any type derived by restriction from P1 can be cast into any type derived by restriction from P2, provided that the facets of the target type are satisfied. First the input value is cast to P1 using rule (b) above. Next, the value of type P1 is cast to the type P2, using rule (a) above. Finally, the value of type P2 is cast to the target type, using rule (d) above.</p>
</li>
<li>
<p>For any combination of input type and target type that is not in the above list, a <code>cast</code> expression raises a <a title="type error" href="#dt-type-error">type error</a>.[<a title="err:XP0004" href="#ERRXP0004">err:XP0004</a>][<a title="err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>
</li>
</ol>
</li>
</ol>
<p>If casting from the input type to the target type is supported but nevertheless it is not possible to cast the input value into the value space of the target type, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised.[<a title="err:XP0021" href="#ERRXP0021">err:XP0021</a>] This includes the case when any facet of the target type is not satisfied. For example, the expression <code>"2003-02-31" cast as xs:date</code> would raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="div3">
<h4><a id="id-castable" name="id-castable"></a>3.10.3 Castable</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-CastableExpr" name="doc-xpath-CastableExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a> ( "castable" "as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides an expression that tests whether a given value is castable into a given target type. The expression <code>V castable as T</code> returns <code>true</code> if the value <code>V</code> can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; otherwise it returns <code>false</code>. The <code>castable</code> predicate can be used to avoid errors at evaluation time. It can also be used to select an appropriate type for processing of a given value,
as illustrated in the following example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-constructor-functions" name="id-constructor-functions"></a>3.10.4 Constructor Functions</h4>
<p>For every atomic type in the <a title="in-scope type definitions" href="#dt-is-types">in-scope type definitions</a> that is in a namespace, a <b>constructor function</b> is provided. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for type <em>T</em> is as follows:</p>
<div class="exampleInner">
<pre>
<em>T</em>($arg as xdt:anyAtomicType?) as <em>T?</em>
</pre></div>
<p>Constructor functions are normatively defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. In general, if the argument to a constructor function is of type <code>xs:string</code>, the string is whitespace-normalized and converted to the target type by schema validation; otherwise, the semantics of the constructor function are identical to <code>$arg cast as T</code>.</p>
<p>The following examples illustrate the use of constructor functions:</p>
<ul>
<li>
<p>This example is equivalent to <code>"2000-01-01" cast as xs:date</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</div>
</li>
<li>
<p>This example is equivalent to <code>($floatvalue * 0.2E-5) cast as xs:decimal</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</div>
</li>
<li>
<p>This example returns a <code>xdt:dayTimeDuration</code> value equal to 21 days. It is equivalent to <code>"P21D" cast as xdt:dayTimeDuration</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xdt:dayTimeDuration("P21D")
</pre></div>
</div>
</li>
<li>
<p>If <code>usa:zipcode</code> is a user-defined atomic type in the <a title="in-scope type definitions" href="#dt-is-types">in-scope type definitions</a>, then the following expression is equivalent to the expression <code>"12345" cast as usa:zipcode</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</div>
</li>
</ul>
<p>Atomic types that are not in a namespace do not have constructor functions. To construct an instance of such a type, it is necessary to use a <code>cast</code> expression. For example, if the user-defined type <code>apple</code> is derived from <code>xs:integer</code> but is not in a namespace, an instance of this type can be constructed as follows (but only if the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> is no namespace):</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</div>
</div>
<div class="div3">
<h4><a id="id-treat" name="id-treat"></a>3.10.5 Treat</h4>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="doc-xpath-TreatExpr" name="doc-xpath-TreatExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a> ( "treat" "as" <a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides an expression called <code>treat</code> that can be used to modify the <a title="static type" href="#dt-static-type">static type</a> of its operand.</p>
<p>Like <code>cast</code>, the <code>treat</code> expression takes two operands: an expression and a <a title="SequenceType" href="#dt-sequence-type">SequenceType</a>. Unlike <code>cast</code>, however, <code>treat</code> does not change the dynamic type or value of its operand. Instead, the purpose of <code>treat</code> is to ensure that an expression has an expected type at evaluation time.</p>
<p>The semantics of <em><code>expr1</code></em> <code>treat as</code> <em><code>type1</code></em> are as follows:</p>
<ul>
<li>
<p>During static analysis:</p>
<p>The <a title="static type" href="#dt-static-type">static type</a> of the <code>treat</code> expression is <em><code>type1</code></em>. This enables the expression to be used as an argument of a function that requires a parameter of <em><code>type1</code></em>.</p>
</li>
<li>
<p>During expression evaluation:</p>
<p>If <em><code>expr1</code></em> matches <em><code>type1</code></em>, using the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a>, the <code>treat</code> expression returns the value of <em><code>expr1</code></em>; otherwise, it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>] If the value of <em><code>expr1</code></em> is returned, its identity is preserved. The
<code>treat</code> expression ensures that the value of its expression operand conforms to the expected type at run-time.</p>
</li>
<li>
<p>Example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
</div>
<p>The <a title="static type" href="#dt-static-type">static type</a> of <code>$myaddress</code> may be <code>element(*, Address)</code>, a less specific type than <code>element(*, USAddress)</code>. However, at run-time, the value of <code>$myaddress</code> must match the type <code>element(*, USAddress)</code> using rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a>; otherwise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised.[<a title="err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a id="nt-bnf" name="nt-bnf"></a>A XPath Grammar</h2>
<div class="div2">
<h3><a id="id-grammar" name="id-grammar"></a>A.1 EBNF</h3>
<p>The following grammar uses the same <span>simple</span> Extended Backus-Naur Form (EBNF) notation as <a href="#XML">[XML 1.0]</a> <span>with the following minor differences</span>. The notation "&lt; ... &gt;" is used to indicate a grouping of terminals that together may help disambiguate the individual symbols. To help readability, this "&lt; ... &gt;" notation is absent in the EBNF in the main body of this document. This appendix <span>is</span> the normative version of the EBNF.</p>
<p id="grammar-notes-explanation">Comments on grammar productions are between '/*' and '*/' symbols - please note that these comments are normative. A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing rules, and is explained in <a href="#notes-on-parsing"><b>A.1.1 Grammar Notes</b></a>. A 'ws:' prefix explains the whitespace rules for the production, the details of which are explained in <a href="#whitespace-rules"><b>A.2.2 Whitespace Rules</b></a></p>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-XPath" name="prod-xpath-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Expr" name="prod-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ExprSingle" name="prod-xpath-ExprSingle"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForExpr" name="prod-xpath-ForExpr"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause">SimpleForClause</a> "return" <a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SimpleForClause" name="prod-xpath-SimpleForClause"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"for" "$"&gt; <a href="#prod-xpath-VarName">VarName</a> "in" <a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href="#prod-xpath-VarName">VarName</a> "in" <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-QuantifiedExpr" name="prod-xpath-QuantifiedExpr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(&lt;"some" "$"&gt; | &lt;"every" "$"&gt;) <a href="#prod-xpath-VarName">VarName</a> "in" <a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href="#prod-xpath-VarName">VarName</a> "in" <a href="#prod-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IfExpr" name="prod-xpath-IfExpr"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"if" "("&gt; <a href="#prod-xpath-Expr">Expr</a> ")" "then" <a href="#prod-xpath-ExprSingle">ExprSingle</a> "else" <a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-OrExpr" name="prod-xpath-OrExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a> ( "or" <a href="#prod-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AndExpr" name="prod-xpath-AndExpr"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> ( "and" <a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ComparisonExpr" name="prod-xpath-ComparisonExpr"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a> ( (<a href="#prod-xpath-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath-NodeComp">NodeComp</a>) <a href="#prod-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-RangeExpr" name="prod-xpath-RangeExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> ( "to" <a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AdditiveExpr" name="prod-xpath-AdditiveExpr"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" | "-") <a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-MultiplicativeExpr" name="prod-xpath-MultiplicativeExpr"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a> ( ("*" | "div" | "idiv" | "mod") <a href="#prod-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-UnionExpr" name="prod-xpath-UnionExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union" | "|") <a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IntersectExceptExpr" name="prod-xpath-IntersectExceptExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> ( ("intersect" | "except") <a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-InstanceofExpr" name="prod-xpath-InstanceofExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a> ( &lt;"instance" "of"&gt; <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TreatExpr" name="prod-xpath-TreatExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a> ( &lt;"treat" "as"&gt; <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CastableExpr" name="prod-xpath-CastableExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a> ( &lt;"castable" "as"&gt; <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CastExpr" name="prod-xpath-CastExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a> ( &lt;"cast" "as"&gt; <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-UnaryExpr" name="prod-xpath-UnaryExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ValueExpr" name="prod-xpath-ValueExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-GeneralComp" name="prod-xpath-GeneralComp"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td>
<td><i>/* <a href="#parse-note-lt">gn: lt</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ValueComp" name="prod-xpath-ValueComp"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NodeComp" name="prod-xpath-NodeComp"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PathExpr" name="prod-xpath-PathExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">gn: leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-RelativePathExpr" name="prod-xpath-RelativePathExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a> (("/" | "//") <a href="#prod-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-StepExpr" name="prod-xpath-StepExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AxisStep">AxisStep</a> | <a href="#prod-xpath-FilterExpr">FilterExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AxisStep" name="prod-xpath-AxisStep"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ForwardStep">ForwardStep</a> | <a href="#prod-xpath-ReverseStep">ReverseStep</a>) <a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForwardStep" name="prod-xpath-ForwardStep"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ForwardAxis">ForwardAxis</a> <a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href="#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ForwardAxis" name="prod-xpath-ForwardAxis"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"child" "::"&gt;<br />
| &lt;"descendant" "::"&gt;<br />
| &lt;"attribute" "::"&gt;<br />
| &lt;"self" "::"&gt;<br />
| &lt;"descendant-or-self" "::"&gt;<br />
| &lt;"following-sibling" "::"&gt;<br />
| &lt;"following" "::"&gt;<br />
| &lt;"namespace" "::"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AbbrevForwardStep" name="prod-xpath-AbbrevForwardStep"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href="#prod-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ReverseStep" name="prod-xpath-ReverseStep"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ReverseAxis">ReverseAxis</a> <a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href="#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ReverseAxis" name="prod-xpath-ReverseAxis"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"parent" "::"&gt;<br />
| &lt;"ancestor" "::"&gt;<br />
| &lt;"preceding-sibling" "::"&gt;<br />
| &lt;"preceding" "::"&gt;<br />
| &lt;"ancestor-or-self" "::"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AbbrevReverseStep" name="prod-xpath-AbbrevReverseStep"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NodeTest" name="prod-xpath-NodeTest"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | <a href="#prod-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NameTest" name="prod-xpath-NameTest"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href="#prod-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Wildcard" name="prod-xpath-Wildcard"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| &lt;<a href="#prod-xpath-NCName">NCName</a> ":" "*"&gt;<br />
| &lt;"*" ":" <a href="#prod-xpath-NCName">NCName</a>&gt;</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-FilterExpr" name="prod-xpath-FilterExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-FilterExpr">FilterExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a> <a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PredicateList" name="prod-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Predicate" name="prod-xpath-Predicate"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PrimaryExpr" name="prod-xpath-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a> | <a href="#prod-xpath-VarRef">VarRef</a> | <a href="#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#prod-xpath-ContextItemExpr">ContextItemExpr</a> | <a href="#prod-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Literal" name="prod-xpath-Literal"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a> | <a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NumericLiteral" name="prod-xpath-NumericLiteral"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a> | <a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a> | <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-VarRef" name="prod-xpath-VarRef"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ParenthesizedExpr" name="prod-xpath-ParenthesizedExpr"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ContextItemExpr" name="prod-xpath-ContextItemExpr"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-FunctionCall" name="prod-xpath-FunctionCall"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;<a href="#prod-xpath-QName">QName</a> "("&gt; (<a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-reserved-function-names">gn: reserved-function-names</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SingleType" name="prod-xpath-SingleType"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a> "?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SequenceType" name="prod-xpath-SequenceType"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ItemType">ItemType</a> <a href="#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />
| &lt;"empty" "(" ")"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-OccurrenceIndicator" name="prod-xpath-OccurrenceIndicator"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ItemType" name="prod-xpath-ItemType"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a> | <a href="#prod-xpath-KindTest">KindTest</a> | &lt;"item" "(" ")"&gt;</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AtomicType" name="prod-xpath-AtomicType"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-KindTest" name="prod-xpath-KindTest"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath-AttributeTest">AttributeTest</a><br />
| <a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href="#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xpath-PITest">PITest</a><br />
| <a href="#prod-xpath-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath-TextTest">TextTest</a><br />
| <a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AnyKindTest" name="prod-xpath-AnyKindTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"node" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DocumentTest" name="prod-xpath-DocumentTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"document-node" "("&gt; (<a href="#prod-xpath-ElementTest">ElementTest</a> | <a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TextTest" name="prod-xpath-TextTest"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"text" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CommentTest" name="prod-xpath-CommentTest"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"comment" "("&gt; ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-PITest" name="prod-xpath-PITest"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"processing-instruction" "("&gt; (<a href="#prod-xpath-NCName">NCName</a> | <a href="#prod-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttributeTest" name="prod-xpath-AttributeTest"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"attribute" "("&gt; (<a href="#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> ("," <a href="#prod-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttribNameOrWildcard" name="prod-xpath-AttribNameOrWildcard"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaAttributeTest" name="prod-xpath-SchemaAttributeTest"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"schema-attribute" "("&gt; <a href="#prod-xpath-AttributeDeclaration">AttributeDeclaration</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttributeDeclaration" name="prod-xpath-AttributeDeclaration"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementTest" name="prod-xpath-ElementTest"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"element" "("&gt; (<a href="#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> ("," <a href="#prod-xpath-TypeName">TypeName</a> "?"?)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementNameOrWildcard" name="prod-xpath-ElementNameOrWildcard"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a> | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-SchemaElementTest" name="prod-xpath-SchemaElementTest"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>&lt;"schema-element" "("&gt; <a href="#prod-xpath-ElementDeclaration">ElementDeclaration</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementDeclaration" name="prod-xpath-ElementDeclaration"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-AttributeName" name="prod-xpath-AttributeName"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-ElementName" name="prod-xpath-ElementName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-TypeName" name="prod-xpath-TypeName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<table summary="Scrap" class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-IntegerLiteral" name="prod-xpath-IntegerLiteral"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DecimalLiteral" name="prod-xpath-DecimalLiteral"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href="#prod-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-DoubleLiteral" name="prod-xpath-DoubleLiteral"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href="#prod-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href="#prod-xpath-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-StringLiteral" name="prod-xpath-StringLiteral"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (('"' '"') | [^"])* '"') | ("'" (("'" "'") | [^'])* "'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-VarName" name="prod-xpath-VarName"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Digits" name="prod-xpath-Digits"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Comment" name="prod-xpath-Comment"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href="#prod-xpath-CommentContents">CommentContents</a> | <a href="#prod-xpath-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-CommentContents" name="prod-xpath-CommentContents"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ':)' Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-QName" name="prod-xpath-QName"></a>[78]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-NCName" name="prod-xpath-NCName"></a>[79]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a id="prod-xpath-Char" name="prod-xpath-Char"></a>[80]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">gn: xml-version</a> */</i></td>
</tr>
</tbody>
</table>
<p><span>The following term definitions will be helpful in defining precisely this exposition.</span></p>
<p><span>[<a title="symbol" id="symbol" name="symbol">Definition</a>: Each rule in the grammar defines one <b>symbol</b>, in the form]</span></p>
<div class="exampleInner">
<pre>
<span>symbol ::= expression</span>
</pre></div>
<p><span>[<a title="terminal" id="terminal" name="terminal">Definition</a>: A <b>terminal</b> is a single unit of the grammar that can not be further subdivided, and is specified in the EBNF by a character or characters in quotes, or a regular expression.] The following expressions are used to match strings of one or more characters in a terminal:</span></p>
<dl>
<dt class="label">#xN</dt>
<dd>
<p><span>where N is a hexadecimal integer, the expression matches the character in ISO/IEC 10646 whose canonical (UCS-4) code value, when interpreted as an unsigned binary number, has the value indicated. The number of leading zeros in the #xN form is insignificant; the number of leading zeros in the corresponding code value is governed by the character encoding in use and is not significant for XML.</span></p>
</dd>
<dt class="label">[a-zA-Z], [#xN-#xN]</dt>
<dd>
<p>matches any <span class="xpath"><a href="#prod-xpath-Char">Char</a></span> with a value in the range(s) indicated (inclusive).</p>
</dd>
<dt class="label">[abc], [#xN#xN#xN]</dt>
<dd>
<p>matches any <span class="xpath"><a href="#prod-xpath-Char">Char</a></span> with a value among the characters enumerated. Enumerations and ranges can be mixed in one set of brackets.</p>
</dd>
<dt class="label">[^a-z], [^#xN-#xN]</dt>
<dd>
<p>matches any <span class="xpath"><a href="#prod-xpath-Char">Char</a></span> with a value outside the range indicated.</p>
</dd>
<dt class="label">[^abc], [^#xN#xN#xN]</dt>
<dd>
<p>matches any <span class="xpath"><a href="#prod-xpath-Char">Char</a></span> with a value not among the characters given. Enumerations and ranges of forbidden values can be mixed in one set of brackets.</p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>matches a literal string matching that given inside the double quotes.</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>matches a literal string matching that given inside the single quotes.</p>
</dd>
<dt class="label"><span>[http://example.org/TR/REC-example/#NT-Example]</span></dt>
<dd>
<p><span>matches a production defined in the external specification as per the provided reference. For the purposes of this secification, the entire unit is defined as a terminal.</span></p>
</dd>
</dl>
<p><span>[<a title="production" id="production" name="production">Definition</a>: A <b>production</b> combines symbols to form more complex patterns. ] The following productions serve as examples, where A and B represent simple expressions:</span></p>
<dl>
<dt class="label">(expression)</dt>
<dd>
<p><code>expression</code> is treated as a unit and may be combined as described in this list.</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>matches <code>A</code> followed by <code>B</code>. This operator has higher precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) | (C D)</code>.</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p>matches <code>A</code> or <code>B</code> but not both.</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p>matches one or more occurrences of <code>A</code>.Concatenation has higher precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) | (B+)</code>.</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p>matches zero or more occurrences of <code>A</code>. Concatenation has higher precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) | (B*)</code></p>
</dd>
</dl>
<div class="div3">
<h4><a id="notes-on-parsing" name="notes-on-parsing"></a>A.1.1 Grammar Notes</h4>
<p>This section contains general notes on the EBNF productions, which may be helpful in understanding how to create a parser based on this EBNF, how to read the EBNF, and generally call out issues with the syntax. The notes below are referenced from the right side of the production, with the notation: <em>/* gn: &lt;id&gt; */</em>.</p>
<dl>
<dt class="label"><a id="parse-note-parens" name="parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p>A look-ahead of one character is required to distinguish function patterns from a QName <span>or keyword</span> followed by a <span>Comment</span>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed. <span>Another example is <code>for (: whom the bell :) $tolls = 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</span></p>
</dd>
<dt class="label"><a id="parse-note-lt" name="parse-note-lt"></a>grammar-note: lt</dt>
<dd>
<p>Token disambiguation of the overloaded "&lt;" pattern is defined in terms of positional <a href="#lexical-structure">lexical states</a>. The "&lt;" comparison operator can not occur in the same places as a "&lt;" tag open pattern. The "&lt;" comparison operator can only occur in the <a href="#OPERATOR">OPERATOR</a> state and the "&lt;" tag open pattern can only occur in the <a href="#DEFAULT">DEFAULT</a> <span class="xpath"><span class="xpath">state.</span></span> (These states are only a specification
tool, and do not mandate an implementation strategy for this same effect.)</p>
</dd>
<dt class="label"><a id="parse-note-leading-lone-slash" name="parse-note-leading-lone-slash"></a>grammar-note: leading-lone-slash</dt>
<dd>
<p>The "/" presents an issue because it occurs <span>either as a stand alone unit or as a leading prefix that expects a pattern that will be recognized in the <a href="#DEFAULT">DEFAULT</a> state to follow such as a QName or "*". Both of these patterns also may occur as patterns which are recognized in the <a href="#OPERATOR">OPERATOR</a> state</span>. Thus, expressions such as "/ * 5" can easily be confused with the path expression "/*". Therefore, a stand-alone slash <span>on the right hand side of an
operator</span>, will need to be parenthesized in order to stand alone, as in "(/) * 5". "5 * /", on the other hand, is <span>legal syntax</span>.</p>
</dd>
<dt class="label"><a id="parse-note-comments" name="parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>Expression comments are allowed inside expressions everywhere that <a title="Ignorable whitespace" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed.</p>
<p><span>Comments can nest within each other, as long as all "(:" and ":)" patterns are balanced, no matter where they occur within the outer comment.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><span>Lexical analysis may typically handle nested comments by incrementing a counter for each "(:" pattern, and decrementing the counter for each ":)" pattern. The comment does not terminate until the counter is back to zero.</span></p>
</div>
<p>Following are some illustrative examples:</p>
<ul>
<li>
<p><code>for (: set up loop :) $i in $x return $i</code> will parse correctly, ignoring the comment.</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of xs:integer</code> will also parse correctly, ignoring the comment.</p>
</li>
</ul>
<p>See <a href="#CommentsPragmasExtensions">Comments</a> for further information and examples.</p>
</dd>
<dt class="label"><a id="parse-note-xml-version" name="parse-note-xml-version"></a>grammar-note: xml-version</dt>
<dd>
<p><span>An implementation's choice to support the <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> lexical specification determines the external document from which to obtain the definition for this production. For convenience, XML 1.0 references are always used. In some cases, the XML 1.0 and XML 1.1 definitions may be exactly the same.</span> <span>Also please note that these external productions follow
the whitespace rules of their respective specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><b>A.2.2.1 Default Whitespace Handling</b></a>. Thus <code>prefix : localname</code> is not a valid QName for purposes of this specification, just as it is not permitted in a textual XML document. Also, comments are not permissible on either side of the colon.</span></p>
</dd>
<dt class="label"><a id="parse-note-reserved-function-names" name="parse-note-reserved-function-names"></a><span>grammar-note: reserved-function-names</span></dt>
<dd>
<p><span>Some unprefixed function names may be confused with expression syntax by the parser. For instance, <code>if(foo)</code> could either be a function name invocation or an incomplete <a href="#doc-xpath-IfExpr">IfExpr</a>. Therefore it is not legal syntax for a user to invoke functions with these names. See <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a> for a list of these names.</span></p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a id="lexical-structure" name="lexical-structure"></a>A.2 Lexical structure</h3>
<div class="xpath">
<p class="xpath">A <b>host language</b> may choose whether <span>the lexical rules of</span> <a href="#XML">[XML 1.0]</a> <span>and <a href="#XMLNAMES">[XML Names]</a></span> <span>are followed</span>, or <span>alternatively, the lexical rules of</span><a href="#XML1.1">[XML 1.1]</a> <span>and <a href="#XMLNAMES11">[XML Names 1.1]</a></span> <span>are followed</span>.</p>
</div>
<p>When patterns are simple string matches, the strings are embedded directly into the EBNF. In other cases, named terminals are used.</p>
<p>It is up to an implementation to decide on the exact tokenization strategy, which may be different depending on the parser construction. In the EBNF, the notation "&lt; ... &gt;" is used to indicate a grouping of terminals that together may help disambiguate the individual symbols.</p>
<p>This document uses <a title="lexical state" href="#lexical-state">lexical states</a> to assist with terminal symbol recognition. The states specify lexical constraints and transitions based on grammatical positioning. The rules for calculating these states are given in the <a href="#id-lexical-states"><b>A.2.4 Lexical Rules</b></a> section. The specification of these states in this document does not imply any tokenization strategy on the part of implementations.</p>
<p>When tokenizing, the longest possible match that is valid in the current lexical state is preferred .</p>
<p>All keywords are case sensitive. Keywords are not reserved&#8212;that is, any QName may duplicate a keyword except as noted in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<div class="div3">
<h4><a id="N132F9" name="N132F9"></a>A.2.1 <span>Terminal Types</span></h4>
<p><span>The entire set of <a title="terminal" href="#terminal">terminals</a> in XPath 2.0 may be divided into two major classes, those that can act as token delimiters, and those that can not.</span></p>
<p><span>[<a title="Delimiting Terminal" id="delimiting-token" name="delimiting-token">Definition</a>: A <b>delimiting terminal</b> may delimit adjacent <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminals</a>. Delimiting terminals are only recognized in the appropriate <a title="lexical state" href="#lexical-state">lexical states</a> as specificed by <a href="#id-lexical-states"><b>A.2.4 Lexical Rules</b></a>. ] The following is the list of delimiting
terminals:</span></p>
<p><span>"::", "*", "$", "?", "(", ")", ":", "/", "//", "=", "!=", "&lt;=", "&lt;&lt;", "&gt;=", "&gt;&gt;", "&lt;", "&gt;", "-", "+", "|", "@", "[", "]", ",", ".", "..", <a href="#prod-xpath-Comment">Comment</a>, "(:", ":)"</span></p>
<p><span>[<a title="Non-delimiting Terminal" id="non-delimiting-token" name="non-delimiting-token">Definition</a>: <b>Non-delimiting terminals</b> generally start and end with alphabetic characters or digits. Adjacent non-delimiting terminals must be delimited by a <a title="Delimiting Terminal" href="#delimiting-token">delimiting terminal</a>. Non-delimiting terminals are only recognized in the appropriate <a title="lexical state" href="#lexical-state">lexical states</a> as specificed by <a href=
"#id-lexical-states"><b>A.2.4 Lexical Rules</b></a>. ] The following is the list of non-delimiting terminals:</span></p>
<p><span><a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath-StringLiteral">StringLiteral</a>, "child", "descendant", "parent", "attribute", "self", "descendant-or-self", "ancestor", "following-sibling", "preceding-sibling", "following", "preceding", "namespace", "ancestor-or-self", "unordered", "or", "and", "div", "idiv", "mod", "in", "satisfies", "return", "then", "else", "to", "intersect", "union", "except", "instance",
"of", "castable", "as", "item", "element", "schema-element", "schema-attribute", "empty", "is", "eq", "ne", "gt", "ge", "lt", "le", "some", "every", "for", "cast", "treat", <a href="#prod-xpath-Digits">Digits</a>, "document-node", "node", "comment", "text", "processing-instruction", "if", <a href="#prod-xpath-CommentContents">CommentContents</a>, <a href="#prod-xpath-QName">QName</a>, <a href="#prod-xpath-NCName">NCName</a></span></p>
</div>
<div class="div3">
<h4><a id="whitespace-rules" name="whitespace-rules"></a>A.2.2 Whitespace Rules</h4>
<div class="div4">
<h5><a id="DefaultWhitespaceHandling" name="DefaultWhitespaceHandling"></a>A.2.2.1 Default Whitespace Handling</h5>
<p><span>[<a title="Whitespace" id="Whitespace" name="Whitespace">Definition</a>: <b>Whitespace</b> characters are defined by <a href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a> when these characters occur outside of a <a href="#doc-xpath-StringLiteral">StringLiteral</a>.]</span></p>
<p>[<a title="Ignorable whitespace" id="IgnorableWhitespace" name="IgnorableWhitespace">Definition</a>: <span>Unless otherwise specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.2.2 ExplicitSpecial Whitespace Handling</b></a>), <b>Ignorable whitespace</b> may occur between <a title="terminal" href="#terminal">terminals</a>, and is not significant to the parse tree.</span> For readability, whitespace may be used in most expressions even though not explicitly notated in the EBNF. <span>All allowable
whitespace that is not explicitly specified in the EBNF is ignorable whitespace, and converse, this term does not apply to whitespace that is explicitly specified.</span> ] Whitespace is <span>allowed</span> before the first token and after the last token of <span class="xpath">an expression</span>. Whitespace is optional between <b>delimiting terminals</b>. <span>Whitespace is required to prevent two adjacent <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminal</a> from
being (mis-)recognized as one.</span> <span><a href="#doc-xpath-Comment">Comments</a> may also act as "whitespace" to prevent two adjacent tokens from being recognized as one.</span>. <span>Some illustrative examples are as follows:</span></p>
<ul>
<li>
<p><span><code>foo- foo</code> is a syntax error. "foo-" would be recognized as a QName. The parser would then expect a match in the OPERATOR state for "foo", but would find none.</span></p>
</li>
<li>
<p><span><code>foo -foo</code> parses the same as <code>foo - foo</code>, two QNames separated by a subtraction operator. The parser would match the first "foo" as a QName. The parser would then expect a to match in the OPERATOR state, which is satisfied by "-" (but not "-foo"). The last foo would then be matched as another QName.</span></p>
</li>
<li>
<p><span><code>foo(: This is a comment :)- foo</code> also parses the same as <code>foo - foo</code>. This is because the comment prevents the two adjacent tokens from being recognized as one.</span></p>
<table border="1" summary="Editorial note">
<tr>
<td width="50%" valign="top" align="left"><b>Editorial note</b></td>
<td width="50%" valign="top" align="right">&#160;</td>
</tr>
<tr>
<td valign="top" align="left" colspan="2"><span>In the current test parser, the above fails. So this may need more investigation.</span></td>
</tr>
</table>
</li>
<li>
<p><span><code>foo-foo</code> parses as a single QName. This is because "-" is a valid character in a QName. When used as an operator after the characters of a name, the "-" must be separated from the name, e.g. by using whitespace or parentheses.</span></p>
</li>
<li>
<p><span><code>10div 3</code> results in a syntax error, since the "10" and the "div" would both be <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminals</a> and must be separated by <a title="Delimiting Terminal" href="#delimiting-token">delimiting terminals</a> in order to be recognized.</span></p>
</li>
<li>
<p><span><code>10 div3</code> also results in a syntax error, since the "div" and the "3" would both be <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminals</a> and must be separated by <a title="Delimiting Terminal" href="#delimiting-token">delimiting terminals</a> in order to be recognized.</span></p>
</li>
<li>
<p><span><code>10div3</code> also results in a syntax error, since the "10", "div" and the "3" would all be <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminals</a> and must be separated by <a title="Delimiting Terminal" href="#delimiting-token">delimiting terminals</a> in order to be recognized.</span></p>
</li>
</ul>
</div>
<div class="div4">
<h5><a id="ExplicitWhitespaceHandling" name="ExplicitWhitespaceHandling"></a>A.2.2.2 <span>Explicit</span> Whitespace Handling</h5>
<p><span>Explict</span> whitespace notation is specified with the EBNF productions, when it is different from the default rules, as follows. <span>These notations do not inherit. In other words, if EBNF rule is marked as /* ws: explicit */, the rule does not automatically apply to all the 'child' EBNF productions of that rule.</span></p>
<dl>
<dt class="label"><a id="ws-explicit" name="ws-explicit"></a><span>ws:</span>explicit</dt>
<dd>
<p>"ws: explicit" means that the EBNF notation <code>S</code> explicitly notates where whitespace is allowed. <span>In productions with this notation, <a href="#DefaultWhitespaceHandling"><b>A.2.2.1 Default Whitespace Handling</b></a> does not apply.</span> <span><a href="#doc-xpath-Comment">Comments</a> are also not allowed in these productions.</span></p>
</dd>
<dt class="label"><a id="ws-significant" name="ws-significant"></a></dt>
</dl>
</div>
</div>
<div class="div3">
<h4><a id="CommentsPragmasExtensions" name="CommentsPragmasExtensions"></a>A.2.3 <span>Comments</span></h4>
<p><span>Comments are allowed to nest, though the content of a comment must have balanced comment delimiters without regard to structure. Some illustrative examples:</span></p>
<ul>
<li>
<p><span><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a legal Comment, since balanced nesting of comments is allowed.</span></p>
</li>
<li>
<p><span><code>"this is just a string :)"</code> is a legal expression. However, <code>(: "this is just a string :)" :)</code> will cause a syntax error. Likewise, <code>"this is another string (:"</code> is a legal expression, but <code>(: "this is another string (:" :)</code> will cause a syntax error. It is a limitation of nested comments that literal content can cause unbalanced nesting of comments.</span></p>
</li>
</ul>
</div>
<div class="div3">
<h4><a id="id-lexical-states" name="id-lexical-states"></a>A.2.4 Lexical Rules</h4>
<p>The lexical contexts and transitions between lexical contexts is described in terms of a series of states and transitions between those states.</p>
<p><span>[<a title="lexical state" id="lexical-state" name="lexical-state">Definition</a>: A <b>lexical state</b> is a condition where a defined set of patterns are recognized.]</span> The tables below define the complete lexical rules for XPath. Each <span>two column</span> table corresponds to a lexical state and <span>lists in the first column</span> the tokens <span>that</span>are recognized when in that state. <span>Any token not listed should result in a syntax error when in that state.</span> When a
given token is recognized in the given state, the transition to the next state <span>and/or a lexical action</span> is given <span>in the right column</span>. <span>[<a title="lexical action" id="lexical-action" name="lexical-action">Definition</a>: A <b>lexical action</b> is an action that occurs as an side-effect of a pattern recognition.] Following are a list of lexical actions used in the tables:</span></p>
<dl>
<dt class="label"><a id="lexaction-pushstate" name="lexaction-pushstate"></a><span>pushState()</span></dt>
<dd>
<p><span>The current state, <em>before the transition</em>, is pushed onto an abstract stack.</span></p>
</dd>
<dt class="label"><a id="lexaction-pushstate-with-param" name="lexaction-pushstate-with-param"></a><span>pushState(<em>STATE</em>)</span></dt>
<dd>
<p><span>A STATE parameter is pushed onto an abstract stack.</span></p>
</dd>
<dt class="label"><a id="lexaction-popstate" name="lexaction-popstate"></a><span>popState()</span></dt>
<dd>
<p><span>The most recently pushed state is removed from the top of the stack, and becomes the current state.</span></p>
</dd>
<dt class="label"><a id="lexaction-backup" name="lexaction-backup"></a><span>input_stream.backup(<em>n</em>)</span></dt>
<dd>
<p><span>This is a special action that backs up the character stream by <em>n</em> characters. See the <a href="#OCCURRENCEINDICATOR">description of the OCCURRENCEINDICATOR state</a> for more information.</span></p>
</dd>
<dt class="label"><a id="lexaction-maintain-state" name="lexaction-maintain-state"></a><span>(maintain state)</span></dt>
<dd>
<p><span>This simply means that the current state is maintained with no modification.</span></p>
</dd>
</dl>
<p>The lexical states have, in many cases, close connection to the parser productions. However, just because a token is recognized in a certain lexical state, does not mean it will be legal in the current EBNF production.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no requirement for a lexer/parser to be implemented in terms of lexical states&#8212;these are only a way to specify the behavior. The only requirement is to produce results that are consistent with the results of these tables.</p>
</div>
<dl>
<dt class="label"><a id="DEFAULT" name="DEFAULT"></a>The DEFAULT State</dt>
<dd>
<p>This state is for patterns that occur at the beginning of an expression or subexpression.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a>, "..", ".", <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a>, NotNumber, &lt;<a href="#prod-xpath-NCName">NCName</a> ":" "*"&gt;, <a href="#prod-xpath-QName">QName</a>, ")", &lt;"*" ":" <a href="#prod-xpath-NCName">NCName</a>&gt;, "*", <a href="#prod-xpath-StringLiteral">StringLiteral</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"$", &lt;"for" "$"&gt;, &lt;"some" "$"&gt;, &lt;"every" "$"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#VARNAME">VARNAME</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"element" "("&gt;, &lt;"attribute" "("&gt;, &lt;"schema-element" "("&gt;, &lt;"schema-attribute" "("&gt;, &lt;"comment" "("&gt;, &lt;"text" "("&gt;, &lt;"node" "("&gt;, &lt;"document-node" "("&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate-with-param">pushState(OPERATOR)</a></td>
</tr>
<tr>
<td><a href="#KINDTEST">KINDTEST</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"processing-instruction" "("&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate-with-param">pushState(OPERATOR)</a></td>
</tr>
<tr>
<td><a href="#KINDTESTFORPI">KINDTESTFORPI</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"@", &lt;"ancestor-or-self" "::"&gt;, &lt;"ancestor" "::"&gt;, &lt;"attribute" "::"&gt;, &lt;"child" "::"&gt;, &lt;"descendant-or-self" "::"&gt;, &lt;"descendant" "::"&gt;, &lt;"following-sibling" "::"&gt;, &lt;"following" "::"&gt;, &lt;"namespace" "::"&gt;, &lt;"parent" "::"&gt;, &lt;"preceding-sibling" "::"&gt;, &lt;"preceding" "::"&gt;, &lt;"self" "::"&gt;, ",", &lt;"if" "("&gt;, "(", "-", "+", &lt;<a href="#prod-xpath-QName">QName</a> "("&gt;, "//", "/"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-maintain-state">(maintain state)</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="OPERATOR" name="OPERATOR"></a>The OPERATOR State</dt>
<dd>
<p>This state is for patterns that are defined for operators.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>"then", "else", "and", ",", "div", "=", "except", "eq", "ge", "gt", "le", "lt", "ne", "&gt;=", "&gt;&gt;", "&gt;", "idiv", "intersect", "in", "is", "[", "&lt;=", "&lt;&lt;", "&lt;", "-", "mod", "*", "!=", "or", "+", "return", "satisfies", "//", "/", "to", "union", "|", Unordered</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#DEFAULT">DEFAULT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"castable" "as"&gt;, &lt;"cast" "as"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#SINGLETYPE">SINGLETYPE</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"instance" "of"&gt;, &lt;"treat" "as"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#ITEMTYPE">ITEMTYPE</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"$", &lt;"for" "$"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#VARNAME">VARNAME</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"?", "]", ")", <a href="#prod-xpath-StringLiteral">StringLiteral</a>, NotOperatorKeyword</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-maintain-state">(maintain state)</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="SINGLETYPE" name="SINGLETYPE"></a>The SINGLETYPE State</dt>
<dd>
<p>This state distinguishes tokens that can occur only inside the SingleType production.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#prod-xpath-QName">QName</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="ITEMTYPE" name="ITEMTYPE"></a>The ITEMTYPE State</dt>
<dd>
<p>This state distinguishes tokens that can occur only inside the ItemType production.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;"empty" "(" ")"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"element" "("&gt;, &lt;"attribute" "("&gt;, &lt;"schema-element" "("&gt;, &lt;"schema-attribute" "("&gt;, &lt;"comment" "("&gt;, &lt;"text" "("&gt;, &lt;"node" "("&gt;, &lt;"document-node" "("&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate-with-param">pushState(OCCURRENCEINDICATOR)</a></td>
</tr>
<tr>
<td><a href="#KINDTEST">KINDTEST</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"processing-instruction" "("&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate-with-param">pushState(OCCURRENCEINDICATOR)</a></td>
</tr>
<tr>
<td><a href="#KINDTESTFORPI">KINDTESTFORPI</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td><a href="#prod-xpath-QName">QName</a>, &lt;"item" "(" ")"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OCCURRENCEINDICATOR">OCCURRENCEINDICATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"then", "else"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#DEFAULT">DEFAULT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"and", ",", "div", "=", "except", "eq", "ge", "gt", "le", "lt", "ne", "&gt;=", "&gt;&gt;", "&gt;", "idiv", "intersect", "in", "is", "[", "(", "&lt;=", "&lt;&lt;", "&lt;", "-", "mod", "!=", "or", "return", "satisfies", "to", "union", "|"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#DEFAULT">DEFAULT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"castable" "as"&gt;, &lt;"cast" "as"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#SINGLETYPE">SINGLETYPE</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"instance" "of"&gt;, &lt;"treat" "as"&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#ITEMTYPE">ITEMTYPE</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="KINDTEST" name="KINDTEST"></a>The KINDTEST State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>")"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-popstate">popState()</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"*", <a href="#prod-xpath-QName">QName</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#CLOSEKINDTEST">CLOSEKINDTEST</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&lt;"element" "("&gt;, &lt;"schema-element" "("&gt;</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate-with-param">pushState(KINDTEST)</a></td>
</tr>
<tr>
<td><a href="#KINDTEST">KINDTEST</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="KINDTESTFORPI" name="KINDTESTFORPI"></a>The KINDTESTFORPI State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>")"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-popstate">popState()</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td><a href="#prod-xpath-NCName">NCName</a>, <a href="#prod-xpath-StringLiteral">StringLiteral</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-maintain-state">(maintain state)</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="CLOSEKINDTEST" name="CLOSEKINDTEST"></a>The CLOSEKINDTEST State</dt>
<dd>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>")"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-popstate">popState()</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>","</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#KINDTEST">KINDTEST</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"?"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-maintain-state">(maintain state)</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="OCCURRENCEINDICATOR" name="OCCURRENCEINDICATOR"></a>The OCCURRENCEINDICATOR State</dt>
<dd>
<p>This special state is needed to distinguish occurrence indicators that appear in the SequenceType production. For instance, compare "foo instance of baz*" to "baz*foo". In the first case, the "*" is interpreted as an occurrence indicator, and in the second case, it must be interpreted as a multiplication operator. But, when in the OCCURRENCEINDICATOR state, if anything else other than "?", "*", and "+", those symbols must be interpreted in the OPERATOR state. For instance, this would occur with the
expression "foo instance of baz and $x", with the operator "and". This backing up of the lexical characters in order to reset the state, is symbolized by the notation "input_stream.backup(1)". NotOccurrenceIndicator is a special symbol for any character that is not an occurrence indicator.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>[NotOccurrenceIndicator]</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-backup">input_stream.backup(1)</a></td>
</tr>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"?", "*", "+"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="VARNAME" name="VARNAME"></a>The VARNAME State</dt>
<dd>
<p>This state differentiates variable names from qualified names. This allows only the pattern of a QName to be recognized when otherwise ambiguities could occur.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#prod-xpath-VarName">VarName</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#OPERATOR">OPERATOR</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
<dt class="label"><a id="EXPR_COMMENT" name="EXPR_COMMENT"></a>The EXPR_COMMENT State</dt>
<dd>
<p>The "(:" token marks the beginning of an expression Comment, and the ":)" token marks the end. This allows no special interpretation of other characters in this state.</p>
<table summary="Transition table" border="1">
<thead>
<tr>
<th>Pattern</th>
<th>Transition To State</th>
</tr>
</thead>
<tbody>
<tr>
<td>":)"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-popstate">popState()</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>"(:"</td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-pushstate">pushState()</a></td>
</tr>
<tr>
<td><a href="#EXPR_COMMENT">EXPR_COMMENT</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td><a href="#prod-xpath-Char">Char</a></td>
<td>
<table summary="Transition table">
<tbody>
<tr>
<td><a href="#lexaction-maintain-state">(maintain state)</a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><br /></p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a id="id-reserved-fn-names" name="id-reserved-fn-names"></a>A.3 Reserved Function Names</h3>
<p>The following is a list of names that must not be used as user function names in an unprefixed form, because these functions could be confused with expression syntax. <span>Users should not have unprefixed invocations of functions with these names, and if they want to protect themselves from future changes they should use the prefixed form, or put a distinctive string in their function names.</span></p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>type</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the keyword typeswitch is not used in XPath, it is considered a reserved function name for compatibility with XQuery.</p>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="id-precedence-order" name="id-precedence-order"></a>A.4 Precedence Order</h3>
<p><span>The grammar defines built-in precedence, which is summarised here. Operators that have a lower precedence number can not be contained by operators with a higher precedence number. Operators may contain other operators with the same precedence number on the right-hand-side. In the cases where a number of operators are at the same precedence level, the operators are applied from left to right.</span></p>
<p>The operators in order of increasing precedence are:</p>
<table border="1">
<tbody>
<tr>
<td>1</td>
<td>(comma)</td>
</tr>
<tr>
<td>2</td>
<td><span><span class="xpath"><span class="xpath"><a href="#doc-xpath-ForExpr">for</a>,</span></span></span> <a href="#doc-xpath-QuantifiedExpr">some, every</a>, <span><a href="#doc-xpath-IfExpr">if</a></span></td>
</tr>
<tr>
<td>3</td>
<td><a href="#doc-xpath-OrExpr">or</a></td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xpath-AndExpr">and</a></td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xpath-ValueComp">eq, ne, lt, le, gt, ge</a>, <a href="#doc-xpath-GeneralComp">=, !=, &lt;, &lt;=, &gt;, &gt;=</a>, <a href="#doc-xpath-NodeComp">is</a>, <a href="#doc-xpath-NodeComp">&lt;&lt;, &gt;&gt;</a></td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xpath-RangeExpr">to</a></td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xpath-AdditiveExpr">+, -</a></td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xpath-MultiplicativeExpr">*, div, idiv, mod</a></td>
</tr>
<tr>
<td>9</td>
<td><span><a href="#doc-xpath-UnaryExpr">-(unary), +(unary)</a></span></td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xpath-UnionExpr">union, |</a></td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xpath-IntersectExceptExpr">intersect, except</a></td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xpath-InstanceofExpr">instance of</a></td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xpath-TreatExpr">treat</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xpath-CastableExpr">castable</a></td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xpath-CastExpr">cast</a></td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xpath-PathExpr">/, //</a></td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xpath-PredicateList">[ ]</a><span>, <a href="#doc-xpath-ParenthesizedExpr">( )</a></span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a id="N13BF6" name="N13BF6"></a>B Type Promotion and Operator Mapping</h2>
<div class="div2">
<h3><a id="promotion" name="promotion"></a>B.1 Type Promotion</h3>
<p>[<a title="type promotion" id="dt-type-promotion" name="dt-type-promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from one type to another. <b>Type promotion</b> is used in function calls (see <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a>) and in processing of operators that accept numeric operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).] The following type promotions are permitted:</p>
<ol class="enumar">
<li>
<p>A value of type <code>xs:float</code> (or any type derived by restriction from <code>xs:float</code>) can be promoted to the type <code>xs:double</code>. The result is the <code>xs:double</code> value that is the same as the original value.</p>
</li>
<li>
<p>A value of type <code>xs:decimal</code> (or any type derived by restriction from <code>xs:decimal</code>) can be promoted to either of the types <code>xs:float</code> or <code>xs:double</code>. The result of this promotion is created by casting the original value to the required type. This kind of promotion may cause loss of precision.</p>
</li>
</ol>
<p>Note that <a title="type promotion" href="#dt-type-promotion">type promotion</a> is different from <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. For example:</p>
<ul>
<li>
<p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <a title="type promotion" href="#dt-type-promotion">type promotion</a>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p>
</li>
<li>
<p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a id="mapping" name="mapping"></a>B.2 Operator Mapping</h3>
<p>The tables in this section list the combinations of types for which the various operators of XPath are defined in terms of functions that are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. The <code>and</code> and <code>or</code> operators are defined directly in the main body of this document, and do not occur in this table. For each valid combination of types, the table indicates the function(s) that are used to implement the operator and the type
of the result. Note that in some cases the function does not implement the full semantics of the given operator. For the definition of each operator (including its behavior for empty sequences or sequences of length greater than one), see the descriptive material in the main part of this document.</p>
<p>Any operator listed in the tables may be validly applied to an operand of type <em>AT</em> if the table calls for an operand of type <em>ET</em> and <code>type-matches(</code><em>ET, AT</em><code>)</code> is <code>true</code> (see <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>). For example, a table entry indicates that the <code>gt</code> operator may be applied to two <code>xs:date</code> operands, returning <code>xs:boolean</code>. Therefore, the <code>gt</code> operator
may also be applied to two (possibly different) subtypes of <code>xs:date</code>, also returning <code>xs:boolean</code>.</p>
<p>In the operator tables, the term <b>numeric</b> refers to the types <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, and <code>xs:double</code>. An operator whose operands and result are designated as <b>numeric</b> might be thought of as representing four operators, one for each of the numeric types. For example, the numeric <code>+</code> operator might be thought of as representing the following four operators:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">Operator</td>
<td align="center">First operand type</td>
<td align="center">Second operand type</td>
<td align="center">Result type</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p>A numeric operator may be validly applied to an operand of type <em>AT</em> if <code>type-matches(</code><em>ET, AT</em><code>)</code> is true where <em>ET</em> is any of the four numeric types. If the result type of an operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a> and <a title=
"type promotion" href="#dt-type-promotion">type promotion</a>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>. Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>. Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result
of type <code>xs:integer</code>.</p>
<p>In the following tables, the term <b>Gregorian</b> refers to the types <code>xs:gYearMonth</code>, <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and <code>xs:gMonth</code>. For binary operators that accept two Gregorian-type operands, both operands must have the same type (for example, if one operand is of type <code>xs:gDay</code>, the other operand must be of type <code>xs:gDay</code>.)</p>
<div class="small">
<table border="1" summary="Binary operators" class="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th>Operator</th>
<th>Type(A)</th>
<th>Type(B)</th>
<th>Function</th>
<th>Result type</th>
</tr>
<tr>
<td>A + B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-add(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xdt:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xdt:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xdt:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:datetime</td>
<td>xdt:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:yearMonthDuration</td>
<td>xs:datetime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:datetime</td>
<td>xdt:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:dayTimeDuration</td>
<td>xs:datetime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xdt:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-subtract(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:subtract-dates-yielding-dayTimeDuration(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xdt:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xdt:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xdt:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:datetime</td>
<td>xs:datetime</td>
<td>fn:subtract-dateTimes-yielding-dayTimeDuration(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:datetime</td>
<td>xdt:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:datetime</td>
<td>xdt:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xdt:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-multiply(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A * B</td>
<td>xdt:yearMonthDuration</td>
<td>numeric</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xdt:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xdt:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xdt:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xdt:dayTimeDuration</td>
<td>numeric</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xdt:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:integer-div(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-divide(A, B)</td>
<td>numeric; but xs:decimal if both operands are xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>xdt:yearMonthDuration</td>
<td>numeric</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xdt:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xdt:dayTimeDuration</td>
<td>numeric</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xdt:dayTimeDuration</td>
</tr>
<tr>
<td>A mod B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-mod(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A eq B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>op:yearMonthDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hex-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:anyURI-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 1))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hex-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:anyURI-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td></td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td></td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xdt:yearMonthDuration</td>
<td>xdt:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xdt:dayTimeDuration</td>
<td>xdt:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer+</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
</tbody>
</table>
</div>
<div class="small">
<table border="1" summary="Unary operators" class="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th>Operator</th>
<th>Operand type</th>
<th>Function</th>
<th>Result type</th>
</tr>
<tr>
<td>+ A</td>
<td>numeric</td>
<td>op:numeric-unary-plus(A)</td>
<td>numeric</td>
</tr>
<tr>
<td>- A</td>
<td>numeric</td>
<td>op:numeric-unary-minus(A)</td>
<td>numeric</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="id-xp-context-components" name="id-xp-context-components"></a>C Context Components</h2>
<p>The tables in this section describe the scope (range of applicability) of the various components in the static context and dynamic context.</p>
<div class="div2">
<h3><a id="id-xp-static-context-components" name="id-xp-static-context-components"></a>C.1 Static Context Components</h3>
<p>The following table describes the components of the <b>static context</b>. For each component, "global" indicates that the value of the component applies throughout an XPath expression, whereas "lexical" indicates that the value of the component applies only within the subexpression in which it is defined.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class="small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th>Component</th>
<th>Scope</th>
</tr>
<tr>
<td>XPath 1.0 Compatability Mode</td>
<td>global</td>
</tr>
<tr>
<td>Statically known namespaces</td>
<td>global</td>
</tr>
<tr>
<td>Default element/type namespace</td>
<td>global</td>
</tr>
<tr>
<td>Default function namespace</td>
<td>global</td>
</tr>
<tr>
<td>In-scope type definitions</td>
<td>global</td>
</tr>
<tr>
<td>In-scope element declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope attribute declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope variables</td>
<td>lexical; for-expressions and quantified expressions can bind new variables</td>
</tr>
<tr>
<td>Context item static type</td>
<td>lexical</td>
</tr>
<tr>
<td>Function signatures</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collations</td>
<td>global</td>
</tr>
<tr>
<td>Default collation</td>
<td>global</td>
</tr>
<tr>
<td>Base URI</td>
<td>global</td>
</tr>
<tr>
<td>Statically known documents</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collections</td>
<td>global</td>
</tr>
<tr>
<td>XQuery Flagger status</td>
<td>global</td>
</tr>
<tr>
<td>XQuery Static Flagger status</td>
<td>global</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div2">
<h3><a id="id-xp-evaluation-context-components" name="id-xp-evaluation-context-components"></a>C.2 Dynamic Context Components</h3>
<p>The following table describes how values are assigned to the various components of the <b>dynamic context</b>. All these components are initialized by mechanisms defined by the host language. For each component, "global" indicates that the value of the component remains constant throughout evaluation of the XPath expression, whereas "dynamic" indicates that the value of the component can be modified by the evaluation of subexpressions.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class="small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th>Component</th>
<th>Scope</th>
</tr>
<tr>
<td>Context item</td>
<td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
<td>Context position</td>
<td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
<td>Context size</td>
<td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
<td>Variable values</td>
<td>dynamic; for-expressions and quantified expressions can bind new variables</td>
</tr>
<tr>
<td>Current date and time</td>
<td>global</td>
</tr>
<tr>
<td>Implicit timezone</td>
<td>global</td>
</tr>
<tr>
<td>Available documents</td>
<td>global</td>
</tr>
<tr>
<td>Available collections</td>
<td>global</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a id="id-references" name="id-references"></a>D References</h2>
<div class="div2">
<h3><a id="id-normative-references" name="id-normative-references"></a>D.1 Normative References</h3>
<dl>
<dt class="label"><a id="FunctionsAndOperators" name="FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and Operators</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Functions and Operators</em> W3C Working Draft, 23 Jul. 2004. See <a href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a></dd>
<dt class="label"><a id="XQueryFormalSemantics" name="XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal Semantics</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal Semantics</em>. W3C Working Draft, 20 Feb. 2004. See <a href="http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>
<dt class="label"><a id="XMLSchema" name="XMLSchema"></a>XML Schema</dt>
<dd>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2</em>. W3C Recommendation, 2 May 2001. See <a href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/</a>, <a href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a>, and <a href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>.</dd>
<dt class="label"><a id="datamodel" name="datamodel"></a>XQuery 1.0 and XPath 2.0 Data Model</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Data Model</em>. W3C Working Draft, 23 Jul. 2004. See <a href="http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>
<dt class="label"><a id="serialization" name="serialization"></a>XSLT 2.0 and XQuery 1.0 Serialization</dt>
<dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery 1.0 Serialization</em>. W3C Working Draft, 23 Jul. 2004. See <a href="http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>
<dt class="label"><a id="XML" name="XML"></a>XML 1.0</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a></dd>
<dt class="label"><a id="XML1.1" name="XML1.1"></a>XML 1.1</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.1.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></dd>
<dt class="label"><a id="XMLNAMES" name="XMLNAMES"></a>XML Names</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>
<dt class="label"><a id="XMLNAMES11" name="XMLNAMES11"></a>XML Names 1.1</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></dd>
<dt class="label"><a id="ISO10646" name="ISO10646"></a>ISO/IEC 10646</dt>
<dd>ISO (International Organization for Standardization). <em>ISO/IEC 10646-1993 (E). Information technology&#8212;Universal Multiple-Octet Coded Character Set (UCS)&#8212;Part 1: Architecture and Basic Multilingual Plane.</em> [Geneva]: International Organization for Standardization, 1993 (plus amendments AM 1 through AM 7).</dd>
<dt class="label"><a id="ISO10646-2000" name="ISO10646-2000"></a>ISO/IEC 10646-2000</dt>
<dd>ISO (International Organization for Standardization). <em>ISO/IEC 10646-1:2000. Information technology&#8212;Universal Multiple-Octet Coded Character Set (UCS)&#8212;Part 1: Architecture and Basic Multilingual Plane.</em> [Geneva]: International Organization for Standardization, 2000.</dd>
<dt class="label"><a id="Unicode" name="Unicode"></a>Unicode</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard, Version 2.0.</em> Reading, Mass.: Addison-Wesley Developers Press, 1996.</dd>
<dt class="label"><a id="Unicode3" name="Unicode3"></a>Unicode3</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard, Version 3.0.</em> Reading, Mass.: Addison-Wesley Developers Press, 2000. ISBN 0-201-61633-5.</dd>
</dl>
</div>
<div class="div2">
<h3><a id="id-non-normative-references" name="id-non-normative-references"></a>D.2 Non-normative References</h3>
<dl>
<dt class="label"><span class="xpath"><a id="XPath-Requirements" name="XPath-Requirements"></a>XPath 2.0 Requirements</span></dt>
<dd>
<div class="xpath">World Wide Web Consortium. <em>XPath Requirements Version 2.0</em>. W3C Working Draft 22 August 2003. See <a href="http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.</div>
</dd>
<dt class="label"><span class="xpath"><a id="xquery" name="xquery"></a>XQuery</span></dt>
<dd>
<div class="xpath">World Wide Web Consortium. <em>XQuery 1.0: An XML Query Language</em>. W3C Working Draft, 23 Jul. 2004. See <a href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a></div>
</dd>
<dt class="label"><a id="XSLT" name="XSLT"></a>XSLT 2.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT) 2.0.</em> W3C Working Draft. See <a href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>
<dt class="label"><a id="ISO8601" name="ISO8601"></a>ISO 8601</dt>
<dd>International Organization for Standardization (ISO). <em>Representations of Dates and Times, 2000-08-03.</em> Available from <a href="http://www.iso.ch/">http://www.iso.ch/</a></dd>
</dl>
</div>
<div class="div2">
<h3><a id="id-informative-material" name="id-informative-material"></a>D.3 Non-normative Informative Material</h3>
<dl>
<dt class="label"><a id="RFC2396" name="RFC2396"></a>RFC2396</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 2396. See <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>
<dt class="label"><a id="CHARMOD" name="CHARMOD"></a>Character Model</dt>
<dd>World Wide Web Consortium. <em>Character Model for the World Wide Web.</em> W3C Working Draft. See <a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a></dd>
<dt class="label"><a id="XINFO" name="XINFO"></a>XML Infoset</dt>
<dd>World Wide Web Consortium. <em>XML Information Set.</em> W3C Recommendation 24 October 2001. See <a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>
<dt class="label"><a id="XPath" name="XPath"></a>XPath 1.0</dt>
<dd>World Wide Web Consortium. <em>XML Path Language (XPath) Version 1.0</em>. W3C Recommendation, Nov. 16, 1999. See <a href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
<dt class="label"><a id="XPTR" name="XPTR"></a>XPointer</dt>
<dd>World Wide Web Consortium. <em>XML Pointer Language (XPointer).</em> W3C Last Call Working Draft 8 January 2001. See <a href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>
<dt class="label"><a id="XSLT1" name="XSLT1"></a>XSLT 1.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
</dl>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="N14916" name="N14916"></a>E Conformance</h2>
<p>XPath is intended primarily as a component that can be used by other specifications. Therefore, XPath relies on specifications that use it (such as <a href="#XPTR">[XPointer]</a> and <a href="#XSLT">[XSLT 2.0]</a>) to specify conformance criteria for XPath in their respective environments. Specifications that set conformance criteria for their use of XPath must not change the syntactic or semantic definitions of XPath as given in this specification, except by subsetting and/or compatible extensions.</p>
</div>
</div>
<div class="div1">
<h2><a id="id-glossary" name="id-glossary"></a>F Glossary</h2>
<dl>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic value</dt>
<dd>
<p>An <b>atomic value</b> is a value in the value space of an <b>atomic type</b>, including all the atomic types defined in <a href="#XMLSchema">[XML Schema]</a> and <a title="xdt:untypedAtomic" href="#dt-untypedAtomic">xdt:untypedAtomic</a>.</p>
</dd>
<dt><a name="GLdt-atomization" id="GLdt-atomization"></a>atomization</dt>
<dd>
<p><b>Atomization</b> is applied to a value when the value is used in a context in which a sequence of atomic values is required. The result of atomization is either a sequence of atomic values or a <a title="type error" href="#dt-type-error">type error</a>. Atomization of a sequence is defined as the result of invoking the <code>fn:data</code> function on the sequence, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
</dd>
<dt><a name="GLdt-available-collections" id="GLdt-available-collections"></a>available collections</dt>
<dd>
<p><b>Available collections.</b> This is a mapping of strings onto sequences of nodes. The string represents the absolute URI of a resource. The sequence of nodes represents the result of the <code>fn:collection</code> function when that URI is supplied as the argument.</p>
</dd>
<dt><a name="GLdt-available-docs" id="GLdt-available-docs"></a>available documents</dt>
<dd>
<p><b>Available documents.</b> This is a mapping of strings onto document nodes. The string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.</p>
</dd>
<dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base URI</dt>
<dd>
<p><b>Base URI.</b> This is an absolute URI, used when necessary in the resolution of relative URIs (for example, by the <code>fn:resolve-uri</code> function.)</p>
</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context item</dt>
<dd>
<p>The <b>context item</b> is the item currently being processed. An item is either an atomic value or a node.</p>
</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context node</dt>
<dd>
<p>When the context item is a node, it can also be referred to as the <b>context node</b>.</p>
</dd>
<dt><a name="GLdt-context-position" id="GLdt-context-position"></a>context position</dt>
<dd>
<p>The <b>context position</b> is the position of the context item within the sequence of items currently being processed.</p>
</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context size</dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence of items currently being processed.</p>
</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current date and time</dt>
<dd>
<p><b>Current date and time.</b> This information represents an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during processing of a query or transformation. It can be retrieved by the <code>fn:current-date</code>, <code>fn:current-time</code>, and <code>fn:current-dateTime</code> functions. If invoked multiple times during the execution of a query or transformation, these functions always return the same result.</p>
</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data model</dt>
<dd>
<p>XPath operates on the abstract, logical structure of an XML document, rather than its surface syntax. This logical structure is known as the <b>data model</b>, which is defined in the <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> document.</p>
</dd>
<dt><a name="GLdt-data-model-schema" id="GLdt-data-model-schema"></a>data model schema</dt>
<dd>
<p>For a given node in the <a title="data model" href="#dt-datamodel">data model</a>, the <b>data model schema</b> is defined as the schema from which the type annotation of that node was derived.</p>
</dd>
<dt><a name="GLdt-def-collation" id="GLdt-def-collation"></a>default collation</dt>
<dd>
<p><b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the collation to be used by string comparison functions and operators when no explicit collation is specified.</p>
</dd>
<dt><a name="GLdt-def-elemtype-ns" id="GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<p><b>Default element/type namespace.</b> This is a namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where an element or type name is expected.</p>
</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default function namespace</dt>
<dd>
<p><b>Default function namespace.</b> This is a namespace URI that is used for any unprefixed QName appearing as the function name in a function call. The initial default function namespace may be provided by the external environment.</p>
</dd>
<dt><a name="GLdelimiting-token" id="GLdelimiting-token"></a>Delimiting Terminal</dt>
<dd>
<p>A <b>delimiting terminal</b> may delimit adjacent <a title="Non-delimiting Terminal" href="#non-delimiting-token">non-delimiting terminals</a>. Delimiting terminals are only recognized in the appropriate <a title="lexical state" href="#lexical-state">lexical states</a> as specificed by <a href="#id-lexical-states"><b>A.2.4 Lexical Rules</b></a>.</p>
</dd>
<dt><a name="GLdt-document-order" id="GLdt-document-order"></a>document order</dt>
<dd>
<p>Informally, <b>document order</b> is the order defined by a pre-order, depth-first traversal of the nodes in the data model.</p>
</dd>
<dt><a name="GLdt-dynamic-context" id="GLdt-dynamic-context"></a>dynamic context</dt>
<dd>
<p>The <b>dynamic context</b> of an expression is defined as information that is available at the time the expression is evaluated.</p>
</dd>
<dt><a name="GLdt-dynamic-error" id="GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<p>A <b>dynamic error</b> is an error that must be detected during the evaluation phase and may be detected during the analysis phase. Numeric overflow is an example of a dynamic error.</p>
</dd>
<dt><a name="GLdt-dynamic-evaluation" id="GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd>
<p>The <b>dynamic evaluation phase</b> occurs after completion of the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. During the dynamic evaluation phase, the value of the <span class="xpath"><span class="xpath">expression</span></span> is computed.</p>
</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic type</dt>
<dd>
<p>A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may be either a structural description (such as "sequence of integers") or a named type.</p>
</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean value</dt>
<dd>
<p>The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
</dd>
<dt><a name="GLdt-empty-sequence" id="GLdt-empty-sequence"></a>empty sequence</dt>
<dd>
<p>A sequence containing zero items is called an <b>empty sequence</b>.</p>
</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error value</dt>
<dd>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> carries an <b>error value</b>, which may be a single item or an empty sequence.</p>
</dd>
<dt><a name="GLdt-expanded-qname" id="GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<p>An <b>expanded QName</b> consists of an optional namespace URI and a local name.</p>
</dd>
<dt><a name="GLdt-expression-context" id="GLdt-expression-context"></a>expression context</dt>
<dd>
<p>The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.</p>
</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd>
<p>The first three components of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (context item, context position, and context size) are called the <b>focus</b> of the expression.</p>
</dd>
<dt><a name="GLdt-functional-language" id="GLdt-functional-language"></a>functional langauge</dt>
<dd>
<p>XPath is a <b>functional language</b>, which means that expressions can be nested with full generality.</p>
</dd>
<dt><a name="GLdt-function-implementation" id="GLdt-function-implementation"></a>function implementation</dt>
<dd>
<p><b>Function implementations</b>. Each function in <a title="function signature" href="#dt-function-signature">function signatures</a> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type.</p>
</dd>
<dt><a name="GLdt-function-signature" id="GLdt-function-signature"></a>function signature</dt>
<dd>
<p><b>Function signatures.</b> This component defines the set of functions that are available to be called from within an expression. Each function is uniquely identified by its <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and its arity (number of parameters).</p>
</dd>
<dt><a name="GLIgnorableWhitespace" id="GLIgnorableWhitespace"></a>Ignorable whitespace</dt>
<dd>
<p><span>Unless otherwise specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.2.2 ExplicitSpecial Whitespace Handling</b></a>), <b>Ignorable whitespace</b> may occur between <a title="terminal" href="#terminal">terminals</a>, and is not significant to the parse tree.</span> For readability, whitespace may be used in most expressions even though not explicitly notated in the EBNF. <span>All allowable whitespace that is not explicitly specified in the EBNF is ignorable whitespace, and converse, this
term does not apply to whitespace that is explicitly specified.</span></p>
</dd>
<dt><a name="GLdt-implementation-defined" id="GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id="GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.</p>
</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit timezone</dt>
<dd>
<p><b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or in any other operation. This value is an instance of <code>xdt:dayTimeDuration</code> that is <span class="xpath"><span class="xpath">determined by the host language</span></span>. See <a href="#ISO8601">[ISO 8601]</a> for the range of legal values of a timezone.</p>
</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope attribute declarations</dt>
<dd>
<p><b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration).</p>
</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element declarations</dt>
<dd>
<p><b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration).</p>
</dd>
<dt><a name="GLdt-in-scope-namespaces" id="GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
<p>The <b>in-scope namespaces</b> property of an element node is a set of <b>namespace bindings</b>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting QNames within the scope of the element. For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</p>
</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema definitions</dt>
<dd>
<p><b>In-scope schema definitions.</b> This is a generic term for all the element, attribute, and type definitions that are in scope during processing of an expression.</p>
</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope type definitions</dt>
<dd>
<p><b>In-scope type definitions.</b> Each named type definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation dependent" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope type definitions include the predefined types described in <a href="#id-predefined-types"><b>2.4.1 Predefined Types</b></a>.</p>
</dd>
<dt><a name="GLdt-in-scope-variables" id="GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd>
<p><b>In-scope variables.</b> This is a set of (expanded QName, type) pairs. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" href="#dt-static-type">static type</a> of the variable.</p>
</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd>
<p>An <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a> or a <a title="node" href="#dt-node">node</a>.</p>
</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>
<p>An alternative form of a node test called a <b>kind test</b> can select nodes based on their kind, name, and type annotation.</p>
</dd>
<dt><a name="GLlexical-action" id="GLlexical-action"></a>lexical action</dt>
<dd>
<p>A <b>lexical action</b> is an action that occurs as an side-effect of a pattern recognition.</p>
</dd>
<dt><a name="GLlexical-state" id="GLlexical-state"></a>lexical state</dt>
<dd>
<p>A <b>lexical state</b> is a condition where a defined set of patterns are recognized.</p>
</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd>
<p>A <b>literal</b> is a direct syntactic representation of an atomic value.</p>
</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>
<p>A node test that consists only of a QName or a Wildcard is called a <b>name test</b>.</p>
</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd>
<p>A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p>
</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd>
<p>A <b>node test</b> is a condition that must be true for each node selected by a step.</p>
</dd>
<dt><a name="GLnon-delimiting-token" id="GLnon-delimiting-token"></a>Non-delimiting Terminal</dt>
<dd>
<p><b>Non-delimiting terminals</b> generally start and end with alphabetic characters or digits. Adjacent non-delimiting terminals must be delimited by a <a title="Delimiting Terminal" href="#delimiting-token">delimiting terminal</a>. Non-delimiting terminals are only recognized in the appropriate <a title="lexical state" href="#lexical-state">lexical states</a> as specificed by <a href="#id-lexical-states"><b>A.2.4 Lexical Rules</b></a>.</p>
</dd>
<dt><a name="GLdt-primary-expression" id="GLdt-primary-expression"></a>primary expression</dt>
<dd>
<p><b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context item expressions, and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</p>
</dd>
<dt><a name="GLdt-principal-node-kind" id="GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
<p>Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.</p>
</dd>
<dt><a name="GLproduction" id="GLproduction"></a>production</dt>
<dd>
<p>A <b>production</b> combines symbols to form more complex patterns.</p>
</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>QName</dt>
<dd>
<p>Lexically, a <b>QName</b> consists of an optional namespace prefix and a local name.</p>
</dd>
<dt><a name="GLdt-reverse-document-order" id="GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>
<p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.</p>
</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd>
<p>A <b>sequence</b> is an ordered collection of zero or more <a title="item" href="#dt-item">items</a>.</p>
</dd>
<dt><a name="GLdt-sequence-type" id="GLdt-sequence-type"></a>SequenceType</dt>
<dd>
<p>When it is necessary to refer to a type in an XPath expression, the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax is used. The name <a href="#doc-xpath-SequenceType">SequenceType</a> suggests that this syntax is used to describe the type of an XPath value, which is always a sequence.</p>
</dd>
<dt><a name="GLdt-sequencetype-matching" id="GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>
<p>During evaluation of an expression, it is sometimes necessary to determine whether a value with a known type "matches" an expected type, expressed in the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax. This process is known as <b>SequenceType matching</b>.</p>
</dd>
<dt><a name="GLdt-serialization" id="GLdt-serialization"></a>serialization</dt>
<dd>
<p><b>Serialization</b> is the process of converting a sequence of nodes and atomic values from the <a title="data model" href="#dt-datamodel">data model</a> into a sequence of octets (step DM4 in Figure 1.)</p>
</dd>
<dt><a name="GLdt-singleton-sequence" id="GLdt-singleton-sequence"></a>singleton sequence</dt>
<dd>
<p>A sequence containing exactly one item is called a <b>singleton sequence</b>.</p>
</dd>
<dt><a name="GLdt-static-collations" id="GLdt-static-collations"></a>statically known collations</dt>
<dd>
<p><b>Statically known collations.</b> This is a set of (URI, collation) pairs. It defines the names of the collations that are available for use in function calls that take a collation name as an argument.</p>
</dd>
<dt><a name="GLdt-known-collections" id="GLdt-known-collections"></a>statically known collections</dt>
<dd>
<p><b>Statically known collections.</b> This is a mapping from strings onto types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:collection</code> function. The type is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with this URI as its argument.</p>
</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically known documents</dt>
<dd>
<p><b>Statically known documents.</b> This is a mapping from strings onto types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:doc</code> function. The type is the static type of a call to <code>fn:doc</code> with the given URI as its literal argument.</p>
</dd>
<dt><a name="GLdt-static-namespaces" id="GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd>
<p><b>Statically known namespaces.</b> This is a set of (prefix, URI) pairs that define all the namespaces that are known during static processing of a given expression.</p>
</dd>
<dt><a name="GLdt-static-analysis" id="GLdt-static-analysis"></a>static analysis phase</dt>
<dd>
<p>The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).</p>
</dd>
<dt><a name="GLdt-static-context" id="GLdt-static-context"></a>static context</dt>
<dd>
<p>The <b>static context</b> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</p>
</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static error</dt>
<dd>
<p>A <b>static error</b> is an error that must be detected during the analysis phase. A syntax error is an example of a <a title="static error" href="#dt-static-error">static error</a>. The means by which <a title="static error" href="#dt-static-error">static errors</a> are reported during the analysis phase is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static type</dt>
<dd>
<p>The <b>static type</b> of an expression may be either a named type or a structural description&#8212;for example, <code>xs:boolean?</code> denotes an optional occurrence of the <code>xs:boolean</code> type. The rules for inferring the <a title="static type" href="#dt-static-type">static types</a> of various expressions are described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p>
</dd>
<dt><a name="GLdt-static-typing-feature" id="GLdt-static-typing-feature"></a>Static Typing Feature</dt>
<dd>
<p>XPath 2.0 defines an optional feature called the <b>Static Typing Feature</b>. An implementation that includes this feature is required to detect type errors during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.</p>
</dd>
<dt><a name="GLdt-strongly-typed" id="GLdt-strongly-typed"></a>strongly typed</dt>
<dd>
<p>XPath is also a <b>strongly-typed language</b> in which the operands of various expressions, operators, and functions must conform to the expected types.</p>
</dd>
<dt><a name="GLdt-substitution-group" id="GLdt-substitution-group"></a>substitution group</dt>
<dd>
<p><b>Substitution groups</b> are defined in <a href="#XMLSchema">[XML Schema]</a> Part 1, Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</p>
</dd>
<dt><a name="GLdt-subtype-substitution" id="GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd>
<p>The use of a value whose actual type is derived from the expected type is known as <b>subtype substitution</b>.</p>
</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>
<p>Each rule in the grammar defines one <b>symbol</b>, in the form</p>
</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<p>A <b>terminal</b> is a single unit of the grammar that can not be further subdivided, and is specified in the EBNF by a character or characters in quotes, or a regular expression.</p>
</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type error</dt>
<dd>
<p>A <b>type error</b> may be raised during the analysis or evaluation phase. During the analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the evaluation phase, a <a title="type error" href="#dt-type-error">type error</a> occurs when the dynamic type of a value does not match the expected type of the
context in which the value occurs.</p>
</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type promotion</dt>
<dd>
<p>Under certain circumstances, an atomic value can be promoted from one type to another. <b>Type promotion</b> is used in function calls (see <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a>) and in processing of operators that accept numeric operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).</p>
</dd>
<dt><a name="GLdt-variable-values" id="GLdt-variable-values"></a>variable values</dt>
<dd>
<p><b>Variable values</b>. This is a set of (expanded QName, value) pairs. It contains the same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" href="#dt-static-context">static context</a> for the expression. The QName is the name of the variable and the value is the dynamic value of the variable.</p>
</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>Whitespace</dt>
<dd>
<p><b>Whitespace</b> characters are defined by <a href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a> when these characters occur outside of a <a href="#doc-xpath-StringLiteral">StringLiteral</a>.</p>
</dd>
<dt><a name="GLdt-anyAtomicType" id="GLdt-anyAtomicType"></a>xdt:anyAtomicType</dt>
<dd>
<p><code>xdt:anyAtomicType</code> includes all atomic values (and no values that are not atomic).</p>
</dd>
<dt><a name="GLdt-dayTimeDuration" id="GLdt-dayTimeDuration"></a>xdt:dayTimeDuration</dt>
<dd>
<p><code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code> whose lexical representation is restricted to contain only day, hour, minute, and second components.</p>
</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xdt:untyped</dt>
<dd>
<p><code>xdt:untyped</code> is used to denote the dynamic type of an element node that has not been validated, or has been validated in <code>skip</code> mode.</p>
</dd>
<dt><a name="GLdt-untypedAtomic" id="GLdt-untypedAtomic"></a>xdt:untypedAtomic</dt>
<dd>
<p><code>xdt:untypedAtomic</code> is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</p>
</dd>
<dt><a name="GLdt-yearMonthDuration" id="GLdt-yearMonthDuration"></a>xdt:yearMonthDuration</dt>
<dd>
<p><code>xdt:yearMonthDuration</code> is a subtype of <code>xs:duration</code> whose lexical representation is restricted to contain only year and month components.</p>
</dd>
<dt><a name="GLdt-xpath-compat-mode" id="GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd>
<p><b>XPath 1.0 compatibility mode.</b> <span class="xpath"><span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</span></span></p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a id="id-errors" name="id-errors"></a>G Summary of Error Conditions (Non-Normative)</h2>
<dl>
<dt><a name="ERRXP0001" id="ERRXP0001"></a>err:XP0001</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if analysis of an expression relies on some component of the <a title="static context" href="#dt-static-context">static context</a> that has not been assigned a value.</p>
</dd>
<dt><a name="ERRXP0002" id="ERRXP0002"></a>err:XP0002</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if evaluation of an expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that has not been assigned a value.</p>
</dd>
<dt><a name="ERRXP0003" id="ERRXP0003"></a>err:XP0003</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if an expression is not a valid instance of the grammar defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
</dd>
<dt><a name="ERRXP0004" id="ERRXP0004"></a>err:XP0004</dt>
<dd>
<p>During the analysis phase, it is a <a title="type error" href="#dt-type-error">type error</a> if the static typing feature is in effect and an expression is found to have a static type that is not appropriate for the context in which the expression occurs.</p>
</dd>
<dt><a name="ERRXP0005" id="ERRXP0005"></a>err:XP0005</dt>
<dd>
<p>During the analysis phase, it is a <a title="static error" href="#dt-static-error">static error</a> if the static typing feature is in effect and the static type assigned to an expression other than the expression <code>()</code> or <code>data(())</code> is the empty type.</p>
</dd>
<dt><a name="ERRXP0006" id="ERRXP0006"></a>err:XP0006</dt>
<dd>
<p>During the evaluation phase, it is a <a title="type error" href="#dt-type-error">type error</a> if a value does not match a required type as specified by the matching rules in <a href="#id-sequencetype-matching"><b>2.4.4 SequenceType Matching</b></a>.</p>
</dd>
<dt><a name="ERRXP0007" id="ERRXP0007"></a>err:XP0007</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if the <code>fn:data</code> function is applied to a node whose type annotation denotes a complex type with non-mixed complex content.</p>
</dd>
<dt><a name="ERRXP0008" id="ERRXP0008"></a>err:XP0008</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if an expression refers to an element name, attribute name, type name, function name, namespace prefix, or variable name that is not defined in the <a title="static context" href="#dt-static-context">static context</a>, except within an <a href="#doc-xpath-ElementTest">ElementTest</a> or an <a href="#doc-xpath-AttributeTest">AttributeTest</a>.</p>
</dd>
<dt><a name="ERRXP0017" id="ERRXP0017"></a>err:XP0017</dt>
<dd>
<p>It is <span class="xpath"><span class="xpath">It is an error (the host language environment may define this error as either a static or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>)</span></span> if the expanded QName and number of arguments in a function call do not match the name and arity of a <a title="function signature" href="#dt-function-signature">function signature</a> in the <a title="static context" href="#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXP0018" id="ERRXP0018"></a>err:XP0018</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> for an expression to depend on the focus when the focus is undefined.</p>
</dd>
<dt><a name="ERRXP0019" id="ERRXP0019"></a>err:XP0019</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if the result of a step expression (StepExpr) is not a (possibly empty) sequence of nodes.</p>
</dd>
<dt><a name="ERRXP0020" id="ERRXP0020"></a>err:XP0020</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type error</a> if in an axis expression, the context item is not a node.</p>
</dd>
<dt><a name="ERRXP0021" id="ERRXP0021"></a>err:XP0021</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the argument of a cast expression or constructor function cannot be cast to the required type.</p>
</dd>
<dt><a name="ERRXP0029" id="ERRXP0029"></a>err:XP0029</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> in a cast expression if the input value does not satisfy the facets of the target type.</p>
</dd>
<dt><a name="ERRXP0050" id="ERRXP0050"></a>err:XP0050</dt>
<dd>
<p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the dynamic type of the operand of a <code>treat</code> expression does not match the type specified by the <code>treat</code> expression.</p>
</dd>
<dt><a name="ERRXP0051" id="ERRXP0051"></a>err:XP0051</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if a QName that is used as an <a href="#doc-xpath-AtomicType">AtomicType</a> in a <a href="#doc-xpath-SequenceType">SequenceType</a> is not defined in the <a title="in-scope type definitions" href="#dt-is-types">in-scope type definitions</a> as an atomic type.</p>
</dd>
<dt><a name="ERRXP0055" id="ERRXP0055"></a>err:XP0055</dt>
<dd>
<p>(Not currently used.)</p>
</dd>
</dl>
</div>
<div class="xpath">
<div class="div1">
<h2><a id="id-backwards-compatibility" name="id-backwards-compatibility"></a>H Backwards Compatibility with XPath 1.0 (Non-Normative)</h2>
<p>This section provides a summary of the main areas of incompatibility between XPath 2.0 and <a href="#XPath">[XPath 1.0]</a>.</p>
<p>Three separate cases are considered:</p>
<ol class="enumar">
<li>
<p>Incompatibilities that exist when source documents have no schema, and when running with XPath 1.0 compatibility mode set to true. This specification has been designed to reduce the number of incompatibilities in this situation to an absolute minumum, but some differences remain and are listed individually.</p>
</li>
<li>
<p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to false. In this case, the number of expressions where compatibility is lost is rather greater.</p>
</li>
<li>
<p>Incompatibilities that arise when the source document is processed using a schema (whether or not XPath 1.0 compatibility mode is set to true). Processing the document with a schema changes the way that the values of nodes are interpreted, and this can cause an XPath expression to return different results.</p>
</li>
</ol>
<div class="div2">
<h3><a id="N14A6B" name="N14A6B"></a>H.1 Incompatibilities when Compatibility Mode is true</h3>
<p>The list below contains all known areas, within the scope of this specification, where an XPath 2.0 processor running with compatibility mode set to true will produce different results from an XPath 1.0 processor evaluating the same expression, assuming that the expression was valid in XPath 1.0, and that the nodes in the source document have no type annotations other than <code>xdt:untyped</code> and <code>xdt:untypedAtomic</code>.</p>
<p>Incompatibilities in the behavior of individual functions are not listed here, but are included in an appendix of <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p>
<p>In the description below, the terms <em>node-set</em> and <em>number</em> are used with their XPath 1.0 meanings, that is, to describe expressions which according to the rules of XPath 1.0 would have generated a node-set or a number respectively.</p>
<ol class="enumar">
<li>
<p>The rules for comparing a node-set to a boolean have changed. In XPath 1.0, an expression such as <code>$nodeset=true()</code> was evaluated by converting the node-set to a boolean and then performing a boolean comparison: so this expression would return <code>true</code> if <code>$nodeset</code> was non-empty. In XPath 2.0, this expression is handled in the same way as other comparisons between a sequence and a singleton: it is <code>true</code> if <code>$nodeset</code> contains at least one node whose
value, after casting to a boolean, is <code>true</code>.</p>
<p>This means that if <code>$nodeset</code> is empty, the result under XPath 2.0 will be <code>false</code> regardless of the value of the boolean operand, and regardless of which operator is used. If <code>$nodeset</code> is non-empty, then in most cases the cast to a boolean is likely to fail, giving a dynamic error. But if a node has the value "0", "1", "true", or "false", evaluation of the expression may succeed.</p>
</li>
<li>
<p>The rules for comparing an integer to a boolean have changed. In XPath 1.0, the expression <code>(4 = true())</code> is evaluated by converting the number 4 to boolean (yielding <code>true</code>). The expression returns <code>true</code>. In XPath 2.0, running in compatibility mode, the same expression is evaluated by converting both operands to double (yielding <code>4e0 = 1e0</code>). The expression returns <code>false</code>.</p>
</li>
<li>
<p>The rules for comparing a string to a boolean have changed. In XPath 1.0, the expression <code>("x" = true())</code> is evaluated by converting the string to a boolean, and performing a boolean comparison. In XPath 2.0 a comparison between a boolean and a string raises a type error, even when compatibility mode is true.</p>
</li>
<li>
<p>Additional numeric types have been introduced, with the effect that arithmetic may now be done as an integer, decimal, or single- or double-precision floating point calculation where previously it was always performed as double-precision floating point. The result of the <code>div</code> operator when dividing two integers is now a value of type decimal rather than double. The expression <code>10 div 0</code> raises an error rather than returning positive infinity.</p>
</li>
<li>
<p>The rules for converting numbers to strings have changed. These may affect the way numbers are displayed in the output of a stylesheet. For numbers whose absolute value is in the range 1E-6 to 1E+6, the result should be the same, but outside this range, scientific format is used for <code>xs:float</code> and <code>xs:double</code> values.</p>
</li>
<li>
<p>The rules for converting strings to numbers have changed. The representation of special values such as Infinity has been aligned with XML Schema. Strings containing a leading plus sign, or numbers in scientific notation, may now be converted to ordinary numeric values, whereas in XPath 1.0 they were converted to <code>NaN</code>.</p>
</li>
<li>
<p>Many operations in XPath 2.0 produce an empty sequence as their result when one of the arguments or operands is an empty sequence. With XPath 1.0, the result of such an operation was typically a zero-length string or the numeric value <code>NaN</code>. An example of an expression whose value will change as a result of this rule is <code>string(@a+0) = "NaN"</code>, in the case where <code>@a</code> returns an empty node-set. With XPath 1.0, this would produce the value <code>true</code>. With XPath 2.0,
it produces the value <code>false</code>.</p>
</li>
<li>
<p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when applied to two strings, attempted to convert both the strings to numbers and then made a numeric comparison between the results. In XPath 2.0, these operators perform a string comparison using the default collating sequence. (If either value is numeric, however, the results are compatible with XPath 1.0)</p>
</li>
<li>
<p>In XPath 1.0, functions and operators that compared strings (for example, the <code>=</code> operator) worked on the basis of character-by-character equality of Unicode codepoints, allowing Unicode normalization at the discretion of the implementor. In XPath 2.0, these comparisons are done using the default collating sequence. The host language from which XPath is invoked may define mechanisms allowing codepoint comparison to be selected as the default collating sequence, but there is no such mechanism
defined in XPath itself.</p>
</li>
<li>
<p>In XPath 1.0, it was defined that with an expression of the form <code>A and B</code>, B would not be evaluated if A was false. Similarly in the case of <code>A or B</code>, B would not be evaluated if A was true. This is no longer guaranteed with XPath 2.0: the implementation is free to evaluate the two operands in either order or in parallel. This change has been made to give more scope for optimization in situations where XPath expressions are evaluated against large data collections supported by
indexes. Implementations may choose to retain backwards compatibility in this area, but they are not obliged to do so.</p>
</li>
<li>
<p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were supported in XPath 1.0, but are not permitted by the XPath 2.0 grammar. Such comparisons in XPath 1.0 did not have the intuitive meaning, so it is unlikely that they have been widely used in practice.</p>
</li>
<li>
<p>The namespace axis is deprecated in XPath 2.0. Implementations may support the namespace axis for backward compatibility with XPath 1.0, but they are not required to do so.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a id="N14B07" name="N14B07"></a>H.2 Incompatibilities when Compatibility Mode is false</h3>
<p>Even when the setting of the XPath 1.0 compatibility mode is false, many XPath expressions will still produce the same results under XPath 2.0 as under XPath 1.0. However, there are exceptions.</p>
<p>The main additional incompatibilities are as follows:</p>
<ol class="enumar">
<li>
<p>When a node-set containing more than one node is supplied as an argument to a function or operator that expects a single node or value, the rule that all nodes after the first are discarded no longer applies. Instead, a type error occurs if there is more than one node. The XPath 1.0 behavior can always be restored by using the predicate <code>[1]</code> to explicitly select the first node in the node-set.</p>
</li>
<li>
<p>When an empty node-set is supplied as an argument to a function or operator that expects a number, the value is no longer converted implicitly to NaN. The XPath 1.0 behavior can always be restored by using the <code>number</code> function to perform an explicit conversion.</p>
</li>
<li>
<p>More generally, the supplied arguments to a function or operator are no longer implicitly converted to the required type, except in the case where the supplied argument is of type <code>xdt:untypedAtomic</code> (which will commonly be the case when a node in a schema-less document is supplied as the argument). For example, the function call <code>concat("chapter", $nr)</code> raises a type error if the variable <code>$nr</code> is numeric, because the arguments to the <code>concat</code> function must
be strings rather than numbers. The XPath 1.0 behavior can be restored by performing an explicit conversion to the required type using a constructor function or cast.</p>
</li>
</ol>
<p>It is <em>not</em> the case that these differences will always result in XPath 2.0 raising an error. In some cases, XPath 2.0 will return different results for the same expression. For example, the expression <code>"4" &lt; "4.0"</code>. This returns <code>false</code> in XPath 1.0, and <code>true</code> in XPath 2.0.</p>
</div>
<div class="div2">
<h3><a id="N14B38" name="N14B38"></a>H.3 Incompatibilities when using a Schema</h3>
<p>An XPath expression applied to a document that has been processed against a schema will not always give the same results as the same expression applied to the same document in the absence of a schema. Since schema processing had no effect on the result of an XPath 1.0 expression, this may give rise to further incompatibilities.</p>
<p>Suppose that the context node is an element node derived from the following markup: <code>&lt;background color="red green blue"/&gt;</code>. In XPath 1.0, the predicate <code>[@color="blue"]</code> would return <code>false</code>. In XPath 2.0, if the <code>color</code> attribute is defined in a schema to be of type <code>xs:NMTOKENS</code>, the same predicate will return <code>true</code>.</p>
<p>Similarly, consider the expression <code>@birth &lt; @death</code> applied to the element <code>&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</code>. With XPath 1.0, this expression would return false, because both attributes are converted to numbers, which returns <code>NaN</code> in each case. With XPath 2.0, in the presence of a schema that annotates these attributes as dates, the expression returns <code>true</code>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a id="id-issues" name="id-issues"></a>I XPath 2.0 and XQuery 1.0 Issues (Non-Normative)</h2>
<p>The XPath 2.0 and XQuery 1.0 Issues List that records pre-Last Call issues can be found at <a href="http://www.w3.org/XML/2003/11/xpath-xquery-issues">http://www.w3.org/XML/2003/11/xpath-xquery-issues</a>.</p>
</div>
<div class="div1">
<h2><a id="id-revisions-log" name="id-revisions-log"></a>J Revision Log (Non-Normative)</h2>
<p>This log records the changes that have been made to this document since the Last Call Draft of 12 November 2003.</p>
<div class="div2">
<h3><a id="N14B73" name="N14B73"></a>J.1 23 July 2004</h3>
<ol class="enumar">
<li>
<p>The SequenceType syntax has been simplified. SchemaContextPath is no longer part of the SequenceType syntax. Also, the section on SequenceType Matching has been rewritten to make its terminology more consistent with the Formal Semantics document.</p>
</li>
<li>
<p>The term <code>xdt:untypedAny</code> is changed to <code>xdt:untyped</code>.</p>
</li>
<li>
<p><code>xs:anyType</code> is no longer an abstract type, but is now used to denote the type of a partially validated element node. Since there is no longer a meaningful distinction between abstract types and concrete types, these terms are no longer used in this document.</p>
</li>
<li>
<p>Value comparisons now return <code>()</code> if either operand is <code>()</code>.</p>
</li>
<li class="xpath">
<p>The typed value of a namespace node is an instance of <code>xs:string</code>, not <code>xdt:untypedAtomic</code>.</p>
</li>
<li>
<p>The name of the Predicates grammar production has been changed to PredicateList.</p>
</li>
<li>
<p>The grammar production formerly called a FilterStep is now called a FilterExpression and is described in a separate section rather than as part of a path expression.</p>
</li>
<li>
<p>The precedence of the <code>cast</code> and <code>treat</code> operators in the grammar has been increased.</p>
</li>
<li>
<p>The precedence of unary arithmetic operators has been increased.</p>
</li>
<li>
<p>The appendix containing a list of error messages has been made non-normative.</p>
</li>
<li class="xpath">
<p>A new component has been added to the static context: context item static type.</p>
</li>
<li>
<p>The expression <code>data(())</code> no longer raises a static error, although its static type is empty.</p>
</li>
<li>
<p>If a dynamic implementation detects a static error, the evaluation phase is optional.</p>
</li>
<li>
<p>XPath allows host languages to specify whether they recognize the concept of a namespace node. XQuery does not recognize namespace nodes. Instead, it recognizes an "in-scope namespaces" property of an element node.</p>
</li>
<li>
<p>The specification now clearly distinguishes between "statically-known namespaces" (a static property of an expression) and "in-scope namespaces" (a dynamic property of an element).</p>
</li>
<li>
<p>The names of certain components in the static and dynamic contexts have been changed to make them more consistent and descriptive.</p>
</li>
<li class="xpath">
<p>Corrections have been made to the rules for XPath 1.0 Compatability Mode in the semantics of function calls.</p>
</li>
<li>
<p>The definition of the <code>idiv</code> operator has been made consistent with the Functions and Operators document. The <code>idiv</code> operator accepts operands of any numeric types, performs a division, and truncates the result to an integer.</p>
</li>
<li>
<p>Certain grammar productions have been renamed and reordered to make the grammar easier to read.</p>
</li>
<li>
<p>The section on constructor functions has been edited to make it more consistent with the definition of constructor functions in the Functions and Operators document.</p>
</li>
<li>
<p>The Comments section has been moved out of the Primary Expressions section, because a comment is not a primary expression.</p>
</li>
<li>
<p>Various minor changes, both editorial and substantive, have been made in response to public comments and working group discussions.</p>
</li>
</ol>
</div>
</div>
</div>
</body>
</html>
