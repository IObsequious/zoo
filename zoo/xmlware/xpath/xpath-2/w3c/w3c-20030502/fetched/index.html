<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator"
    content="HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org" />
    <meta http-equiv="Content-Type"
    content="text/html; charset=ISO-8859-1" />
    <meta http-equiv="Content-Type"
    content="text/html; charset=ISO-8859-1" />

    <title>XML Path Language (XPath) 2.0</title>
<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

table.small    { font-size: x-small; }
    
/*]]>*/
</style>
    <link rel="stylesheet" type="text/css"
    href="http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
  </head>

  <body>
    <div class="head">
      <p><a href="http://www.w3.org/"><img
      src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48"
      width="72" /></a></p>

      <h1><a name="title" id="title"></a>XML Path Language (XPath)
      2.0</h1>

      <h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working
      Draft 02 May 2003</h2>

      <dl>
        <dt>This version:</dt>

        <dd><span class="xpath"><a
        href="http://www.w3.org/TR/2003/WD-xpath20-20030502">http://www.w3.org/TR/2003/WD-xpath20-20030502</a></span></dd>

        <dt>Latest version:</dt>

        <dd><span class="xpath"><a
        href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></dd>

        <dt>Previous versions:</dt>

        <dd><span class="xpath"><a
        href="http://www.w3.org/TR/2002/WD-xpath20-20021115/">http://www.w3.org/TR/2002/WD-xpath20-20021115/</a></span>
        <span class="xpath"><a
        href="http://www.w3.org/TR/2002/WD-xpath20-20020816/">http://www.w3.org/TR/2002/WD-xpath20-20020816/</a></span>
        <span class="xpath"><a
        href="http://www.w3.org/TR/2002/WD-xpath20-20020430/">http://www.w3.org/TR/2002/WD-xpath20-20020430/</a></span>
        <span class="xpath"><a
        href="http://www.w3.org/TR/2001/WD-xpath20-20011220/">http://www.w3.org/TR/2001/WD-xpath20-20011220/</a></span></dd>

        <dt>Editors:</dt>

        <dd class="xpath">Anders Berglund (XSL WG), IBM Research <a
        href="mailto:%20alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd>

        <dd>Scott Boag (XSL WG), IBM Research <a
        href="mailto:%20scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>

        <dd>Don Chamberlin (XML Query WG), IBM Almaden Research
        Center <a
        href="mailto:%20chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>

        <dd>Mary F. Fernandez (XML Query WG), AT&amp;T Labs <a
        href="mailto:%20mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>

        <dd class="xpath">Michael Kay (XSL WG), Software AG <a
        href="mailto:%20Michael.Kay@softwareag.com">&lt;Michael.Kay@softwareag.com&gt;</a></dd>

        <dd>Jonathan Robie (XML Query WG), DataDirect Technologies
        <a
        href="mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>

        <dd>J&#233;r&#244;me Sim&#233;on (XML Query WG), Bell Labs,
        Lucent Technologies <a
        href="mailto:%20simeon@research.bell-labs.com">&lt;simeon@research.bell-labs.com&gt;</a></dd>
      </dl>

      <p class="copyright"><a
      href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;&#169;&#160;2003&#160;<a
      href="http://www.w3.org/"><acronym
      title="World Wide Web Consortium">W3C</acronym></a><sup>&#174;</sup>
      (<a href="http://www.lcs.mit.edu/"><acronym
      title="Massachusetts Institute of Technology">MIT</acronym></a>,
      <a href="http://www.ercim.org/"><acronym
      title="European Research Consortium for Informatics and Mathematics">
      ERCIM</acronym></a>, <a
      href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
      W3C <a
      href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a
      href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>, <a
      href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> and <a
      href="http://www.w3.org/Consortium/Legal/copyright-software">software
      licensing</a> rules apply.</p>
    </div>
    <hr />

    <div>
      <h2><a name="abstract" id="abstract"></a>Abstract</h2>

      <div class="xpath">
        <p class="xpath">XPath is a language for addressing parts
        of an XML document.</p>
      </div>
    </div>

    <div>
      <h2><a name="status" id="status"></a>Status of this
      Document</h2>

      <p>This is a public W3C Working Draft for review by W3C
      Members and other interested parties. This section describes
      the status of this document at the time of its publication.
      It is a draft document and may be updated, replaced, or made
      obsolete by other documents at any time. It is inappropriate
      to use W3C Working Drafts as reference material or to cite
      them as other than "work in progress." A list of current
      public W3C technical reports can be found at <a
      href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.</p>

      <p><span class="xpath"><span class="xpath">This document is
      the result of joint work by the XSL and XML Query Working
      Groups,</span></span> which are jointly responsible for XPath
      2.0, a language derived from both XPath 1.0 and XQuery. The
      XPath 2.0 and XQuery 1.0 Working Drafts are generated from a
      common source. These languages are closely related, sharing
      much of the same expression syntax and semantics, and much of
      the text found in the two Working Drafts is identical.</p>

      <p>This version contains a new syntax for identifying types,
      and new features that allow path expressions to select
      element and attribute nodes based on their types as well as
      their names. It changes some of the details of the semantics
      of arithmetic and comparison operators, including making the
      value comparison operators transitive. It includes some
      grammar changes, including changes in the comment delimiters
      and the syntax of the <code>cast</code> expression. A
      detailed list of changes can be found in <a
      href="#id-revisions-log"><b>H Revision Log</b></a>.</p>

      <p>This document is a work in progress. It contains many open
      issues, and should not be considered to be fully stable.
      Vendors who wish to create preview implementations based on
      this document do so at their own risk. While this document
      reflects the general consensus of the working groups, there
      are still controversial areas that may be subject to
      change.</p>

      <p>Public comments on this document and its open issues are
      welcome, in particular comments on Issue 510. Comments should
      be sent to the W3C XPath/XQuery mailing list, <a
      href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>
      (archived at <a
      href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>).</p>

      <p>XPath 2.0 has been defined jointly by the <a
      href="http://www.w3.org/XML/Query">XML Query Working
      Group</a> and the <a href="http://www.w3.org/Style/XSL/">XSL
      Working Group</a> (both part of the <a
      href="http://www.w3.org/XML/Activity.html">XML
      Activity</a>).</p>

      <p>Patent disclosures relevant to this specification may be
      found on the XSL Working Group's patent disclosure page at <a
      href="http://www.w3.org/Style/XSL/Disclosures">http://www.w3.org/Style/XSL/Disclosures</a>.</p>
    </div>

    <div class="toc">
      <h2><a name="contents" id="contents"></a>Table of
      Contents</h2>

      <p class="toc">1 <a
      href="#id-introduction">Introduction</a><br />
      2 <a href="#id-basics">Basics</a><br />
      &#160;&#160;&#160;&#160;2.1 <a href="#context">Expression
      Context</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a
      href="#static_context">Static Context</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a
      href="#eval_context">Evaluation Context</a><br />
      &#160;&#160;&#160;&#160;2.2 <a
      href="#id-input-functions">Input Functions</a><br />
      &#160;&#160;&#160;&#160;2.3 <a href="#d0e722">Expression
      Processing</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a
      href="#d0e824">Document Order</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a
      href="#id-typed-value">Typed Value and String Value</a><br />
      &#160;&#160;&#160;&#160;2.4 <a
      href="#id-type-conversion">Types</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a
      href="#d0e1065">Predefined Types</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a
      href="#id-type-checking">Type Checking</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a
      href="#id-sequencetype">SequenceType</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3.1
      <a href="#id-sequencetype-matching">SequenceType
      Matching</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a
      href="#id-type-conversions">Type Conversions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.1
      <a href="#id-atomization">Atomization</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4.2
      <a href="#id-ebv">Effective Boolean Value</a><br />
      &#160;&#160;&#160;&#160;2.5 <a href="#errors">Error
      Handling</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a
      href="#id-kinds-of-errors">Kinds of Errors</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a
      href="#id-handling-dynamic">Handling Dynamic Errors</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a
      href="#id-errors-and-opt">Errors and Optimization</a><br />
      &#160;&#160;&#160;&#160;2.6 <a
      href="#id-optional-features">Optional Features</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1 <a
      href="#id-basic">Basic XPath</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2 <a
      href="#id-static-typing">Static Typing Feature</a><br />
      3 <a href="#id-expressions">Expressions</a><br />
      &#160;&#160;&#160;&#160;3.1 <a
      href="#id-primary-expressions">Primary Expressions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a
      href="#id-literals">Literals</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a
      href="#id-variables">Variables</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a
      href="#id-paren-expressions">Parenthesized
      Expressions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a
      href="#id-function-calls">Function Calls</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a
      href="#comments">XPath Comments</a><br />
      &#160;&#160;&#160;&#160;3.2 <a
      href="#id-path-expressions">Path Expressions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a
      href="#id-axis-steps">Steps</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.1
      <a href="#axes">Axes</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.2
      <a href="#node-tests">Node Tests</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a
      href="#id-predicates">Predicates</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a
      href="#unabbrev">Unabbreviated Syntax</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a
      href="#abbrev">Abbreviated Syntax</a><br />
      &#160;&#160;&#160;&#160;3.3 <a
      href="#id-sequence-expressions">Sequence
      Expressions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a
      href="#construct_seq">Constructing Sequences</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a
      href="#combining_seq">Combining Sequences</a><br />
      &#160;&#160;&#160;&#160;3.4 <a
      href="#id-arithmetic">Arithmetic Expressions</a><br />
      &#160;&#160;&#160;&#160;3.5 <a
      href="#id-comparisons">Comparison Expressions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a
      href="#id-value-comparisons">Value Comparisons</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a
      href="#id-general-comparisons">General Comparisons</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a
      href="#id-node-comparisons">Node Comparisons</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.4 <a
      href="#id-order-comparisons">Order Comparisons</a><br />
      &#160;&#160;&#160;&#160;3.6 <a
      href="#id-logical-expressions">Logical Expressions</a><br />
      &#160;&#160;&#160;&#160;3.7 <a href="#id-for-expressions">For
      Expressions</a><br />
      &#160;&#160;&#160;&#160;3.8 <a
      href="#id-conditionals">Conditional Expressions</a><br />
      &#160;&#160;&#160;&#160;3.9 <a
      href="#id-quantified-expressions">Quantified
      Expressions</a><br />
      &#160;&#160;&#160;&#160;3.10 <a
      href="#id-expressions-on-datatypes">Expressions on
      SequenceTypes</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a
      href="#id-instance-of">Instance Of</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a
      href="#id-cast">Cast</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a
      href="#id-castable">Castable</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a
      href="#id-constructor-functions">Constructor
      Functions</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a
      href="#id-treat">Treat</a><br />
      </p>

      <h3><a name="appendices" id="appendices"></a>Appendices</h3>

      <p class="toc">A <a href="#nt-bnf">XPath Grammar</a><br />
      &#160;&#160;&#160;&#160;A.1 <a
      href="#id-grammar">EBNF</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a
      href="#notes-on-parsing">Parsing Notes</a><br />
      &#160;&#160;&#160;&#160;A.2 <a
      href="#lexical-structure">Lexical structure</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a
      href="#whitespace-rules">Whitespace Rules</a><br />
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a
      href="#id-lexical-states">Lexical Rules</a><br />
      &#160;&#160;&#160;&#160;A.3 <a href="#d0e8260">Reserved
      Function Names</a><br />
      &#160;&#160;&#160;&#160;A.4 <a
      href="#id-precedence-order">Precedence Order</a><br />
      B <a href="#d0e8295">Type Promotion and Operator
      Mapping</a><br />
      &#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type
      Promotion</a><br />
      &#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator
      Mapping</a><br />
      C <a href="#id-references">References</a><br />
      &#160;&#160;&#160;&#160;C.1 <a
      href="#id-normative-references">Normative
      References</a><br />
      &#160;&#160;&#160;&#160;C.2 <a
      href="#id-non-normative-references">Non-normative
      References</a><br />
      &#160;&#160;&#160;&#160;C.3 <a
      href="#id-background-references">Background
      References</a><br />
      &#160;&#160;&#160;&#160;C.4 <a
      href="#id-informative-material">Informative
      Material</a><br />
      D <a href="#id-glossary">Glossary</a><br />
      E <a href="#d0e9977">Conformance</a><br />
      F <a href="#id-backwards-compatibility">Backwards
      Compatibility with XPath 1.0</a> (Non-Normative)<br />
      G <a href="#id-issues">XPath 2.0 and XQuery 1.0 Issues</a>
      (Non-Normative)<br />
      H <a href="#id-revisions-log">Revision Log</a>
      (Non-Normative)<br />
      &#160;&#160;&#160;&#160;H.1 <a href="#d0e10182">18 April
      2003</a><br />
      </p>
    </div>
    <hr />

    <div class="body">
      <div class="div1">
        <h2><a name="id-introduction" id="id-introduction"></a>1
        Introduction</h2>

        <div class="xpath">
          <p class="xpath">The primary purpose of XPath is to
          address parts of an <a href="#XML">[XML]</a> document.
          XPath uses a compact, non-XML syntax to facilitate use of
          XPath within URIs and XML attribute values. XPath
          operates on the abstract, logical structure of an XML
          document, rather than its surface syntax. This logical
          structure is known as the <b>data model</b>, and is
          described in the <a href="#datamodel">[XQuery 1.0 and
          XPath 2.0 Data Model]</a> document. XPath gets its name
          from its use of a path notation as in URLs for navigating
          through the hierarchical structure of an XML
          document.</p>
        </div>

        <div class="xpath">
          <p class="xpath">XPath is designed to be embedded in a
          <b>host language</b> such as <a href="#XSLT">[XSLT
          2.0]</a> or <a href="#xquery">[XQuery]</a>. XPath has a
          natural subset that can be used for matching (testing
          whether or not a node matches a pattern); this use of
          XPath is described in <a href="#XSLT">[XSLT 2.0]</a>.</p>
        </div>

        <p>XQuery Version 1.0 is an extension of XPath Version 2.0.
        Any expression that is syntactically valid and executes
        successfully in both XPath 2.0 and XQuery 1.0 will return
        the same result in both languages. Since these languages
        are so closely related, their grammars and language
        descriptions are generated from a common source to ensure
        consistency, and the editors of these specifications work
        together closely.</p>

        <p>XPath also depends on and is closely related to the
        following specifications:</p>

        <ul>
          <li>
            <p>The XPath data model defines the information in an
            XML document that is available to an XPath processor.
            The data model is defined in <a
            href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
            Model]</a>.</p>
          </li>

          <li>
            <p>The static and dynamic semantics of XPath are
            formally defined in <a
            href="#XQueryFormalSemantics">[XQuery 1.0 Formal
            Semantics]</a>. This document is useful for
            implementors and others who require a rigorous
            definition of XPath.</p>
          </li>

          <li>
            <p>The type system of XPath is based on <a
            href="#XMLSchema">[XML Schema]</a>.</p>
          </li>

          <li>
            <p>The default library of functions and operators
            supported by XPath is defined in <a
            href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a>.</p>
          </li>
        </ul>

        <p>This document specifies a grammar for XPath, using the
        same Basic EBNF notation used in <a href="#XML">[XML]</a>,
        except that grammar symbols always have initial capital
        letters. Unless otherwise noted (see <a
        href="#lexical-structure"><b>A.2 Lexical
        structure</b></a>), whitespace is not significant in the
        grammar. Grammar productions are introduced together with
        the features that they describe, and a complete grammar is
        also presented in the appendix [<a href="#nt-bnf"><b>A
        XPath Grammar</b></a>].</p>

        <p>In the grammar productions in this document, nonterminal
        symbols are underlined and literal text is enclosed in
        double quotes. Certain productions (including the
        productions that define DecimalLiteral, DoubleLiteral, and
        StringLiteral) employ a regular-expression notation. The
        following example production describes the syntax of a
        function call:</p>

        <h5><a name="d0e204" id="d0e204"></a></h5>

        <table class="scrap" summary="Scrap">
          <tbody>
            <tr valign="baseline">
              <td><a name="fakeid_doc-FunctionCall"
              id="fakeid_doc-FunctionCall"></a>[59]&#160;&#160;&#160;</td>

              <td><code>FunctionCall</code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a> "(" (<a
              href="#doc-ExprSingle">ExprSingle</a> ("," <a
              href="#doc-ExprSingle">ExprSingle</a>)*)?
              ")"</code></td>
            </tr>
          </tbody>
        </table>

        <p>The production should be read as follows: A function
        call consists of a QName followed by an open-parenthesis.
        The open-parenthesis is followed by an optional argument
        list. The argument list (if present) consists of one or
        more expressions, separated by commas. The optional
        argument list is followed by a close-parenthesis. The
        symbol <code>ExprSingle</code> denotes an expression that
        does not contain any top-level commas (since top-level
        commas in a function call are used to separate the function
        arguments).</p>

        <p>Certain aspects of language processing are described in
        this specification as <b>implementation-defined</b> or
        <b>implementation-dependent</b>. These terms are defined as
        follows:</p>

        <ul>
          <li>
            <p><b>Implementation-defined</b> indicates an aspect
            that may differ between implementations, but must be
            specified by the implementor for each particular
            implementation.</p>
          </li>

          <li>
            <p><b>Implementation-dependent</b> indicates an aspect
            that may differ between implementations, is not
            specified by this or any W3C specification, and is not
            required to be specified by the implementor for any
            particular implementation.</p>
          </li>
        </ul>

        <table border="1" summary="Editorial note">
          <tr>
            <td align="left" valign="top" width="50%"><b>Editorial
            note</b></td>

            <td align="right" valign="top" width="50%">&#160;</td>
          </tr>

          <tr>
            <td colspan="2" align="left" valign="top">A future
            version of this document will include links between
            terms (in bold font) and their definitions.</td>
          </tr>
        </table>
        <br />
        <br />
      </div>

      <div class="div1">
        <h2><a name="id-basics" id="id-basics"></a>2 Basics</h2>

        <p>The basic building block of XPath is the
        <b>expression</b>. The language provides several kinds of
        expressions which may be constructed from keywords,
        symbols, and operands. In general, the operands of an
        expression are other expressions. XPath is a <b>functional
        language</b> which allows various kinds of expressions to
        be nested with full generality. (However, unlike a pure
        functional language, it does not allow variable
        substitutability if the variable definition contains
        construction of new nodes.) XPath is also a
        <b>strongly-typed language</b> in which the operands of
        various expressions, operators, and functions must conform
        to the expected types.</p>

        <p>Like XML, XPath is a case-sensitive language. All
        keywords in XPath use lower-case characters.</p>

        <p>The value of an expression is always a <b>sequence</b>,
        which is an ordered collection of zero or more
        <b>items</b>. An <b>item</b> is either an atomic value or a
        node. An <b>atomic value</b> is a value in the value space
        of an XML Schema <b>atomic type</b>, as defined in <a
        href="#XMLSchema">[XML Schema]</a> (that is, a simple type
        that is not a list type or a union type). A <b>node</b>
        conforms to one of the seven <b>node kinds</b> described in
        <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
        Model]</a>. Each node has a unique <b>node identity</b>.
        Some kinds of nodes have typed values, string values, and
        names, which can be extracted from the node. The <b>typed
        value</b> of a node is a sequence of zero or more atomic
        values. The <b>string value</b> of a node is a value of
        type <code>xs:string</code>. The <b>name</b> of a node is a
        value of type <code>xs:QName</code>.</p>

        <p>A sequence containing exactly one item is called a
        <b>singleton sequence</b>. An item is identical to a
        singleton sequence containing that item. Sequences are
        never nested--for example, combining the values 1, (2, 3),
        and ( ) into a single sequence results in the sequence (1,
        2, 3). A sequence containing zero items is called an
        <b>empty sequence.</b></p>

        <p>In this document, the namespace prefixes
        <code>xs:</code> and <code>xsi:</code> are considered to be
        bound to the XML Schema namespaces
        <code>http://www.w3.org/2001/XMLSchema</code> and
        <code>http://www.w3.org/2001/XMLSchema-instance</code>,
        respectively (as described in <a href="#XMLSchema">[XML
        Schema]</a>), and the prefix <code>fn:</code> is considered
        to be bound to the namespace of XPath/XQuery functions,
        <code>http://www.w3.org/2003/05/xpath-functions</code>
        (described in <a href="#FunctionsAndOperators">[XQuery 1.0
        and XPath 2.0 Functions and Operators]</a>). In some cases,
        where the meaning is clear and namespaces are not important
        to the discussion, built-in XML Schema typenames such as
        <code>integer</code> and <code>string</code> are used
        without a namespace prefix. Also, this document assumes
        that the <b>default function namespace</b> is set to the
        namespace of XPath/XQuery functions, so function names
        appearing without a namespace prefix can be assumed to be
        in this namespace.</p>

        <div class="div2">
          <h3><a name="context" id="context"></a>2.1 Expression
          Context</h3>

          <p>The <b>expression context</b> for a given expression
          consists of all the information that can affect the
          result of the expression. This information is organized
          into two categories called the <b>static context</b> and
          the <b>evaluation context</b>.</p>

          <div class="div3">
            <h4><a name="static_context"
            id="static_context"></a>2.1.1 Static Context</h4>

            <p>The <b>static context</b> of an expression is the
            information that is available during static analysis of
            the expression, prior to its evaluation. This
            information can be used to decide whether the
            expression contains a static error.</p>

            <p>Any component of the static context that is not
            assigned a default value in the XPath specification,
            <span class="xpath"><span class="xpath">and is not
            assigned a value by the host language,</span></span>
            may be assigned an implementation-defined initial
            value. If processing of an expression relies on some
            component of the static context that has not been
            assigned a value, a static error is raised.</p>

            <p>Static context consists of the following
            components:</p>

            <ul>
              <li class="xpath">
                <p><b>XPath 1.0 compatibility mode.</b> This value
                is <code>true</code> if rules for backward
                compatibility with XPath Version 1.0 are in effect;
                otherwise it is <code>false</code>.</p>
              </li>

              <li>
                <p><b>In-scope namespaces.</b> This is a set of
                (prefix, URI) pairs. The in-scope namespaces are
                used for resolving prefixes used in QNames within
                the expression.</p>
              </li>

              <li>
                <p><b>Default element namespace.</b> This is a
                namespace URI. This namespace is used for any
                unprefixed QName appearing in a position where an
                element or type name is expected.</p>
              </li>

              <li>
                <p><b>Default function namespace.</b> This is a
                namespace URI. This namespace URI is used for any
                unprefixed QName appearing as the function name in
                a function call.</p>
              </li>

              <li>
                <p><b>In-scope schema definitions.</b> This is a
                generic term for all the element, attribute, and
                type definitions that are in scope during
                processing of an expression. It includes the
                following three parts:</p>

                <ul>
                  <li>
                    <p><b>In-scope type definitions.</b> The
                    in-scope type definitions always include the
                    built-in types of <a href="#XMLSchema">[XML
                    Schema]</a> and the predefined types in the
                    namespace
                    <code>http://www.w3.org/2003/05/xpath-datatypes</code>.
                    Additional type definitions may be added to the
                    in-scope type definitions by the <span
                    class="xpath"><span class="xpath">host
                    language.</span></span></p>

                    <p>XML Schema distinguishes <b>named types</b>,
                    which are given a QName by the schema designer,
                    must be declared at the top level of a schema,
                    and are uniquely identified by their QName,
                    from <b>anonymous types</b>, which are not
                    given a name by the schema designer, must be
                    local, and are identified in an
                    implementation-dependent way. Both named types
                    and anonymous types can be present in the
                    in-scope type definitions.</p>
                  </li>

                  <li>
                    <p><b>In-scope element declarations.</b> Each
                    element declaration is identified either by a
                    QName (for a top-level element) or by an
                    implementation-defined element identifier (for
                    a local element). Element declarations may be
                    provided by the language environment.An element
                    declaration includes information about the
                    <b>substitution groups</b> to which this
                    element belongs.</p>
                  </li>

                  <li>
                    <p><b>In-scope attribute declarations.</b> Each
                    attribute declaration is identified either by a
                    QName (for a top-level attribute) or by an
                    implementation-defined attribute identifier
                    (for a local attribute). Attribute declarations
                    may be provided by the language
                    environment.</p>
                  </li>
                </ul>
              </li>

              <li>
                <p><b>In-scope variables.</b> This is a set of
                (QName, type) pairs. It defines the set of
                variables that have been declared and are available
                for reference within the expression. The QName
                represents the name of the variable, and the type
                represents its static data type.</p>

                <p>The static types of in-scope variables may be
                derived from static analysis of the expressions in
                which the variables are bound, or provided by the
                external environment.</p>
              </li>

              <li>
                <p><b>In-scope functions.</b> This part of the
                static context defines the set of functions that
                are available to be called from within an
                expression. Each function is uniquely identified by
                its QName and its arity (number of parameters). The
                static context maps the QName and arity into a
                function signature and a function definition. The
                function signature specifies the static types of
                the function parameters and the function
                result.</p>

                <p>For each atomic type in the <b>in-scope type
                definitions</b>, there is a constructor function in
                the <b>in-scope functions</b>. Constructor
                functions are discussed in <a
                href="#id-constructor-functions"><b>3.10.4
                Constructor Functions</b></a>.</p>
              </li>

              <li>
                <p><b>In-scope collations.</b> This is a set of
                (URI, collation) pairs. It defines the names of the
                collations that are available for use in function
                calls that take a collation name as an argument. A
                collation may be regarded as an object that
                supports two functions: a function that given a set
                of strings, returns a sequence containing those
                strings in sorted order; and a function that given
                two strings, returns true if they are considered
                equal, and false if not.</p>
              </li>

              <li>
                <p><b>Default collation.</b> This is a collation.
                This collation is used by string comparison
                functions when no explicit collation is
                specified.</p>
              </li>

              <li>
                <p><b>Base URI.</b> This is an absolute URI, used
                when necessary in the resolution of relative URIs
                (for example, by the <code>fn:resolve-uri</code>
                function.) The <b>base URI</b> is always provided
                by the external environment.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="eval_context" id="eval_context"></a>2.1.2
            Evaluation Context</h4>

            <p>The <b>evaluation context</b> of an expression is
            defined as information that is available at the time
            the expression is evaluated.</p>

            <p>Any component of the evaluation context that is not
            assigned a default value in the XPath specification,
            <span class="xpath"><span class="xpath">and is not
            assigned a value by the host language,</span></span>
            may be assigned an implementation-defined initial
            value. If processing of an expression relies on some
            component of the evaluation context that has not been
            assigned a value, a dynamic error is raised.</p>

            <p>The evaluation context consists of all the
            components of the <b>static context</b>, and the
            additional components listed below.</p>

            <p>The first three components of the evaluation context
            (context item, context position, and context size) are
            called the <b>focus</b> of the expression. The focus
            enables the processor to keep track of which nodes are
            being processed by the expression.</p>

            <p>The focus for the outermost expression may supplied
            by the environment in which the expression is
            evaluated--otherwise, the focus for the outermost
            expression is undefined. Any reference to a component
            of an undefined focus raises an error. Certain language
            constructs, notably the path expression
            <code>E1/E2</code> and the predicate expression
            <code>E1[E2]</code>, create a new focus for the
            evaluation of a sub-expression. In these constructs,
            <code>E2</code> is evaluated once for each item in the
            sequence that results from evaluating <code>E1</code>.
            Each time <code>E2</code> is evaluated, it is evaluated
            with a different focus. The focus for evaluating
            <code>E2</code> is referred to below as the <b>inner
            focus</b>, while the focus for evaluating
            <code>E1</code> is referred to as the <b>outer
            focus</b>. The inner focus exists only while
            <code>E2</code> is being evaluated. When this
            evaluation is complete, evaluation of the containing
            expression continues with its original focus
            unchanged.</p>

            <ul>
              <li>
                <p>The <b>context item</b> is the item currently
                being processed. An item is either an atomic value
                or a node. When the context item is a node, it can
                also be referred to as the <b>context node</b>. The
                context item is returned by the expression
                "<code>.</code>". When an expression
                <code>E1/E2</code> or <code>E1[E2]</code> is
                evaluated, each item in the sequence obtained by
                evaluating <code>E1</code> becomes the context item
                in the inner focus for an evaluation of
                <code>E2</code>.</p>
              </li>

              <li>
                <p>The <b>context position</b> is the position of
                the context item within the sequence of items
                currently being processed. It changes whenever the
                context item changes. Its value is always an
                integer greater than zero. The context position is
                returned by the expression
                <code>fn:position()</code>. When an expression
                <code>E1/E2</code> or <code>E1[E2]</code> is
                evaluated, the context position in the inner focus
                for an evaluation of <code>E2</code> is the
                position of the context item in the sequence
                obtained by evaluating <code>E1</code>. The
                position of the first item in a sequence is always
                1 (one). The context position is always less than
                or equal to the context size.</p>
              </li>

              <li>
                <p>The <b>context size</b> is the number of items
                in the sequence of items currently being processed.
                Its value is always an integer greater than zero.
                The context size is returned by the expression
                <code>last()</code>. When an expression
                <code>E1/E2</code> or <code>E1[E2]</code> is
                evaluated, the context size in the inner focus for
                an evaluation of <code>E2</code> is the number of
                items in the sequence obtained by evaluating
                <code>E1</code>.</p>
              </li>

              <li>
                <p><b>Dynamic variables.</b> This is a set of
                (QName, value) pairs. It contains the same QNames
                as the <b>in-scope variables</b> in the static
                context for the expression. Each variable name is
                associated with a typed value. The dynamic type
                associated with the value of a variable may be more
                specific than the static type associated with the
                same variable. The value of a variable is, in
                general, a sequence.</p>

                <p>The typed value of a variable may be set by
                execution of an expression that binds a value to
                the variable, or by the external environment.</p>
              </li>

              <li>
                <p><b>Current date and time.</b> This information
                represents an implementation-dependent point in
                time during processing of a query or
                transformation. It can be retrieved by the
                <code>fn:current-date</code>,
                <code>fn:current-time</code>, and
                <code>fn:current-dateTime</code> functions. If
                invoked multiple times during the execution of a
                query or transformation, these functions always
                returns the same result.</p>
              </li>

              <li>
                <p><b>Implicit timezone.</b> This is the timezone
                to be used when a date, time, or dateTime value
                that does not have a timezone is used in a
                comparison or in any other operation. This value is
                an instance of <code>xdt:dayTimeDuration</code>
                that is implementation-defined. See <a
                href="#ISO8601">[ISO 8601]</a> for the range of
                legal values of a timezone.</p>
              </li>

              <li>
                <p><b>Input sequence.</b> An input sequence is a
                sequence of nodes that can be accessed by the
                <code>input</code> function. It might be thought of
                as an "implicit input". The content of the input
                sequence is determined <span class="xpath"><span
                class="xpath">by the host
                language.</span></span></p>
              </li>
            </ul>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-input-functions"
          id="id-input-functions"></a>2.2 Input Functions</h3>

          <p>XPath has a set of functions that provide access to
          input data. These functions are of particular importance
          because they provide a way in which an expression can
          reference a document or a collection of documents. The
          input functions are described informally here, and in
          more detail in <a href="#FunctionsAndOperators">[XQuery
          1.0 and XPath 2.0 Functions and Operators]</a>.</p>

          <p>The <b>input sequence</b> is a part of the evaluation
          context for an expression. The way in which nodes are
          assigned to the input sequence is <span
          class="xpath"><span class="xpath">defined by the host
          language.</span></span></p>

          <p>The input functions supported by XPath are as
          follows:</p>

          <ul>
            <li>
              <p>The <code>fn:input</code> function, which takes no
              parameters, returns the input sequence. For example,
              the expression <code>fn:input()//customer</code>
              returns all the <code>customer</code> elements that
              are descendants of nodes in the input sequence. If no
              input sequence has been bound, the
              <code>fn:input</code> function raises a dynamic
              error.</p>
            </li>

            <li>
              <p>The <code>fn:collection</code> function returns
              the nodes found in a collection. A collection may be
              any sequence of nodes. A collection is identified by
              a string, which must be a valid URI. For example, the
              expression
              <code>fn:collection("http://example.org")//customer</code>
              identifies all the <code>customer</code> elements
              that are descendants of nodes found in the collection
              whose URI is <code>http://example.org</code>.</p>
            </li>

            <li>
              <p>The <code>fn:doc</code> function, when its first
              argument is a string containing a single URI that
              refers to an XML document, returns a document node
              whose content is the Data Model representation of the
              given document.</p>
            </li>
          </ul>

          <p>If a given input function is invoked repeatedly with
          the same arguments during the scope of a single query or
          transformation, each invocation returns the same
          result.</p>
        </div>

        <div class="div2">
          <h3><a name="d0e722" id="d0e722"></a>2.3 Expression
          Processing</h3>

          <table border="1" summary="Editorial note">
            <tr>
              <td align="left" valign="top" width="50%">
              <b>Editorial note</b></td>

              <td align="right" valign="top" width="50%">
              &#160;</td>
            </tr>

            <tr>
              <td colspan="2" align="left" valign="top">Some
              material in this section duplicates material in <a
              href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
              Model]</a>. Work is in progress to decide where this
              material will be normatively defined (see Issue
              554.)</td>
            </tr>
          </table>

          <p>XPath is defined in terms of the <a
          href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
          Model]</a> (referred to in this document simply as the
          Data Model), which represents information in the form of
          nodes and atomic values. Before an XPath expression can
          be processed, the input documents to be operated on by
          the expression must be represented in the Data Model. For
          example, an XML document might be converted to the Data
          Model by the following steps:</p>

          <ol class="enum1">
            <li>
              <p>The document might be parsed using an XML parser
              that generates an <b>XML Information Set</b> (see <a
              href="#XINFO">[XML Infoset]</a>).</p>
            </li>

            <li>
              <p>The parsed document might be validated against one
              or more schemas. This process, which is described in
              <a href="#XMLSchema">[XML Schema]</a>, results in an
              abstract information structure called the
              <b>Post-Schema Validation Infoset</b> (PSVI).</p>
            </li>

            <li>
              <p>If necessary, the PSVI can be transformed to make
              it acceptable for processing by a particular system.
              For example, if the implementation understands only
              built-in XML Schema types, user-defined typenames in
              the PSVI might be replaced by their built-in base
              types or by generic types such as
              <code>xs:anyType</code> (for elements) and
              <code>xs:anySimpleType</code> (for attributes).</p>
            </li>

            <li>
              <p>The PSVI can be transformed into the Data Model by
              a process described in <a href="#datamodel">[XQuery
              1.0 and XPath 2.0 Data Model]</a>. During this
              transformation, an error is raised if the PSVI
              contains an element, attribute, or type whose
              expanded name matches a name in the <b>in-scope
              schema definitions</b> (ISSD), but whose definition
              in the PSVI is not consistent with the corresponding
              definition in the ISSD. Typenames in the PSVI that
              are not present in the ISSD are replaced by
              <code>xs:anyType</code> (for types of elements) or
              <code>xs:anySimpleType</code> (for types of
              attributes). At the conclusion of the transformation
              process, every element name, attribute name, and type
              name in the resulting Data Model instance matches an
              entry in the ISSD.</p>
            </li>
          </ol>

          <p>The above steps provide an example of how a Data Model
          instance might be constructed. A Data Model instance
          might also be synthesized directly from a relational
          database, or constructed in some other way. XPath is
          defined in terms of operations on the Data Model, but it
          does not place any constraints on how the input Data
          Model instance is constructed (except for the constraint
          that the result must be consistent with the <b>in-scope
          schema definitions</b>).</p>

          <p>Each element or attribute node in the Data Model has
          an annotation that indicates its <b>dynamic type</b>. If
          the Data Model was derived from an input XML document,
          the dynamic types of the elements and attributes are
          derived from schema validation. The dynamic type of an
          element or attribute indicates its range of values--for
          example, an attribute named <code>version</code> might
          have the dynamic type <code>xs:decimal</code>, indicating
          that it contains a decimal value.</p>

          <p>The value of an attribute is represented directly
          within the attribute node. An attribute node whose type
          is unknown (such as might occur in a schemaless document)
          is annotated with the dynamic type
          <code>xdt:untypedAtomic</code>.</p>

          <p>The value of an element is represented by the children
          of the element node, which may include text nodes and
          other element nodes. The dynamic type of an element node
          indicates how the values in its child text nodes are to
          be interpreted. An element whose type is unknown (such as
          might occur in a schemaless document) is annotated with
          the type <code>xs:anyType</code>.</p>

          <p>Atomic values in the Data Model also carry dynamic
          type annotations. An atomic value of unknown type is
          annotated with the type <code>xdt:untypedAtomic</code>.
          Under certain circumstances (such as during processing of
          an arithmetic operator), an atomic value of
          <code>xdt:untypedAtomic</code> may be cast into a more
          specific type (such as <code>xs:double</code>).</p>

          <p>This document provides a description of how each kind
          of expression is processed. For each expression, the
          operands and result are instances of the Data Model.</p>

          <p>The terms <b>document order</b>, <b>typed value</b>,
          and <b>string value</b> are described here because they
          are of particular importance for the processing of
          expressions.</p>

          <div class="div3">
            <h4><a name="d0e824" id="d0e824"></a>2.3.1 Document
            Order</h4>

            <p><b>Document order</b> defines a total ordering among
            all the nodes seen by the language processor.
            Informally, document order corresponds to a pre-order,
            depth-first, left-to-right traversal of the nodes in
            the Data Model.</p>

            <p>Within a given document, the document node is the
            first node, followed by element nodes, text nodes,
            comment nodes, and processing instruction nodes in the
            order of their representation in the XML form of the
            document (after expansion of entities). Element nodes
            occur before their children, and the children of an
            element node occur before its following siblings. The
            namespace nodes of an element immediately follow the
            element node, in implementation-defined order. The
            attribute nodes of an element immediately follow its
            namespace nodes, and are also in implementation-defined
            order.</p>

            <p>The relative order of nodes in distinct documents is
            implementation-defined but stable within a given query
            or transformation. Given two distinct documents A and
            B, if a node in document A is before a node in document
            B, then every node in document A is before every node
            in document B. The relative order among free-floating
            nodes (those not in a document) is also
            implementation-defined but stable.</p>
          </div>

          <div class="div3">
            <h4><a name="id-typed-value"
            id="id-typed-value"></a>2.3.2 Typed Value and String
            Value</h4>

            <p>Nodes have a <b>typed value</b> and a <b>string
            value</b> that can be extracted by calling the
            <code>fn:data</code> function and the
            <code>fn:string</code> function, respectively. The
            typed value of a node is a sequence of atomic values,
            and the string value of a node is a string. Element and
            attribute nodes also have a <b>type annotation</b>,
            which is a type identifier that is found in the
            <b>in-scope type definitions</b>. The type annotation
            represents the dynamic (run-time) type of the node.
            XPath does not provide a way to directly access the
            type annotation of an element or attribute node.</p>

            <p>The typed value and string value for each kind of
            node are defined by the <code>dm:typed-value</code> and
            <code>dm:string-value</code> accessors in <a
            href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
            Model]</a>. The relationship between the typed value
            and the string value for various kinds of nodes is
            described and illustrated by examples below.</p>

            <ol class="enum1">
              <li>
                <p>For text, document, comment, processing
                instruction, and namespace nodes, the typed value
                of the node is the same as its string value, as an
                instance of <code>xdt:untypedAtomic</code>. (The
                string value of a document node is formed by
                concatenating the string values of all its
                descendant text nodes, in document order.)</p>
              </li>

              <li>
                <p>The typed value of an attribute node with the
                type annotation <code>xdt:untypedAtomic</code> is
                the same as its string value, as an instance of
                <code>xdt:untypedAtomic</code>. The typed value of
                an attribute node with any other type annotation is
                derived from its string value and type annotation
                in a way that is consistent with schema
                validation.</p>

                <p>Example: A1 is an attribute having string value
                <code>"3.14E-2"</code> and type annotation
                <code>xs:double</code>. The typed value of A1 is
                the <code>xs:double</code> value whose lexical
                representation is <code>3.14E-2</code>.</p>

                <p>Example: A2 is an attribute with type annotation
                <code>IDREFS</code>, which is a list type derived
                from <code>IDREF</code>. Its string value is
                "<code>bar baz faz</code>". The typed value of A2
                is a sequence of three atomic values
                ("<code>bar</code>", "<code>baz</code>",
                "<code>faz</code>"), each of type
                <code>IDREF</code>. The typed value of a node is
                never treated as an instance of a named list type.
                Instead, if the type annotation of a node is a list
                type (such as <code>IDREFS</code>), its typed value
                is treated as a sequence of the underlying base
                type (such as <code>IDREF</code>).</p>
              </li>

              <li>
                <p>For an element node, the relationship between
                typed value and string value depends on the node's
                type annotation, as follows:</p>

                <ol class="enuma">
                  <li>
                    <p>If the type annotation is
                    <code>xs:anyType</code>, or denotes a complex
                    type with mixed content, then the typed value
                    of the node is equal to its string value, as an
                    instance of <code>xdt:untypedAtomic</code>.</p>

                    <p>Example: E1 is an element node having type
                    annotation <code>xs:anyType</code> and string
                    value "<code>1999-05-31</code>". The typed
                    value of E1 is "<code>1999-05-31</code>", as an
                    instance of <code>xdt:untypedAtomic</code>.</p>

                    <p>Example: E2 is an element node with the type
                    annotation <code>formula</code>, which is a
                    complex type with mixed content. The content of
                    E2 consists of the character "<code>H</code>",
                    a child element named <code>subscript</code>
                    with string value "<code>2</code>", and the
                    character "<code>O</code>". The typed value of
                    E2 is "<code>H2O</code>" as an instance of
                    <code>xdt:untypedAtomic</code>.</p>
                  </li>

                  <li>
                    <p>If the type annotation denotes a simple type
                    or a complex type with simple content, then the
                    typed value of the node is derived from its
                    string value and its type annotation in a way
                    that is consistent with schema validation.</p>

                    <p>Example: E3 is an element node with the type
                    annotation <code>cost</code>, which is a
                    complex type that has several attributes and a
                    simple content type of <code>xs:decimal</code>.
                    The string value of E3 is "<code>74.95</code>".
                    The typed value of E3 is <code>74.95</code>, as
                    an instance of <code>xs:decimal</code>.</p>

                    <p>Example: E4 is an element node with the type
                    annotation <code>hatsizelist</code>, which is a
                    simple type derived by list from the type
                    <code>hatsize</code>, which in turn is derived
                    from <code>xs:integer</code>. The string value
                    of E4 is "<code>7 8 9</code>". The typed value
                    of E4 is a sequence of three values
                    (<code>7</code>, <code>8</code>,
                    <code>9</code>), each of type
                    <code>hatsize</code>.</p>
                  </li>

                  <li>
                    <p>If the type annotation denotes a complex
                    type with empty content, then the typed value
                    of the node is the empty sequence.</p>
                  </li>

                  <li>
                    <p>If the type annotation denotes a complex
                    type with non-mixed complex content, then the
                    typed value of the node is undefined. The
                    <code>fn:data</code> function raises an error
                    when applied to such a node.</p>

                    <p>Example: E5 is an element node with the type
                    annotation <code>weather</code>, which is a
                    complex type whose content type specifies
                    <code>elementOnly</code>. E5 has two child
                    elements named <code>temperature</code> and
                    <code>precipitation</code>. The typed value of
                    E5 is undefined, and the <code>fn:data</code>
                    function applied to E5 raises an error.</p>
                  </li>
                </ol>
              </li>
            </ol>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-type-conversion"
          id="id-type-conversion"></a>2.4 Types</h3>

          <p>XPath is a strongly typed language with a type system
          based on <a href="#XMLSchema">[XML Schema]</a>. When the
          type of a value is incompatible with the expected type
          for the context in which it is used, a <b>type error</b>
          is raised. A type error may be detected and reported
          during the analysis phase or during the evaluation phase,
          as described in <a href="#id-type-checking"><b>2.4.2 Type
          Checking</b></a>.</p>

          <p>The XPath type system is formally defined in <a
          href="#XQueryFormalSemantics">[XQuery 1.0 Formal
          Semantics]</a>. This section presents a summary of types
          from a user's perspective.</p>

          <div class="div3">
            <h4><a name="d0e1065" id="d0e1065"></a>2.4.1 Predefined
            Types</h4>

            <p>All the built-in types of <a href="#XMLSchema">[XML
            Schema]</a> are recognized by XPath. These built-in
            types are in the namespace
            <code>http://www.w3.org/2001/XMLSchema</code>, <span
            class="xpath"><span class="xpath">which is represented
            in this document by the prefix</span></span>
            <code>xs</code>. Some examples of built-in schema types
            include <code>xs:integer</code>,
            <code>xs:string</code>, and <code>xs:date</code>.</p>

            <p>In addition, XPath recognizes the predefined types
            listed below. All these predefined types are in the
            namespace
            <code>http://www.w3.org/2003/05/xpath-datatypes</code>,
            which is <span class="xpath"><span
            class="xpath">represented in this document by the
            prefix</span></span> <code>xdt</code>.</p>

            <ol class="enum1">
              <li>
                <p><code>xdt:anyAtomicType</code> is an abstract
                type that includes all atomic values (and no values
                that are not atomic). It is a subtype of
                <code>xs:anySimpleType</code>, which is the base
                type for all simple types, including atomic, list,
                and union types. All specific atomic types such as
                <code>xs:integer</code>, <code>xs:string</code>,
                and <code>xdt:untypedAtomic</code>, are subtypes of
                <code>xdt:anyAtomicType</code>.</p>
              </li>

              <li>
                <p><code>xdt:untypedAtomic</code> is a specific
                atomic type used for untyped data, such as text
                that is not given a specific type by schema
                validation. It has no subtypes.</p>
              </li>

              <li>
                <p><code>xdt:dayTimeDuration</code> is a subtype of
                <code>xs:duration</code> whose lexical
                representation contains only day, hour, minute, and
                second components.</p>
              </li>

              <li>
                <p><code>xdt:yearMonthDuration</code> is a subtype
                of <code>xs:duration</code> whose lexical
                representation is restricted to contain only year
                and month components.</p>
              </li>
            </ol>

            <p>For more details about predefined types, see <a
            href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a>.</p>

            <p><span class="xpath"><span class="xpath">Additional
            type definitions may be added by the host language
            environment via the <b>in-scope type
            definitions</b>.</span></span></p>
          </div>

          <div class="div3">
            <h4><a name="id-type-checking"
            id="id-type-checking"></a>2.4.2 Type Checking</h4>

            <p>XPath defines two phases of processing called the
            <b>analysis phase</b> and the <b>evaluation
            phase</b>.</p>

            <p>The <b>analysis phase</b> depends on the expression
            itself and on the <b>static context</b>. The analysis
            phase does not depend on any input data. The purpose of
            type-checking during the analysis phase is to provide
            early detection of type errors and to compute the type
            of a result.</p>

            <p>During the analysis phase, each expression is
            assigned a <b>static type</b>. In some cases, the
            static type is derived from the lexical form of the
            expression; for example, the static type of the literal
            <code>5</code> is <code>xs:integer</code>. In other
            cases, the static type of an expression is inferred
            according to rules based on the static types of its
            operands; for example, the static type of the
            expression <code>5 + 1.2</code> is
            <code>xs:decimal</code>. The static type of an
            expression may be either a named type or a structural
            description--for example, <code>xs:boolean?</code>
            denotes an optional occurrence of the
            <code>xs:boolean</code> type. The rules for inferring
            the static types of various expressions are described
            in <a href="#XQueryFormalSemantics">[XQuery 1.0 Formal
            Semantics]</a>. During the analysis phase, if static
            type checking is in effect and an operand of an
            expression is found to have a static type that is not
            appropriate for that operand, a type error is raised.
            If static type checking raises no errors and assigns a
            static type T to an expression, then execution of the
            expression on valid input data is guaranteed either to
            produce a value of type T or to raise a dynamic
            error.</p>

            <p>The <b>evaluation phase</b> is performed only after
            successful completion of the <b>analysis phase</b>. The
            evaluation phase depends on input data, on the
            expression being evaluated, and on the <b>evaluation
            context</b>. During the evaluation phase, a <b>dynamic
            type</b> is associated with each value as it is
            computed. The dynamic type of a value may be either a
            structural type (such as "sequence of integers") or a
            named type. The dynamic type of a value may be more
            specific than the static type of the expression that
            computed it (for example, the static type of an
            expression might be "zero or more integers or strings,"
            but at run time its value may have the dynamic type
            "integer.") If an operand of an expression is found to
            have a dynamic type that is incompatible with the
            expected type for that operand, a type error is
            raised.</p>

            <p>Even though static typing can catch many type errors
            before an expression is executed, it is possible for an
            expression to raise an error during evaluation that was
            not detected by static analysis. For example, an
            expression may contain a cast of a string into an
            integer, which is statically valid. However, if the
            actual value of the string at run time cannot be cast
            into an integer, a dynamic error will result.
            Similarly, an expression may apply an arithmetic
            operator to a value whose static type is
            <code>xs:anySimpleType</code>. This is not a static
            error, but at run time, if the value cannot be
            successfully cast to a numeric type, a dynamic error
            will be raised.</p>

            <p>It is also possible for static analysis of an
            expression to raise a type error, even though execution
            of the expression on certain inputs would be
            successful. For example, an expression might contain a
            function that requires an element as its parameter, and
            the analysis phase might infer the static type of the
            function parameter to be an optional element. This case
            would be treated as a static type error, even though
            the function call would be successful for input data in
            which the optional element is present.</p>
          </div>

          <div class="div3">
            <h4><a name="id-sequencetype"
            id="id-sequencetype"></a>2.4.3 SequenceType</h4>

            <p>When it is necessary to refer to a type in an XPath
            expression, the syntax shown below is used. This syntax
            production is called "SequenceType", since it describes
            the type of an XPath value, which is a sequence.</p>

            <h5><a name="d0e1223"
            id="d0e1223"></a>SequenceType</h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SequenceType"
                  id="doc-SequenceType"></a>[61]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SequenceType">SequenceType</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>(<a href="#doc-ItemType">ItemType</a>
                  <a
                  href="#doc-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />

                  | "empty" "(" ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-OccurrenceIndicator"
                  id="doc-OccurrenceIndicator"></a>[76]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-OccurrenceIndicator">OccurrenceIndicator</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"?" | "*" | "+"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ItemType"
                  id="doc-ItemType"></a>[63]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ItemType">ItemType</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-AtomicType">AtomicType</a> | <a
                  href="#doc-KindTest">KindTest</a> | "item" "("
                  ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AtomicType"
                  id="doc-AtomicType"></a>[62]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AtomicType">AtomicType</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-QName">QName</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-KindTest"
                  id="doc-KindTest"></a>[64]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-KindTest">KindTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-DocumentTest">DocumentTest</a><br />
                  | <a
                  href="#doc-ElementTest">ElementTest</a><br />
                  | <a
                  href="#doc-AttributeTest">AttributeTest</a><br />
                  | <a
                  href="#doc-ProcessingInstructionTest">ProcessingInstructionTest</a><br />

                  | <a
                  href="#doc-CommentTest">CommentTest</a><br />
                  | <a href="#doc-TextTest">TextTest</a><br />
                  | <a
                  href="#doc-AnyKindTest">AnyKindTest</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ProcessingInstructionTest"
                  id="doc-ProcessingInstructionTest"></a>[67]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ProcessingInstructionTest">ProcessingInstructionTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"processing-instruction" "(" <a
                  href="#doc-StringLiteral">StringLiteral</a>?
                  ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-CommentTest"
                  id="doc-CommentTest"></a>[69]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-CommentTest">CommentTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"comment" "(" ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-TextTest"
                  id="doc-TextTest"></a>[70]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-TextTest">TextTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"text" "(" ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AnyKindTest"
                  id="doc-AnyKindTest"></a>[71]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AnyKindTest">AnyKindTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"node" "(" ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-DocumentTest"
                  id="doc-DocumentTest"></a>[68]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-DocumentTest">DocumentTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"document-node" "(" <a
                  href="#doc-ElementTest">ElementTest</a>?
                  ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ElementTest"
                  id="doc-ElementTest"></a>[65]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ElementTest">ElementTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"element" "(" ((<a
                  href="#doc-SchemaContextPath">SchemaContextPath</a>
                  <a href="#doc-LocalName">LocalName</a>)<br />
                  | (<a href="#doc-NodeName">NodeName</a> ("," <a
                  href="#doc-TypeName">TypeName</a>
                  "nillable"?)?))? ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AttributeTest"
                  id="doc-AttributeTest"></a>[66]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AttributeTest">AttributeTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"attribute" "(" ((<a
                  href="#doc-SchemaContextPath">SchemaContextPath</a>
                  "@" <a href="#doc-LocalName">LocalName</a>)<br />
                  | ("@" <a href="#doc-NodeName">NodeName</a> (","
                  <a href="#doc-TypeName">TypeName</a>)?))?
                  ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SchemaContextPath"
                  id="doc-SchemaContextPath"></a>[72]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SchemaContextPath">SchemaContextPath</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-SchemaGlobalContext">SchemaGlobalContext</a>
                  "/" <a
                  href="#doc-SchemaContextStep">SchemaContextStep</a>
                  "/"*</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SchemaGlobalContext"
                  id="doc-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SchemaGlobalContext">SchemaGlobalContext</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-QName">QName</a> | <a
                  href="#doc-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SchemaContextStep"
                  id="doc-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SchemaContextStep">SchemaContextStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-QName">QName</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SchemaGlobalTypeName"
                  id="doc-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"type" "(" <a
                  href="#prod-QName">QName</a> ")"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-LocalName"
                  id="doc-LocalName"></a>[73]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-LocalName">LocalName</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-QName">QName</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-NodeName"
                  id="doc-NodeName"></a>[74]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-NodeName">NodeName</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-QName">QName</a> |
                  "*"</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-TypeName"
                  id="doc-TypeName"></a>[75]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-TypeName">TypeName</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-QName">QName</a> |
                  "*"</code></td>
                </tr>
              </tbody>
            </table>

            <p>QNames appearing in a SequenceType have their
            prefixes expanded to namespace URIs by means of the
            <b>in-scope namespaces</b> and the <b>default element
            namespace</b>. It is a static error to use a name in a
            SequenceType if that name is not found in the
            appropriate part of the <b>in-scope schema
            definitions</b>. If the name is used as an element
            name, it must appear in the <b>in-scope element
            declarations</b>; if it is used as an attribute name,
            it must appear in the <b>in-scope attribute
            declarations</b>; and if it is used as a type name, it
            must appear in the <b>in-scope type
            definitions</b>.</p>

            <p>Here are some examples of SequenceTypes that might
            be used in XPath expressions:</p>

            <ul>
              <li>
                <p><code>xs:date</code> refers to the built-in
                Schema type <code>date</code></p>
              </li>

              <li>
                <p><code>attribute()?</code> refers to an optional
                attribute</p>
              </li>

              <li>
                <p><code>element()</code> refers to any element</p>
              </li>

              <li>
                <p><code>element(po:shipto, po:address)</code>
                refers to an element that has the name
                <code>po:shipto</code> (or is in the substitution
                group of that element), and has the type annotation
                <code>po:address</code> (or a subtype of that
                type)</p>
              </li>

              <li>
                <p><code>element(po:shipto, *)</code> refers to an
                element named <code>po:shipto</code> (or in the
                substitution group of <code>po:shipto</code>), with
                no restrictions on its type</p>
              </li>

              <li>
                <p><code>element(*, po:address)</code> refers to an
                element of any name that has the type annotation
                <code>po:address</code> (or a subtype of
                <code>po:address</code>). If the keyword
                <code>nillable</code> were used following
                <code>po:address</code>, that would indicate that
                the element may have empty content and the
                attribute <code>xsi:nil="true"</code>, even though
                the declaration of the type <code>po:address</code>
                has required content.</p>
              </li>

              <li>
                <p><code>node()*</code> refers to a sequence of
                zero or more nodes of any type</p>
              </li>

              <li>
                <p><code>item()+</code> refers to a sequence of one
                or more nodes or atomic values</p>
              </li>
            </ul>

            <div class="div4">
              <h5><a name="id-sequencetype-matching"
              id="id-sequencetype-matching"></a>2.4.3.1
              SequenceType Matching</h5>

              <p>During processing of an expression, it is
              sometimes necessary to determine whether a given
              value matches a type that was declared using the
              SequenceType syntax. This process is known as
              <b>SequenceType matching</b>. For example, an
              <code>instance of</code> expression returns
              <code>true</code> if a given value matches a given
              type, or <code>false</code> if it does not.</p>

              <p><b>SequenceType matching</b> between a given value
              and a given SequenceType is performed as follows:</p>

              <p>If the SequenceType is <code>empty()</code>, the
              match succeeds only if the value is an empty
              sequence. If the SequenceType is an ItemType with no
              OccurrenceIndicator, the match succeeds only if the
              value contains precisely one item and that item
              matches the ItemType (see below). If the SequenceType
              contains an ItemType and an OccurrenceIndicator, the
              match succeeds only if the number of items in the
              value is consistent with the OccurrenceIndicator, and
              each of these items matches the ItemType. As a
              consequence of these rules, a value that is an empty
              sequence matches any SequenceType whose occurrence
              indicator is <code>*</code> or <code>?</code>.</p>

              <p>An <b>OccurrenceIndicator</b> indicates the number
              of items in a sequence, as follows:</p>

              <ul>
                <li>
                  <p><code>?</code> indicates zero or one items</p>
                </li>

                <li>
                  <p><code>*</code> indicates zero or more
                  items</p>
                </li>

                <li>
                  <p><code>+</code> indicates one or more items</p>
                </li>
              </ul>

              <p>As stated above, an item may be a node or an
              atomic value. The process of matching a given item
              against a given ItemType is performed as follows</p>

              <ol class="enum1">
                <li>
                  <p>The ItemType <code>item()</code> matches any
                  single item. For example, <code>item()</code>
                  matches the atomic value <code>1</code> or the
                  element <code>&lt;a/&gt;</code>.</p>
                </li>

                <li>
                  <p>If an ItemType consists simply of a QName,
                  that QName must be the name of an atomic type
                  that is in the <b>in-scope type definitions</b>;
                  otherwise a static error is raised. An ItemType
                  consisting of the QName of an atomic type matches
                  a value if the dynamic type of the value is the
                  same as the named atomic type, or is derived from
                  the named atomic type by restriction. For
                  example, the ItemType <code>xs:decimal</code>
                  matches the value <code>12.34</code> (a decimal
                  literal); it also matches a value whose dynamic
                  type is <code>shoesize</code>, if
                  <code>shoesize</code> is an atomic type derived
                  by restriction from <code>xs:decimal</code>. The
                  named atomic type may be a generic type such as
                  <code>xdt:anyAtomicType</code>. (Note that names
                  of non-atomic types such as
                  <code>xs:IDREFS</code> are not accepted in this
                  context.)</p>
                </li>

                <li>
                  <p>The following ItemTypes (referred to
                  generically as <b>KindTests</b>) match nodes:</p>

                  <ol class="enuma">
                    <li>
                      <p><code>node()</code> matches any node.</p>
                    </li>

                    <li>
                      <p><code>text()</code> matches any text
                      node.</p>
                    </li>

                    <li>
                      <p><code>processing-instruction()</code>
                      matches any processing instruction node.</p>
                    </li>

                    <li>
                      <p>
                      <code>processing-instruction(</code><em>N</em><code>
                      )</code> matches any processing instruction
                      node whose name (called its "PITarget" in
                      XML) is equal to <em>N</em>, where <em>N</em>
                      is a StringLiteral. Example:
                      <code>processing-instruction("browser")</code>
                      matches any processing instruction directed
                      to the application named
                      <code>browser</code>.</p>
                    </li>

                    <li>
                      <p><code>comment()</code> matches any comment
                      node.</p>
                    </li>

                    <li>
                      <p><code>document-node()</code> matches any
                      document node.</p>
                    </li>

                    <li>
                      <p>
                      <code>document-node(</code><em>E</em><code>)</code>
                      matches any document node whose content
                      consists of exactly one element node that
                      matches <em>E</em>, where <em>E</em> is an
                      <b>ElementTest</b> (see below). Example:
                      <code>document-node(element(book))</code>
                      matches any document node whose content
                      consists of exactly one element node named
                      <code>book</code>, that conforms to the
                      schema declaration for the top-level element
                      <code>book</code>.</p>
                    </li>

                    <li>
                      <p>An <b>ElementTest</b> (see below) matches
                      an element node, optionally qualifying the
                      node by its name, its type, or both.</p>
                    </li>

                    <li>
                      <p>An <b>AttributeTest</b> (see below)
                      matches an attribute node, optionally
                      qualifying the node by its name, its type, or
                      both.</p>
                    </li>
                  </ol>
                </li>
              </ol>

              <p>An <b>ElementTest</b> is used to match an element
              node by its name and/or type. An ElementTest may take
              one of the following forms:</p>

              <ol class="enum1">
                <li>
                  <p><code>element()</code>, or
                  <code>element(*)</code>, or
                  <code>element(*,*)</code>. All these forms of
                  ElementTest are equivalent, and they all match
                  any single element node, regardless of its name
                  or type.</p>
                </li>

                <li>
                  <p><code>element(</code><em>N</em><code>,</code>
                  <em>T</em><code>)</code>, where <em>N</em> is a
                  QName and <em>T</em> is a QName optionally
                  followed by the keyword <code>nillable</code>. In
                  this case, <em>T</em> must be the name of a
                  top-level type definition in the <b>in-scope type
                  definitions</b>. The ElementTest matches a given
                  element node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given element node is
                      equal to <em>N</em> (expanded QNames match),
                      or is equal to the name of any element in a
                      substitution group headed by a top-level
                      element with the name <em>N</em>; and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given element
                      node is <em>T</em>, or is a named type that
                      is derived by restriction or extension from
                      <em>T</em>. However, this test is not
                      satisfied if the given element node has an
                      attribute <code>xsi:nil="true"</code> and
                      <em>T</em> does not specify
                      <code>nillable</code>.</p>
                    </li>
                  </ol>

                  <p>The following examples illustrate this form of
                  ElementTest, matching an element node whose name
                  is <code>person</code> and whose type annotation
                  is <code>surgeon</code> (the second example
                  permits the element to have
                  <code>xsi:nil="true"</code>):</p>

                  <div class="exampleInner">
<pre>
element(person, surgeon)
element(person, surgeon nillable)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>element(</code><em>N</em><code>)</code>,
                  where <em>N</em> is a QName. This form is very
                  similar to the previous form, except that the
                  required type, rather than being named
                  explicitly, is taken from the top-level
                  declaration of element <em>N</em>. In this case,
                  <em>N</em> must be the name of a top-level
                  element declaration in the <b>in-scope element
                  declarations</b>. The ElementTest matches a given
                  element node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given element node is
                      equal to <em>N</em> (expanded QNames match),
                      or is equal to the name of any element in a
                      substitution group headed by <em>N</em>;
                      and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given element
                      node is the same as, or derived by
                      restriction or extension from, the type of
                      the top-level declaration for element
                      <em>N</em>. The types to be compared may be
                      either named types (identified by QNames) or
                      anonymous types (identified in an
                      implementation-dependent way). However, this
                      test is not satisfied if the given element
                      node has an attribute
                      <code>xsi:nil="true"</code> and the top-level
                      declaration for element <em>N</em> does not
                      specify <code>nillable</code>.</p>
                    </li>
                  </ol>
                  <br />
                  <br />

                  <p>The following example illustrates this form of
                  ElementTest, matching an element node whose name
                  is <code>person</code> and whose type annotation
                  conforms to the top-level <code>person</code>
                  element declaration in the <b>in-scope element
                  declarations</b>:</p>

                  <div class="exampleInner">
<pre>
element(person)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>element(</code><em>N</em><code>,
                  *),</code> where <em>N</em> is a QName. This
                  ElementTest matches a given element node if the
                  name of the node is equal to <em>N</em> (expanded
                  QNames match), or is equal to the name of any
                  element in a substitution group headed by a
                  top-level element with the name <em>N</em>. The
                  given element node may have any type
                  annotation.</p>

                  <p>The following example illustrates this form of
                  ElementTest, matching any element node whose name
                  is <code>person</code> or is in the
                  <code>person</code> substitution group,
                  regardless of its type annotation:</p>

                  <div class="exampleInner">
<pre>
element(person, *)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>element(*,</code>
                  <em>T</em><code>)</code>, where <em>T</em> is a
                  QName optionally followed by the keyword
                  <code>nillable</code>. In this case, <em>T</em>
                  must be the name of a top-level type definition
                  in the <b>in-scope type definitions</b>. The
                  ElementTest matches a given element node if the
                  node's type annotation is <em>T</em>, or is a
                  named type that is derived by restriction or
                  extension from <em>T</em>. However, this test is
                  not satisfied if the given element node has an
                  attribute <code>xsi:nil="true"</code> and
                  <em>T</em> does not specify
                  <code>nillable</code>.</p>

                  <p>The following examples illustrate this form of
                  ElementTest, matching any element node whose type
                  annotation is <code>surgeon</code>, regardless of
                  its name (the second example permits the element
                  to have <code>xsi:nil="true"</code>):</p>

                  <div class="exampleInner">
<pre>
element(*, surgeon)
element(*, surgeon nillable)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>element(</code><em>P</em><code>)</code>,
                  where <em>P</em> is a valid schema context path
                  beginning with a top-level element name or type
                  name in the <b>in-scope schema definitions</b>
                  and ending with an element name. This ElementTest
                  matches a given element node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given element node is
                      equal to the last name in the path (expanded
                      QNames match), and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given element
                      node is the same as the type of the element
                      represented by the schema path
                      <em>P</em>.</p>
                    </li>
                  </ol>

                  <p>The following examples illustrate this form of
                  ElementTest, matching element nodes whose name is
                  <code>person</code>. In the first example, the
                  node must conform to the schema definition of a
                  <code>person</code> element in a
                  <code>staff</code> element in a
                  <code>hospital</code> element. In the second
                  example, the node must conform to the schema
                  definition of a <code>person</code> element
                  within the top-level type
                  <code>schedule</code>:</p>

                  <div class="exampleInner">
<pre>
element(hospital/staff/person)
element(type(schedule)/person)
</pre>
                  </div>
                </li>
              </ol>

              <p>An <b>AttributeTest</b> is used to match an
              attribute node by its name and/or type. An
              AttributeTest may take one of the following
              forms:</p>

              <ol class="enum1">
                <li>
                  <p><code>attribute()</code>, or
                  <code>attribute(@*)</code>, or
                  <code>attribute(@*,*)</code>. All these forms of
                  AttributeTest are equivalent, and they all match
                  any single attribute node, regardless of its name
                  or type.</p>
                </li>

                <li>
                  <p>
                  <code>attribute(@</code><em>N</em><code>,</code>
                  <em>T</em><code>)</code>, where <em>N</em> and
                  <em>T</em> are QNames. In this case, <em>T</em>
                  must be the name of a top-level simple type
                  definition in the <b>in-scope type
                  definitions</b>. This AttributeTest matches a
                  given attribute node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given attribute node is
                      equal to <em>N</em> (expanded QNames match),
                      and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given attribute
                      node is <em>T</em>, or is a named type that
                      is derived by restriction from
                      <em>T</em>.</p>
                    </li>
                  </ol>

                  <p>The following example illustrates this form of
                  AttributeTest, matching an attribute node whose
                  name is <code>price</code> and whose type
                  annotation is <code>currency</code>:</p>

                  <div class="exampleInner">
<pre>
attribute(@price, currency)
</pre>
                  </div>
                </li>

                <li>
                  <p>
                  <code>attribute(@</code><em>N</em><code>)</code>,
                  where <em>N</em> is a QName. This form is very
                  similar to the previous form, except that the
                  required type, rather than being named
                  explicitly, is taken from the top-level attribute
                  declaration with name <em>N</em>.In this case,
                  <em>N</em> must be the name of a top-level
                  attribute declaration in the <b>in-scope
                  attribute declarations</b>. This AttributeTest
                  matches a given attribute node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given attribute node is
                      equal to <em>N</em> (expanded QNames match),
                      and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given attribute
                      node is the same as, or derived by
                      restriction from, the type of the top-level
                      attribute declaration for <em>N</em>. The
                      types to be compared may be either named
                      types (identified by QNames) or anonymous
                      types (identified in an
                      implementation-dependent way).</p>
                    </li>
                  </ol>
                  <br />
                  <br />

                  <p>The following example illustrates this form of
                  AttributeTest, matching an attribute node whose
                  name is <code>price</code> and whose type
                  annotation conforms to the schema declaration for
                  a top-level <code>price</code> attribute:</p>

                  <div class="exampleInner">
<pre>
attribute(@price)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>attribute(@</code><em>N</em><code>,
                  *)</code>, where <em>N</em> is a QName. This
                  AttributeTest matches a given attribute node if
                  the name of the node is equal to <em>N</em>
                  (expanded QNames match). The given attribute node
                  may have any type annotation.</p>

                  <p>The following example illustrates this form of
                  AttributeTest, matching any attribute node whose
                  name is <code>price</code>, regardless of its
                  type annotation:</p>

                  <div class="exampleInner">
<pre>
attribute(@price, *)
</pre>
                  </div>
                </li>

                <li>
                  <p><code>attribute(@*,</code>
                  <em>T</em><code>)</code>, where <em>T</em> is a
                  QName. In this case, <em>T</em> must be the name
                  of a top-level simple type definition in the
                  <b>in-scope type definitions</b>. This
                  AttributeTest matches a given attribute node if
                  the node's type annotation is <span>T</span>, or
                  is a named type that is derived by restriction
                  from <em>T</em>.</p>

                  <p>The following example illustrates this form of
                  AttributeTest, matching any attribute node whose
                  type annotation is <code>currency</code>,
                  regardless of its name:</p>

                  <div class="exampleInner">
<pre>
attribute(@*, currency)
</pre>
                  </div>
                </li>

                <li>
                  <p>
                  <code>attribute(</code><em>P</em><code>)</code>,
                  where <em>P</em> is a valid schema context path
                  beginning with a top-level element name or type
                  name in the <b>in-scope schema definitions</b>,
                  and ending with an attribute name (preceded by
                  <code>@</code>). This AttributeTest matches a
                  given attribute node if:</p>

                  <ol class="enuma">
                    <li>
                      <p>the name of the given attribute node is
                      equal to the last name in the path (expanded
                      QNames match), and:</p>
                    </li>

                    <li>
                      <p>the type annotation of the given attribute
                      node is the same as the type of the attribute
                      represented by the schema path
                      <em>P</em>.</p>
                    </li>
                  </ol>

                  <p>The following examples illustrate this form of
                  AttributeTest, matching attribute nodes whose
                  name is <code>price</code>. In the first example,
                  the node must conform to the schema definition of
                  a <code>price</code> attribute in a
                  <code>product</code> element in a
                  <code>catalog</code> element. In the second
                  example, the node must conform to the schema
                  definition of a <code>price</code> attribute
                  within the top-level type <code>plan</code>:</p>

                  <div class="exampleInner">
<pre>
attribute(catalog/product/@price)
attribute(type(plan)/@price)
</pre>
                  </div>
                </li>
              </ol>
            </div>
          </div>

          <div class="div3">
            <h4><a name="id-type-conversions"
            id="id-type-conversions"></a>2.4.4 Type
            Conversions</h4>

            <p>Some expressions do not require their operands to
            exactly match the expected type. For example, function
            parameters and returns expect a value of a particular
            type, but automatically perform certain type
            conversions, such as extraction of atomic values from
            nodes, promotion of numeric values, and implicit
            casting of untyped values. The conversion rules for
            function parameters and returns are discussed in <a
            href="#id-function-calls"><b>3.1.4 Function
            Calls</b></a>. Other operators that provide special
            conversion rules include arithmetic operators, which
            are discussed in <a href="#id-arithmetic"><b>3.4
            Arithmetic Expressions</b></a>, and value comparisons,
            which are discussed in <a
            href="#id-value-comparisons"><b>3.5.1 Value
            Comparisons</b></a>.</p>

            <div class="div4">
              <h5><a name="id-atomization"
              id="id-atomization"></a>2.4.4.1 Atomization</h5>

              <p>Type conversions sometimes depend on a process
              called <b>atomization</b>, which is used when a
              sequence of atomic values is required. The result of
              atomization is either a sequence of atomic values or
              a type error. Atomization of a sequence is defined as
              the result of invoking the <code>fn:data</code>
              function on the sequence, as defined in <a
              href="#FunctionsAndOperators">[XQuery 1.0 and XPath
              2.0 Functions and Operators]</a>.</p>

              <p>The semantics of <code>fn:data</code> are repeated
              here for convenience. The result of
              <code>fn:data</code> is the sequence of atomic values
              produced by applying the following rules to each item
              in the input sequence:</p>

              <ul>
                <li>
                  <p>If the item is an atomic value, it is
                  returned.</p>
                </li>

                <li>
                  <p>If the item is a node, it is replaced by its
                  <b>typed value</b>.</p>
                </li>
              </ul>

              <p>Atomization may be used in processing the
              following types of expressions:</p>

              <ul>
                <li>
                  <p>Arithmetic expressions</p>
                </li>

                <li>
                  <p>Comparison expressions</p>
                </li>

                <li>
                  <p>Function calls and returns</p>
                </li>

                <li>
                  <p>Cast expressions</p>
                </li>
              </ul>
            </div>

            <div class="div4">
              <h5><a name="id-ebv" id="id-ebv"></a>2.4.4.2
              Effective Boolean Value</h5>

              <p>Under certain circumstances (listed below), it is
              necessary to find the <b>effective boolean value</b>
              of a sequence. This is defined as the result of
              invoking the <code>fn:boolean</code> function on the
              sequence, as defined in <a
              href="#FunctionsAndOperators">[XQuery 1.0 and XPath
              2.0 Functions and Operators]</a>.</p>

              <p>The semantics of <code>fn:boolean</code> are
              repeated here for convenience.
              <code>fn:boolean</code> returns <code>false</code> if
              its operand is any of the following:</p>

              <ul>
                <li>
                  <p>An empty sequence.</p>
                </li>

                <li>
                  <p>The boolean value <code>false</code>.</p>
                </li>

                <li>
                  <p>A zero-length string (<code>""</code>).</p>
                </li>

                <li>
                  <p>A numeric value that is equal to zero.</p>
                </li>

                <li>
                  <p>The <code>double</code> or <code>float</code>
                  value <code>NaN</code>.</p>
                </li>
              </ul>

              <p>Otherwise, <code>fn:boolean</code> returns
              <code>true</code>.</p>

              <p>The <b>effective boolean value</b> of a sequence
              is computed implicitly during processing of the
              following types of expressions:</p>

              <ul>
                <li>
                  <p>Logical expressions (<code>and</code>,
                  <code>or</code>)</p>
                </li>

                <li>
                  <p>The <code>fn:not</code> function</p>
                </li>

                <li>
                  <p>Certain types of predicates, such as
                  <code>a[b]</code>.</p>
                </li>

                <li>
                  <p>Conditional expressions (<code>if</code>)</p>
                </li>

                <li>
                  <p>Quantified expressions (<code>some</code>,
                  <code>every</code>)</p>
                </li>
              </ul>

              <p>Note that the definition of <b>effective boolean
              value</b> is not used when casting a value to the
              type <code>xs:boolean</code>.</p>
            </div>
          </div>
        </div>

        <div class="div2">
          <h3><a name="errors" id="errors"></a>2.5 Error
          Handling</h3>

          <div class="div3">
            <h4><a name="id-kinds-of-errors"
            id="id-kinds-of-errors"></a>2.5.1 Kinds of Errors</h4>

            <p>As described in <a href="#id-type-checking"><b>2.4.2
            Type Checking</b></a>, XPath defines an <b>analysis
            phase</b>, which does not depend on input data, and an
            <b>evaluation phase</b>, which does depend on input
            data.</p>

            <p>The result of the <b>analysis phase</b> is either
            success or one or more <b>type errors</b> and/or
            <b>static errors</b>. <b>Type errors</b> reported by
            the analysis phase occur when the static type of an
            expression is not correct for the context in which it
            appears. <b>Static errors</b> are non-type-related
            errors such as syntax errors. The means by which errors
            are reported during the analysis phase is
            implementation-defined.</p>

            <p>The result of the <b>evaluation phase</b> is either
            a result value, a <b>type error</b>, or a <b>dynamic
            error</b>. <b>Type errors</b> are raised during the
            evaluation phase when the dynamic type of an expression
            is not correct for the context in which it appears.
            <b>Dynamic errors</b> are non-type-related errors such
            as numeric overflow. If evaluation of an expression
            yields a value (that is, it does not raise an error),
            the value must be the value specified by the dynamic
            semantics defined in <a
            href="#XQueryFormalSemantics">[XQuery 1.0 Formal
            Semantics]</a>.</p>

            <p>If an implementation can determine by static
            analysis that an expression will necessarily raise a
            dynamic error (for example, because it attempts to
            construct a decimal value from a constant string that
            is not in the lexical space of
            <code>xs:decimal</code>), the implementation is allowed
            to report this error during the analysis phase (as well
            as during the evaluation phase).</p>

            <p><a href="#XQueryFormalSemantics">[XQuery 1.0 Formal
            Semantics]</a> defines the set of static, dynamic, and
            type errors. In addition to these errors, an XPath
            implementation may raise implementation-defined
            <b>warnings</b>, either during the analysis phase or
            the evaluation phase. The circumstances in which
            warnings are raised, and the ways in which warnings are
            handled, are implementation-defined.</p>

            <p>In addition to the errors defined in this
            specification, an implementation may raise a dynamic
            error if insufficient resources are available for
            processing a given expression. For example, an
            implementation may specify limitations on the maximum
            numbers or sizes of various objects. These limitations,
            and the consequences of exceeding them, are
            implementation-defined.</p>
          </div>

          <div class="div3">
            <h4><a name="id-handling-dynamic"
            id="id-handling-dynamic"></a>2.5.2 Handling Dynamic
            Errors</h4>

            <p>Except as noted in this document, if any operand of
            an expression raises a dynamic error, the expression
            also raises a dynamic error. If an expression can
            validly return a value or raise a dynamic error, the
            implementation may choose to return the value or raise
            the dynamic error. For example, the logical expression
            <code>expr1 and expr2</code> may return the value
            <code>false</code> if either operand returns
            <code>false</code>, or may raise a dynamic error if
            either operand raises a dynamic error.</p>

            <p>If more than one operand of an expression raises an
            error, the implementation may choose which error is
            raised by the expression. For example, in this
            expression:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre>
              </div>
            </div>

            <p>both <code>($x div $y)</code> and
            <code>xs:decimal($z)</code> may raise an error. The
            implementation may choose which error is raised by the
            "<code>+</code>" expression. Once one operand raises an
            error, the implementation is not required, but is
            permitted, to evaluate any other operands.</p>

            <p>A dynamic error carries an <b>error value</b>, which
            may be a single item or an empty sequence. For example,
            an error value might be an integer, a string, a QName,
            or an element. An implementation may provide a
            mechanism whereby an application-defined error handler
            can process error values and produce diagnostics; in
            the absence of such an error handler, the
            <b>string-value</b> of the error value may be used
            directly as an error message.</p>

            <p>A dynamic error may be raised by a built-in function
            or operator. For example, the <code>input</code>
            function raises an error if the <b>input sequence</b>
            is not defined in the <b>evaluation context</b>.</p>

            <p>An error can be raised explicitly by calling the
            <code>fn:error</code> function, which only raises an
            error and never returns a value. The
            <code>fn:error</code> function takes an optional item
            as its parameter, which is used as the error value. For
            example, the following function call raises a dynamic
            error whose error value is a string:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
fn:error(fn:concat("Unexpected value ", fn:string($v)))
</pre>
              </div>
            </div>
          </div>

          <div class="div3">
            <h4><a name="id-errors-and-opt"
            id="id-errors-and-opt"></a>2.5.3 Errors and
            Optimization</h4>

            <p>Because different implementations may choose to
            evaluate or optimize an expression in different ways,
            the detection and reporting of dynamic errors is
            implementation dependent.</p>

            <p>When an implementation is able to evaluate an
            expression without evaluating some subexpression, the
            implementation is never required to evaluate that
            subexpression solely to determine whether it raises a
            dynamic error. For example, if a function parameter is
            never used in the body of the function, an
            implementation may choose whether to evaluate the
            expression bound to that parameter in a function
            call.</p>

            <p>In some cases, an optimizer may be able to achieve
            substantial performance improvements by rearranging an
            expression so that the underlying operations such as
            projection, restriction, and sorting are performed in a
            different order than that specified in <a
            href="#XQueryFormalSemantics">[XQuery 1.0 Formal
            Semantics]</a>. In such cases, dynamic errors may occur
            that could not have occurred if the expression were
            evaluated as written. For example, consider the
            following expression:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
$N[@x castable as xs:date]
      [xs:date(@x) gt xs:date("2000-01-01")]
</pre>
              </div>
            </div>

            <p>This expression cannot fail with a casting error if
            it is evaluated exactly as written. An implementation
            is permitted, however, to reorder the predicates to
            achieve better performance (for example, by taking
            advantage of an index). This reordering could cause the
            above expression to fail. However, an expression must
            not be rearranged in a way that causes it to return a
            non-error result that is different from the result
            defined by <a href="#XQueryFormalSemantics">[XQuery 1.0
            Formal Semantics]</a>.</p>

            <p>To avoid unexpected errors caused by reordering of
            expressions, tests that are designed to prevent dynamic
            errors should be expressed using conditional
            expressions, as in the following example:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre>
              </div>
            </div>

            <p>In the case of a conditional expression, the
            implementation is required not to evaluate the
            <code>then</code> branch if the condition is false, and
            not to evaluate the <code>else</code> branch if the
            condition is true. Conditional expressions are the only
            kinds of expressions that provide guaranteed conditions
            under which a particular subexpression will not be
            evaluated.</p>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-optional-features"
          id="id-optional-features"></a>2.6 Optional Features</h3>

          <p>XPath defines a a required level of functionality,
          called <span class="xpath"><span class="xpath"><b>Basic
          XPath,</b> and an optional feature called the <b>Static
          Typing Feature</b>.</span></span></p>

          <div class="div3">
            <h4><a name="id-basic" id="id-basic"></a>2.6.1 Basic
            <span class="xpath"><span
            class="xpath">XPath</span></span></h4>

            <p>A <span class="xpath"><b>Basic XPath</b></span>
            implementation must implement the full XPath language
            as described in this specification, subject to the
            following limitations:</p>

            <ol class="enum1">
              <li>
                <p>In a Basic XPath implementation, the <b>in-scope
                type definitions</b> consist only of the built-in
                types defined in <a href="#XMLSchema">[XML
                Schema]</a> and the additional predefined types in
                the
                <code>http://www.w3.org/2003/05/xpath-datatypes</code>
                namespace.</p>
              </li>

              <li>
                <p>A mapping from a Post-Schema Validation Infoset
                (PSVI) to the Data Model is specified in <a
                href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
                Model]</a>. In a Basic XPath implementation, this
                mapping maps each datatype that is not one of the
                predefined types listed above into its nearest
                supertype that belongs to this list. As a result of
                this mapping, all complex types are mapped into
                <code>xs:anyType</code>. (Of course, mapping from a
                PSVI is only one way in which a Data Model instance
                might be constructed--other ways are also
                possible.)</p>
              </li>

              <li>
                <p>If any <b>SequenceType</b> contains a typename
                that is not one of the predefined types listed
                above, a Basic XPath implementation raises a static
                error.</p>
              </li>

              <li>
                <p>If any <b>SequenceType</b> contains an
                <b>ElementTest</b> or <b>AttributeTest</b> that
                contains a <b>TypeName</b> or a
                <b>SchemaContextPath</b>, a Basic XPath
                implementation raises a static error.</p>
              </li>

              <li>
                <p>If the processing of an expression depends on
                the type of some value, and that type is not one of
                the predefined types listed above, a Basic XPath
                implementation raises a dynamic error.</p>
              </li>

              <li>
                <p>A Basic XPath implementation is not required to
                raise type errors during the analysis phase. If an
                expression contains one or more non-type-related
                static errors, then a Basic XPath implementation
                must raise at least one of these static errors
                during the analysis phase. If the analysis phase is
                successful but one or more dynamic errors are
                encountered during the evaluation phase, then a
                Basic XPath implementation must raise at least one
                of these dynamic errors.</p>
              </li>
            </ol>
          </div>

          <div class="div3">
            <h4><a name="id-static-typing"
            id="id-static-typing"></a>2.6.2 Static Typing
            Feature</h4>

            <p>The <b>Static Typing Feature</b> removes the
            limitation specified by Rule <span class="xpath"><span
            class="xpath">6</span></span> of Basic XPath. An
            implementation that includes this feature is required
            to detect type errors during the analysis phase. If an
            expression contains one or more static errors or type
            errors, then a Static Typing implementation must raise
            at least one of these errors during the analysis
            phase.</p>
          </div>
        </div>
      </div>

      <div class="div1">
        <h2><a name="id-expressions" id="id-expressions"></a>3
        Expressions</h2>

        <p>This section introduces each of the basic kinds of
        expression. Each kind of expression has a name such as
        <code>PathExpr</code>, which is introduced on the left side
        of the grammar production that defines the expression.
        Since XPath is a composable language, each kind of
        expression is defined in terms of other expressions whose
        operators have a higher precedence. In this way, the
        precedence of operators is represented explicitly in the
        grammar.</p>

        <p>The order in which expressions are discussed in this
        document does not reflect the order of operator precedence.
        In general, this document introduces the simplest kinds of
        expressions first, followed by more complex expressions.
        For a complete overview of the grammar, see the Appendix
        [<a href="#nt-bnf"><b>A XPath Grammar</b></a>].</p>

        <h5><a name="d0e2610" id="d0e2610"></a></h5>

        <table class="scrap" summary="Scrap">
          <tbody>
            <tr valign="baseline">
              <td><a name="doc-XPath"
              id="doc-XPath"></a>[15]&#160;&#160;&#160;</td>

              <td><code><a href="#prod-XPath">XPath</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-Expr">Expr</a>?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a name="doc-Expr"
              id="doc-Expr"></a>[16]&#160;&#160;&#160;</td>

              <td><code><a href="#prod-Expr">Expr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-ExprSingle">ExprSingle</a>
              ("," <a
              href="#doc-ExprSingle">ExprSingle</a>)*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a name="doc-ExprSingle"
              id="doc-ExprSingle"></a>[17]&#160;&#160;&#160;</td>

              <td><code><a
              href="#prod-ExprSingle">ExprSingle</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-ForExpr">ForExpr</a><br />
              | <a
              href="#doc-QuantifiedExpr">QuantifiedExpr</a><br />
              | <a href="#doc-IfExpr">IfExpr</a><br />
              | <a href="#doc-OrExpr">OrExpr</a></code></td>
            </tr>
          </tbody>
        </table>

        <p><span class="xpath"><span class="xpath">The
        highest-level (goal) symbol in the XPath grammar is
        XPath.</span></span></p>

        <p>The XPath operator that has lowest precedence is the
        comma operator, which is used to concatenate two operands
        to form a sequence. As shown in the grammar, a general
        expression (Expr) can consist of two operands (ExprSingle)
        separated by a comma. The name ExprSingle denotes an
        expression that does not contain a top-level comma operator
        (despite its name, an ExprSingle may evaluate to a sequence
        containing more than one item.)</p>

        <p>The symbol ExprSingle is used in various places in the
        grammar where an expression is not allowed to contain a
        top-level comma. For example, each of the arguments of a
        function call must be an ExprSingle, because commas are
        used to separate the arguments of a function call.</p>

        <p>After the comma, the expressions that have next lowest
        precedence are <span class="xpath"><span
        class="xpath">ForExpr,</span></span> QuantifiedExpr,
        IfExpr, and OrExpr. Each of these expressions is described
        in a separate section of this document.</p>

        <div class="div2">
          <h3><a name="id-primary-expressions"
          id="id-primary-expressions"></a>3.1 Primary
          Expressions</h3>

          <p><b>Primary expressions</b> are the basic primitives of
          the language. They include literals, variables, function
          calls, constructors, and the use of parentheses to
          control precedence of operators.</p>

          <h5><a name="d0e2669" id="d0e2669"></a></h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-PrimaryExpr"
                id="doc-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-PrimaryExpr">PrimaryExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-Literal">Literal</a> | <a
                href="#doc-FunctionCall">FunctionCall</a> | ("$" <a
                href="#doc-VarName">VarName</a>) | <a
                href="#doc-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-VarName"
                id="doc-VarName"></a>[12]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-VarName">VarName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QName">QName</a></code></td>
              </tr>
            </tbody>
          </table>

          <div class="div3">
            <h4><a name="id-literals" id="id-literals"></a>3.1.1
            Literals</h4>

            <p>A <b>literal</b> is a direct syntactic
            representation of an atomic value. XPath supports two
            kinds of literals: numeric literals and string
            literals.</p>

            <h5><a name="d0e2700" id="d0e2700"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-Literal"
                  id="doc-Literal"></a>[56]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-Literal">Literal</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-NumericLiteral">NumericLiteral</a> |
                  <a
                  href="#doc-StringLiteral">StringLiteral</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-NumericLiteral"
                  id="doc-NumericLiteral"></a>[57]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-NumericLiteral">NumericLiteral</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-IntegerLiteral">IntegerLiteral</a> |
                  <a href="#doc-DecimalLiteral">DecimalLiteral</a>
                  | <a
                  href="#doc-DoubleLiteral">DoubleLiteral</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-IntegerLiteral"
                  id="doc-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-IntegerLiteral">IntegerLiteral</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-Digits">Digits</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-DecimalLiteral"
                  id="doc-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-DecimalLiteral">DecimalLiteral</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>("." <a href="#prod-Digits">Digits</a>)
                  | (<a href="#prod-Digits">Digits</a> "."
                  [0-9]*)</code></td>

                  <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                  */</i></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-DoubleLiteral"
                  id="doc-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-DoubleLiteral">DoubleLiteral</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>(("." <a
                  href="#prod-Digits">Digits</a>) | (<a
                  href="#prod-Digits">Digits</a> ("." [0-9]*)?))
                  ("e" | "E") ("+" | "-")? <a
                  href="#prod-Digits">Digits</a></code></td>

                  <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                  */</i></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-StringLiteral"
                  id="doc-StringLiteral"></a>[6]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-StringLiteral">StringLiteral</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>('"' (('"' '"') | [^"])* '"') | ("'"
                  (("'" "'") | [^'])* "'")</code></td>

                  <td><i>/* <a href="#ws-significant">ws:
                  significant</a> */</i></td>
                </tr>
              </tbody>
            </table>

            <p>The value of a <b>numeric literal</b> containing no
            "<code>.</code>" and no <code>e</code> or
            <code>E</code> character is an atomic value whose type
            is <code>xs:integer</code> and whose value is obtained
            by parsing the numeric literal according to the rules
            of the <code>xs:integer</code> datatype. The value of a
            numeric literal containing "<code>.</code>" but no
            <code>e</code> or <code>E</code> character is an atomic
            value whose type is <code>xs:decimal</code> and whose
            value is obtained by parsing the numeric literal
            according to the rules of the <code>xs:decimal</code>
            datatype. The value of a numeric literal containing an
            <code>e</code> or <code>E</code> character is an atomic
            value whose type is <code>xs:double</code> and whose
            value is obtained by parsing the numeric literal
            according to the rules of the <code>xs:double</code>
            datatype.</p>

            <p>The value of a <b>string literal</b> is an atomic
            value whose type is <code>xs:string</code> and whose
            value is the string denoted by the characters between
            the delimiting apostrophes or quotation marks. If the
            literal is delimited by apostrophes, two adjacent
            apostrophes within the literal are interpreted as a
            single apostrophe. Similarly, if the literal is
            delimited by quotation marks, two adjacent quotation
            marks within the literal are interpreted as one
            quotation mark.</p>

            <p>If a string literal is used in an XPath expression
            contained within the value of an XML attribute, the
            characters used to delimit the literal should be
            different from the characters that are used to delimit
            the attribute.</p>

            <p>Here are some examples of literal expressions:</p>

            <ul>
              <li>
                <p><code>"12.5"</code> denotes the string
                containing the characters '1', '2', '.', and
                '5'.</p>
              </li>

              <li>
                <p><code>12</code> denotes the integer value
                twelve.</p>
              </li>

              <li>
                <p><code>12.5</code> denotes the decimal value
                twelve and one half.</p>
              </li>

              <li>
                <p><code>125E2</code> denotes the double value
                twelve thousand, five hundred.</p>
              </li>

              <li>
                <p><code>"He said, ""I don't like it."""</code>
                denotes a string containing two quotation marks and
                one apostrophe.</p>
              </li>
            </ul>

            <p>The boolean values <code>true</code> and
            <code>false</code> can be represented by calls to the
            built-in functions <code>fn:true()</code> and
            <code>fn:false()</code>, respectively.</p>

            <p>Values of other XML Schema built-in types can be
            constructed by calling the constructor for the given
            type. The constructors for XML Schema built-in types
            are defined in <a href="#FunctionsAndOperators">[XQuery
            1.0 and XPath 2.0 Functions and Operators]</a>. In
            general, the name of a constructor function for a given
            type is the same as the name of the type (including its
            namespace). For example:</p>

            <ul>
              <li>
                <p><code>xs:integer("12")</code> returns the
                integer value twelve.</p>
              </li>

              <li>
                <p><code>xs:date("2001-08-25")</code> returns an
                item whose type is <code>xs:date</code> and whose
                value represents the date 25th August 2001.</p>
              </li>

              <li>
                <p><code>xdt:dayTimeDuration("PT5H")</code> returns
                an item whose type is
                <code>xdt:dayTimeDuration</code> and whose value
                represents a duration of five hours.</p>
              </li>
            </ul>

            <p>It is also possible to construct values of various
            types by using a <code>cast</code> expression. For
            example:</p>

            <ul>
              <li>
                <p><code>9 cast as hatsize</code> returns the
                atomic value <code>9</code> whose type is
                <code>hatsize</code>.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="id-variables" id="id-variables"></a>3.1.2
            Variables</h4>

            <p>A <b>variable reference</b> is a QName preceded by a
            $-sign. Two variable references are equivalent if their
            local names are the same and their namespace prefixes
            are bound to the same namespace URI in the <b>in-scope
            namespaces</b>. An unprefixed variable reference is in
            no namespace.</p>

            <p>Every variable reference must match a name in the
            <b>in-scope variables</b>, which include variables from
            the following sources:</p>

            <ol class="enum1">
              <li>
                <p>A variable may be added to the in-scope
                variables by the host language environment.</p>
              </li>

              <li>
                <p>A variable may be bound by an XPath expression.
                <span class="xpath"><span class="xpath">The kinds
                of expressions that can bind variables are
                <code>for</code> expressions (<a
                href="#id-for-expressions"><b>3.7 For
                Expressions</b></a>) and quantified expressions (<a
                href="#id-quantified-expressions"><b>3.9 Quantified
                Expressions</b></a>).</span></span></p>
              </li>
            </ol>
            <br />
            <br />

            <p>Every variable binding has a static scope. The scope
            defines where references to the variable can validly
            occur. It is a static error to reference a variable
            that is not in scope. If a variable is bound in the
            static context for an expression, that variable is in
            scope for the entire expression.</p>

            <p>If a variable reference matches two or more bindings
            that are in scope, then the reference is taken as
            referring to the inner binding, that is, the one whose
            scope is smaller. At evaluation time, the value of a
            variable reference is the value of the expression to
            which the relevant variable is bound. The scope of a
            variable binding is defined separately for each kind of
            expression that can bind variables.</p>
          </div>

          <div class="div3">
            <h4><a name="id-paren-expressions"
            id="id-paren-expressions"></a>3.1.3 Parenthesized
            Expressions</h4>

            <h5><a name="d0e2955" id="d0e2955"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ParenthesizedExpr"
                  id="doc-ParenthesizedExpr"></a>[58]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ParenthesizedExpr">ParenthesizedExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"(" <a href="#doc-Expr">Expr</a>?
                  ")"</code></td>
                </tr>
              </tbody>
            </table>

            <p>Parentheses may be used to enforce a particular
            evaluation order in expressions that contain multiple
            operators. For example, the expression <code>(2 + 4) *
            5</code> evaluates to thirty, since the parenthesized
            expression <code>(2 + 4)</code> is evaluated first and
            its result is multiplied by five. Without parentheses,
            the expression <code>2 + 4 * 5</code> evaluates to
            twenty-two, because the multiplication operator has
            higher precedence than the addition operator.</p>

            <p>Empty parentheses are used to denote an empty
            sequence, as described in <a
            href="#construct_seq"><b>3.3.1 Constructing
            Sequences</b></a>.</p>
          </div>

          <div class="div3">
            <h4><a name="id-function-calls"
            id="id-function-calls"></a>3.1.4 Function Calls</h4>

            <p>A <b>function call</b> consists of a QName followed
            by a parenthesized list of zero or more expressions,
            called <b>arguments</b>. If the QName in the function
            call has no namespace prefix, it is considered to be in
            the <b>default function namespace.</b></p>

            <p>If the expanded QName and number of arguments in a
            function call do not match the name and arity of an
            <b>in-scope function</b> in the <b>static context</b>,
            <span class="xpath"><span class="xpath">an error is
            raised (the host language environment may define this
            error as either a static or a dynamic
            error.)</span></span></p>

            <h5><a name="d0e3003" id="d0e3003"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-FunctionCall"
                  id="doc-FunctionCall"></a>[59]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-FunctionCall">FunctionCall</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-QName">QName</a> "(" (<a
                  href="#doc-ExprSingle">ExprSingle</a> ("," <a
                  href="#doc-ExprSingle">ExprSingle</a>)*)?
                  ")"</code></td>
                </tr>
              </tbody>
            </table>

            <p>A function call is evaluated as follows:</p>

            <ol class="enum1">
              <li>
                <p>Each argument expression is evaluated, producing
                an argument value. The order of argument evaluation
                is implementation-dependent and a function need not
                evaluate an argument if the function can evaluate
                its body without evaluating that argument.</p>
              </li>

              <li>
                <p>Each argument value is converted by applying the
                function conversion rules listed below.</p>
              </li>

              <li class="xpath">
                <p>The function is executed using the converted
                argument values. The result is a value of the
                function's declared return type.</p>
              </li>
            </ol>

            <p>The <b>function conversion rules</b> are used to
            convert an argument value to its expected type; that
            is, to the declared type of the function parameter. The
            expected type is expressed as a <b>SequenceType</b>.
            The function conversion rules are applied to a given
            value as follows:</p>

            <ul>
              <li class="xpath">
                <p>If <b>XPath 1.0 compatibility mode</b> is
                <code>true</code>, then one of the following
                conversions is applied:</p>

                <ol class="enum1">
                  <li>
                    <p>If the expected type is
                    <code>xs:string</code> or
                    <code>xs:string?</code>, then the given value
                    <code>V</code> is effectively replaced by
                    <code>fn:string(fn:subsequence(V, 1,
                    1))</code>.</p>
                  </li>

                  <li>
                    <p>If the expected type is
                    <code>xs:double</code> or
                    <code>xs:double?</code>, then the given value
                    <code>V</code> is effectively replaced by
                    <code>fn:number(fn:subsequence(V, 1,
                    1))</code>.</p>
                  </li>

                  <li>
                    <p>If the expected type is a (possibly
                    optional) node or item, then the given value
                    <code>V</code> is effectively replaced by
                    <code>fn:subsequence(V, 1, 1)</code>.</p>
                  </li>

                  <li>
                    <p>Otherwise, the given value is unchanged.</p>
                  </li>
                </ol>
              </li>

              <li>
                <p>If the expected type is a sequence of an atomic
                type (possibly with an occurrence indicator
                <code>*</code>, <code>+</code>, or <code>?</code>),
                the following conversions are applied:</p>

                <ol class="enum1">
                  <li>
                    <p><b>Atomization</b> is applied to the given
                    value, resulting in a sequence of atomic
                    values.</p>
                  </li>

                  <li>
                    <p>Each item in the atomic sequence that is of
                    type <code>xdt:untypedAtomic</code> is cast to
                    the expected atomic type.</p>
                  </li>

                  <li>
                    <p>For each numeric item in the atomic sequence
                    that can be <b>promoted</b> to the expected
                    atomic type using the promotion rules in <a
                    href="#promotion"><b>B.1 Type
                    Promotion</b></a>, the promotion is done.</p>
                  </li>
                </ol>
              </li>

              <li>
                <p>If, after the above conversions, the resulting
                value does not match the expected type according to
                the rules for <b>SequenceType Matching</b>, a type
                error is raised. Note that the rules for
                SequenceType Matching permit a value of a derived
                type to be substituted for a value of its base
                type.</p>
              </li>
            </ul>

            <p>A core library of functions is defined in <a
            href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a>. <span class="xpath"><span
            class="xpath">Additional functions may be provided in
            the <b>static context</b>.</span></span></p>

            <p>Since the arguments of a function call are separated
            by commas, any argument expression that contains a
            top-level comma operator must be enclosed in
            parentheses. Here are some illustrative examples of
            function calls:</p>

            <ul>
              <li>
                <p><code>three-argument-function(1, 2, 3)</code>
                denotes a function call with three arguments.</p>
              </li>

              <li>
                <p><code>two-argument-function((1, 2), 3)</code>
                denotes a function call with two arguments, the
                first of which is a sequence of two values.</p>
              </li>

              <li>
                <p><code>two-argument-function(1, ())</code>
                denotes a function call with two arguments, the
                second of which is an empty sequence.</p>
              </li>

              <li>
                <p><code>one-argument-function((1, 2, 3))</code>
                denotes a function call with one argument that is a
                sequence of three values.</p>
              </li>

              <li>
                <p><code>one-argument-function(( ))</code> denotes
                a function call with one argument that is an empty
                sequence.</p>
              </li>

              <li>
                <p><code>zero-argument-function( )</code> denotes a
                function call with zero arguments.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="comments" id="comments"></a>3.1.5 XPath
            Comments</h4>

            <h5><a name="d0e3181" id="d0e3181"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ExprComment"
                  id="doc-ExprComment"></a>[1]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ExprComment">ExprComment</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"(:" (<a
                  href="#doc-ExprCommentContent">ExprCommentContent</a>
                  | <a href="#doc-ExprComment">ExprComment</a>)*
                  ":)"</code></td>

                  <td><i>/* <a href="#parse-note-parens">pn:
                  parens</a> */</i></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ExprCommentContent"
                  id="doc-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ExprCommentContent">ExprCommentContent</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-Char">Char</a></code></td>
                </tr>
              </tbody>
            </table>

            <p>XPath comments can be used to provide informative
            annotation. These comments are lexical constructs only,
            and do not affect the processing of an expression.
            Comments are delimited by the symbols <code>(:</code>
            and <code>:)</code>. Comments may be nested.</p>

            <p>Comments may be used anywhere that ignorable
            whitespace is allowed. See <a
            href="#lexical-structure"><b>A.2 Lexical
            structure</b></a> for the exact lexical states where
            comments are recognized.</p>

            <p>The following is an example of a comment:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-path-expressions"
          id="id-path-expressions"></a>3.2 Path Expressions</h3>

          <p>A <b>path expression</b> can be used to locate nodes
          within a tree.</p>

          <h5><a name="d0e3227" id="d0e3227"></a></h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-PathExpr"
                id="doc-PathExpr"></a>[36]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-PathExpr">PathExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("/" <a
                href="#doc-RelativePathExpr">RelativePathExpr</a>?)<br />

                | ("//" <a
                href="#doc-RelativePathExpr">RelativePathExpr</a>)<br />

                | <a
                href="#doc-RelativePathExpr">RelativePathExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-RelativePathExpr"
                id="doc-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-RelativePathExpr">RelativePathExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-StepExpr">StepExpr</a>
                (("/" | "//") <a
                href="#doc-StepExpr">StepExpr</a>)*</code></td>
              </tr>
            </tbody>
          </table>

          <p>A path expression consists of a series of one or more
          <b>steps</b>, separated by "<code>/</code>" or
          "<code>//</code>", and optionally beginning with
          "<code>/</code>" or "<code>//</code>". An initial
          "<code>/</code>" or "<code>//</code>" is an abbreviation
          for one or more initial steps that are implicitly added
          to the beginning of the path expression, as described
          below.</p>

          <p>A path expression consisting of a single step is
          evaluated as described in <a
          href="#id-axis-steps"><b>3.2.1 Steps</b></a>.</p>

          <p>Each occurrence of <code>//</code> in a path
          expression is expanded as described in <a
          href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>,
          leaving a sequence of steps separated by <code>/</code>.
          This sequence of steps is then evaluated from left to
          right. Each operation <code>E1/E2</code> is evaluated as
          follows: Expression <code>E1</code> is evaluated, and if
          the result is not a sequence of nodes, a dynamic error is
          raised. Each node resulting from the evaluation of
          <code>E1</code> then serves in turn to provide an
          <b>inner focus</b> for an evaluation of <code>E2</code>,
          as described in <a href="#eval_context"><b>2.1.2
          Evaluation Context</b></a>. Each evaluation of
          <code>E2</code> must result in a sequence of nodes;
          otherwise, a dynamic error is raised. The sequences of
          nodes resulting from all the evaluations of
          <code>E2</code> are merged, eliminating duplicate nodes
          based on node identity and sorting the results in
          document order.</p>

          <p>As an example of a path expression,
          <code>child::div1/child::para</code> selects the
          <code>para</code> element children of the
          <code>div1</code> element children of the context node,
          or, in other words, the <code>para</code> element
          grandchildren of the context node that have
          <code>div1</code> parents.</p>

          <p>A "<code>/</code>" at the beginning of a path
          expression is an abbreviation for the initial step
          <code>fn:root(self::node())</code>. The effect of this
          initial step is to begin the path at the root node of the
          tree that contains the context node. If the context item
          is not a node, a type error is raised.</p>

          <p>A "<code>//</code>" at the beginning of a path
          expression is an abbreviation for the initial steps
          <code>fn:root(self::node())/descendant-or-self::node()</code>.
          The effect of these initial steps is to establish an
          initial node sequence that contains all nodes in the same
          tree as the context node. This node sequence is then
          filtered by subsequent steps in the path expression. If
          the context item is not a node, a dynamic error is
          raised.</p>

          <div class="div3">
            <h4><a name="id-axis-steps"
            id="id-axis-steps"></a>3.2.1 Steps</h4>

            <h5><a name="d0e3352" id="d0e3352"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-StepExpr"
                  id="doc-StepExpr"></a>[38]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-StepExpr">StepExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#doc-AxisStep">AxisStep</a> |
                  <a
                  href="#doc-FilterStep">FilterStep</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AxisStep"
                  id="doc-AxisStep"></a>[39]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AxisStep">AxisStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>(<a
                  href="#doc-ForwardStep">ForwardStep</a> | <a
                  href="#doc-ReverseStep">ReverseStep</a>) <a
                  href="#doc-Predicates">Predicates</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-FilterStep"
                  id="doc-FilterStep"></a>[40]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-FilterStep">FilterStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-PrimaryExpr">PrimaryExpr</a> <a
                  href="#doc-Predicates">Predicates</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ForwardStep"
                  id="doc-ForwardStep"></a>[47]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ForwardStep">ForwardStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>(<a
                  href="#doc-ForwardAxis">ForwardAxis</a> <a
                  href="#doc-NodeTest">NodeTest</a>) | <a
                  href="#doc-AbbreviatedForwardStep">AbbreviatedForwardStep</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ReverseStep"
                  id="doc-ReverseStep"></a>[48]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ReverseStep">ReverseStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>(<a
                  href="#doc-ReverseAxis">ReverseAxis</a> <a
                  href="#doc-NodeTest">NodeTest</a>) | <a
                  href="#doc-AbbreviatedReverseStep">AbbreviatedReverseStep</a></code></td>
                </tr>
              </tbody>
            </table>

            <p>A <b>step</b> generates a sequence of items and then
            filters the sequence by zero or more <b>predicates</b>.
            The value of the step consists of those items that
            satisfy the predicates. Predicates are described in <a
            href="#id-predicates"><b>3.2.2 Predicates</b></a>.
            XPath provides two kinds of step, called a <b>filter
            step</b> and an <b>axis step</b>.</p>

            <p>A <b>filter step</b> consists simply of a <b>primary
            expression</b> followed by zero or more predicates. The
            result of the filter expression consists of all the
            items returned by the primary expression for which all
            the predicates are true. If no predicates are
            specified, the result is simply the result of the
            primary expression. This result may contain nodes,
            atomic values, or any combination of these. The
            ordering of the items returned by a filter step is the
            same as their order in the result of the primary
            expression.</p>

            <p>The result of an <b>axis step</b> is always a
            sequence of zero or more nodes, and these nodes are
            always returned in document order. An axis step may be
            either a <b>forward step</b> or a <b>reverse step</b>,
            followed by zero or more predicates. An axis step might
            be thought of as beginning at the <b>context node</b>
            and navigating to those nodes that are reachable from
            the context node via a specified <b>axis</b>. Such a
            step has two parts: an <b>axis</b>, which defines the
            "direction of movement" for the step, and a <b>node
            test</b>, which selects nodes based on their kind,
            name, and/or type.</p>

            <p>In the <b>abbreviated syntax</b> for a step, the
            axis can be omitted and other shorthand notations can
            be used as described in <a href="#abbrev"><b>3.2.4
            Abbreviated Syntax</b></a>.</p>

            <p>The unabbreviated syntax for an axis step consists
            of the axis name and node test separated by a double
            colon. The result of the step consists of the nodes
            reachable from the context node via the specified axis
            that have the node kind, name, and/or type specified by
            the node test. For example, the step
            <code>child::para</code> selects the <code>para</code>
            element children of the context node:
            <code>child</code> is the name of the axis, and
            <code>para</code> is the name of the element nodes to
            be selected on this axis. The available axes are
            described in <a href="#axes"><b>3.2.1.1 Axes</b></a>.
            The available node tests are described in <a
            href="#node-tests"><b>3.2.1.2 Node Tests</b></a>.
            Examples of steps are provided in <a
            href="#unabbrev"><b>3.2.3 Unabbreviated Syntax</b></a>
            and <a href="#abbrev"><b>3.2.4 Abbreviated
            Syntax</b></a>.</p>

            <div class="div4">
              <h5><a name="axes" id="axes"></a>3.2.1.1 Axes</h5>

              <h5><a name="d0e3490" id="d0e3490"></a></h5>

              <table class="scrap" summary="Scrap">
                <tbody>
                  <tr valign="baseline">
                    <td><a name="doc-ForwardAxis"
                    id="doc-ForwardAxis"></a>[51]&#160;&#160;&#160;</td>

                    <td><code><a
                    href="#prod-ForwardAxis">ForwardAxis</a></code></td>

                    <td>
                    &#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                    <td><code>"child" "::"<br />
                    | "descendant" "::"<br />
                    | "attribute" "::"<br />
                    | "self" "::"<br />
                    | "descendant-or-self" "::"<br />
                    | "following-sibling" "::"<br />
                    | "following" "::"<br />
                    | "namespace" "::"</code></td>
                  </tr>
                </tbody>

                <tbody>
                  <tr valign="baseline">
                    <td><a name="doc-ReverseAxis"
                    id="doc-ReverseAxis"></a>[52]&#160;&#160;&#160;</td>

                    <td><code><a
                    href="#prod-ReverseAxis">ReverseAxis</a></code></td>

                    <td>
                    &#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                    <td><code>"parent" "::"<br />
                    | "ancestor" "::"<br />
                    | "preceding-sibling" "::"<br />
                    | "preceding" "::"<br />
                    | "ancestor-or-self" "::"</code></td>
                  </tr>
                </tbody>
              </table>

              <div class="xpath">
                <p class="xpath">XPath defines a set of full set of
                <b>axes</b> for traversing documents, but a <b>host
                language</b> may define a subset of these axes. The
                following axes are defined:</p>
              </div>

              <ul>
                <li>
                  <p>the <code>child</code> axis contains the
                  children of the context node</p>
                </li>

                <li>
                  <p>the <code>descendant</code> axis contains the
                  descendants of the context node; a descendant is
                  a child or a child of a child and so on; thus the
                  descendant axis never contains attribute or
                  namespace nodes</p>
                </li>

                <li>
                  <p>the <code>parent</code> axis contains the
                  parent of the context node, if there is one</p>
                </li>

                <li class="xpath">
                  <p>the <code>ancestor</code> axis contains the
                  ancestors of the context node; the ancestors of
                  the context node consist of the parent of context
                  node and the parent's parent and so on; thus, the
                  ancestor axis will always include the root node,
                  unless the context node is the root node</p>
                </li>

                <li class="xpath">
                  <p>the <code>following-sibling</code> axis
                  contains all the following siblings of the
                  context node; if the context node is an attribute
                  node or namespace node, the
                  <code>following-sibling</code> axis is empty</p>
                </li>

                <li class="xpath">
                  <p>the <code>preceding-sibling</code> axis
                  contains all the preceding siblings of the
                  context node; if the context node is an attribute
                  node or namespace node, the
                  <code>preceding-sibling</code> axis is empty</p>
                </li>

                <li class="xpath">
                  <p>the <code>following</code> axis contains all
                  nodes, in the same tree as the context node, that
                  are after the context node in document order,
                  excluding any descendants and excluding attribute
                  nodes and namespace nodes</p>
                </li>

                <li class="xpath">
                  <p>the <code>preceding</code> axis contains all
                  nodes, in the same tree as the context node, that
                  are before the context node in document order,
                  excluding any ancestors and excluding attribute
                  nodes and namespace nodes</p>
                </li>

                <li>
                  <p>the <code>attribute</code> axis contains the
                  attributes of the context node; the axis will be
                  empty unless the context node is an element</p>
                </li>

                <li>
                  <p>the <code>self</code> axis contains just the
                  context node itself</p>
                </li>

                <li>
                  <p>the <code>descendant-or-self</code> axis
                  contains the context node and the descendants of
                  the context node</p>
                </li>

                <li class="xpath">
                  <p>the <code>ancestor-or-self</code> axis
                  contains the context node and the ancestors of
                  the context node; thus, the ancestor-or-self axis
                  will always include the root node</p>
                </li>

                <li class="xpath">
                  <p>the <code>namespace</code> axis contains the
                  namespace nodes of the context node; this axis is
                  empty unless the context node is an element node.
                  The <code>namespace</code> axis is deprecated in
                  XPath 2.0. Whether an implementation supports the
                  <code>namespace</code> axis is
                  implementation-defined. An implementation that
                  does not support the <code>namespace</code> axis
                  must raise a static error if it is used.
                  Applications needing information about the
                  namespaces of an element should use the functions
                  <code>fn:get-in-scope-namespaces</code> and
                  <code>fn:get-namespace-uri-for-prefix</code>
                  defined in <a
                  href="#FunctionsAndOperators">[XQuery 1.0 and
                  XPath 2.0 Functions and Operators]</a>.</p>
                </li>
              </ul>

              <p>Axes can be categorized as <b>forward axes</b> and
              <b>reverse axes</b>. An axis that only ever contains
              the context node or nodes that are after the context
              node in document order is a forward axis. An axis
              that only ever contains the context node or nodes
              that are before the context node in document order is
              a reverse axis.</p>

              <div class="xpath">
                <p class="xpath">In XPath, the <code>parent</code>,
                <code>ancestor</code>,
                <code>ancestor-or-self</code>,
                <code>preceding</code>, and
                <code>preceding-sibling</code> axes are reverse
                axes; all other axes are forward axes. The
                <code>ancestor</code>, <code>descendant</code>,
                <code>following</code>, <code>preceding</code> and
                <code>self</code> axes partition a document
                (ignoring attribute and namespace nodes): they do
                not overlap and together they contain all the nodes
                in the document.</p>
              </div>

              <div class="xpath">
                <p class="xpath">In a sequence of nodes selected by
                a step, the context positions of the nodes are
                determined in a way that depends on the axis. If
                the axis is a forward axis, context positions are
                assigned to the nodes in document order. If the
                axis is a reverse axis, context positions are
                assigned to the nodes in reverse document order. In
                either case, the first context position is 1.</p>
              </div>
            </div>

            <div class="div4">
              <h5><a name="node-tests" id="node-tests"></a>3.2.1.2
              Node Tests</h5>

              <p>A <b>node test</b> is a condition that must be
              true for each node selected by a step. The condition
              may be based on the kind of the node (element,
              attribute, text, document, comment, processing
              instruction, or namespace), the name of the node, or
              (in the case of element and attribute nodes), the
              <b>type annotation</b> of the node.</p>

              <h5><a name="d0e3687" id="d0e3687"></a></h5>

              <table class="scrap" summary="Scrap">
                <tbody>
                  <tr valign="baseline">
                    <td><a name="doc-NodeTest"
                    id="doc-NodeTest"></a>[53]&#160;&#160;&#160;</td>

                    <td><code><a
                    href="#prod-NodeTest">NodeTest</a></code></td>

                    <td>
                    &#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                    <td><code><a href="#doc-KindTest">KindTest</a>
                    | <a
                    href="#doc-NameTest">NameTest</a></code></td>
                  </tr>
                </tbody>

                <tbody>
                  <tr valign="baseline">
                    <td><a name="doc-NameTest"
                    id="doc-NameTest"></a>[54]&#160;&#160;&#160;</td>

                    <td><code><a
                    href="#prod-NameTest">NameTest</a></code></td>

                    <td>
                    &#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                    <td><code><a href="#prod-QName">QName</a> | <a
                    href="#doc-Wildcard">Wildcard</a></code></td>
                  </tr>
                </tbody>

                <tbody>
                  <tr valign="baseline">
                    <td><a name="doc-Wildcard"
                    id="doc-Wildcard"></a>[55]&#160;&#160;&#160;</td>

                    <td><code><a
                    href="#prod-Wildcard">Wildcard</a></code></td>

                    <td>
                    &#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                    <td><code>"*"<br />
                    | <a href="#prod-NCName">NCName</a> ":"
                    "*"<br />
                    | "*" ":" <a
                    href="#prod-NCName">NCName</a></code></td>

                    <td><i>/* <a href="#ws-explicit">ws:
                    explicit</a> */</i></td>
                  </tr>
                </tbody>
              </table>

              <p>Every axis has a <b>principal node kind</b>. If an
              axis can contain elements, then the principal node
              kind is element; otherwise, it is the kind of nodes
              that the axis can contain. Thus:</p>

              <ul>
                <li>
                  <p>For the attribute axis, the principal node
                  kind is attribute.</p>
                </li>

                <li class="xpath">
                  <p>For the namespace axis, the principal node
                  kind is namespace.</p>
                </li>

                <li>
                  <p>For all other axes, the principal node kind is
                  element.</p>
                </li>
              </ul>

              <p>A node test that consists of a QName is called a
              <b>name test</b>. A name test is true if and only if
              the <b>kind</b> of the node is the principal node
              kind and the expanded-QName of the node is equal to
              the expanded-QName specified by the name test. For
              example, <code>child::para</code> selects the
              <code>para</code> element children of the context
              node; if the context node has no <code>para</code>
              children, it selects an empty set of nodes.
              <code>attribute::abc:href</code> selects the
              attribute of the context node with the QName
              <code>abc:href</code>; if the context node has no
              such attribute, it selects an empty set of nodes.</p>

              <p>A QName in a name test is expanded into an
              expanded-QName using the <b>in-scope namespaces</b>
              in the expression context. It is a static error if
              the QName has a prefix that does not correspond to
              any in-scope namespace. An unprefixed QName, when
              used as a name test on an axis whose principal node
              kind is element, has the namespaceURI of the
              <b>default element namespace</b> in the expression
              context; otherwise, it has no namespaceURI.</p>

              <p>A name test is not satisfied by an element node
              whose name does not match the QName of the name test,
              even if it is in a substitution group whose head is
              the named element.</p>

              <p>A node test <code>*</code> is true for any node of
              the principal node kind. For example,
              <code>child::*</code> will select all element
              children of the context node, and
              <code>attribute::*</code> will select all attributes
              of the context node.</p>

              <p>A node test can have the form
              <code>NCName:*</code>. In this case, the prefix is
              expanded in the same way as with a QName, using the
              <b>in-scope namespaces</b> in the static context. If
              the prefix is not found in the in-scope namespaces, a
              static error is raised. The node test is true for any
              node of the principal node kind whose expanded-QName
              has the namespace URI to which the prefix is bound,
              regardless of the local part of the name.</p>

              <p>A node test can also have the form
              <code>*:NCName</code>. In this case, the node test is
              true for any node of the principal node kind whose
              local name matches the given NCName, regardless of
              its namespace.</p>

              <p>An alternative form of a node test is called a
              <b>KindTest</b>, which can select nodes based on
              their kind, name, and type annotation. The syntax and
              semantics of a KindTest are described in <a
              href="#id-sequencetype"><b>2.4.3
              SequenceType</b></a>. When a KindTest is used in a
              node test, only those nodes on the designated axis
              that match the KindTest are selected. Shown below are
              several examples of KindTests that might be used in
              path expressions:</p>

              <ul>
                <li>
                  <p><code>node()</code> matches any node.</p>
                </li>

                <li>
                  <p><code>text()</code> matches any text node.</p>
                </li>

                <li>
                  <p><code>comment()</code> matches any comment
                  node.</p>
                </li>

                <li>
                  <p><code>element()</code> matches any element
                  node.</p>
                </li>

                <li>
                  <p><code>element(person)</code> matches any
                  element node whose name is <code>person</code>
                  (or is in the substitution group headed by
                  <code>person</code>), and whose type annotation
                  conforms to the top-level schema declaration for
                  a <code>person</code> element.</p>
                </li>

                <li>
                  <p><code>element(person, *)</code> matches any
                  element node whose name is <code>person</code>
                  (or is in the substitution group headed by
                  <code>person</code>), without any restriction on
                  type annotation.</p>
                </li>

                <li>
                  <p><code>element(person, surgeon)</code> matches
                  any element node whose name is
                  <code>person</code> (or is in the substitution
                  group headed by <code>person</code>), and whose
                  type annotation is <code>surgeon</code>.</p>
                </li>

                <li>
                  <p><code>element(*, surgeon)</code> matches any
                  element node whose type annotation is
                  <code>surgeon</code>, regardless of its name.</p>
                </li>

                <li>
                  <p><code>element(hospital/staff/person)</code>
                  matches any element node whose name and type
                  annotation conform to the schema declaration of a
                  <code>person</code> element in a
                  <code>staff</code> element in a top-level
                  <code>hospital</code> element.</p>
                </li>

                <li>
                  <p><code>attribute()</code> matches any attribute
                  node.</p>
                </li>

                <li>
                  <p><code>attribute(@price, *)</code> matches any
                  attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p>
                </li>

                <li>
                  <p><code>attribute(*, xs:decimal)</code> matches
                  any attribute whose type annotation is
                  <code>xs:decimal</code>, regardless of its
                  name.</p>
                </li>

                <li>
                  <p><code>document-node()</code> matches any
                  document node.</p>
                </li>

                <li>
                  <p><code>document-node(element(book))</code>
                  matches any document node whose content consists
                  of a single element node that satisfies the
                  KindTest <code>element(book)</code>.</p>
                </li>
              </ul>
            </div>
          </div>

          <div class="div3">
            <h4><a name="id-predicates"
            id="id-predicates"></a>3.2.2 Predicates</h4>

            <h5><a name="d0e3922" id="d0e3922"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-Predicates"
                  id="doc-Predicates"></a>[42]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-Predicates">Predicates</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>("[" <a href="#doc-Expr">Expr</a>
                  "]")*</code></td>
                </tr>
              </tbody>
            </table>

            <p>A predicate consists of an expression, called a
            <b>predicate expression</b>, enclosed in square
            brackets. A predicate serves to filter a sequence,
            retaining some items and discarding others. For each
            item in the sequence to be filtered, the predicate
            expression is evaluated using an <b>inner focus</b>
            derived from that item, as described in <a
            href="#eval_context"><b>2.1.2 Evaluation
            Context</b></a>. The result of the predicate expression
            is coerced to a Boolean value, called the <b>predicate
            truth value</b>, as described below. Those items for
            which the predicate truth value is <code>true</code>
            are retained, and those for which the predicate truth
            value is <code>false</code> are discarded.</p>

            <p>The predicate truth value is derived by applying the
            following rules, in order:</p>

            <ol class="enum1">
              <li>
                <p>If the value of the predicate expression is an
                atomic value of a numeric type, the predicate truth
                value is <code>true</code> if the value of the
                predicate expression is equal to the <b>context
                position</b>, and is false otherwise.</p>
              </li>

              <li>
                <p>Otherwise, the predicate truth value is the
                <b>Effective Boolean Value</b> of the predicate
                expression.</p>
              </li>
            </ol>

            <p>Here are some examples of <b>axis steps</b> that
            contain predicates:</p>

            <ul>
              <li>
                <p>This example selects the second
                <code>chapter</code> element that is a child of the
                context node:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
child::chapter[2]
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>This example selects all the descendants of the
                context node whose name is <code>"toy"</code> and
                whose <code>color</code> attribute has the value
                <code>"red"</code>:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>This example selects all the
                <code>employee</code> children of the context node
                that have a <code>secretary</code> subelement:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
child::employee[secretary]
</pre>
                  </div>
                </div>
              </li>
            </ul>

            <p>Here are some examples of <b>filter steps</b> that
            contain predicates:</p>

            <ul>
              <li>
                <p>List all the integers from 1 to 100 that are
                divisible by 5. (See <a
                href="#construct_seq"><b>3.3.1 Constructing
                Sequences</b></a> for an explanation of the
                <code>to</code> operator.)</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>The result of the following expression is the
                integer 95:</p>

                <div class="exampleInner">
<pre>
(99 to 0)[5]
</pre>
                </div>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="unabbrev" id="unabbrev"></a>3.2.3
            Unabbreviated Syntax</h4>

            <p>This section provides a number of examples of path
            expressions in which the axis is explicitly specified
            in each step. The syntax used in these examples is
            called the <b>unabbreviated syntax</b>. In many common
            cases, it is possible to write path expressions more
            concisely using an <b>abbreviated syntax</b>, as
            explained in <a href="#abbrev"><b>3.2.4 Abbreviated
            Syntax</b></a>.</p>

            <ul>
              <li>
                <p><code>child::para</code> selects the
                <code>para</code> element children of the context
                node</p>
              </li>

              <li>
                <p><code>child::*</code> selects all element
                children of the context node</p>
              </li>

              <li>
                <p><code>child::text()</code> selects all text node
                children of the context node</p>
              </li>

              <li>
                <p><code>child::node()</code> selects all the
                children of the context node, whatever their node
                type</p>
              </li>

              <li>
                <p><code>attribute::name</code> selects the
                <code>name</code> attribute of the context node</p>
              </li>

              <li>
                <p><code>attribute::*</code> selects all the
                attributes of the context node</p>
              </li>

              <li>
                <p><code>parent::*</code> selects the parent of the
                context node. If the context node is an attribute
                node, this expression returns the element node (if
                any) to which the attribute node is attached.</p>
              </li>

              <li>
                <p><code>descendant::para</code> selects the
                <code>para</code> element descendants of the
                context node</p>
              </li>

              <li class="xpath">
                <p><code>ancestor::div</code> selects all
                <code>div</code> ancestors of the context node</p>
              </li>

              <li class="xpath">
                <p><code>ancestor-or-self::div</code> selects the
                <code>div</code> ancestors of the context node and,
                if the context node is a <code>div</code> element,
                the context node as well</p>
              </li>

              <li>
                <p><code>descendant-or-self::para</code> selects
                the <code>para</code> element descendants of the
                context node and, if the context node is a
                <code>para</code> element, the context node as
                well</p>
              </li>

              <li>
                <p><code>self::para</code> selects the context node
                if it is a <code>para</code> element, and otherwise
                selects nothing</p>
              </li>

              <li>
                <p><code>child::chapter/descendant::para</code>
                selects the <code>para</code> element descendants
                of the <code>chapter</code> element children of the
                context node</p>
              </li>

              <li>
                <p><code>child::*/child::para</code> selects all
                <code>para</code> grandchildren of the context
                node</p>
              </li>

              <li>
                <p><code>/</code> selects the root of the node
                hierarchy that contains the context node</p>
              </li>

              <li>
                <p><code>/descendant::para</code> selects all the
                <code>para</code> elements in the same document as
                the context node</p>
              </li>

              <li>
                <p><code>/descendant::list/child::member</code>
                selects all the <code>member</code> elements that
                have a <code>list</code> parent and that are in the
                same document as the context node</p>
              </li>

              <li>
                <p><code>child::para[fn:position() = 1]</code>
                selects the first <code>para</code> child of the
                context node</p>
              </li>

              <li>
                <p><code>child::para[fn:position() =
                fn:last()]</code> selects the last
                <code>para</code> child of the context node</p>
              </li>

              <li>
                <p><code>child::para[fn:position() =
                fn:last()-1]</code> selects the last but one
                <code>para</code> child of the context node</p>
              </li>

              <li>
                <p><code>child::para[fn:position() &gt; 1]</code>
                selects all the <code>para</code> children of the
                context node other than the first <code>para</code>
                child of the context node</p>
              </li>

              <li class="xpath">
                <p><code>following-sibling::chapter[fn:position() =
                1]</code>selects the next <code>chapter</code>
                sibling of the context node</p>
              </li>

              <li class="xpath">
                <p><code>preceding-sibling::chapter[fn:position() =
                1]</code>selects the previous <code>chapter</code>
                sibling of the context node</p>
              </li>

              <li>
                <p><code>/descendant::figure[fn:position() =
                42]</code> selects the forty-second
                <code>figure</code> element in the document</p>
              </li>

              <li>
                <p><code>/child::doc/child::chapter[fn:position() =
                5]/child::section[fn:position() = 2]</code>selects
                the second <code>section</code> of the fifth
                <code>chapter</code> of the <code>doc</code>
                document element</p>
              </li>

              <li>
                <p>
                <code>child::para[attribute::type="warning"]</code>selects
                all <code>para</code> children of the context node
                that have a <code>type</code> attribute with value
                <code>warning</code></p>
              </li>

              <li>
                <p>
                <code>child::para[attribute::type='warning'][fn:position()
                = 5]</code>selects the fifth <code>para</code>
                child of the context node that has a
                <code>type</code> attribute with value
                <code>warning</code></p>
              </li>

              <li>
                <p><code>child::para[fn:position() =
                5][attribute::type="warning"]</code>selects the
                fifth <code>para</code> child of the context node
                if that child has a <code>type</code> attribute
                with value <code>warning</code></p>
              </li>

              <li>
                <p>
                <code>child::chapter[child::title='Introduction']</code>selects
                the <code>chapter</code> children of the context
                node that have one or more <code>title</code>
                children with string-value equal to
                <code>Introduction</code></p>
              </li>

              <li>
                <p><code>child::chapter[child::title]</code>
                selects the <code>chapter</code> children of the
                context node that have one or more
                <code>title</code> children</p>
              </li>

              <li>
                <p><code>child::*[self::chapter or
                self::appendix]</code> selects the
                <code>chapter</code> and <code>appendix</code>
                children of the context node</p>
              </li>

              <li>
                <p><code>child::*[self::chapter or
                self::appendix][fn:position() = fn:last()]</code>
                selects the last <code>chapter</code> or
                <code>appendix</code> child of the context node</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="abbrev" id="abbrev"></a>3.2.4 Abbreviated
            Syntax</h4>

            <h5><a name="d0e4369" id="d0e4369"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AbbreviatedForwardStep"
                  id="doc-AbbreviatedForwardStep"></a>[49]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AbbreviatedForwardStep">AbbreviatedForwardStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"." | ("@" <a
                  href="#doc-NameTest">NameTest</a>) | <a
                  href="#doc-NodeTest">NodeTest</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-AbbreviatedReverseStep"
                  id="doc-AbbreviatedReverseStep"></a>[50]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-AbbreviatedReverseStep">AbbreviatedReverseStep</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>".."</code></td>
                </tr>
              </tbody>
            </table>

            <p>The abbreviated syntax permits the following
            abbreviations:</p>

            <ol class="enum1">
              <li>
                <p>The most important abbreviation is that the axis
                name can be omitted from an <b>axis step</b>. If
                the axis name is omitted from an axis step, the
                default axis is <code>child</code> unless the axis
                step contains an <b>AttributeTest</b>; in that
                case, the default axis is <code>attribute</code>.
                For example, a path expression
                <code>section/para</code> is an abbreviation for
                <code>child::section/child::para</code>. Similarly,
                <code>section/attribute(@id)</code> is an
                abbreviation for
                <code>child::section/attribute::attribute(@id)</code>.</p>
              </li>

              <li>
                <p>There is also an abbreviation for attributes:
                <code>attribute::</code> can be abbreviated by
                <code>@</code>. For example, a path expression
                <code>para[@type="warning"]</code> is short for
                <code>child::para[attribute::type="warning"]</code>
                and so selects <code>para</code> children with a
                <code>type</code> attribute with value equal to
                <code>warning</code>.</p>
              </li>

              <li>
                <p><code>//</code> is effectively replaced by
                <code>/descendant-or-self::node()/</code> during
                processing of a path expression. For example,
                <code>//para</code> is an abbreviation for
                <code>/descendant-or-self::node()/child::para</code>
                and so will select any <code>para</code> element in
                the document (even a <code>para</code> element that
                is a document element will be selected by
                <code>//para</code> since the document element node
                is a child of the root node);
                <code>div1//para</code> is short for
                <code>div1/descendant-or-self::node()/child::para</code>
                and so will select all <code>para</code>
                descendants of <code>div1</code> children.</p>

                <p>Note that the path expression
                <code>//para[1]</code> does <em>not</em> mean the
                same as the path expression
                <code>/descendant::para[1]</code>. The latter
                selects the first descendant <code>para</code>
                element; the former selects all descendant
                <code>para</code> elements that are the first
                <code>para</code> children of their parents.</p>
              </li>

              <li>
                <p>A step consisting of <code>.</code> returns the
                context item. This is particularly useful in
                conjunction with the <code>//</code> operator. For
                example, the path expression <code>.//para</code>
                returns all <code>para</code> descendant elements
                of the context node.</p>
              </li>

              <li>
                <p>A step consisting of <code>..</code> is short
                for <code>parent::node()</code>. For example,
                <code>../title</code> is short for
                <code>parent::node()/child::title</code> and so
                will select the <code>title</code> children of the
                parent of the context node.</p>
              </li>
            </ol>

            <p>Here are some examples of path expressions that use
            the abbreviated syntax:</p>

            <ul>
              <li>
                <p><code>para</code> selects the <code>para</code>
                element children of the context node</p>
              </li>

              <li>
                <p><code>*</code> selects all element children of
                the context node</p>
              </li>

              <li>
                <p><code>text()</code> selects all text node
                children of the context node</p>
              </li>

              <li>
                <p><code>@name</code> selects the <code>name</code>
                attribute of the context node</p>
              </li>

              <li>
                <p><code>@*</code> selects all the attributes of
                the context node</p>
              </li>

              <li>
                <p><code>para[1]</code> selects the first
                <code>para</code> child of the context node</p>
              </li>

              <li>
                <p><code>para[fn:last()]</code> selects the last
                <code>para</code> child of the context node</p>
              </li>

              <li>
                <p><code>*/para</code> selects all
                <code>para</code> grandchildren of the context
                node</p>
              </li>

              <li>
                <p><code>/doc/chapter[5]/section[2]</code> selects
                the second <code>section</code> of the fifth
                <code>chapter</code> of the <code>doc</code></p>
              </li>

              <li>
                <p><code>chapter//para</code> selects the
                <code>para</code> element descendants of the
                <code>chapter</code> element children of the
                context node</p>
              </li>

              <li>
                <p><code>//para</code> selects all the
                <code>para</code> descendants of the document root
                and thus selects all <code>para</code> elements in
                the same document as the context node</p>
              </li>

              <li>
                <p><code>//list/member</code> selects all the
                <code>member</code> elements in the same document
                as the context node that have a <code>list</code>
                parent</p>
              </li>

              <li>
                <p><code>.</code> selects the context item</p>
              </li>

              <li>
                <p><code>.//para</code> selects the
                <code>para</code> element descendants of the
                context node</p>
              </li>

              <li>
                <p><code>..</code> selects the parent of the
                context node</p>
              </li>

              <li>
                <p><code>../@lang</code> selects the
                <code>lang</code> attribute of the parent of the
                context node</p>
              </li>

              <li>
                <p><code>para[@type="warning"]</code> selects all
                <code>para</code> children of the context node that
                have a <code>type</code> attribute with value
                <code>warning</code></p>
              </li>

              <li>
                <p><code>para[@type="warning"][5]</code> selects
                the fifth <code>para</code> child of the context
                node that has a <code>type</code>attribute with
                value <code>warning</code></p>
              </li>

              <li>
                <p><code>para[5][@type="warning"]</code> selects
                the fifth <code>para</code> child of the context
                node if that child has a <code>type</code>
                attribute with value <code>warning</code></p>
              </li>

              <li>
                <p><code>chapter[title="Introduction"]</code>
                selects the <code>chapter</code> children of the
                context node that have one or more
                <code>title</code> children with string-value equal
                to <code>Introduction</code></p>
              </li>

              <li>
                <p><code>chapter[title]</code> selects the
                <code>chapter</code> children of the context node
                that have one or more <code>title</code>
                children</p>
              </li>

              <li>
                <p><code>employee[@secretary and @assistant]</code>
                selects all the <code>employee</code> children of
                the context node that have both a
                <code>secretary</code> attribute and an
                <code>assistant</code> attribute</p>
              </li>

              <li>
                <p><code>book/(chapter|appendix)/section</code>
                selects every <code>section</code> element that has
                a parent that is either a <code>chapter</code> or
                an <code>appendix</code> element, that in turn is a
                child of a <code>book</code> element that is a
                child of the context node.</p>
              </li>

              <li>
                <p><code>book/fn:id(publisher)/name</code> returns
                the same result as
                <code>fn:id(book/publisher)/name</code>.</p>
              </li>

              <li>
                <p>If <code>E</code> is any expression that returns
                a sequence of nodes, then the expression
                <code>E/.</code> returns the same nodes in document
                order, with duplicates eliminated based on node
                identity.</p>
              </li>
            </ul>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-sequence-expressions"
          id="id-sequence-expressions"></a>3.3 Sequence
          Expressions</h3>

          <p>XPath supports operators to construct and combine
          sequences. A <b>sequence</b> is an ordered collection of
          zero or more items. An <b>item</b> may be an atomic value
          or a node. An item is identical to a sequence of length
          one containing that item. Sequences are never nested--for
          example, combining the values 1, (2, 3), and ( ) into a
          single sequence results in the sequence (1, 2, 3).</p>

          <div class="div3">
            <h4><a name="construct_seq"
            id="construct_seq"></a>3.3.1 Constructing
            Sequences</h4>

            <h5><a name="d0e4813" id="d0e4813"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="noid_d0e5doc-Expr"
                  id="noid_d0e5doc-Expr"></a>[16]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-Expr">Expr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-ExprSingle">ExprSingle</a> ("," <a
                  href="#doc-ExprSingle">ExprSingle</a>)*</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-RangeExpr"
                  id="doc-RangeExpr"></a>[29]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-RangeExpr">RangeExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-AdditiveExpr">AdditiveExpr</a> ( "to"
                  <a href="#doc-AdditiveExpr">AdditiveExpr</a>
                  )?</code></td>
                </tr>
              </tbody>
            </table>

            <p>One way to construct a sequence is by using the
            comma operator, which evaluates each of its operands
            and concatenates the resulting values, in order, into a
            single result sequence. Empty parentheses can be used
            to denote an empty sequence. In places where the
            grammar calls for ExprSingle, such as the arguments of
            a function call, any expression that contains a
            top-level comma operator must be enclosed in
            parentheses.</p>

            <p>A sequence may contain duplicate values or nodes,
            but a sequence is never an item in another sequence.
            When a new sequence is created by concatenating two or
            more input sequences, the new sequence contains all the
            items of the input sequences and its length is the sum
            of the lengths of the input sequences.</p>

            <p>Here are some examples of expressions that construct
            sequences:</p>

            <ul>
              <li>
                <p>This expression is a sequence of five
                integers:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>This expression constructs one sequence from the
                sequences 10, (1, 2), the empty sequence (), and
                (3, 4):</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre>
                  </div>
                </div>

                <p>It evaluates to the sequence:</p>

                <p><code>10, 1, 2, 3, 4</code></p>
              </li>

              <li>
                <p>This expression contains all <code>salary</code>
                children of the context node followed by all
                <code>bonus</code> children:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
(salary, bonus)
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>Assuming that <code>$price</code> is bound to
                the value <code>10.50</code>, this expression:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
($price, $price)
</pre>
                  </div>
                </div>

                <p>evaluates to the sequence</p>

                <p><code>10.50, 10.50</code></p>
              </li>
            </ul>

            <p>A <b>RangeExpr</b> can be used to construct a
            sequence of consecutive integers. Each of the operands
            of the <code>to</code> operator is converted as though
            it was an argument of a function with the expected
            parameter type <code>xs:integer</code> (this process
            raises an error if the operand cannot be converted to a
            single integer). A sequence is constructed containing
            the two integer operands and every integer between the
            two operands. If the first operand is less than the
            second, the sequence is in increasing order, otherwise
            it is in decreasing order.</p>

            <ul>
              <li>
                <p>This example uses a range expression as one
                operand in constructing a sequence:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
(10, 1 to 4)
</pre>
                  </div>
                </div>

                <p>It evaluates to the sequence:</p>

                <p><code>10, 1, 2, 3, 4</code></p>
              </li>

              <li>
                <p>This example constructs a sequence of length
                one:</p>

                <div class="exampleInner">
<pre>
10 to 10
</pre>
                </div>

                <p>It evaluates to a sequence consisting of the
                single integer <code>10</code>.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="combining_seq"
            id="combining_seq"></a>3.3.2 Combining Sequences</h4>

            <h5><a name="d0e4925" id="d0e4925"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-UnionExpr"
                  id="doc-UnionExpr"></a>[33]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-UnionExpr">UnionExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-IntersectExceptExpr">IntersectExceptExpr</a>
                  ( ("union" | "|") <a
                  href="#doc-IntersectExceptExpr">IntersectExceptExpr</a>
                  )*</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-IntersectExceptExpr"
                  id="doc-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-IntersectExceptExpr">IntersectExceptExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#doc-ValueExpr">ValueExpr</a>
                  ( ("intersect" | "except") <a
                  href="#doc-ValueExpr">ValueExpr</a>
                  )*</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ValueExpr"
                  id="doc-ValueExpr"></a>[35]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-ValueExpr">ValueExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-PathExpr">PathExpr</a></code></td>
                </tr>
              </tbody>
            </table>

            <p>XPath provides several operators for combining
            sequences of nodes. The <code>union</code> and
            <code>|</code> operators are equivalent. They take two
            node sequences as operands and return a sequence
            containing all the nodes that occur in either of the
            operands. The <code>intersect</code> operator takes two
            node sequences as operands and returns a sequence
            containing all the nodes that occur in both operands.
            The <code>except</code> operator takes two node
            sequences as operands and returns a sequence containing
            all the nodes that occur in the first operand but not
            in the second operand. All of these operators return
            their result sequences in document order without
            duplicates based on node identity. If an operand of
            <code>union</code>, <code>intersect</code>, or
            <code>except</code> contains an item that is not a
            node, a type error is raised.</p>

            <p>Here are some examples of expressions that combine
            sequences. Assume the existence of three element nodes
            that we will refer to by symbolic names A, B, and C.
            Assume that <code>$seq1</code> is bound to a sequence
            containing A and B, <code>$seq2</code> is also bound to
            a sequence containing A and B, and <code>$seq3</code>
            is bound to a sequence containing B and C. Then:</p>

            <ul>
              <li>
                <p><code>$seq1 union $seq1</code> evaluates to a
                sequence containing A and B.</p>
              </li>

              <li>
                <p><code>$seq2 union $seq3</code> evaluates to a
                sequence containing A, B, and C.</p>
              </li>

              <li>
                <p><code>$seq1 intersect $seq1</code> evaluates to
                a sequence containing A and B.</p>
              </li>

              <li>
                <p><code>$seq2 intersect $seq3</code> evaluates to
                a sequence containing B only.</p>
              </li>

              <li>
                <p><code>$seq1 except $seq2</code> evaluates to the
                empty sequence.</p>
              </li>

              <li>
                <p><code>$seq2 except $seq3</code> evaluates to a
                sequence containing A only.</p>
              </li>
            </ul>

            <p>In addition to the sequence operators described
            here,<a href="#FunctionsAndOperators">[XQuery 1.0 and
            XPath 2.0 Functions and Operators]</a> includes
            functions for indexed access to items or sub-sequences
            of a sequence, for indexed insertion or removal of
            items in a sequence, and for removing duplicate values
            or nodes from a sequence.</p>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-arithmetic" id="id-arithmetic"></a>3.4
          Arithmetic Expressions</h3>

          <p>XPath provides arithmetic operators for addition,
          subtraction, multiplication, division, and modulus, in
          their usual binary and unary forms.</p>

          <h5><a name="d0e5033" id="d0e5033"></a></h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-AdditiveExpr"
                id="doc-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-AdditiveExpr">AdditiveExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-MultiplicativeExpr">MultiplicativeExpr</a>
                ( ("+" | "-") <a
                href="#doc-MultiplicativeExpr">MultiplicativeExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-MultiplicativeExpr"
                id="doc-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-MultiplicativeExpr">MultiplicativeExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-UnaryExpr">UnaryExpr</a> (
                ("*" | "div" | "idiv" | "mod") <a
                href="#doc-UnaryExpr">UnaryExpr</a> )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-UnaryExpr"
                id="doc-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-UnaryExpr">UnaryExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("-" | "+")* <a
                href="#doc-UnionExpr">UnionExpr</a></code></td>
              </tr>
            </tbody>
          </table>

          <p>The binary subtraction operator must be preceded by
          whitespace if it could otherwise be interpreted as part
          of the previous token. For example, <code>a-b</code> will
          be interpreted as a name, but <code>a - b</code> will be
          interpreted as an arithmetic operation.</p>

          <p>An arithmetic expression is evaluated by applying the
          following rules, in order, until an error is raised or a
          value is computed:</p>

          <ol class="enum1">
            <li>
              <p><b>Atomization</b> is applied to each operand.</p>
            </li>

            <li>
              <p>If either operand is now an empty sequence, the
              result of the operation is an empty sequence.</p>
            </li>

            <li>
              <p>If either operand is now a sequence of length
              greater than one, <span class="xpath"><span
              class="xpath">then:</span></span></p>

              <div class="xpath">
                <ol class="enuma">
                  <li>
                    <p>If <b>XPath 1.0 compatibility mode</b> is
                    <code>true</code>, any items after the first
                    item in the sequence are discarded.</p>
                  </li>

                  <li>
                    <p>Otherwise, a type error is raised.</p>
                  </li>
                </ol>
              </div>
            </li>

            <li>
              <p>If either operand is now of type
              <code>xdt:untypedAtomic</code>, it is cast to the
              default type for the given operator. The default type
              for the <code>idiv</code> operator is
              <code>xs:integer</code>; the default type for all
              other arithmetic operators is <code>xs:double</code>.
              If the cast fails, a type error is raised.</p>
            </li>

            <li>
              <p>If the operand types are now valid for the given
              operator, the operator is applied to the operands,
              resulting in an atomic value or a dynamic error (for
              example, an error might result from dividing by
              zero.) The combinations of atomic types that are
              accepted by the various arithmetic operators, and
              their respective result types, are listed in <a
              href="#mapping"><b>B.2 Operator Mapping</b></a>
              together with the functions in <a
              href="#FunctionsAndOperators">[XQuery 1.0 and XPath
              2.0 Functions and Operators]</a> that define the
              semantics of the operation for each type.</p>
            </li>

            <li class="xpath">
              <p>If the operand types are not valid for the given
              operator, and <b>XPath 1.0 compatibility mode</b> is
              <code>true</code>, and the operator is not
              <code>idiv</code>, then each operand is further
              converted according to the rules in <a
              href="#id-function-calls"><b>3.1.4 Function
              Calls</b></a> as if it were a function argument with
              the expected type <code>xs:double</code>. The
              operator is then applied to the operands, resulting
              in an atomic value or a dynamic error.</p>
            </li>

            <li>
              <p>If the operand types are still not valid for the
              given operator, a type error is raised.</p>
            </li>
          </ol>

          <p>XPath supports two division operators named
          <code>div</code> and <code>idiv</code>. The
          <code>div</code> operator accepts operands of any numeric
          types. The type of the result of the <code>div</code>
          operator is the least common type of its operands;
          however, if both operands are of type
          <code>xs:integer</code>, <code>div</code> returns a
          result of type <code>xs:decimal</code>. The
          <code>idiv</code> operator, on the other hand, requires
          its operands to be of type <code>xs:integer</code> and
          returns a result of type <code>xs:integer</code>, rounded
          toward zero.</p>

          <p>Here are some examples of arithmetic expressions:</p>

          <ul>
            <li>
              <p>The first expression below returns
              <code>-1.5</code>, and the second expressions returns
              <code>-1</code>:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>Subtraction of two date values results in a value
              of type <code>xdt:dayTimeDuration</code>:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This example illustrates the difference between a
              subtraction operator and a hyphen:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>Unary operators have higher precedence than binary
              operators, subject of course to the use of
              parentheses:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
-($bellcost + $whistlecost)
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="div2">
          <h3><a name="id-comparisons" id="id-comparisons"></a>3.5
          Comparison Expressions</h3>

          <p>Comparison expressions allow two values to be
          compared. XPath provides four kinds of comparison
          expressions, called value comparisons, general
          comparisons, node comparisons, and order comparisons.</p>

          <h5><a name="d0e5210" id="d0e5210"></a></h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-ComparisonExpr"
                id="doc-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-ComparisonExpr">ComparisonExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-RangeExpr">RangeExpr</a> (
                (<a href="#doc-ValueComp">ValueComp</a><br />
                | <a href="#doc-GeneralComp">GeneralComp</a><br />
                | <a href="#doc-NodeComp">NodeComp</a><br />
                | <a href="#doc-OrderComp">OrderComp</a>) <a
                href="#doc-RangeExpr">RangeExpr</a> )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-ValueComp"
                id="doc-ValueComp"></a>[44]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-ValueComp">ValueComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"eq" | "ne" | "lt" | "le" | "gt" |
                "ge"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-GeneralComp"
                id="doc-GeneralComp"></a>[43]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-GeneralComp">GeneralComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
                "&gt;="</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-NodeComp"
                id="doc-NodeComp"></a>[45]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-NodeComp">NodeComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"is" | "isnot"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-OrderComp"
                id="doc-OrderComp"></a>[46]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-OrderComp">OrderComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"&lt;&lt;" | "&gt;&gt;"</code></td>
              </tr>
            </tbody>
          </table>

          <div class="xpath">
            <p class="xpath">When an XPath expression is written
            within an XML document, the XML escaping rules for
            special characters must be followed; thus
            "<code>&lt;</code>" must be written as
            "<code>&amp;lt;</code>".</p>
          </div>

          <div class="div3">
            <h4><a name="id-value-comparisons"
            id="id-value-comparisons"></a>3.5.1 Value
            Comparisons</h4>

            <p>Value comparisons are intended for comparing single
            values. The result of a value comparison is defined by
            applying the following rules, in order:</p>

            <ol class="enum1">
              <li>
                <p><b>Atomization</b> is applied to each operand.
                If the result, called an <b>atomized operand</b>,
                does not contain exactly one atomic value, a type
                error is raised.</p>
              </li>

              <li>
                <p>Any atomized operand that has the dynamic type
                <code>xdt:untypedAtomic</code> is cast to the type
                <code>xs:string</code>.</p>
              </li>

              <li>
                <p>The result of the comparison is
                <code>true</code> if the value of the first operand
                is (equal, not equal, less than, less than or
                equal, greater than, greater than or equal) to the
                value of the second operand; otherwise the result
                of the comparison is <code>false</code>. <a
                href="#mapping"><b>B.2 Operator Mapping</b></a>
                describes which combinations of atomic types are
                comparable, and how comparisons are performed on
                values of various types. If the value of the first
                atomized operand is not comparable with the value
                of the second atomized operand, a type error is
                raised.</p>
              </li>
            </ol>

            <p>Here are some examples of value comparisons:</p>

            <ul>
              <li>
                <p>The following comparison is true only if
                <code>$book1</code> has a single
                <code>author</code> subelement and its value is
                "Kennedy":</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>The following comparison is true if
                <code>hatsize</code> and <code>shoesize</code> are
                both user-defined types that are derived by
                restriction from a primitive numeric type:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
hatsize(5) eq shoesize(5)
</pre>
                  </div>
                </div>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="id-general-comparisons"
            id="id-general-comparisons"></a>3.5.2 General
            Comparisons</h4>

            <p>General comparisons are existentially quantified
            comparisons that may be applied to operand sequences of
            any length. The result of a general comparison that
            does not raise an error is always <code>true</code> or
            <code>false</code>.</p>

            <p><b>Atomization</b> is applied to each operand of a
            general comparison. The result of the comparison is
            <code>true</code> if and only if there is a pair of
            atomic values, one belonging to the result of
            atomization of the first operand and the other
            belonging to the result of atomization of the second
            operand, that have the required <b>magnitude
            relationship</b>. Otherwise the result of the general
            comparison is <code>false</code>. The <b>magnitude
            relationship</b> between two atomic values is
            determined as follows:</p>

            <ol class="enum1">
              <li>
                <p>If either atomic value has the dynamic type
                <code>xdt:untypedAtomic</code>, that value is cast
                to a required type, which is determined as
                follows:</p>

                <ol class="enuma">
                  <li>
                    <p>If the dynamic type of the other atomic
                    value is a numeric type, the required type is
                    <code>xs:double</code>.</p>
                  </li>

                  <li>
                    <p>If the dynamic type of the other atomic
                    value is <code>xdt:untypedAtomic</code>, the
                    required type is <code>xs:string</code>.</p>
                  </li>

                  <li>
                    <p>Otherwise, the required type is the dynamic
                    type of the other atomic value.</p>
                  </li>
                </ol>

                <p>If the cast to the required type fails, a
                dynamic error is raised.</p>
              </li>

              <li class="xpath">
                <p>If <b>XPath 1.0 compatibility mode</b> is
                <code>true</code>, and at least one of the atomic
                values has a numeric type, then both atomic values
                are cast to to the type <code>xs:double</code>.</p>
              </li>

              <li>
                <p>After any necessary casting, the atomic values
                are compared using one of the value comparison
                operators <code>eq</code>, <code>ne</code>,
                <code>lt</code>, <code>le</code>, <code>gt</code>,
                or <code>ge</code>, depending on whether the
                general comparison operator was <code>=</code>,
                <code>!=</code>, <code>&lt;</code>,
                <code>&lt;=</code>, <code>&gt;</code>, or
                <code>&gt;=</code>. The values have the required
                <b>magnitude relationship</b> if the result of this
                value comparison is <code>true</code>.</p>
              </li>
            </ol>

            <p>When evaluating a general comparison in which either
            operand is a sequence of items, an implementation may
            return <code>true</code> as soon as it finds an item in
            the first operand and an item in the second operand for
            which the underlying value comparison is
            <code>true</code>. Similarly, a general comparison may
            raise a dynamic error as soon as it encounters an error
            in evaluating either operand, or in comparing a pair of
            items from the two operands. As a result of these
            rules, the result of a general comparison is not
            deterministic in the presence of errors.</p>

            <p>Here are some examples of general comparisons:</p>

            <ul>
              <li>
                <p>The following comparison is true if the value of
                any <code>author</code> subelement of
                <code>$book1</code> has the string value
                "Kennedy":</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>The following example contains three general
                comparisons. The value of the first two comparisons
                is <code>true</code>, and the value of the third
                comparison is <code>false</code>. This example
                illustrates the fact that general comparisons are
                not transitive.</p>

                <div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre>
                </div>
              </li>

              <li>
                <p>Suppose that <code>$a</code>, <code>$b</code>,
                and <code>$c</code> are bound to element nodes with
                type annotation <code>xdt:untypedAtomic</code>,
                with string values "<code>1</code>",
                "<code>2</code>", and "<code>2.0</code>"
                respectively. Then <code>($a, $b) = ($c,
                3.0)</code> returns <code>false</code>, because
                <code>$b</code> and <code>$c</code> are compared as
                strings. However, <code>($a, $b) = ($c, 2.0)</code>
                returns <code>true</code>, because <code>$b</code>
                and <code>2.0</code> are compared as numbers.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="id-node-comparisons"
            id="id-node-comparisons"></a>3.5.3 Node
            Comparisons</h4>

            <p>The result of a node comparison is defined by
            applying the following rules, in order:</p>

            <ol class="enum1">
              <li>
                <p>Each operand must be either a single node or an
                empty sequence; otherwise a type error is
                raised.</p>
              </li>

              <li>
                <p>If either operand is an empty sequence, the
                result of the comparison is an empty sequence.</p>
              </li>

              <li>
                <p>A comparison with the <code>is</code> operator
                is <code>true</code> if the two operands are nodes
                that have the same identity; otherwise it is
                <code>false</code>. A comparison with the
                <code>isnot</code> operator is <code>true</code> if
                the two operands are nodes that have different
                identities; otherwise it is <code>false</code>. See
                <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
                Model]</a> for a discussion of node identity.</p>
              </li>
            </ol>

            <p>Use of the <code>is</code> operator is illustrated
            below.</p>

            <ul>
              <li>
                <p>The following comparison is true only if the
                left and right sides each evaluate to exactly the
                same single node:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
//book[isbn="1558604820"] is //book[call="QA76.9 C3845"]
</pre>
                  </div>
                </div>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="id-order-comparisons"
            id="id-order-comparisons"></a>3.5.4 Order
            Comparisons</h4>

            <p>The result of an order comparison is defined by
            applying the following rules, in order:</p>

            <ol class="enum1">
              <li>
                <p>Both operands must be either a single node or an
                empty sequence; otherwise a type error is
                raised.</p>
              </li>

              <li>
                <p>If either operand is an empty sequence, the
                result of the comparison is an empty sequence.</p>
              </li>

              <li>
                <p>A comparison with the <code>&lt;&lt;</code>
                operator returns <code>true</code> if the first
                operand node is earlier than the second operand
                node in document order; otherwise it returns
                <code>false</code>.</p>
              </li>

              <li>
                <p>A comparison with the <code>&gt;&gt;</code>
                operator returns <code>true</code> if the first
                operand node is later than the second operand node
                in document order; otherwise it returns
                <code>false</code>.</p>
              </li>
            </ol>

            <p>Here is an example of an order comparison:</p>

            <ul>
              <li>
                <p>The following comparison is true only if the
                node identified by the left side occurs before the
                node identified by the right side in document
                order:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
//purchase[parcel="28-451"] &lt;&lt; //sale[parcel="33-870"]
</pre>
                  </div>
                </div>
              </li>
            </ul>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-logical-expressions"
          id="id-logical-expressions"></a>3.6 Logical
          Expressions</h3>

          <p>A <b>logical expression</b> is either an
          <b>and-expression</b> or an <b>or-expression</b>. If a
          logical expression does not raise an error, its value is
          always one of the boolean values <code>true</code> or
          <code>false</code>.</p>

          <h5><a name="d0e5627" id="d0e5627"></a>Logical
          Expressions</h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-OrExpr"
                id="doc-OrExpr"></a>[22]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-OrExpr">OrExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-AndExpr">AndExpr</a> ( "or"
                <a href="#doc-AndExpr">AndExpr</a> )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="doc-AndExpr"
                id="doc-AndExpr"></a>[23]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-AndExpr">AndExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-InstanceofExpr">InstanceofExpr</a> (
                "and" <a
                href="#doc-InstanceofExpr">InstanceofExpr</a>
                )*</code></td>
              </tr>
            </tbody>
          </table>

          <p>The first step in evaluating a logical expression is
          to find the <b>effective boolean value</b> of each of its
          operands (see <a href="#id-ebv"><b>2.4.4.2 Effective
          Boolean Value</b></a>).</p>

          <p>The value of an and-expression is determined by the
          effective boolean values (EBV's) of its operands. If an
          error is raised during computation of one of the
          effective boolean values, an and-expression <em>may</em>
          raise a dynamic error, as shown in the following
          table:</p>

          <table border="1" cellpadding="4" cellspacing="1"
          width="80%" summary="AND EBV">
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">AND:</td>

                <td rowspan="1" colspan="1">EBV<sub>2</sub> =
                true</td>

                <td rowspan="1" colspan="1">EBV<sub>2</sub> =
                false</td>

                <td rowspan="1" colspan="1">error in
                EBV<sub>2</sub></td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">EBV<sub>1</sub> =
                true</td>

                <td rowspan="1" colspan="1">true</td>

                <td rowspan="1" colspan="1">false</td>

                <td rowspan="1" colspan="1">error</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">EBV<sub>1</sub> =
                false</td>

                <td rowspan="1" colspan="1">false</td>

                <td rowspan="1" colspan="1">false</td>

                <td rowspan="1" colspan="1">false or error</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">error in
                EBV<sub>1</sub></td>

                <td rowspan="1" colspan="1">error</td>

                <td rowspan="1" colspan="1">false or error</td>

                <td rowspan="1" colspan="1">error</td>
              </tr>
            </tbody>
          </table>

          <p>The value of an or-expression is determined by the
          effective boolean values (EBV's) of its operands. If an
          error is raised during computation of one of the
          effective boolean values, an or-expression <em>may</em>
          raise a dynamic error, as shown in the following
          table:</p>

          <table border="1" cellpadding="4" cellspacing="1"
          width="80%" summary="OR EBV">
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">OR:</td>

                <td rowspan="1" colspan="1">EBV<sub>2</sub> =
                true</td>

                <td rowspan="1" colspan="1">EBV<sub>2</sub> =
                false</td>

                <td rowspan="1" colspan="1">error in
                EBV<sub>2</sub></td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">EBV<sub>1</sub> =
                true</td>

                <td rowspan="1" colspan="1">true</td>

                <td rowspan="1" colspan="1">true</td>

                <td rowspan="1" colspan="1">true or error</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">EBV<sub>1</sub> =
                false</td>

                <td rowspan="1" colspan="1">true</td>

                <td rowspan="1" colspan="1">false</td>

                <td rowspan="1" colspan="1">error</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">error in
                EBV<sub>1</sub></td>

                <td rowspan="1" colspan="1">true or error</td>

                <td rowspan="1" colspan="1">error</td>

                <td rowspan="1" colspan="1">error</td>
              </tr>
            </tbody>
          </table>

          <p>The order in which the operands of a logical
          expression are evaluated is implementation-dependent. The
          tables above are defined in such a way that an
          or-expression can return <code>true</code> if the first
          expression evaluated is true, and it can raise an error
          if evaluation of the first expression raises an error.
          Similarly, an and-expression can return
          <code>false</code> if the first expression evaluated is
          false, and it can raise an error if evaluation of the
          first expression raises an error. As a result of these
          rules, a logical expression is not deterministic in the
          presence of errors, as illustrated in the examples
          below.</p>

          <p>Here are some examples of logical expressions:</p>

          <ul>
            <li>
              <p>The following expressions return
              <code>true</code>:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre>
                </div>
              </div>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The following expression may return either
              <code>false</code> or raise a dynamic error:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The following expression may return either
              <code>true</code> or raise a dynamic error:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The following expression must raise a dynamic
              error:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre>
                </div>
              </div>
            </li>
          </ul>

          <p>In addition to and- and or-expressions, XPath provides
          a function named <code>not</code> that takes a general
          sequence as parameter and returns a boolean value. The
          <code>not</code> function reduces its parameter to an
          <b>effective boolean value</b>. It then returns
          <code>true</code> if the effective boolean value of its
          parameter is <code>false</code>, and <code>false</code>
          if the effective boolean value of its parameter is
          <code>true</code>. If an error is encountered in finding
          the effective boolean value of its operand,
          <code>not</code> raises a dynamic error. The
          <code>not</code> function is described in <a
          href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
          Functions and Operators]</a>.</p>
        </div>

        <div class="xpath">
          <div class="div2">
            <h3><a name="id-for-expressions"
            id="id-for-expressions"></a>3.7 For Expressions</h3>

            <p>XPath provides an iteration facility called a <b>for
            expression</b>.</p>

            <h5><a name="d0e5858" id="d0e5858"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-ForExpr"
                  id="doc-ForExpr"></a>[18]&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-ForExpr"
                  class="xpath">ForExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-SimpleForClause">SimpleForClause</a>
                  "return" <a
                  href="#doc-ExprSingle">ExprSingle</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SimpleForClause"
                  id="doc-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-SimpleForClause"
                  class="xpath">SimpleForClause</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"for" "$" <a
                  href="#doc-VarName">VarName</a> "in" <a
                  href="#doc-ExprSingle">ExprSingle</a> ("," "$" <a
                  href="#doc-VarName">VarName</a> "in" <a
                  href="#doc-ExprSingle">ExprSingle</a>)*</code></td>
                </tr>
              </tbody>
            </table>

            <p>A <code>for</code> expression is evaluated as
            follows:</p>

            <ol class="enum1">
              <li>
                <p>If the <code>for</code> expression uses multiple
                variables, it is first expanded to a set of nested
                <code>for</code> expressions, each of which uses
                only one variable. For example, the expression
                <code>for $x in X, $y in Y return $x + $y</code> is
                expanded to <code>for $x in X return for $y in Y
                return $x + $y</code>.</p>
              </li>

              <li>
                <p>In a single-variable <code>for</code>
                expression, the variable is called the <b>range
                variable</b>, the value of the expression that
                follows the <code>in</code> keyword is called the
                <b>input sequence</b>, and the expression that
                follows the <code>return</code> keyword is called
                the <b>return expression</b>. The result of the
                <code>for</code> expression is obtained by
                evaluating the <code>return</code> expression once
                for each item in the input sequence, with the range
                variable bound to that item. The resulting
                sequences are concatenated in the order of the
                items in the input sequence from which they were
                derived.</p>
              </li>
            </ol>

            <div class="xpath">
              <p class="xpath">The following example illustrates
              the use of a <code>for</code> expression in
              restructuring an input document. The example is based
              on the following input:</p>
            </div>

            <div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Unix Programming&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre>
            </div>

            <p>The following example transforms the input document
            into a list in which each author's name appears only
            once, followed by a list of titles of books written by
            that author. This example assumes that the context item
            is the <code>bib</code> element in the input
            document.</p>

            <div class="exampleInner">
<pre>
<span class="parse-test"><span
class="parse-test">for $a in distinct-values(//author)
return ($a,
        for $b in //book[author = $a]
        return $b/title)</span></span>
</pre>
            </div>

            <p>The result of the above expression consists of the
            following sequence of elements. The ordering of
            <code>author</code> elements in the result is
            implementation-dependent.</p>

            <div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre>
            </div>

            <p>The following example illustrates a <code>for</code>
            expression containing more than one variable:</p>

            <div class="exampleInner">
<pre>
<span class="parse-test"><span
class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span>
</pre>
            </div>

            <p>The result of the above expression, expressed as a
            sequence of numbers, is as follows: <code>11, 12, 21,
            22</code></p>

            <p>The scope of a variable bound in a <code>for</code>
            expression comprises all subexpressions of the
            <code>for</code> expression that appear after the
            variable binding. The scope does not include the
            expression to which the variable is bound. The
            following example illustrates how a variable binding
            may reference another variable bound earlier in the
            same <code>for</code> expression:</p>

            <div class="exampleInner">
<pre>
<span class="parse-test"><span
class="parse-test">for $x in input(), $y in f($x)
return g($x, $y)</span></span>
</pre>
            </div>

            <p>Note that the focus for evaluation of the
            <code>return</code> clause of a <code>for</code>
            expression is the same as the focus for evaluation of
            the <code>for</code> expression itself. The following
            example, which attempts to find the total value of a
            set of order-items, is therefore incorrect:</p>

            <div class="exampleInner">
<pre>
sum(for $i in order-item return @price * @qty)
</pre>
            </div>

            <p>Instead, the expression must be written to use the
            variable bound in the <code>for</code> clause:</p>

            <div class="exampleInner">
<pre>
sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre>
            </div>
          </div>
        </div>

        <div class="div2">
          <h3><a name="id-conditionals"
          id="id-conditionals"></a>3.8 Conditional Expressions</h3>

          <p>XPath supports a conditional expression based on the
          keywords <code>if</code>, <code>then</code>, and
          <code>else</code>.</p>

          <h5><a name="d0e6016" id="d0e6016"></a>Conditional
          Expression</h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-IfExpr"
                id="doc-IfExpr"></a>[21]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-IfExpr">IfExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"if" "(" <a href="#doc-Expr">Expr</a> ")"
                "then" <a href="#doc-Expr">Expr</a> "else" <a
                href="#doc-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>
          </table>

          <p>The expression following the <code>if</code> keyword
          is called the <b>test expression</b>, and the expressions
          following the <code>then</code> and <code>else</code>
          keywords are called the <b>then-expression</b> and
          <b>else-expression</b>, respectively.</p>

          <p>The first step in processing a conditional expression
          is to find the <b>effective boolean value</b> of the test
          expression, as defined in <a href="#id-ebv"><b>2.4.4.2
          Effective Boolean Value</b></a>.</p>

          <p>The value of a conditional expression is defined as
          follows: If the effective boolean value of the test
          expression is <code>true</code>, the value of the
          then-expression is returned. If the effective boolean
          value of the test expression is <code>false</code>, the
          value of the else-expression is returned.</p>

          <p>Conditional expressions have a special rule for
          propagating dynamic errors. If the effective value of the
          test expression is <code>true</code>, the conditional
          expression ignores (does not raise) any dynamic errors
          encountered in the else-expression. In this case, since
          the else-expression can have no observable effect, it
          need not be evaluated. Similarly, if the effective value
          of the test expression is <code>false</code>, the
          conditional expression ignores any dynamic errors
          encountered in the then-expression, and the
          then-expression need not be evaluated.</p>

          <p>Here are some examples of conditional expressions:</p>

          <ul>
            <li>
              <p>In this example, the test expression is a
              comparison expression:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>In this example, the test expression tests for the
              existence of an attribute named
              <code>discounted</code>, independently of its
              value:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="div2">
          <h3><a name="id-quantified-expressions"
          id="id-quantified-expressions"></a>3.9 Quantified
          Expressions</h3>

          <p>Quantified expressions support existential and
          universal quantification. The value of a quantified
          expression is always <code>true</code> or
          <code>false</code>.</p>

          <h5><a name="d0e6102" id="d0e6102"></a></h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="doc-QuantifiedExpr"
                id="doc-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QuantifiedExpr">QuantifiedExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("some" "$" | "every" "$") <a
                href="#doc-VarName">VarName</a> "in" <a
                href="#doc-ExprSingle">ExprSingle</a> ("," "$" <a
                href="#doc-VarName">VarName</a> "in" <a
                href="#doc-ExprSingle">ExprSingle</a>)* "satisfies"
                <a
                href="#doc-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>
          </table>

          <p>A <b>quantified expression</b> begins with a
          <b>quantifier</b>, which is the keyword <code>some</code>
          or <code>every</code>, followed by one or more in-clauses
          that are used to bind variables, followed by the keyword
          <code>satisfies</code> and a test expression. Each
          in-clause associates a variable with an expression that
          returns a sequence of values. The in-clauses generate
          tuples of variable bindings, using values drawn from the
          Cartesian product of the sequences returned by the
          binding expressions. Conceptually, the test expression is
          evaluated for each tuple of variable bindings. Results
          depend on the <b>effective boolean values</b> of the test
          expressions, as defined in <a href="#id-ebv"><b>2.4.4.2
          Effective Boolean Value</b></a>. The value of the
          quantified expression is defined by the following
          rules:</p>

          <ol class="enum1">
            <li>
              <p>If the quantifier is <code>some</code>, the
              quantified expression is <code>true</code> if at
              least one evaluation of the test expression has the
              <b>effective boolean value</b> <code>true</code>;
              otherwise the quantified expression is
              <code>false</code>. This rule implies that, if the
              in-clauses generate zero binding tuples, the value of
              the quantified expression is <code>false</code>.</p>
            </li>

            <li>
              <p>If the quantifier is <code>every</code>, the
              quantified expression is <code>true</code> if every
              evaluation of the test expression has the
              <b>effective boolean value</b> <code>true</code>;
              otherwise the quantified expression is
              <code>false</code>. This rule implies that, if the
              in-clauses generate zero binding tuples, the value of
              the quantified expression is <code>true</code>.</p>
            </li>
          </ol>

          <p>The scope of a variable bound in a quantified
          expression comprises all subexpressions of the quantified
          expression that appear after the variable binding. The
          scope does not include the expression to which the
          variable is bound.</p>

          <p>The order in which test expressions are evaluated for
          the various binding tuples is implementation-defined. If
          the quantifier is <code>some</code>, an implementation
          may return <code>true</code> as soon as it finds one
          binding tuple for which the test expression has an
          effective Boolean value of <code>true</code>, and it may
          raise a dynamic error as soon as it finds one binding
          tuple for which the test expression raises an error.
          Similarly, if the quantifier is <code>every</code>, an
          implementation may return <code>false</code> as soon as
          it finds one binding tuple for which the test expression
          has an effective Boolean value of <code>false</code>, and
          it may raise a dynamic error as soon as it finds one
          binding tuple for which the test expression raises an
          error. As a result of these rules, the value of a
          quantified expression is not deterministic in the
          presence of errors, as illustrated in the examples
          below.</p>

          <p>Here are some examples of quantified expressions:</p>

          <ul>
            <li>
              <p>This expression is <code>true</code> if every
              <code>part</code> element has a
              <code>discounted</code> attribute (regardless of the
              values of these attributes):</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
every $part in //part satisfies $part/@discounted
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This expression is <code>true</code> if at least
              one <code>employee</code> element satisfies the given
              comparison expression:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
some $emp in //employee satisfies ($emp/bonus &gt; 0.25 * $emp/salary)
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>In the following examples, each quantified
              expression evaluates its test expression over nine
              tuples of variable bindings, formed from the
              Cartesian product of the sequences <code>(1, 2,
              3)</code> and <code>(2, 3, 4)</code>. The expression
              beginning with <code>some</code> evaluates to
              <code>true</code>, and the expression beginning with
              <code>every</code> evaluates to
              <code>false</code>.</p>

              <div class="exampleInner">
<pre>
<span class="parse-test"><span
class="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre>
              </div>

              <div class="exampleInner">
<pre>
<span class="parse-test"><span
class="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre>
              </div>
            </li>

            <li>
              <p>This quantified expression may either return
              <code>true</code> or raise a type error, since its
              test expression returns <code>true</code> for one
              variable binding and raises a type error for
              another:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This quantified expression may either return
              <code>false</code> or raise a type error, since its
              test expression returns <code>false</code> for one
              variable binding and raises a type error for
              another:</p>

              <div class="parse-test">
                <div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="div2">
          <h3><a name="id-expressions-on-datatypes"
          id="id-expressions-on-datatypes"></a>3.10 Expressions on
          SequenceTypes</h3>

          <p><b>SequenceTypes</b> are used in <code>instance
          of</code>, <code>cast</code>, <code>castable</code>, and
          <code>treat</code> expressions.</p>

          <div class="div3">
            <h4><a name="id-instance-of"
            id="id-instance-of"></a>3.10.1 Instance Of</h4>

            <h5><a name="d0e6308" id="d0e6308"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-InstanceofExpr"
                  id="doc-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-InstanceofExpr">InstanceofExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#doc-TreatExpr">TreatExpr</a>
                  ( "instance" "of" <a
                  href="#doc-SequenceType">SequenceType</a>
                  )?</code></td>
                </tr>
              </tbody>
            </table>

            <p>The boolean operator <code>instance of</code>
            returns <code>true</code> if the value of its first
            operand matches the type named in its second operand,
            according to the rules for <b>SequenceType
            Matching</b>; otherwise it returns <code>false</code>.
            For example:</p>

            <ul>
              <li>
                <p><code>5 instance of xs:integer</code></p>

                <p>This example returns <code>true</code> because
                the given value is an instance of the given
                type.</p>
              </li>

              <li>
                <p><code>5 instance of xs:decimal</code></p>

                <p>This example returns <code>true</code> because
                the given value is an integer literal, and
                <code>xs:integer</code> is derived by restriction
                from <code>xs:decimal</code>.</p>
              </li>

              <li>
                <p><code>. instance of element()</code></p>

                <p>This example returns <code>true</code> if the
                context item is an element node.</p>
              </li>
            </ul>
          </div>

          <div class="div3">
            <h4><a name="id-cast" id="id-cast"></a>3.10.2 Cast</h4>

            <h5><a name="d0e6371" id="d0e6371"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-CastExpr"
                  id="doc-CastExpr"></a>[27]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-CastExpr">CastExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-ComparisonExpr">ComparisonExpr</a> (
                  "cast" "as" <a
                  href="#doc-SingleType">SingleType</a>
                  )?</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-SingleType"
                  id="doc-SingleType"></a>[60]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-SingleType">SingleType</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-AtomicType">AtomicType</a>
                  "?"?</code></td>
                </tr>
              </tbody>
            </table>

            <p>Occasionally it is necessary to convert a value to a
            specific datatype. For this purpose, XPath provides a
            <code>cast</code> expression that creates a new value
            of a specific type based on an existing value. A
            <code>cast</code> expression takes two operands: an
            <b>input expression</b> and a <b>target type</b>. The
            type of the input expression is called the <b>input
            type</b>. The target type must be a named atomic type,
            represented by a QName, optionally followed by the
            occurrence indicator <code>?</code> if an empty
            sequence is permitted. If the target type has no
            namespace prefix, it is considered to be in the
            <b>default element namespace</b>. The semantics of the
            <code>cast</code> expression are as follows:</p>

            <ol class="enum1">
              <li>
                <p><b>Atomization</b> is performed on the input
                expression.</p>
              </li>

              <li>
                <p>If the result of atomization is a sequence of
                more than one atomic value, a type error is
                raised.</p>
              </li>

              <li>
                <p>If the result of atomization is an empty
                sequence:</p>

                <ol class="enuma">
                  <li>
                    <p>If <code>?</code> is specified after the
                    target type, the result of the
                    <code>cast</code> expression is an empty
                    sequence.</p>
                  </li>

                  <li>
                    <p>If <code>?</code> is not specified after the
                    target type, a type error is raised.</p>
                  </li>
                </ol>
              </li>

              <li>
                <p>If the result of atomization is a single atomic
                value, the result of the cast expression depends on
                the input type and the target type. In general, the
                cast expression attempts to create a new value of
                the target type based on the input value. Only
                certain combinations of input type and target type
                are supported. The rules are listed below. For the
                purpose of these rules, we use the terms
                <b>subtype</b> and <b>supertype</b> in the
                following sense: if type B is derived from type A
                by restriction, then B is a <b>subtype</b> of A,
                and A is a <b>supertype</b> of B.</p>

                <ol class="enuma">
                  <li>
                    <p><code>cast</code> is supported for the
                    combinations of input type and target type
                    listed in <a
                    href="#FunctionsAndOperators">[XQuery 1.0 and
                    XPath 2.0 Functions and Operators]</a>. For
                    each of these combinations, both the input type
                    and the target type are built-in schema types.
                    For example, a value of type
                    <code>xs:string</code> can be cast into the
                    type <code>xs:decimal</code>. For each of these
                    built-in combinations, the semantics of casting
                    are specified in <a
                    href="#FunctionsAndOperators">[XQuery 1.0 and
                    XPath 2.0 Functions and Operators]</a>.</p>
                  </li>

                  <li>
                    <p><code>cast</code> is supported if the input
                    type is a derived atomic type and the target
                    type is a supertype of the input type. In this
                    case, the input value is mapped into the value
                    space of the target type, unchanged except for
                    its type. For example, if <code>shoesize</code>
                    is derived by restriction from
                    <code>xs:integer</code>, a value of type
                    <code>shoesize</code> can be cast into the type
                    <code>xs:integer</code>.</p>
                  </li>

                  <li>
                    <p><code>cast</code> is supported if the target
                    type is a derived atomic type and the input
                    type is <code>xs:string</code> or
                    <code>xdt:untypedAtomic</code>. The input value
                    is first converted to a value in the lexical
                    space of the target type by applying the
                    whitespace normalization rules for the target
                    type; a dynamic error is raised if the
                    resulting lexical value does not satisfy the
                    pattern facet of the target type. The lexical
                    value is then converted to the value space of
                    the target type using the schema-defined rules
                    for the target type; a dynamic error is raised
                    if the resulting value does not satisfy all the
                    facets of the target type.</p>
                  </li>

                  <li>
                    <p><code>cast</code> is supported if the target
                    type is a derived atomic type and the input
                    type is a supertype of the target type. The
                    input value must satisfy all the facets of the
                    target type (in the case of the pattern facet,
                    this is checked by generating a string
                    representation of the input value, using the
                    rules for casting to <code>xs:string</code>).
                    The resulting value is the same as the input
                    value, but with a different dynamic type.</p>
                  </li>

                  <li>
                    <p>If a primitive type P1 can be cast into a
                    primitive type P2, then any subtype of P1 can
                    be cast into any subtype of P2, provided that
                    the facets of the target type are satisfied.
                    First the input value is cast to P1 using rule
                    (b) above. Next, the value of type P1 is cast
                    to the type P2, using rule (a) above. Finally,
                    the value of type P2 is cast to the target
                    type, using rule (d) above.</p>
                  </li>

                  <li>
                    <p>For any combination of input type and target
                    type that is not in the above list, a
                    <code>cast</code> expression raises a type
                    error.</p>
                  </li>
                </ol>
              </li>
            </ol>

            <p>If casting from the input type to the target type is
            supported but nevertheless it is not possible to cast
            the input value into the value space of the target
            type, a dynamic error is raised. This includes the case
            when any facet of the target type is not satisfied. For
            example, the expression <code>"2003-02-31" cast as
            xs:date</code> would raise a dynamic error.</p>
          </div>

          <div class="div3">
            <h4><a name="id-castable" id="id-castable"></a>3.10.3
            Castable</h4>

            <h5><a name="d0e6528" id="d0e6528"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-CastableExpr"
                  id="doc-CastableExpr"></a>[26]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-CastableExpr">CastableExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#doc-CastExpr">CastExpr</a> (
                  "castable" "as" <a
                  href="#doc-SingleType">SingleType</a>
                  )?</code></td>
                </tr>
              </tbody>
            </table>

            <p>XPath provides a form of Boolean expression that
            tests whether a given value is castable into a given
            target type. The expression <code>V castable as
            T</code> returns <code>true</code> if the value
            <code>V</code> can be successfully cast into the target
            type <code>T</code> by using a <code>cast</code>
            expression; otherwise it returns <code>false</code>.
            The <code>castable</code> predicate can be used to
            avoid errors at evaluation time. It can also be used to
            select an appropriate type for processing of a given
            value, as illustrated in the following example:</p>

            <div class="parse-test">
              <div class="exampleInner">
<pre>
if ($x castable as hatsize)
then $x cast as hatsize
else if ($x castable as IQ)
then $x cast as IQ
else $x cast as xs:string
</pre>
              </div>
            </div>
          </div>

          <div class="div3">
            <h4><a name="id-constructor-functions"
            id="id-constructor-functions"></a>3.10.4 Constructor
            Functions</h4>

            <p>Constructor functions provide an alternative syntax
            for casting.</p>

            <p>For every built-in atomic type <em>T</em> that is
            defined in <a href="#XMLSchema">[XML Schema]</a>, as
            well as the predefined types
            <code>xdt:dayTimeDuration</code>,
            <code>xdt:yearMonthDuration</code>, and
            <code>xdt:untypedAtomic</code>, a built-in constructor
            function is provided. The signature of the built-in
            constructor function for type <em>T</em> is as
            follows:</p>

            <div class="exampleInner">
<pre>
<em>T</em>($x as item) as <em>T</em>
</pre>
            </div>

            <p>The constructor function for type <em>T</em> accepts
            any single item (either a node or an atomic value) as
            input, and returns a value of type <em>T</em> (or
            raises a dynamic error). Its semantics are exactly the
            same as a <code>cast</code> expression with target type
            <em>T</em>. The built-in constructor functions are
            described in more detail in <a
            href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a>. The following are
            examples of built-in constructor functions:</p>

            <ul>
              <li>
                <p>This example is equivalent to <code>"2000-01-01"
                cast as xs:date</code>.</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>This example is equivalent to <code>($floatvalue
                * 0.2E-5) cast as xs:decimal</code>.</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre>
                  </div>
                </div>
              </li>

              <li>
                <p>This example returns a
                <code>dayTimeDuration</code> value equal to 21
                days. It is equivalent to <code>"P21D" cast as
                xdt:dayTimeDuration</code>.</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
xdt:dayTimeDuration("P21D")
</pre>
                  </div>
                </div>
              </li>
            </ul>

            <p>For each user-defined top-level atomic type
            <em>T</em> in the <b>in-scope type definitions</b>, a
            constructor function is effectively defined. Like the
            built-in constructor functions, the constructor
            functions for user-defined types have the same name
            (including namespace or lack of namespace) as the type,
            accept any item as input, and have semantics identical
            to a <code>cast</code> expression with the user-defined
            type as target type. For example, if
            <code>usa:zipcode</code> is a user-defined top-level
            atomic type in the <b>in-scope type definitions</b>,
            then the expression <code>usa:zipcode("12345")</code>
            is equivalent to the expression <code>"12345" cast as
            usa:zipcode</code>.</p>

            <p>If the argument to any constructor function is a
            literal value, the result of the function may be
            computed statically, and an error encountered in this
            process may be reported as a static error.</p>
          </div>

          <div class="div3">
            <h4><a name="id-treat" id="id-treat"></a>3.10.5
            Treat</h4>

            <h5><a name="d0e6668" id="d0e6668"></a></h5>

            <table class="scrap" summary="Scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a name="doc-TreatExpr"
                  id="doc-TreatExpr"></a>[25]&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#prod-TreatExpr">TreatExpr</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a
                  href="#doc-CastableExpr">CastableExpr</a> (
                  "treat" "as" <a
                  href="#doc-SequenceType">SequenceType</a>
                  )?</code></td>
                </tr>
              </tbody>
            </table>

            <p>XPath provides an expression called
            <code>treat</code> that can be used to modify the
            static type of its operand.</p>

            <p>Like <code>cast</code>, the <code>treat</code>
            expression takes two operands: an expression and a
            <b>SequenceType</b>. Unlike <code>cast</code>, however,
            <code>treat</code> does not change the dynamic type or
            value of its operand. Instead, the purpose of
            <code>treat</code> is to ensure that an expression has
            an expected type at evaluation time.</p>

            <p>The semantics of <code>expr1 treat as type1</code>
            are as follows:</p>

            <ul>
              <li>
                <p>During static analysis (if the Static Typing
                Feature is implemented):</p>

                <p><code>type1</code> must be derived by
                restriction from the static type of
                <code>expr1</code>--otherwise, a type error is
                raised. The static type of the <code>treat</code>
                expression is <code>type1</code>. This enables the
                expression to be used as an argument of a function
                that requires a parameter of
                <code>type1</code>.</p>
              </li>

              <li>
                <p>During expression evaluation (at
                "run-time"):</p>

                <p>If <code>expr1</code> matches
                <code>type1</code>, using the SequenceType Matching
                rules in <a href="#id-sequencetype"><b>2.4.3
                SequenceType</b></a>, the <code>treat</code>
                expression returns the value of <code>expr1</code>;
                otherwise, it raises a dynamic error. If the value
                of <code>expr1</code> is returned, its identity is
                preserved. The <code>treat</code> expression
                ensures that the value of its expression operand
                conforms to the expected type at run-time.</p>
              </li>

              <li>
                <p>Example:</p>

                <div class="parse-test">
                  <div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre>
                  </div>
                </div>

                <p>The static type of <code>$myaddress</code> may
                be <code>element(*, Address)</code>, a less
                specific type than <code>element(*,
                USAddress)</code>. However, at run-time, the value
                of <code>$myaddress</code> must match the type
                <code>element(*, USAddress)</code> using
                SequenceType Matching rules; otherwise a dynamic
                error is raised.</p>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="back">
      <div class="div1">
        <h2><a name="nt-bnf" id="nt-bnf"></a>A XPath Grammar</h2>

        <div class="div2">
          <h3><a name="id-grammar" id="id-grammar"></a>A.1
          EBNF</h3>

          <p>The following grammar uses the same Basic Extended
          Backus-Naur Form (EBNF) notation as <a
          href="#XML">[XML]</a>, except that grammar symbols always
          have initial capital letters. The notation "&lt; ...
          &gt;" is used to indicate a grouping of terminals that
          together may help disambiguate the individual symbols. To
          help readability, this "&lt; ... &gt;" notation is absent
          in the EBNF in the main body of this document.</p>

          <p>Comments on grammar productions are between '/*' and
          '*/' symbols. A 'pn:' prefix means a 'Parser Note', and
          are meant as clarifications for parsing rules, and are
          explained in <a href="#notes-on-parsing"><b>A.1.1 Parsing
          Notes</b></a>. A 'ws:' prefix explains the whitespace
          rules for the production, the details of which are
          explained in <a href="#whitespace-rules"><b>A.2.1
          Whitespace Rules</b></a></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The Semicolon character is reserved for future
            use.</p>
          </div>

          <h5><a name="d0e6796" id="d0e6796"></a>Named
          Terminals</h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ExprComment"
                id="prod-ExprComment"></a>[1]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ExprComment">ExprComment</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"(:" (<a
                href="#prod-ExprCommentContent">ExprCommentContent</a>
                | <a href="#prod-ExprComment">ExprComment</a>)*
                ":)"</code></td>

                <td><i>/* <a href="#parse-note-parens">pn:
                parens</a> */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ExprCommentContent"
                id="prod-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ExprCommentContent">ExprCommentContent</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-Char">Char</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-IntegerLiteral"
                id="prod-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-IntegerLiteral">IntegerLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-Digits">Digits</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-DecimalLiteral"
                id="prod-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-DecimalLiteral">DecimalLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("." <a href="#prod-Digits">Digits</a>) |
                (<a href="#prod-Digits">Digits</a> "."
                [0-9]*)</code></td>

                <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-DoubleLiteral"
                id="prod-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-DoubleLiteral">DoubleLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(("." <a href="#prod-Digits">Digits</a>)
                | (<a href="#prod-Digits">Digits</a> ("."
                [0-9]*)?)) ("e" | "E") ("+" | "-")? <a
                href="#prod-Digits">Digits</a></code></td>

                <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-StringLiteral"
                id="prod-StringLiteral"></a>[6]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-StringLiteral">StringLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>('"' (('"' '"') | [^"])* '"') | ("'"
                (("'" "'") | [^'])* "'")</code></td>

                <td><i>/* <a href="#ws-significant">ws:
                significant</a> */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SchemaGlobalTypeName"
                id="prod-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"type" "(" <a
                href="#prod-QName">QName</a> ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SchemaGlobalContext"
                id="prod-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SchemaGlobalContext">SchemaGlobalContext</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> | <a
                href="#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SchemaContextStep"
                id="prod-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SchemaContextStep">SchemaContextStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Digits"
                id="prod-Digits"></a>[10]&#160;&#160;&#160;</td>

                <td><code>Digits</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>[0-9]+</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NCName"
                id="prod-NCName"></a>[11]&#160;&#160;&#160;</td>

                <td><code>NCName</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-VarName"
                id="prod-VarName"></a>[12]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-VarName">VarName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-QName"
                id="prod-QName"></a>[13]&#160;&#160;&#160;</td>

                <td><code>QName</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Char"
                id="prod-Char"></a>[14]&#160;&#160;&#160;</td>

                <td><code>Char</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="http://www.w3.org/TR/REC-xml#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a></code></td>
              </tr>
            </tbody>
          </table>

          <h5><a name="BNF-Grammar"
          id="BNF-Grammar"></a>Non-Terminals</h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="prod-XPath"
                id="prod-XPath"></a>[15]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-XPath">XPath</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-Expr">Expr</a>?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Expr"
                id="prod-Expr"></a>[16]&#160;&#160;&#160;</td>

                <td><code><a href="#doc-Expr">Expr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-ExprSingle">ExprSingle</a>
                ("," <a
                href="#prod-ExprSingle">ExprSingle</a>)*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ExprSingle"
                id="prod-ExprSingle"></a>[17]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ExprSingle">ExprSingle</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-ForExpr">ForExpr</a><br />
                | <a
                href="#prod-QuantifiedExpr">QuantifiedExpr</a><br />

                | <a href="#prod-IfExpr">IfExpr</a><br />
                | <a href="#prod-OrExpr">OrExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ForExpr"
                id="prod-ForExpr"></a>[18]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ForExpr">ForExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-SimpleForClause">SimpleForClause</a>
                "return" <a
                href="#prod-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SimpleForClause"
                id="prod-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SimpleForClause">SimpleForClause</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"for" "$"&gt; <a
                href="#prod-VarName">VarName</a> "in" <a
                href="#prod-ExprSingle">ExprSingle</a> ("," "$" <a
                href="#prod-VarName">VarName</a> "in" <a
                href="#prod-ExprSingle">ExprSingle</a>)*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-QuantifiedExpr"
                id="prod-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-QuantifiedExpr">QuantifiedExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(&lt;"some" "$"&gt; | &lt;"every"
                "$"&gt;) <a href="#prod-VarName">VarName</a> "in"
                <a href="#prod-ExprSingle">ExprSingle</a> ("," "$"
                <a href="#prod-VarName">VarName</a> "in" <a
                href="#prod-ExprSingle">ExprSingle</a>)*
                "satisfies" <a
                href="#prod-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-IfExpr"
                id="prod-IfExpr"></a>[21]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-IfExpr">IfExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"if" "("&gt; <a
                href="#prod-Expr">Expr</a> ")" "then" <a
                href="#prod-Expr">Expr</a> "else" <a
                href="#prod-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-OrExpr"
                id="prod-OrExpr"></a>[22]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-OrExpr">OrExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-AndExpr">AndExpr</a> (
                "or" <a href="#prod-AndExpr">AndExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AndExpr"
                id="prod-AndExpr"></a>[23]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AndExpr">AndExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-InstanceofExpr">InstanceofExpr</a> (
                "and" <a
                href="#prod-InstanceofExpr">InstanceofExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-InstanceofExpr"
                id="prod-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-InstanceofExpr">InstanceofExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-TreatExpr">TreatExpr</a> (
                &lt;"instance" "of"&gt; <a
                href="#prod-SequenceType">SequenceType</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-TreatExpr"
                id="prod-TreatExpr"></a>[25]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-TreatExpr">TreatExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-CastableExpr">CastableExpr</a> (
                &lt;"treat" "as"&gt; <a
                href="#prod-SequenceType">SequenceType</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-CastableExpr"
                id="prod-CastableExpr"></a>[26]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-CastableExpr">CastableExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-CastExpr">CastExpr</a> (
                &lt;"castable" "as"&gt; <a
                href="#prod-SingleType">SingleType</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-CastExpr"
                id="prod-CastExpr"></a>[27]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-CastExpr">CastExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-ComparisonExpr">ComparisonExpr</a> (
                &lt;"cast" "as"&gt; <a
                href="#prod-SingleType">SingleType</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ComparisonExpr"
                id="prod-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ComparisonExpr">ComparisonExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-RangeExpr">RangeExpr</a> (
                (<a href="#prod-ValueComp">ValueComp</a><br />
                | <a href="#prod-GeneralComp">GeneralComp</a><br />
                | <a href="#prod-NodeComp">NodeComp</a><br />
                | <a href="#prod-OrderComp">OrderComp</a>) <a
                href="#prod-RangeExpr">RangeExpr</a> )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-RangeExpr"
                id="prod-RangeExpr"></a>[29]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-RangeExpr">RangeExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-AdditiveExpr">AdditiveExpr</a> ( "to"
                <a href="#prod-AdditiveExpr">AdditiveExpr</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AdditiveExpr"
                id="prod-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AdditiveExpr">AdditiveExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-MultiplicativeExpr">MultiplicativeExpr</a>
                ( ("+" | "-") <a
                href="#prod-MultiplicativeExpr">MultiplicativeExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-MultiplicativeExpr"
                id="prod-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-MultiplicativeExpr">MultiplicativeExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-UnaryExpr">UnaryExpr</a> (
                ("*" | "div" | "idiv" | "mod") <a
                href="#prod-UnaryExpr">UnaryExpr</a> )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-UnaryExpr"
                id="prod-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-UnaryExpr">UnaryExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("-" | "+")* <a
                href="#prod-UnionExpr">UnionExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-UnionExpr"
                id="prod-UnionExpr"></a>[33]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-UnionExpr">UnionExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-IntersectExceptExpr">IntersectExceptExpr</a>
                ( ("union" | "|") <a
                href="#prod-IntersectExceptExpr">IntersectExceptExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-IntersectExceptExpr"
                id="prod-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-IntersectExceptExpr">IntersectExceptExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-ValueExpr">ValueExpr</a> (
                ("intersect" | "except") <a
                href="#prod-ValueExpr">ValueExpr</a> )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ValueExpr"
                id="prod-ValueExpr"></a>[35]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ValueExpr">ValueExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-PathExpr">PathExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-PathExpr"
                id="prod-PathExpr"></a>[36]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-PathExpr">PathExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("/" <a
                href="#prod-RelativePathExpr">RelativePathExpr</a>?)<br />

                | ("//" <a
                href="#prod-RelativePathExpr">RelativePathExpr</a>)<br />

                | <a
                href="#prod-RelativePathExpr">RelativePathExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-RelativePathExpr"
                id="prod-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-RelativePathExpr">RelativePathExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-StepExpr">StepExpr</a>
                (("/" | "//") <a
                href="#prod-StepExpr">StepExpr</a>)*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-StepExpr"
                id="prod-StepExpr"></a>[38]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-StepExpr">StepExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-AxisStep">AxisStep</a> |
                <a
                href="#prod-FilterStep">FilterStep</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AxisStep"
                id="prod-AxisStep"></a>[39]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AxisStep">AxisStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a
                href="#prod-ForwardStep">ForwardStep</a> | <a
                href="#prod-ReverseStep">ReverseStep</a>) <a
                href="#prod-Predicates">Predicates</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-FilterStep"
                id="prod-FilterStep"></a>[40]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-FilterStep">FilterStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-PrimaryExpr">PrimaryExpr</a> <a
                href="#prod-Predicates">Predicates</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-PrimaryExpr"
                id="prod-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-PrimaryExpr">PrimaryExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-Literal">Literal</a> | <a
                href="#prod-FunctionCall">FunctionCall</a> | ("$"
                <a href="#prod-VarName">VarName</a>) | <a
                href="#prod-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Predicates"
                id="prod-Predicates"></a>[42]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-Predicates">Predicates</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("[" <a href="#prod-Expr">Expr</a>
                "]")*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-GeneralComp"
                id="prod-GeneralComp"></a>[43]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-GeneralComp">GeneralComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
                "&gt;="</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ValueComp"
                id="prod-ValueComp"></a>[44]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ValueComp">ValueComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"eq" | "ne" | "lt" | "le" | "gt" |
                "ge"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NodeComp"
                id="prod-NodeComp"></a>[45]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-NodeComp">NodeComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"is" | "isnot"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-OrderComp"
                id="prod-OrderComp"></a>[46]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-OrderComp">OrderComp</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"&lt;&lt;" | "&gt;&gt;"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ForwardStep"
                id="prod-ForwardStep"></a>[47]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ForwardStep">ForwardStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a
                href="#prod-ForwardAxis">ForwardAxis</a> <a
                href="#prod-NodeTest">NodeTest</a>) | <a
                href="#prod-AbbreviatedForwardStep">AbbreviatedForwardStep</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ReverseStep"
                id="prod-ReverseStep"></a>[48]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ReverseStep">ReverseStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a
                href="#prod-ReverseAxis">ReverseAxis</a> <a
                href="#prod-NodeTest">NodeTest</a>) | <a
                href="#prod-AbbreviatedReverseStep">AbbreviatedReverseStep</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AbbreviatedForwardStep"
                id="prod-AbbreviatedForwardStep"></a>[49]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AbbreviatedForwardStep">AbbreviatedForwardStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"." | ("@" <a
                href="#prod-NameTest">NameTest</a>) | <a
                href="#prod-NodeTest">NodeTest</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AbbreviatedReverseStep"
                id="prod-AbbreviatedReverseStep"></a>[50]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AbbreviatedReverseStep">AbbreviatedReverseStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>".."</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ForwardAxis"
                id="prod-ForwardAxis"></a>[51]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ForwardAxis">ForwardAxis</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"child" "::"&gt;<br />
                | &lt;"descendant" "::"&gt;<br />
                | &lt;"attribute" "::"&gt;<br />
                | &lt;"self" "::"&gt;<br />
                | &lt;"descendant-or-self" "::"&gt;<br />
                | &lt;"following-sibling" "::"&gt;<br />
                | &lt;"following" "::"&gt;<br />
                | &lt;"namespace" "::"&gt;</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ReverseAxis"
                id="prod-ReverseAxis"></a>[52]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ReverseAxis">ReverseAxis</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"parent" "::"&gt;<br />
                | &lt;"ancestor" "::"&gt;<br />
                | &lt;"preceding-sibling" "::"&gt;<br />
                | &lt;"preceding" "::"&gt;<br />
                | &lt;"ancestor-or-self" "::"&gt;</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NodeTest"
                id="prod-NodeTest"></a>[53]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-NodeTest">NodeTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-KindTest">KindTest</a> |
                <a href="#prod-NameTest">NameTest</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NameTest"
                id="prod-NameTest"></a>[54]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-NameTest">NameTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> | <a
                href="#prod-Wildcard">Wildcard</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Wildcard"
                id="prod-Wildcard"></a>[55]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-Wildcard">Wildcard</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"*"<br />
                | &lt;<a href="#prod-NCName">NCName</a> ":"
                "*"&gt;<br />
                | &lt;"*" ":" <a
                href="#prod-NCName">NCName</a>&gt;</code></td>

                <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-Literal"
                id="prod-Literal"></a>[56]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-Literal">Literal</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-NumericLiteral">NumericLiteral</a> | <a
                href="#prod-StringLiteral">StringLiteral</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NumericLiteral"
                id="prod-NumericLiteral"></a>[57]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-NumericLiteral">NumericLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-IntegerLiteral">IntegerLiteral</a> | <a
                href="#prod-DecimalLiteral">DecimalLiteral</a> | <a
                href="#prod-DoubleLiteral">DoubleLiteral</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ParenthesizedExpr"
                id="prod-ParenthesizedExpr"></a>[58]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ParenthesizedExpr">ParenthesizedExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"(" <a href="#prod-Expr">Expr</a>?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-FunctionCall"
                id="prod-FunctionCall"></a>[59]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-FunctionCall">FunctionCall</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;<a href="#prod-QName">QName</a>
                "("&gt; (<a href="#prod-ExprSingle">ExprSingle</a>
                ("," <a href="#prod-ExprSingle">ExprSingle</a>)*)?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SingleType"
                id="prod-SingleType"></a>[60]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SingleType">SingleType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-AtomicType">AtomicType</a>
                "?"?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SequenceType"
                id="prod-SequenceType"></a>[61]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SequenceType">SequenceType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a href="#prod-ItemType">ItemType</a> <a
                href="#prod-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />

                | &lt;"empty" "(" ")"&gt;</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AtomicType"
                id="prod-AtomicType"></a>[62]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AtomicType">AtomicType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ItemType"
                id="prod-ItemType"></a>[63]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ItemType">ItemType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-AtomicType">AtomicType</a>
                | <a href="#prod-KindTest">KindTest</a> |
                &lt;"item" "(" ")"&gt;</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-KindTest"
                id="prod-KindTest"></a>[64]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-KindTest">KindTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-DocumentTest">DocumentTest</a><br />
                | <a href="#prod-ElementTest">ElementTest</a><br />
                | <a
                href="#prod-AttributeTest">AttributeTest</a><br />
                | <a
                href="#prod-ProcessingInstructionTest">ProcessingInstructionTest</a><br />

                | <a href="#prod-CommentTest">CommentTest</a><br />
                | <a href="#prod-TextTest">TextTest</a><br />
                | <a
                href="#prod-AnyKindTest">AnyKindTest</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ElementTest"
                id="prod-ElementTest"></a>[65]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ElementTest">ElementTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"element" "("&gt; ((<a
                href="#prod-SchemaContextPath">SchemaContextPath</a>
                <a href="#prod-LocalName">LocalName</a>)<br />
                | (<a href="#prod-NodeName">NodeName</a> ("," <a
                href="#prod-TypeName">TypeName</a> "nillable"?)?))?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AttributeTest"
                id="prod-AttributeTest"></a>[66]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AttributeTest">AttributeTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"attribute" "("&gt; ((<a
                href="#prod-SchemaContextPath">SchemaContextPath</a>
                "@" <a href="#prod-LocalName">LocalName</a>)<br />
                | ("@" <a href="#prod-NodeName">NodeName</a> (","
                <a href="#prod-TypeName">TypeName</a>)?))?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-ProcessingInstructionTest"
                id="prod-ProcessingInstructionTest"></a>[67]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-ProcessingInstructionTest">ProcessingInstructionTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"processing-instruction" "("&gt; <a
                href="#prod-StringLiteral">StringLiteral</a>?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-DocumentTest"
                id="prod-DocumentTest"></a>[68]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-DocumentTest">DocumentTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"document-node" "("&gt; <a
                href="#prod-ElementTest">ElementTest</a>?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-CommentTest"
                id="prod-CommentTest"></a>[69]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-CommentTest">CommentTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"comment" "("&gt; ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-TextTest"
                id="prod-TextTest"></a>[70]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-TextTest">TextTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"text" "("&gt; ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-AnyKindTest"
                id="prod-AnyKindTest"></a>[71]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-AnyKindTest">AnyKindTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;"node" "("&gt; ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-SchemaContextPath"
                id="prod-SchemaContextPath"></a>[72]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-SchemaContextPath">SchemaContextPath</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>&lt;<a
                href="#prod-SchemaGlobalContext">SchemaGlobalContext</a>
                "/"&gt; &lt;<a
                href="#prod-SchemaContextStep">SchemaContextStep</a>
                "/"&gt;*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-LocalName"
                id="prod-LocalName"></a>[73]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-LocalName">LocalName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a
                href="#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-NodeName"
                id="prod-NodeName"></a>[74]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-NodeName">NodeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> |
                "*"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-TypeName"
                id="prod-TypeName"></a>[75]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-TypeName">TypeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> |
                "*"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a name="prod-OccurrenceIndicator"
                id="prod-OccurrenceIndicator"></a>[76]&#160;&#160;&#160;</td>

                <td><code><a
                href="#doc-OccurrenceIndicator">OccurrenceIndicator</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"?" | "*" | "+"</code></td>
              </tr>
            </tbody>
          </table>

          <div class="div3">
            <h4><a name="notes-on-parsing"
            id="notes-on-parsing"></a>A.1.1 Parsing Notes</h4>

            <ol class="enum1">
              <li>
                <p id="parse-note-parens">A look-ahead of one
                character is required to distinguish function
                patterns from a QName followed by a comment. For
                example:<code>address (: this may be empty
                :)</code> may be mistaken for a call to a function
                named "address" unless this lookahead is
                employed.</p>
              </li>

              <li>
                <p id="parse-note-lt">Token disambiguation of the
                overloaded "&lt;" pattern is defined in terms of
                positional <a href="#lexical-structure">lexical
                states</a>. The "&lt;" comparison operator can not
                occur in the same places as a "&lt;" tag open
                pattern. The "&lt;" comparison operator can only
                occur in the <a href="#OPERATOR">OPERATOR</a>
                state, and the "&lt;" tag open pattern can only
                occur in the <a href="#DEFAULT">DEFAULT</a> 
                state. (These states are only a specification
                tool, and do not imply an implementation strategy
                for this same effect.)</p>
              </li>
            </ol>
          </div>
        </div>

        <div class="div2">
          <h3><a name="lexical-structure"
          id="lexical-structure"></a>A.2 Lexical structure</h3>

          <p>Legal characters are those allowed in the <a
          href="#XML">[XML]</a> recommendation.</p>

          <p>When patterns are simple string matches, the strings
          are embedded directly into the EBNF. In other cases,
          named terminals are used.</p>

          <p>It is up to an implementation to decide on the exact
          tokenization strategy, which may be different depending
          on the parser construction. In the EBNF, the notation
          "&lt; ... &gt;" is used to indicate a grouping of
          terminals that together may help disambiguate the
          individual symbols.</p>

          <p>This document uses <b>lexical states</b> to assist
          with terminal symbol recognition. The states specify
          lexical constraints and transitions based on grammatical
          positioning. The rules for calculating these states are
          given in the <a href="#id-lexical-states"><b>A.2.2
          Lexical Rules</b></a> section. The specification of these
          states in this document does not imply any tokenization
          strategy on the part of implementations.</p>

          <p>When tokenizing, the longest possible match that is
          valid in the current lexical state is prefered .</p>

          <p>All keywords are case sensitive.</p>

          <div class="div3">
            <h4><a name="whitespace-rules"
            id="whitespace-rules"></a>A.2.1 Whitespace Rules</h4>

            <p>For readability, Whitespace 
            may be used in most expressions even though not
            explicitly notated in the EBNF. Whitespace may be
            freely added between terminals, except a few cases
            where whitespace is needed to disambiguate the token.
            For instance, in XML, "-" is a valid character in an
            element or attribute name. When used as an operator
            after the characters of a name, it must be separated
            from the name, e.g. by using whitespace or
            parentheses.</p>

            <p>Special whitespace notation is specified with the
            EBNF productions, when it is different from the default
            rules, as follows.</p>

            <dl>
              <dt class="label"><a name="ws-explicit"
              id="ws-explicit"></a>Whitespace: explicit</dt>

              <dd>
                <p>"ws: explicit" means that the EBNF notation must
                explicitly notate where whitespace is allowed,
                otherwise whitespace may not be freely used.</p>
              </dd>

              <dt class="label"><a name="ws-significant"
              id="ws-significant"></a>Whitespace: significant</dt>

              <dd>
                <p>"ws: significant" means that whitespace is
                significant as value content.</p>
              </dd>
            </dl>
          </div>

          <div class="div3">
            <h4><a name="id-lexical-states"
            id="id-lexical-states"></a>A.2.2 Lexical Rules</h4>

            <table border="1" summary="Editorial note">
              <tr>
                <td align="left" valign="top" width="50%">
                <b>Editorial note</b></td>

                <td align="right" valign="top" width="50%">
                &#160;</td>
              </tr>

              <tr>
                <td colspan="2" align="left" valign="top">The role
                of these states as normative parts of the
                specification is being investigated. One proposal
                suggests that only of subset of these states need
                be normative.</td>
              </tr>
            </table>

            <p>The lexical contexts and transitions between lexical
            contexts is described in terms of a series of states
            and transitions between those states.</p>

            <p>The tables below define the complete lexical rules
            for XPath. Each table corresponds to a lexical state in
            which the tokens listed are recognized only in that
            state. When a given token is recognized in the given
            state, the transition to the next state is given. In
            some cases, a transition will "push" the current state
            or a specific state onto an abstract stack, and will
            later restore that state by a "pop" when another
            lexical event occurs.</p>

            <p>The lexical states have in many cases close
            connection to the parser productions. However, just
            because a token is recognized in a certain lexical
            state, does not mean it will be legal in the parser
            state.</p>

            <dl>
              <dt class="label"><a name="DEFAULT"
              id="DEFAULT"></a>The DEFAULT State</dt>

              <dd>
                <p>This state is for patterns that occur at the
                beginning of an expression or subexpression.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1"><a
                      href="#prod-DecimalLiteral">DecimalLiteral</a>,
                      "..", ".", <a
                      href="#prod-DoubleLiteral">DoubleLiteral</a>,
                      <a
                      href="#prod-IntegerLiteral">IntegerLiteral</a>,
                      &lt;<a href="#prod-NCName">NCName</a> ":"
                      "*"&gt;, "]", ")", &lt;"*" ":" <a
                      href="#prod-NCName">NCName</a>&gt;, "*", <a
                      href="#prod-StringLiteral">StringLiteral</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"$", &lt;"for"
                      "$"&gt;, &lt;"some" "$"&gt;, &lt;"every"
                      "$"&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              VARNAME</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">&lt;"element"
                      "("&gt;, &lt;"attribute" "("&gt;,
                      &lt;"comment" "("&gt;, &lt;"text" "("&gt;,
                      &lt;"node" "("&gt;,
                      &lt;"processing-instruction" "("&gt;,
                      &lt;"document-node" "("&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              KINDTEST</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState(OPERATOR)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">OfType</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              QNAME</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">Rbrace</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              popState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">
                      LbraceExprEnclosure, "@",
                      &lt;"ancestor-or-self" "::"&gt;,
                      &lt;"ancestor" "::"&gt;, &lt;"attribute"
                      "::"&gt;, &lt;"child" "::"&gt;,
                      &lt;"descendant-or-self" "::"&gt;,
                      &lt;"descendant" "::"&gt;,
                      &lt;"following-sibling" "::"&gt;,
                      &lt;"following" "::"&gt;, &lt;"namespace"
                      "::"&gt;, &lt;"parent" "::"&gt;,
                      &lt;"preceding-sibling" "::"&gt;,
                      &lt;"preceding" "::"&gt;, &lt;"self"
                      "::"&gt;, ",", &lt;"if" "("&gt;, "[", "(",
                      "-", "+", QMark, &lt;<a
                      href="#prod-QName">QName</a> "("&gt;, "//",
                      "/"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="OPERATOR"
              id="OPERATOR"></a>The OPERATOR State</dt>

              <dd>
                <p>This state is for patterns that are defined for
                operators.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">"and", ",",
                      "div", "else", "=", "except", "eq", "ge",
                      "gt", "le", "lt", "ne", "&gt;=", "&gt;&gt;",
                      "&gt;", "idiv", Global, "intersect", "in",
                      "isnot", "is", "[", "(", "&lt;=", "&lt;&lt;",
                      "&lt;", "-", "mod", "*", "!=", "or", "+",
                      QMark, "return", "satisfies", "//", "/",
                      "then", "to", "union", "|",
                      LbraceExprEnclosure</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              DEFAULT</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">&lt;"instance"
                      "of"&gt;, &lt;"castable" "as"&gt;, &lt;"cast"
                      "as"&gt;, &lt;"treat" "as"&gt;,
                      InContext</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              ITEMTYPE</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">OfType</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              QNAME</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">Rbrace</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              popState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"$", &lt;"for"
                      "$"&gt;, &lt;"some" "$"&gt;, &lt;"every"
                      "$"&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              VARNAME</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"]", <a
                      href="#prod-IntegerLiteral">IntegerLiteral</a>,
                      <a
                      href="#prod-DecimalLiteral">DecimalLiteral</a>,
                      <a
                      href="#prod-DoubleLiteral">DoubleLiteral</a>,
                      ")", <a
                      href="#prod-StringLiteral">StringLiteral</a>,
                      &lt;<a href="#prod-NCName">NCName</a> ":"
                      "*"&gt;, &lt;"*" ":" <a
                      href="#prod-NCName">NCName</a>&gt;, ".",
                      ".."</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="QNAME" id="QNAME"></a>The
              QNAME State</dt>

              <dd>
                <p>When a qualified name is expected, and it is
                required to remove ambiguity from patterns that
                look like functions, this state is used.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">&lt;<a
                      href="#prod-NCName">NCName</a> ":" "*"&gt;,
                      &lt;"*" ":" <a
                      href="#prod-NCName">NCName</a>&gt;, ".",
                      ".."</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="ITEMTYPE"
              id="ITEMTYPE"></a>The ITEMTYPE State</dt>

              <dd>
                <p>This state distinguishes tokens that can occur
                only inside the ItemType production.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">"$"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              VARNAME</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">&lt;"empty" "("
                      ")"&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">&lt;"element"
                      "("&gt;, &lt;"attribute" "("&gt;,
                      &lt;"comment" "("&gt;, &lt;"text" "("&gt;,
                      &lt;"node" "("&gt;,
                      &lt;"processing-instruction" "("&gt;,
                      &lt;"document-node" "("&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              KINDTEST</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState(OCCURRENCEINDICATOR)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1"><a
                      href="#prod-QName">QName</a>, &lt;"item" "("
                      ")"&gt;</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OCCURRENCEINDICATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="KINDTEST"
              id="KINDTEST"></a>The KINDTEST State</dt>

              <dd>
                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">
                      LbraceExprEnclosure</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              DEFAULT</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">&lt;<a
                      href="#prod-SchemaGlobalContext">SchemaGlobalContext</a>
                      "/"&gt;, <a
                      href="#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              SCHEMACONTEXTSTEP</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">")"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              popState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"*", <a
                      href="#prod-QName">QName</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              CLOSEKINDTEST</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"@",
                      InContextForKindTest, Global, <a
                      href="#prod-StringLiteral">StringLiteral</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="CLOSEKINDTEST"
              id="CLOSEKINDTEST"></a>The CLOSEKINDTEST State</dt>

              <dd>
                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">")"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              popState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">","</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              KINDTEST</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">
                      LbraceExprEnclosure</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              DEFAULT</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"nillable"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="OCCURRENCEINDICATOR"
              id="OCCURRENCEINDICATOR"></a>The OCCURRENCEINDICATOR
              State</dt>

              <dd>
                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">
                      NotOccurrenceIndicator</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              input_stream.backup(1)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"?", "*",
                      "+"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="SCHEMACONTEXTSTEP"
              id="SCHEMACONTEXTSTEP"></a>The SCHEMACONTEXTSTEP
              State</dt>

              <dd>
                <p>This state distinguishes the SchemaContextStep
                from the SchemaGlobalContext.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">&lt;<a
                      href="#prod-SchemaContextStep">SchemaContextStep</a>
                      "/"&gt;, "@"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">
                      LbraceExprEnclosure</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              DEFAULT</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1"><a
                      href="#prod-QName">QName</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              CLOSEKINDTEST</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="VARNAME"
              id="VARNAME"></a>The VARNAME State</dt>

              <dd>
                <p>This state differentiates variable names from
                qualified names. This allows only the pattern of a
                QName to be recognized when otherwise ambiguities
                could occur.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1"><a
                      href="#prod-VarName">VarName</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              OPERATOR</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>

              <dt class="label"><a name="EXPR_COMMENT"
              id="EXPR_COMMENT"></a>The EXPR_COMMENT State</dt>

              <dd>
                <p>The "(:" token marks the beginning of an
                expression Comment, and the ":)" token marks the
                end. This allows no special interpretation of other
                characters in this state.</p>

                <table border="1" summary="Transition table">
                  <thead>
                    <tr>
                      <th rowspan="1" colspan="1">Pattern</th>

                      <th rowspan="1" colspan="1">Transition To
                      State</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td rowspan="1" colspan="1">":)"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              popState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1">"(:"</td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">
                              EXPR_COMMENT</td>
                            </tr>

                            <tr>
                              <td rowspan="1" colspan="1">
                              pushState()</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>

                    <tr>
                      <td rowspan="1" colspan="1"><a
                      href="#prod-ExprCommentContent">ExprCommentContent</a></td>

                      <td rowspan="1" colspan="1">
                        <table summary="Transition table">
                          <tbody>
                            <tr>
                              <td rowspan="1" colspan="1">(maintain
                              state)</td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <br />
              </dd>
            </dl>
          </div>
        </div>

        <div class="div2">
          <h3><a name="d0e8260" id="d0e8260"></a>A.3 Reserved
          Function Names</h3>

          <p>The following is a list of names that may not be used
          as user function names, in an unprefixed form.</p>

          <ul>
            <li>
              <p><code>if</code></p>
            </li>

            <li>
              <p><code>typeswitch</code></p>
            </li>

            <li>
              <p><code>node</code></p>
            </li>

            <li>
              <p><code>comment</code></p>
            </li>

            <li>
              <p><code>text</code></p>
            </li>

            <li>
              <p><code>processing-instruction</code></p>
            </li>
          </ul>
        </div>

        <div class="div2">
          <h3><a name="id-precedence-order"
          id="id-precedence-order"></a>A.4 Precedence Order</h3>

          <p>In all cases the grammar defines built-in precedence.
          In the cases where a number of statements are a choice at
          the same production level, the expressions are always
          evaluated from left to right.</p>
        </div>
      </div>

      <div class="div1">
        <h2><a name="d0e8295" id="d0e8295"></a>B Type Promotion and
        Operator Mapping</h2>

        <div class="div2">
          <h3><a name="promotion" id="promotion"></a>B.1 Type
          Promotion</h3>

          <p>Under certain circumstances, an atomic value can be
          promoted from one type to another. <b>Type promotion</b>
          is used in function calls (see <a
          href="#id-function-calls"><b>3.1.4 Function
          Calls</b></a>) and in processing of operators that accept
          <b>numeric</b> operands (listed in the tables below). The
          following type promotions are permitted:</p>

          <ol class="enum1">
            <li>
              <p>A value of type <code>xs:float</code> (or any type
              derived by restriction from <code>xs:float</code>)
              can be promoted to the type <code>xs:double</code>.
              The result is the <code>xs:double</code> value that
              is the same as the original value. This kind of
              promotion may cause loss of precision.</p>
            </li>

            <li>
              <p>A value of type <code>xs:decimal</code> (or any
              type derived by restriction from
              <code>xs:decimal</code>) can be promoted to either of
              the types <code>xs:float</code> or
              <code>xs:double</code>. The result is the value of
              the target type that is closest to the original
              value.</p>
            </li>
          </ol>

          <p>Note that <b>promotion</b> is different from
          <b>subtype substitution</b>. For example:</p>

          <ul>
            <li>
              <p>A function that expects a parameter
              <code>$p</code> of type <code>xs:float</code> can be
              invoked with a value of type <code>xs:decimal</code>.
              This is an example of <b>promotion</b>. The value is
              actually converted to the expected type. Within the
              body of the function, <code>$p instance of
              xs:decimal</code> returns <code>false</code>.</p>
            </li>

            <li>
              <p>A function that expects a parameter
              <code>$p</code> of type <code>xs:decimal</code> can
              be invoked with a value of type
              <code>xs:integer</code>. This is an example of
              <b>subtype substitution</b>. The value retains its
              original type. Within the body of the function,
              <code>$p instance of xs:integer</code> returns
              <code>true</code>.</p>
            </li>
          </ul>
        </div>

        <div class="div2">
          <h3><a name="mapping" id="mapping"></a>B.2 Operator
          Mapping</h3>

          <p>The tables in this section list the combinations of
          types for which the various operators of XPath are
          defined. For each valid combination of types, the table
          indicates the function(s) that are used to implement the
          operator and the type of the result. Definitions of the
          functions can be found in <a
          href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
          Functions and Operators]</a>. Note that in some cases the
          function does not implement the full semantics of the
          given operator. For a complete description of each
          operator (including its behavior for empty sequences or
          sequences of length greater than one), see the
          descriptive material in the main part of this
          document.</p>

          <p>Operators listed in the tables may be validly applied
          to operands whose types are derived by restriction from
          the listed operand types. For example, a table entry
          indicates that the <code>gt</code> operator may be
          applied to two <code>xs:date</code> operands, returning
          <code>xs:boolean</code>. Therefore, the <code>gt</code>
          operator may also be applied to two (possibly different)
          subtypes of <code>xs:date</code>, also returning
          <code>xs:boolean</code>.</p>

          <p>In the operator tables, the term <b>numeric</b> refers
          to the types <code>xs:integer</code>,
          <code>xs:decimal</code>, <code>xs:float</code>, and
          <code>xs:double</code>. An operator whose operands and
          result are designated as <b>numeric</b> might be thought
          of as representing four operators, one for each of the
          numeric types. For example, the numeric <code>+</code>
          operator might be thought of as representing the
          following four operators:</p>

          <table width="80%" border="1" summary="Operators">
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                Operator</td>

                <td align="center" rowspan="1" colspan="1">First
                operand type</td>

                <td align="center" rowspan="1" colspan="1">Second
                operand type</td>

                <td align="center" rowspan="1" colspan="1">Result
                type</td>
              </tr>

              <tr>
                <td align="center" rowspan="1" colspan="1">
                <code>+</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code></td>
              </tr>

              <tr>
                <td align="center" rowspan="1" colspan="1">
                <code>+</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code></td>
              </tr>

              <tr>
                <td align="center" rowspan="1" colspan="1">
                <code>+</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code></td>
              </tr>

              <tr>
                <td align="center" rowspan="1" colspan="1">
                <code>+</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code></td>

                <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code></td>
              </tr>
            </tbody>
          </table>

          <p>A numeric operator accepts operands of the four
          numeric types and any type that is derived by restriction
          from one of the four numeric types. If the result type of
          an operator is listed as numeric, it means "the first
          numeric type, in promotion order, into which all operands
          can be converted by subtype substitution and promotion."
          As an example, suppose that the type <code>hatsize</code>
          is derived from <code>xs:integer</code> and the type
          <code>shoesize</code> is derived from
          <code>xs:float</code>. Then if the <code>+</code>
          operator is invoked with operands of type
          <code>hatsize</code> and <code>shoesize</code>, it
          returns a result of type <code>xs:float</code>.
          Similarly, if <code>+</code> is invoked with two operands
          of type <code>hatsize</code> it returns a result of type
          <code>xs:integer</code>.</p>

          <p>In the following tables, the term <b>Gregorian</b>
          refers to the types <code>xs:gYearMonth</code>,
          <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
          <code>xs:gDay</code>, and <code>xs:gMonth</code>. For
          binary operators that accept two Gregorian-type operands,
          both operands must have the same type (for example, if
          one operand is of type <code>xs:gDay</code>, the other
          operand must be of type <code>xs:gDay</code>.)</p>

          <div class="small">
            <table border="1" summary="Binary operators"
            class="small">
              <caption>
                Binary Operators
              </caption>

              <tbody>
                <tr>
                  <th rowspan="1" colspan="1">Operator</th>

                  <th rowspan="1" colspan="1">Type(A)</th>

                  <th rowspan="1" colspan="1">Type(B)</th>

                  <th rowspan="1" colspan="1">Function</th>

                  <th rowspan="1" colspan="1">Result type</th>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">op:numeric-add(A,
                  B)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-yearMonthDuration-to-date(A, B)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  op:add-yearMonthDuration-to-date(B, A)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-date(A, B)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-date(B, A)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-time(A, B)</td>

                  <td rowspan="1" colspan="1">xs:time</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-time(B, A)</td>

                  <td rowspan="1" colspan="1">xs:time</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-yearMonthDuration-to-dateTime(A, B)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  op:add-yearMonthDuration-to-dateTime(B, A)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-dateTime(A, B)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDuration-to-dateTime(B, A)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-yearMonthDurations(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A + B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:add-dayTimeDurations(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-subtract(A, B)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">op:subtract-dates(A,
                  B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-yearMonthDuration-from-date(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-dayTimeDuration-from-date(A, B)</td>

                  <td rowspan="1" colspan="1">xs:date</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">op:subtract-times(A,
                  B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-dayTimeDuration-from-time(A, B)</td>

                  <td rowspan="1" colspan="1">xs:time</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  fn:subtract-dateTimes-yielding-dayTimeDuration(A,
                  B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-yearMonthDuration-from-dateTime(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">xs:datetime</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-dayTimeDuration-from-dateTime(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-yearMonthDurations(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A - B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:subtract-dayTimeDurations(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A * B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-multiply(A, B)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A * B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  op:multiply-yearMonthDuration(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A * B</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:multiply-yearMonthDuration(B, A)</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A * B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  op:multiply-dayTimeDuration(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A * B</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:multiply-dayTimeDuration(B, A)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A idiv B</td>

                  <td rowspan="1" colspan="1">xs:integer</td>

                  <td rowspan="1" colspan="1">xs:integer</td>

                  <td rowspan="1" colspan="1">op:integer-div(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:integer</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A div B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">op:numeric-divide(A,
                  B)</td>

                  <td rowspan="1" colspan="1">numeric; but
                  xs:decimal if both operands are xs:integer</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A div B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  op:divide-yearMonthDuration(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A div B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">xs:decimal</td>

                  <td rowspan="1" colspan="1">
                  op:divide-dayTimeDuration(A, B)</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A mod B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">op:numeric-mod(A,
                  B)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">op:numeric-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">op:boolean-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-equal(fn:compare(A, B), 1)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">op:date-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">op:time-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">op:datetime-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:yearMonthDuration-equal(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:dayTimeDuration-equal(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">Gregorian</td>

                  <td rowspan="1" colspan="1">Gregorian</td>

                  <td rowspan="1" colspan="1">op:gYear-equal(A, B)
                  etc.</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:hexBinary</td>

                  <td rowspan="1" colspan="1">xs:hexBinary</td>

                  <td rowspan="1" colspan="1">
                  op:hex-binary-equal(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:base64Binary</td>

                  <td rowspan="1" colspan="1">xs:base64Binary</td>

                  <td rowspan="1" colspan="1">
                  op:base64-binary-equal(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:anyURI</td>

                  <td rowspan="1" colspan="1">xs:anyURI</td>

                  <td rowspan="1" colspan="1">op:anyURI-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:QName</td>

                  <td rowspan="1" colspan="1">xs:QName</td>

                  <td rowspan="1" colspan="1">op:QName-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A eq B</td>

                  <td rowspan="1" colspan="1">xs:NOTATION</td>

                  <td rowspan="1" colspan="1">xs:NOTATION</td>

                  <td rowspan="1" colspan="1">op:NOTATION-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:numeric-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:boolean-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:numeric-equal(fn:compare(A, B),
                  1))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:date-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:time-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:datetime-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:yearMonthDuration-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:dayTimeDuration-equal(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">Gregorian</td>

                  <td rowspan="1" colspan="1">Gregorian</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:gYear-equal(A, B)) etc.</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:hexBinary</td>

                  <td rowspan="1" colspan="1">xs:hexBinary</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:hex-binary-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:base64Binary</td>

                  <td rowspan="1" colspan="1">xs:base64Binary</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:base64-binary-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:anyURI</td>

                  <td rowspan="1" colspan="1">xs:anyURI</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:anyURI-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:QName</td>

                  <td rowspan="1" colspan="1">xs:QName</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:QName-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ne B</td>

                  <td rowspan="1" colspan="1">xs:NOTATION</td>

                  <td rowspan="1" colspan="1">xs:NOTATION</td>

                  <td rowspan="1" colspan="1">
                  xs:not(op:NOTATION-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">
                  op:boolean-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-greater-than(fn:compare(A, B), 0)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  op:date-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  op:time-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">
                  op:datetime-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:yearMonthDuration-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A gt B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:dayTimeDuration-greater-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-less-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>

                  <td rowspan="1" colspan="1">
                  op:boolean-less-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-less-than(fn:compare(A, B), 0)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">op:date-less-than(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">op:time-less-than(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">
                  op:datetime-less-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  op:yearMonthDuration-less-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A lt B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  op:dayTimeDuration-less-than(A, B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:numeric-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-greater-than(fn:compare(A, B),
                  -1)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:date-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:time-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:datetime-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:yearMonthDuration-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A ge B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:dayTimeDuration-less-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:numeric-greater-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">xs:string</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-less-than(fn:compare(A, B), 1)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">xs:date</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:date-greater-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">xs:time</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:time-greater-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">xs:dateTime</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:datetime-greater-than(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:yearMonthDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:yearMonthDuration-greater-than(A,
                  B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A le B</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  xdt:dayTimeDuration</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:dayTimeDuration-greater-than(A,
                  B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A is B</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">op:node-equal(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A isnot B</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">
                  fn:not(op:node-equal(A, B))</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A &lt;&lt; B</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">op:node-before(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A &gt;&gt; B</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">node</td>

                  <td rowspan="1" colspan="1">op:node-after(A,
                  B)</td>

                  <td rowspan="1" colspan="1">xs:boolean</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A union B</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">op:union(A, B)</td>

                  <td rowspan="1" colspan="1">node*</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A | B</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">op:union(A, B)</td>

                  <td rowspan="1" colspan="1">node*</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A intersect B</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">op:intersect(A,
                  B)</td>

                  <td rowspan="1" colspan="1">node*</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A except B</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">node*</td>

                  <td rowspan="1" colspan="1">op:except(A, B)</td>

                  <td rowspan="1" colspan="1">node*</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A to B</td>

                  <td rowspan="1" colspan="1">xs:integer</td>

                  <td rowspan="1" colspan="1">xs:integer</td>

                  <td rowspan="1" colspan="1">op:to(A, B)</td>

                  <td rowspan="1" colspan="1">xs:integer+</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">A , B</td>

                  <td rowspan="1" colspan="1">item*</td>

                  <td rowspan="1" colspan="1">item*</td>

                  <td rowspan="1" colspan="1">op:concatenate(A,
                  B)</td>

                  <td rowspan="1" colspan="1">item*</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="small">
            <table border="1" summary="Unary operators"
            class="small">
              <caption>
                Unary Operators
              </caption>

              <tbody>
                <tr>
                  <th rowspan="1" colspan="1">Operator</th>

                  <th rowspan="1" colspan="1">Operand type</th>

                  <th rowspan="1" colspan="1">Function</th>

                  <th rowspan="1" colspan="1">Result type</th>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">+ A</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-unary-plus(A)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">- A</td>

                  <td rowspan="1" colspan="1">numeric</td>

                  <td rowspan="1" colspan="1">
                  op:numeric-unary-minus(A)</td>

                  <td rowspan="1" colspan="1">numeric</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="div1">
        <h2><a name="id-references" id="id-references"></a>C
        References</h2>

        <div class="div2">
          <h3><a name="id-normative-references"
          id="id-normative-references"></a>C.1 Normative
          References</h3>

          <dl>
            <dt class="label"><a name="FunctionsAndOperators"
            id="FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0
            Functions and Operators</dt>

            <dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath
            2.0 Functions and Operators</em> W3C Working Draft, 15
            November 2002. See <a
            href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a></dd>

            <dt class="label"><a name="XQueryFormalSemantics"
            id="XQueryFormalSemantics"></a>XQuery 1.0 Formal
            Semantics</dt>

            <dd>World Wide Web Consortium. <em>XQuery 1.0 Formal
            Semantics</em>. W3C Working Draft, 2 May 2003. See <a
            href="http://www.w3.org/TR/query-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>

            <dt class="label"><a name="XMLSchema"
            id="XMLSchema"></a>XML Schema</dt>

            <dd>World Wide Web Consortium. <em>XML Schema, Parts 0,
            1, and 2</em>. W3C Recommendation, 2 May 2001. See <a
            href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/</a>,
            <a
            href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a>,
            and <a
            href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>.</dd>

            <dt class="label"><a name="datamodel"
            id="datamodel"></a>XQuery 1.0 and XPath 2.0 Data
            Model</dt>

            <dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath
            2.0 Data Model</em>. W3C Working Draft, 2 May 2003. See
            <a
            href="http://www.w3.org/TR/query-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>

            <dt class="label"><a name="serialization"
            id="serialization"></a>XSLT 2.0 and XQuery 1.0
            Serialization</dt>

            <dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery
            1.0 Serialization</em>. W3C Working Draft, 2 May 2003.
            See <a
            href="http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>

            <dt class="label"><a name="XML" id="XML"></a>XML</dt>

            <dd>World Wide Web Consortium. <em>Extensible Markup
            Language (XML) 1.0.</em> W3C Recommendation. See <a
            href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/2000/REC-xml-20001006</a></dd>

            <dt class="label"><a name="XMLNAMES"
            id="XMLNAMES"></a>XML Names</dt>

            <dd>World Wide Web Consortium. <em>Namespaces in
            XML.</em> W3C Recommendation. See <a
            href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>

            <dt class="label"><a name="ISO10646"
            id="ISO10646"></a>ISO/IEC 10646</dt>

            <dd>ISO (International Organization for
            Standardization). <em>ISO/IEC 10646-1993 (E).
            Information technology -- Universal Multiple-Octet
            Coded Character Set (UCS) -- Part 1: Architecture and
            Basic Multilingual Plane.</em> [Geneva]: International
            Organization for Standardization, 1993 (plus amendments
            AM 1 through AM 7).</dd>

            <dt class="label"><a name="ISO10646-2000"
            id="ISO10646-2000"></a>ISO/IEC 10646-2000</dt>

            <dd>ISO (International Organization for
            Standardization). <em>ISO/IEC 10646-1:2000. Information
            technology -- Universal Multiple-Octet Coded Character
            Set (UCS) -- Part 1: Architecture and Basic
            Multilingual Plane.</em> [Geneva]: International
            Organization for Standardization, 2000.</dd>

            <dt class="label"><a name="Unicode"
            id="Unicode"></a>Unicode</dt>

            <dd>The Unicode Consortium. <em>The Unicode Standard,
            Version 2.0.</em> Reading, Mass.: Addison-Wesley
            Developers Press, 1996.</dd>

            <dt class="label"><a name="Unicode3"
            id="Unicode3"></a>Unicode3</dt>

            <dd>The Unicode Consortium. <em>The Unicode Standard,
            Version 3.0.</em> Reading, Mass.: Addison-Wesley
            Developers Press, 2000. ISBN 0-201-61633-5.</dd>
          </dl>
        </div>

        <div class="div2">
          <h3><a name="id-non-normative-references"
          id="id-non-normative-references"></a>C.2 Non-normative
          References</h3>

          <dl>
            <dt class="label"><span class="xpath"><a
            name="XPath-Requirements"
            id="XPath-Requirements"></a>XPath 2.0
            Requirements</span></dt>

            <dd>
              <div class="xpath">
                World Wide Web Consortium. <em>XPath Requirements
                Version 2.0</em>. W3C Working Draft 14 February
                2001. See <a
                href="http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.
              </div>
            </dd>

            <dt class="label"><a name="XQueryX"
            id="XQueryX"></a>XQueryX 1.0</dt>

            <dd>
              World Wide Web Consortium. <em>XQueryX, Version
              1.0</em>. W3C Working Draft, 7 June 2001. See <a
              href="http://www.w3.org/TR/xqueryx">http://www.w3.org/TR/xqueryx</a>

              <table border="1" summary="Editorial note">
                <tr>
                  <td align="left" valign="top" width="50%">
                  <b>Editorial note</b></td>

                  <td align="right" valign="top" width="50%">
                  &#160;</td>
                </tr>

                <tr>
                  <td colspan="2" align="left" valign="top">As of
                  the date of this publication, XQueryX has not
                  incorporated recent language changes; it will be
                  made consistent with this document in its next
                  edition.</td>
                </tr>
              </table>
            </dd>

            <dt class="label"><span class="xpath"><a name="xquery"
            id="xquery"></a>XQuery</span></dt>

            <dd>
              <div class="xpath">
                World Wide Web Consortium. <em>XQuery 1.0: An XML
                Query Language</em>. W3C Working Draft, 2 May 2003.
                See <a
                href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>
              </div>
            </dd>

            <dt class="label"><a name="XSLT" id="XSLT"></a>XSLT
            2.0</dt>

            <dd>World Wide Web Consortium. <em>XSL Transformations
            (XSLT) 2.0.</em> W3C Working Draft. See <a
            href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>

            <dt class="label"><a name="ISO8601"
            id="ISO8601"></a>ISO 8601</dt>

            <dd>International Organization for Standardization
            (ISO). <em>Representations of Dates and Times,
            2000-08-03.</em> Available from <a
            href="http://www.iso.ch/">http://www.iso.ch/</a></dd>
          </dl>
        </div>

        <div class="div2">
          <h3><a name="id-background-references"
          id="id-background-references"></a>C.3 Background
          References</h3>

          <dl>
            <dt class="label"><a name="XQL" id="XQL"></a>XQL</dt>

            <dd>J. Robie, J. Lapp, D. Schach. <em>XML Query
            Language (XQL)</em>. See <a
            href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</dd>

            <dt class="label"><a name="XML-QL"
            id="XML-QL"></a>XML-QL</dt>

            <dd>Alin Deutsch, Mary Fernandez, Daniela Florescu,
            Alon Levy, and Dan Suciu. <em>A Query Language for
            XML</em>. See <a
            href="http://www.research.att.com/~mff/files/final.html">http://www.research.att.com/~mff/files/final.html</a></dd>

            <dt class="label"><a name="SQL" id="SQL"></a>SQL</dt>

            <dd>International Organization for Standardization
            (ISO). <em>Information Technology-Database Language
            SQL</em>. Standard No. ISO/IEC 9075:1999. (Available
            from American National Standards Institute, New York,
            NY 10036, (212) 642-4900.)</dd>

            <dt class="label"><a name="ODMG"
            id="ODMG"></a>ODMG</dt>

            <dd>Rick Cattell et al. <em>The Object Database
            Standard: ODMG-93, Release 1.2</em>. Morgan Kaufmann
            Publishers, San Francisco, 1996.</dd>

            <dt class="label"><a name="Lorel"
            id="Lorel"></a>Lorel</dt>

            <dd>Serge Abiteboul, Dallan Quass, Jason McHugh,
            Jennifer Widom, and Janet L. Wiener. <em>The Lorel
            Query Language for Semistructured Data. International
            Journal on Digital Libraries</em>, 1(1):68-88, April
            1997. See <a
            href="http://www-db.stanford.edu/~widom/pubs.html">"http://www-db.stanford.edu/~widom/pubs.html</a></dd>

            <dt class="label"><a name="YATL"
            id="YATL"></a>YATL</dt>

            <dd>S. Cluet, S. Jacqmin, and J. Simeon. <em>The New
            YATL: Design and Specifications</em>. Technical Report,
            INRIA, 1999.</dd>

            <dt class="label"><a name="Quilt"
            id="Quilt"></a>Quilt</dt>

            <dd>Don Chamberlin, Jonathan Robie, and Daniela
            Florescu. <em>Quilt: an XML Query Language for
            Heterogeneous Data Sources</em>. In <em>Lecture Notes
            in Computer Science</em>, Springer-Verlag, Dec. 2000.
            Also available at <a
            href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</a>.
            See also <a
            href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</a>.</dd>

            <dt class="label"><a name="XPath" id="XPath"></a>XPath
            1.0</dt>

            <dd>World Wide Web Consortium. <em>XML Path Language
            (XPath) Version 1.0</em>. W3C Recommendation, Nov. 16,
            1999. See <a
            href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
          </dl>
        </div>

        <div class="div2">
          <h3><a name="id-informative-material"
          id="id-informative-material"></a>C.4 Informative
          Material</h3>

          <dl>
            <dt class="label"><a name="RFC2396"
            id="RFC2396"></a>RFC2396</dt>

            <dd>T. Berners-Lee, R. Fielding, and L. Masinter.
            <em>Uniform Resource Identifiers (URI): Generic
            Syntax</em>. IETF RFC 2396. See <a
            href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>

            <dt class="label"><a name="CHARMOD"
            id="CHARMOD"></a>Character Model</dt>

            <dd>World Wide Web Consortium. <em>Character Model for
            the World Wide Web.</em> W3C Working Draft. See <a
            href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a></dd>

            <dt class="label"><a name="XINFO" id="XINFO"></a>XML
            Infoset</dt>

            <dd>World Wide Web Consortium. <em>XML Information
            Set.</em> W3C Recommendation 24 October 2001. See <a
            href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>

            <dt class="label"><a name="XPTR"
            id="XPTR"></a>XPointer</dt>

            <dd>World Wide Web Consortium. <em>XML Pointer Language
            (XPointer).</em> W3C Last Call Working Draft 8 January
            2001. See <a
            href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>

            <dt class="label"><a name="XSLT1" id="XSLT1"></a>XSLT
            1.0</dt>

            <dd>World Wide Web Consortium. <em>XSL Transformations
            (XSLT) 1.0.</em> W3C Recommendation. See <a
            href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
          </dl>
        </div>
      </div>

      <div class="div1">
        <h2><a name="id-glossary" id="id-glossary"></a>D
        Glossary</h2>

        <table border="1" summary="Editorial note">
          <tr>
            <td align="left" valign="top" width="50%"><b>Editorial
            note</b></td>

            <td align="right" valign="top" width="50%">&#160;</td>
          </tr>

          <tr>
            <td colspan="2" align="left" valign="top">To be
            done.</td>
          </tr>
        </table>
      </div>

      <div class="xpath">
        <div class="div1">
          <h2><a name="d0e9977" id="d0e9977"></a>E Conformance</h2>

          <p>XPath is intended primarily as a component that can be
          used by other specifications. Therefore, XPath relies on
          specifications that use it (such as <a
          href="#XPTR">[XPointer]</a> and <a href="#XSLT">[XSLT
          2.0]</a>) to specify conformance criteria for XPath in
          their respective environments. Specifications that set
          conformance criteria for their use of XPath must not
          change the syntactic or semantic definitions of XPath as
          given in this specification, except by subsetting and/or
          compatible extensions.</p>
        </div>
      </div>

      <div class="xpath">
        <div class="div1">
          <h2><a name="id-backwards-compatibility"
          id="id-backwards-compatibility"></a>F Backwards
          Compatibility with XPath 1.0 (Non-Normative)</h2>

          <p>This section provides a summary of the main areas of
          incompatibility between XPath 2.0 and <a
          href="#XPath">[XPath 1.0]</a>.</p>

          <p>The list given here assumes (a) that the source
          document is processed in the absence of a schema, and (b)
          that XPath 1.0 compatibility mode is
          <code>true</code>.</p>

          <p>In the description below, the terms <em>node-set</em>
          and <em>number</em> are used with their XPath 1.0
          meanings, that is, to describe expressions which
          according to the rules of XPath 1.0 would have generated
          a node-set or a number respecively.</p>

          <ul>
            <li>
              <p>The rules for comparing a node-set to a boolean
              have changed. In XPath 1.0, an expression such as
              <code>$nodeset=true()</code> was evaluated by
              converting the node-set to a boolean and comparing
              the result: so this expression would return true if
              <code>$nodeset</code> was non-empty. In XPath 2.0,
              this expression is handled in the same way as other
              comparisons between a sequence and a singleton: it is
              true if <code>$nodeset</code> contains at least one
              node whose typed value is <code>true</code>.</p>

              <p>This means that if <code>$nodeset</code> is empty,
              the result will be <code>false</code> regardless of
              the value of the boolean operand, and regardless of
              which operator is used. If <code>$nodeset</code> is
              non-empty, then in the absence of a schema the
              expression will usually raise a type error, caused by
              a failure when attempting to cast the untyped value
              of a node to a boolean. But if a node has the value
              "0", "1", "true", or "false", evaluation of the
              expression may succeed.</p>
            </li>

            <li>
              <p>Additional numeric types have been introduced,
              with the effect that arithmetic may now be done as an
              integer, decimal, or single-precision floating point
              calculation where previously it was always performed
              as double-precision floating point. The result of the
              <code>div</code> operator when dividing two integers
              is now a value of type decimal rather than double.
              The expression <code>10 div 0</code> raises an error
              rather than returning positive infinity.</p>
            </li>

            <li>
              <p>The rules for converting numbers to strings have
              changed. These will affect the way numbers are
              displayed in the output of a stylesheet. The output
              format depends on the data type of the result:
              floating point values, for example, will be displayed
              using scientific notation. The result of a decimal
              calculation such as <code>1.5 + 3.5</code> will be
              displayed as <code>5.0</code>, not <code>5</code> as
              previously. The general rule is that the numbers are
              converted to strings using the rules for casting to
              the type <code>xs:string</code>.</p>
            </li>

            <li>
              <p>The rules for converting strings to numbers have
              changed. A string that cannot be interpreted as a
              number now produces an error, whereas in XPath 1.0 it
              produced the value <code>NaN</code> (not a number).
              The representation of special values such as Infinity
              has been aligned with XML Schema. Strings containing
              a leading plus sign, or numbers in scientific
              notation, may now be converted to ordinary numeric
              values, whereas in XPath 1.0 they were converted to
              <code>NaN</code>.</p>
            </li>

            <li>
              <p>Many operations in XPath 2.0 produce an empty
              sequence as their result when one of the arguments or
              operands is an empty sequence. With XPath 1.0, the
              result of such an operation was typically a
              zero-length string or the numeric value
              <code>NaN</code>. Examples include the numeric
              operators and certain functions such as
              <code>substring</code>. Functions also produce an
              empty sequence when applied to an argument for which
              no other value is defined. However, for functions in
              the core such as <code>name</code>, the XPath 1.0
              behavior has been retained; for example, applying the
              <code>name</code> function to a text node produces a
              zero-length string, as it did in XPath 1.0</p>
            </li>

            <li>
              <p>In XPath 1.0, the <code>&lt;</code> and
              <code>&gt;</code> operators, when applied to two
              strings, attempted to convert both the strings to
              numbers and then made a numeric comparison between
              the results. In XPath 2.0, these operators perform a
              lexicographic comparison using the default collating
              sequence.</p>
            </li>

            <li>
              <p>In XPath 1.0, functions and operators that
              compared strings (for example, the <code>=</code>
              operator and the <code>contains</code> function)
              worked on the basis of character-by-character
              equality of Unicode codepoints, allowing Unicode
              normalization at the discretion of the implementor.
              In XPath 2.0, these comparisons are done using the
              default collating sequence. The working group may
              define mechanisms allowing codepoint comparison to be
              selected as the default collating sequence, but there
              is no such mechanism in the current draft.</p>
            </li>

            <li>
              <p>In XPath 1.0, it was defined that with an
              expression of the form <code>A and B</code>, B would
              not be evaluated if A was false. Similarly in the
              case of <code>A or B</code>, B would not be evaluated
              if A was true. This is no longer guaranteed with
              XPath 2.0: the implementation is free to evaluate the
              two operands in either order or in parallel. This
              change has been made to give more scope for
              optimization in situations where XPath expressions
              are evaluated against large data collections
              supported by indexes.</p>
            </li>

            <li>
              <p>In XPath 1.0, the expression <code>(4 =
              true())</code> is evaluated by converting the number
              4 to boolean (yielding <code>true</code>). The
              expression returns <code>true</code>. In XPath 2.0,
              running in compatibility mode, the same expression is
              evaluated by converting both operands to double
              (yielding <code>4e0 = 1e0</code>). The expression
              returns <code>false</code>.</p>
            </li>

            <li>
              <p>Consecutive comparison operators such as <code>A
              &lt; B &lt; C</code> were supported in XPath 1.0, but
              are not supported in XPath 2.0.</p>
            </li>

            <li>
              <p>Constructs such as <code>@text()</code>,
              <code>@comment()</code>, and
              <code>@processing-instruction()</code> were legal in
              XPath 1.0 (they returned an empty sequence) but have
              become illegal according the the XPath 2.0
              grammar.</p>
            </li>

            <li>
              <p>The namespace axis is deprecated in XPath 2.0.
              Implementations may support the namespace axis for
              backward compatibility with XPath 1.0, but they are
              not required to do so.</p>
            </li>

            <li>
              <p>Suppose that the context node is an element node
              derived from the following markup:
              <code>&lt;background color="red green
              blue"&gt;</code>. In XPath 1.0, the predicate
              <code>[@color="blue"]</code> would return
              <code>false</code>. In XPath 2.0, if the
              <code>color</code> attribute is defined in a schema
              or DTD to be of type <code>NMTOKENS</code>, the same
              predicate will return <code>true</code>.</p>
            </li>

            <li>
              <p>Backward compatibility issues affecting individual
              functions in the core function library are described
              in <a href="#FunctionsAndOperators">[XQuery 1.0 and
              XPath 2.0 Functions and Operators]</a>.</p>
            </li>
          </ul>
        </div>
      </div>

      <div class="div1">
        <h2><a name="id-issues" id="id-issues"></a>G XPath 2.0 and
        XQuery 1.0 Issues (Non-Normative)</h2>

        <p>Values for <b>Status</b> has the following meaning:</p>

        <p><b>resolved</b>: a decision has been finalized and the
        document updated to reflect the decision.</p>

        <p><b>decided</b>: recommendations and decision(s) has been
        made by one or more of the following: a task-force, XPath
        WG, or XQuery WG.</p>

        <p><b>draft</b>: a proposal has been developed for possible
        future inclusion in a published document.</p>

        <p><b>active</b>: issue is actively being discussed.</p>

        <p><b>unassigned</b>: discussion of issue deferred.</p>

        <p><b>subsumed</b>: issue has been subsumed by another
        issue.</p>

        <p>(parameters used: kwSort: cluster, kwFull: brief,
        kwDate: 00000000).</p>
        <hr />

        <table>
          <tr>
            <th style="text-align:left; width:5%">Num</th>

            <th style="text-align:left">Cl</th>

            <th style="text-align:left">Pr</th>

            <th style="text-align:left">Cluster</th>

            <th style="text-align:left">Status</th>

            <th style="text-align:left">Locus</th>

            <th style="text-align:left">Description</th>

            <th style="text-align:left">Responsible</th>
          </tr>

          <tr>
            <td><a href="#cdata-charref-semantics">293</a></td>

            <td>
            </td>

            <td>1</td>

            <td>
            </td>

            <td>decided</td>

            <td>xquery</td>

            <td>Cdata and CharRef Semantics</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0101">444</a></td>

            <td>
            </td>

            <td>1</td>

            <td>
            </td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Support for mixed content in the type system</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#xquery-normalized-equality">96</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>(in)equality-operators</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Normalized Equality</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#cdata-section">328</a></td>

            <td>
            </td>

            <td>1</td>

            <td>cdata section</td>

            <td>decided</td>

            <td>xquery</td>

            <td>What does CDATA section constructor construct?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#collection-always-return-same">257</a></td>

            <td>D</td>

            <td>1</td>

            <td>collections</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Does collection() always return same result?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#conformance-levels">546</a></td>

            <td>
            </td>

            <td>1</td>

            <td>conformance-levels</td>

            <td>active</td>

            <td>xpath</td>

            <td>Are there more processing model options that could
            make sense as consistent features and thus as
            conformance levels?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#element-construction-vs-streaming">286</a></td>

            <td>
            </td>

            <td>1</td>

            <td>constructor-expr</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Element Construction vs Streaming</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#element-attribute-constructor-name-type">290</a></td>

            <td>
            </td>

            <td>1</td>

            <td>constructor-expr</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Element Attribute Constructor Name Type</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#node-identity-modeling">529</a></td>

            <td>
            </td>

            <td>1</td>

            <td>constructor-expr</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Node identity in the formal semantics</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#duplicate-attribute-constructors">329</a></td>

            <td>
            </td>

            <td>1</td>

            <td>constructors</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Duplicate attribute constructors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#document-nodes-identity">258</a></td>

            <td>D</td>

            <td>2</td>

            <td>documents</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Identity of Document Nodes</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#what-is-normative">554</a></td>

            <td>
            </td>

            <td>1</td>

            <td>editorial</td>

            <td>active</td>

            <td>xpath</td>

            <td>What is the really normative text?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#dynamic-errors-reported-statically">553</a></td>

            <td>
            </td>

            <td>1</td>

            <td>errors</td>

            <td>active</td>

            <td>xpath</td>

            <td>Rules for reporting dynamic errors statically</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#element-attribute-construction-order">339</a></td>

            <td>
            </td>

            <td>2</td>

            <td>errors</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Error type for attributes constructed too late</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#errors-unique-identification">340</a></td>

            <td>
            </td>

            <td>1</td>

            <td>errors</td>

            <td>decided</td>

            <td>xpath</td>

            <td>How to identify errors?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#extension-mechanism">317</a></td>

            <td>
            </td>

            <td>1</td>

            <td>extensions</td>

            <td>decided</td>

            <td>xquery</td>

            <td>XQuery Extension Mechanisms</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#keyword-extensions">538</a></td>

            <td>
            </td>

            <td>1</td>

            <td>extensions</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Can (and should) keyword extensions be allowed in
            XQuery by equipping them with a namespace prefix?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#external-functions">272</a></td>

            <td>
            </td>

            <td>1</td>

            <td>external-functions</td>

            <td>decided</td>

            <td>xpath</td>

            <td>External Functions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#external-objests">273</a></td>

            <td>
            </td>

            <td>1</td>

            <td>external-objects</td>

            <td>decided</td>

            <td>xpath</td>

            <td>External Objects</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#module-import-fs">555</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Formal Semantics of Module Import</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#variable-definitions-fs">556</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Formal Semantics of Variable Definitions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#validation-declaration-fs">557</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Formal semantics of Validation Declaration</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-allow-PIs-comments">558</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>The content of element types should always allow
            PI's and comment node types</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#FS-support-new-sequence-type">559</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>New Sequence Type needs to be fully implemented in
            Formal Semantics</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#semantics-interfering-with-optimization">335</a></td>

            <td>
            </td>

            <td>1</td>

            <td>formal-semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>XPath/XQuery's current semantics greatly interferes
            with optimization</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#lang-inheritance">265</a></td>

            <td>
            </td>

            <td>2</td>

            <td>FTTF-xml:lang</td>

            <td>decided</td>

            <td>xpath-fulltext</td>

            <td>How do we determine the xml:lang for a node if it
            inherits xml:lang from a higher-level node?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#lang-sublanguage-support">266</a></td>

            <td>
            </td>

            <td>2</td>

            <td>FTTF-xml:lang</td>

            <td>decided</td>

            <td>xpath-fulltext</td>

            <td>Do we support the sublanguage portion of
            xml:lang?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-external-functions">124</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>functions</td>

            <td>decided</td>

            <td>xquery</td>

            <td>External Functions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-function-library">157</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>functions</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Function Libraries</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#functions-parameter-evaluation">327</a></td>

            <td>
            </td>

            <td>1</td>

            <td>functions</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Evaluate unused function parameters?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#external-function-definition">223</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>functions external</td>

            <td>decided</td>

            <td>xquery</td>

            <td>We need a way to declare external functions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0115">458</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>What is in the default context?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0156">499</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Casting and validation</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0167">510</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Is validate working on sequences?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0116">459</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Serialization</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0149">492</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Derivation by extension in XQuery</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0150">493</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Language</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>May the content of a text node be the empty
            string?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#lexical-representation-of-atomic-values">295</a></td>

            <td>
            </td>

            <td>1</td>

            <td>lexical-representation</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Lexical Representation of Atomic Values</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#xquery-module-syntax">74</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>module-semantics</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Module syntax</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-import">75</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>module-semantics</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Importing Modules</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-encoding">79</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>module-syntax</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Encoding</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#imported-schemas-used-function-signatures">537</a></td>

            <td>
            </td>

            <td>1</td>

            <td>modules</td>

            <td>decided</td>

            <td>xquery</td>

            <td>What happens to imported schemas that are used in
            function signatures?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#default-namespace-functions">228</a></td>

            <td>
            </td>

            <td>o-2</td>

            <td>namespace functions</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Should we keep the default function namespace, and
            the xf: namespace?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#namespace-definitions-and-validate">319</a></td>

            <td>
            </td>

            <td>1</td>

            <td>namespaces</td>

            <td>active</td>

            <td>xquery</td>

            <td>Namespace definitions and in-scope namespaces</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#namespaces-functions">343</a></td>

            <td>
            </td>

            <td>1</td>

            <td>namespaces</td>

            <td>active</td>

            <td>xpath</td>

            <td>Do functions in the null namespace clash with
            functions in the default namespace?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#namespace-default-affecting">247</a></td>

            <td>
            </td>

            <td>2</td>

            <td>namespaces</td>

            <td>decided</td>

            <td>xpath</td>

            <td>What does default namespace(s) affect?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#namespace-constructor">549</a></td>

            <td>
            </td>

            <td>1</td>

            <td>namespaces</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Computed namespace-constructor</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0109">452</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Semantics of order by</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0130">473</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>When to process the query prolog</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0138">481</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Semantics of Schema Context</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0153">496</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Support for lax and strict wildcards</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0165">508</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Namespaces in element constructors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0169">512</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Conformance Levels</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0094">437</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static type errors and warnings</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0098">441</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Implementation of and conformance levels for static
            type checking</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0107">450</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Semantics of data()</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0110">453</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Semantics of element and attribute
            constructors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0114">457</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Dynamic context for current date and time</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0118">461</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Data model syntax and literal values</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0135">478</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Semantics of special functions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0136">479</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Non-determinism in the semantics</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0139">482</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Type equivalence rules</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0141">484</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Treatment of nillability and xsi:nil</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0144">487</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Representation of text nodes in formal values</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0148">491</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Validation of an empty string against a string
            list</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0160">503</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Collations in the static environment</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0171">514</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Raising errors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0177">520</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Coercion between untyped and atomic values</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0178">521</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Semantics of XPath 1.0 compatibility</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0180">525</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static context accessible from the dynamic
            context</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#text-constructor-empty-sequence">528</a></td>

            <td>
            </td>

            <td>1</td>

            <td>semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Semantics of text constructor on empty
            sequence</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0100">443</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Semantics?</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Namespace resolution</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#cdata-serialization">244</a></td>

            <td>
            </td>

            <td>2</td>

            <td>serialization</td>

            <td>decided</td>

            <td>xquery</td>

            <td>CDATA sections and serialization</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-phantom-sortby">155</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>sort</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Sorting by Non-exposed Data</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#sort-disappearing">243</a></td>

            <td>
            </td>

            <td>3</td>

            <td>sort</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Provide an example of sorting "disappearing"</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#sort-by">251</a></td>

            <td>
            </td>

            <td>2</td>

            <td>sort</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Sorting "input to loop", not the result</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#sort-in-FLWR">318</a></td>

            <td>
            </td>

            <td>1</td>

            <td>sort</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Add 'order by' clause to FLWR?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0132">475</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Typing for descendant</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0112">455</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Typing for the typeswitch default clause</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0129">472</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static typing of union</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0145">488</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static typing of path expressions in the presence
            of derivation by extension</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0166">509</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static typing for validate</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0170">513</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Static typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Imprecise static type of constructed elements</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#grammar-declare">547</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>active</td>

            <td>xquery</td>

            <td>Use "declare" for declarations</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#lexical-rules">548</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>active</td>

            <td>xpath</td>

            <td>Lexical Rules: states normative?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#comments-location">550</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>active</td>

            <td>xquery</td>

            <td>Location of Comments</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#processing-instruction-quotes">552</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>active</td>

            <td>xpath</td>

            <td>Should the quotes in processing-instruction("...")
            be optional?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#xquery-escaping-quotes-and-apostrophes">144</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>syntax</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Escaping Quotes and Apostrophes</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#nested-comments">246</a></td>

            <td>
            </td>

            <td>2</td>

            <td>syntax</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Nested XQuery comments allowed?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#SequenceType-problems">341</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Problems with SequenceType</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#sequence-type-path-alignment">532</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Alignment between path expressions and sequence
            types</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#lexical-state-tables">535</a></td>

            <td>
            </td>

            <td>1</td>

            <td>syntax</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Lexical state tables</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#schema-plural-data-types">524</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Plural datatypes different from Singular *?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#input-and-schema-validation">523</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>active</td>

            <td>xpath</td>

            <td>input(), collection(), document(); validation
            semantics</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#function-calls-and-expected-type">534</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Semantics of function calls and notion of "expected
            type"</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#type-of-well-formed">542</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>What should be the type of an attribute or element
            that is well-formed but not validated, or is validated
            in skip mode?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#xquery-define-schema-variants">43</a></td>

            <td>T</td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Defining Behavior for Well Formed, DTD, and Schema
            Documents</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#xquery-subtype-substitutability">47</a></td>

            <td>T</td>

            <td>2</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Subtype Substitutability</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#xquery-typeswitch-case-not-subtype">48</a></td>

            <td>T</td>

            <td>3</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>algebra</td>

            <td>CASE not a subtype</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xpath-lightweight-cast">279</a></td>

            <td>T</td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Should there be a lightweight cast?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-failed-validation">334</a></td>

            <td>T</td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>How are documents for which validation has failed
            processed?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#type-copied-subelement">531</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Should discard the type of copied subelement</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#automatic-coersion-strict-or-not">533</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Strict static typing for automatic coercion of
            untyped atomic to atomic values</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#static-type-empty-error">541</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Should it be a static error if an expression other
            than () has type empty?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#xpath-matching-substitution-groups">543</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>How can a path expression match elements in the
            substitution group of a given element?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xpath-matching-types">544</a></td>

            <td>
            </td>

            <td>1</td>

            <td>type-semantics</td>

            <td>decided</td>

            <td>xpath</td>

            <td>How can a path expression match nodes of a given
            type?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xquery-type-syntax">56</a></td>

            <td>T</td>

            <td>3</td>

            <td>type-syntax</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Human-Readable Syntax for Types</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#schema-types-from-input-documents">307</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>xpath</td>

            <td>Schema Types from input documents?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#static-semantics-anySimpleType-untypedAtomic">526</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>xpath</td>

            <td>Semantics for anySimpleType and untypedAtomic</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#datamodel-infoset-types">536</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>xpath</td>

            <td>Data model to infoset mapping and type
            information</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#cast-untypedAtomic-backward-compatibility-mode">539</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Semantics of fs:cast-untypedAtomic in backward
            compatibility mode</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#static-semantics-input-unions">540</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>How does the static semantics works in the case
            where the input types are unions?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#implicitly-element-attribute">545</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>xpath</td>

            <td>Are XS element/attribute declarations implicitly
            added to the schema context?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#constructor-functions-user-types">551</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>active</td>

            <td>xpath</td>

            <td>Constructor functions for unprefixed user defined
            types</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#xpath-datatype-support">206</a></td>

            <td>T</td>

            <td>2</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Typing support in XPath</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#function-return-datatype">224</a></td>

            <td>T</td>

            <td>2</td>

            <td>types</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Why do we want to allow optional returns and
            DataType?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#binding">297</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Should XPath have "type binding" in variable?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#PSVI-Data-Model-mapping-normative">306</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>PSVI to Data Model mapping part of normative
            text?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#type-soundness">308</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Type Soundness</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#type-annotations-child-of-element">310</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Are the children of a newly constructed element
            typed?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#cardinality-typed-comparison">316</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Is anySimpleType = anySimpleType*?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#types-conformancelevels-same-results">320</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Should different conformance levels give the same
            result for the same query and data?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#element-def-not-in-in-scope">325</a></td>

            <td>T</td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>xpath</td>

            <td>Refering to element that is not in the in-scope
            schema def.</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#static-typing-index-expressions">527</a></td>

            <td>
            </td>

            <td>1</td>

            <td>types</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Static typing of XPath index expressions</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0143">486</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>active</td>

            <td>formal-semantics</td>

            <td>Support for PI, comment and namespace nodes</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0103">446</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Complexity of interleaving</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0106">449</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Constraint on attribute and element content
            models</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0158">501</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Support for XML Schema groups</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#FS-Issue-0173">516</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Typeswitch and type substitutability</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#FS-Issue-0176">519</a></td>

            <td>
            </td>

            <td>1</td>

            <td>Typing</td>

            <td>decided</td>

            <td>formal-semantics</td>

            <td>Type of document node</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#validate-lax-strict">321</a></td>

            <td>
            </td>

            <td>1</td>

            <td>validate</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Is validate strict or lax?</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#validate-lax-strict-override">322</a></td>

            <td>
            </td>

            <td>1</td>

            <td>validate</td>

            <td>decided</td>

            <td>xquery</td>

            <td>"validate" strict/lax override?</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a href="#default-validation-mode">530</a></td>

            <td>
            </td>

            <td>1</td>

            <td>validation</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Default default validation mode</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#declaring-variables-in-prolog">250</a></td>

            <td>
            </td>

            <td>2</td>

            <td>variables</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Declaring Variables in Prolog</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a
            href="#whitespace-in-element-constructors">191</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>whitespace</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Whitespace handling in element constructors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#whitespace-attribute-constructors">311</a></td>

            <td>
            </td>

            <td>1</td>

            <td>whitespace</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Whitespace and Attribute Constructors</td>

            <td>
            </td>
          </tr>

          <tr>
            <td><a
            href="#whitespace-character-reference">338</a></td>

            <td>
            </td>

            <td>1</td>

            <td>whitespace</td>

            <td>decided</td>

            <td>xquery</td>

            <td>Handling of whitespace and character
            references</td>

            <td>
            </td>
          </tr>

          <tr style="background-color:#FFA">
            <td><a href="#xquery-abql">152</a></td>

            <td>
            </td>

            <td>o-1</td>

            <td>xqueryx</td>

            <td>active</td>

            <td>xqueryx</td>

            <td>XML-based Syntax</td>

            <td>
            </td>
          </tr>
        </table>
        <hr />

        <div class="issue"
        style="color: green; background-color: white">
          <h2>43. <a id="xquery-define-schema-variants"
          name="xquery-define-schema-variants"><u>xquery-define-schema-variants</u>:
          Defining Behavior for Well Formed, DTD, and Schema
          Documents</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>type-semantics</b> Priority: <b>1</b>
            Status: <b>decided</b><br />
             Originator: <b>Don Chamberlin</b></small>Defining
            Behavior for Well Formed, DTD, and Schema Documents

            <h3><a id="id-issue-d1e876"
            name="id-issue-d1e876"></a>Description</h3>

            <div>
              <p>We should specify the behavior of XQuery for well
              formed XML, XML validated by a schema, and XML
              validated by a DTD.</p>
            </div>

            <h3><a id="id-issue-d1e881"
            name="id-issue-d1e881"></a>Proposed Resolution</h3>

            <div>
              <p>The mapping of a DTD validated or well formed
              document still needs to be defined in the Data
              Model.</p>
            </div>

            <h3><a id="id-issue-d1e886"
            name="id-issue-d1e886"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Closing of the directly related issues: [resolved
              issue #xquery-abstract-syntax] and [resolved issue
              #xpath-issue-complex-type-value] is sufficient to
              close this issue.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>On recommendation of the Processing Model
              Taskforce the disposition is reaffirmed.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>47. <a id="xquery-subtype-substitutability"
          name="xquery-subtype-substitutability"><u>xquery-subtype-substitutability</u>:
          Subtype Substitutability</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>type-semantics</b> Priority: <b>2</b>
            Status: <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>Subtype
            Substitutability

            <h3><a id="id-issue-d1e984"
            name="id-issue-d1e984"></a>Description</h3>

            <div>
              <p>Should XQuery 1.0 support subtype substitutability
              for function parameters?</p>

              <p>If subtype substitutability is not supported in
              XQuery Version 1, the motivation for TYPESWITCH is
              weakened and the decision to support TYPESWITCH
              should be revisited.</p>
            </div>

            <h3><a id="id-issue-d1e992"
            name="id-issue-d1e992"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Michael Rys:</p>

              <div style="margin-left: 2em; margin-right: 2em;">
                <div class="exampleInner">
<pre>
I think this is still an open issue given some semantic issues that we
found between named subtype substitutability and derivation by
extension. I will send mail on this issue this week,
</pre>
                </div>
              </div>
            </div>

            <h3><a id="id-issue-d1e1000"
            name="id-issue-d1e1000"></a>Actual Resolution</h3>

            <div>
              <p>Addressed by the "Named Typing" proposal.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2002-05-07
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-05-22
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-06-27
              ([link to member only information] )</small></p>

              <p>Accepting text in 2002-04-30 public draft.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>48. <a id="xquery-typeswitch-case-not-subtype"
          name="xquery-typeswitch-case-not-subtype"><u>xquery-typeswitch-case-not-subtype</u>:
          CASE not a subtype</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>algebra</b>
            Cluster: <b>type-semantics</b> Priority: <b>3</b>
            Status: <b>decided</b><br />
             Originator: <b>XML Query</b></small>CASE not a subtype

            <h3><a id="id-issue-d1e1014"
            name="id-issue-d1e1014"></a>Description</h3>

            <div>
              <p>If the types in the CASE branches are not subtypes
              of the TYPESWITCH, is this an error, or are these
              branches simply never executed? If the latter, should
              we require a warning?</p>
            </div>

            <h3><a id="id-issue-d1e1019"
            name="id-issue-d1e1019"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Issue 48 closed without changes to the document
              (no static errors will be raised, implementations can
              but are not required to raise warnings).</p>

              <p><small>Decision by: <b>fs-editors</b> on
              2003-02-13 ([link to member only information]
              )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-19
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-02-27
              ([link to member only information] )</small></p>

              <p>Accepting proposal in <a
              href="#FS-Issue-0173">#FS-Issue-0173</a> closes this
              issue in a consistent way.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>56. <a id="xquery-type-syntax"
          name="xquery-type-syntax"><u>xquery-type-syntax</u>:
          Human-Readable Syntax for Types</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>type-syntax</b> Priority: <b>3</b> Status:
            <b>decided</b><br />
             Originator: <b>Algebra
            Editors</b></small>Human-Readable Syntax for Types

            <h3><a id="id-issue-d1e1207"
            name="id-issue-d1e1207"></a>Description</h3>

            <div>
              <p>The Algebra has a syntax for declaring types. Up
              to now, XQuery uses XML Schema for declaring types.
              Is this sufficient? Some important questions:</p>

              <ol class="enum1">
                <li>Are type names sufficient, or does XQuery
                really need its own syntax for declaring
                types?</li>

                <li>Would Normalized Universal Names (derived from
                MSL) be sufficient for type names?</li>

                <li>How will type names be bound to
                definitions?</li>
              </ol>
            </div>

            <h3><a id="id-issue-d1e1220"
            name="id-issue-d1e1220"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-15
              ([link to member only information] )</small>Joint
              F2F</p>

              <p>Decided:</p>

              <p>Are type names sufficient - YES</p>

              <p>Would NUNS be sufficient for type name - not
              needed</p>

              <p>How will type names be bound to definitions - with
              imported schemas and namespaces</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>74. <a id="xquery-module-syntax"
          name="xquery-module-syntax"><u>xquery-module-syntax</u>:
          Module syntax</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>module-semantics</b> Priority: <b>o-1</b> Status:
            <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>Module syntax

            <h3><a id="id-issue-d1e1572"
            name="id-issue-d1e1572"></a>Description</h3>

            <div>
              <p>The definition and syntax of a query module are
              still under discussion in the working group. The
              specifications in this section are pending approval
              by the working group.</p>

              <p>Future versions of the language may support other
              forms of query modules, such as update statements and
              view definitions.</p>
            </div>

            <h3><a id="id-issue-d1e1580"
            name="id-issue-d1e1580"></a>Proposed Resolution</h3>

            <div>
              <p>Paulist Modules Proposal</p>

              <div class="exampleInner">
<pre>
This proposal adds modules, external variables, external functions,
and global variables to XQuery. It addresses the following open
issues:

   74 Module syntax
   75 Importing Modules
124 External Functions
157 Function Libraries
223 We need a way to declare external functions
250 Declaring Variables in Prolog

This proposal is called the Paulist Modules Proposal, because it is
based on a simplification Paul Cotton made to earlier module
proposals, which can be found here:

  Subject: Paul's Proposal (was: Unified proposal on modules, global
           and external variables, and external functions)
  From: Jonathan Robie (jonathan.robie@datadirect-technologies.com)
  Date: Thu, Dec 19 2002
  http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0391.html

Many other people have contributed to this proposal in various
iterations, including Mary Fernandez, Jerome Simeon, Don Chamberlin,
Michael Rys, Phil Wadler, and Michael Kay.


1. Modules and Module Declarations

    An XQuery module is a resource that contains a Query. A module may
    declare a target namespace using a ModuleDecl. The syntax of Query
    and ModuleDecl is as follows:

      Query ::= ModuleDecl? QueryProlog ExprSequence?
      ModuleDecl ::= "module" ModuleURI

    If a module contains a ModuleDecl, its functions may be imported by
    other modules. A module that does not have a ModuleDecl can not be
    imported. A ModuleURI may be relative - if so, it is combined with
    the Base URI to create an absolute URI.

    In a module that is imported by another module, the optional
    ExprSequence must be absent, or a static error is raised.

2. Module Imports

    A query may import modules in the QueryProlog using
    ModuleImports. The syntax of QueryProlog and ModuleImport is as
    follows:

      QueryProlog ::=  (NamespaceDecl
                       | DefaultNamespaceDecl
                       | SchemaImport
                       | ModuleImport
                       | VarDn)*
                       FunctionDn*

      ModuleImport ::= "import" "module" ModuleURI ("at" ImplURI)?

    Functions and global variables defined in a module may be used in
    any module that imports the defining module. Importing a module
    does not provide access to the imported schemas or namespaces of
    that module. Importing a module does not provide access to the
    functions imported by that module.

    An implementation may locate a module in any convenient manner,
    provided the ModuleURI of the module it locates matches the
    ModuleURI of the ModuleImport. The optional ImplURI specifies the
    resource containing the implemenation of the module. It is treated
    like a schema location hint in XML Schema - an implementation may
    ignore it completely.

    Two modules may import each other. For instance, if module A
    imports module B, then module B may import module A.

3. Variable declarations and definitions

    A variable may be declared or defined using a VarDn in the
    QueryProlog. The syntax of VarDn is as follows:

      VarDn ::=  "define" "global"? "external"? "variable" "$" VarName
                    ("as" SequenceType)? (":=" Expr)?

    A variable may have no forward references to functions or
    variables. Functions and variables imported into a module are
    considered prior to a global variable if they are imported before
    the global variable is defined. A variable may not be used before
    it is defined.

    If the "global" keyword is present, then the variable will be
    imported whenever the module that contains it is imported.

    If the "external" keyword is present, the variable is [external];
    if it is absent, the variable is [internal].

    An [external] variable definition must include only the variable's
    name and optional sequence type, or a static error is raised.
    During dynamic evaluation, an [external] variable must be bound to
    a value in the dynamic context, or an error is raised.

    An [internal] variable definition must include the variable's name,
    optional sequence type, and a required expression, or a static
    error is raised.

    It is a type error, if the value of a variable does not match the
    declared sequence type of the variable.


4. External functions

    An external function definition allows XQuery to call functions
    written in other languages. The syntax of a FunctionDefn is as
    follows:

     FunctionDefn ::= &lt;"define" "function"&gt; "external"? &lt;QName "("&gt;
     ParamList? (")" | (&lt;")" "as"&gt; SequenceType)) EnclosedExpr

    If the "external" keyword is present, the function is [external];
    if it is absent, the function is [internal].

    If a function is [internal], its implementation is given as an
    XQuery expression in the module's implementation. If a function is
    [external], its implementation is given by the query environment.
    XQuery does not specify how external functions are implemented or
    accessed, how actual arguments are passed to external functions, or
    how return values are passed to the query environment - all that is
    implementation defined.
</pre>
              </div>

              <p>Questions in proposal that need resolution:</p>

              <div class="exampleInner">
<pre>
In today's telcon, we identified three central questions that need to
be resolved for the modules proposal. Once we resolve these questions,
it will be easy to rewrite the Paulist module accordingly.

Question 1: What is the relationship between the ModuleURI and the
namespace of the functions it contains?

Possible answers:

1.A. There is no relationship. A module is identified by a URI, and
may contain functions in any namespace.

1.B. The module URI is the namespace of functions and global variables
defined in that module. It serves as a default namespace for both
functions and global variables, but the prolog can change these
defaults.

1.C. The module URI is the namespace of functions and global variables
exported by the module. A module may contain functions and global
variables defined in other namespaces or in no namespace, but they are
not exported when the module is imported into another module.


2. Should there an optional LocationURI?

2.A. A module has an optional LocationURI, which provides the location
of a resource. This allows the name of a resource to be decoupled from
its location, while allowing relative or absolute locations to be
specified explicitly.

2.B. A module is identified only by the ModuleURI, which may be
relative or absolute. Catalogs or other similar devices are used to
map the ModuleURI onto a location.

There are two variations on 2.B:

2.B.i: The ModuleURI may be relative.
2.B.ii: The ModuleURI must be absolute.

Relative ModuleURIs are not useful if we choose 2.A.

Jonathan

Note: Michael Kay suggested Option A and Option B. They are defined as:

Option A: (C3, L1)
Option B: (C1, L2)
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e1594"
            name="id-issue-d1e1594"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>75. <a id="xquery-import"
          name="xquery-import"><u>xquery-import</u>: Importing
          Modules</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>module-semantics</b> Priority: <b>o-1</b> Status:
            <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>Importing
            Modules

            <h3><a id="id-issue-d1e1604"
            name="id-issue-d1e1604"></a>Description</h3>

            <div>
              <p>The means by which a query module gains access to
              the functions defined an an external function library
              remains to be defined.</p>

              <p>Should xmlns only be respected for construction,
              Xquery expressions but not functions, or also
              functions?</p>
            </div>

            <h3><a id="id-issue-d1e1612"
            name="id-issue-d1e1612"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>79. <a id="xquery-encoding"
          name="xquery-encoding"><u>xquery-encoding</u>:
          Encoding</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>module-syntax</b> Priority: <b>o-1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>Encoding

            <h3><a id="id-issue-d1e1685"
            name="id-issue-d1e1685"></a>Description</h3>

            <div>
              <p>Does XQuery need a way to specify the encoding of
              a query? For instance, should the prolog allow
              statements like the following?</p>

              <div class="exampleInner">
<pre>
ENCODING utf-16
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e1693"
            name="id-issue-d1e1693"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-29
              ([link to member only information] )</small></p>

              <p>The text of a query is in Unicode. Serialization
              is done in Unicode, but APIs can set other encodings
              for serialization.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>96. <a id="xquery-normalized-equality"
          name="xquery-normalized-equality"><u>xquery-normalized-equality</u>:
          Normalized Equality</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>(in)equality-operators</b> Priority: <b>o-1</b>
            Status: <b>decided</b><br />
             Originator: <b>Mary Fernandez</b></small>Normalized
            Equality

            <h3><a id="id-issue-d1e2029"
            name="id-issue-d1e2029"></a>Description</h3>

            <div>
              <p>When elements are compared, are comments and PIs
              considered in the comparison? How is whitespace
              handled? Do we need to allow more than one way to
              handle these in comparisons?</p>
            </div>

            <h3><a id="id-issue-d1e2034"
            name="id-issue-d1e2034"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-03
              ([link to member only information] )</small>The XSL
              WG is not agreeable to blessing this.</p>

              <p>"When elements are compared, are comments and PIs
              considered in the comparison?": NO</p>

              <p>"How is whitespace handled?": This depends on the
              whitespace in the instance as per the data model.</p>

              <p>"Do we need to allow more than one way to handle
              these in comparisons?": NO, not in XPath 2.0/XQuery
              1.0.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>124. <a id="xquery-external-functions"
          name="xquery-external-functions"><u>xquery-external-functions</u>:
          External Functions</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>functions</b>
            Priority: <b>o-1</b> Status: <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>External
            Functions

            <h3><a id="id-issue-d1e2614"
            name="id-issue-d1e2614"></a>Description</h3>

            <div>
              <p>An extensibility mechanism needs to be defined
              that permits XQuery to access a library of functions
              written in some other programming language such as
              Java.</p>

              <p>Some sources of information: the definition of
              external functions in SQL, the implementation of
              external functions in Kweelt.</p>
            </div>

            <h3><a id="id-issue-d1e2622"
            name="id-issue-d1e2622"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>144. <a id="xquery-escaping-quotes-and-apostrophes"
          name="xquery-escaping-quotes-and-apostrophes"><u>xquery-escaping-quotes-and-apostrophes</u>:
          Escaping Quotes and Apostrophes</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
            Priority: <b>o-1</b> Status: <b>decided</b><br />
             Originator: <b>XML Query</b></small>Escaping Quotes
            and Apostrophes

            <h3><a id="id-issue-d1e3103"
            name="id-issue-d1e3103"></a>Description</h3>

            <div>
              <p>In attribute constructors and string constructors,
              XQuery uses quotes or apostrophes as delimiters. How
              are these characters escaped when they occur within
              strings that are created by one of these
              constructors?</p>
            </div>

            <h3><a id="id-issue-d1e3108"
            name="id-issue-d1e3108"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Michael Rys:</p>

              <div style="margin-left: 2em; margin-right: 2em;">
                <div class="exampleInner">
<pre>
I asked a member of my team to check for a resolution that he can live
with. He said he has not found it and currently works on constructing
examples that shows the open issue.
</pre>
                </div>
              </div>
            </div>

            <h3><a id="id-issue-d1e3116"
            name="id-issue-d1e3116"></a>Proposed Resolution</h3>

            <div>
              <p>I propose that we use double-delimiters within a
              string literal, e.g. 'I don''t', and unlike most of
              my syntactic ideas, this proposal seemed to recieve
              general support.</p>
            </div>

            <h3><a id="id-issue-d1e3119"
            name="id-issue-d1e3119"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-04-30
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-05-22
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-06-27
              ([link to member only information] )</small></p>

              <p>Syntax in current draft has this, but explanatory
              text need to be added.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>152. <a id="xquery-abql"
          name="xquery-abql"><u>xquery-abql</u>: XML-based
          Syntax</a></h2>

          <div>
            <small>Locus: <b>xqueryx</b> Cluster: <b>xqueryx</b>
            Priority: <b>o-1</b> Status: <b>active</b><br />
             Originator: <b>XML Query WG</b></small>XML-based
            Syntax

            <h3><a id="id-issue-d1e3258"
            name="id-issue-d1e3258"></a>Description</h3>

            <div>
              <p>XQuery needs an XML representation that reflects
              the structure of an XQuery query. Drafts of such a
              representation have been prepared, but it is not yet
              ready for publication.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>155. <a id="xquery-phantom-sortby"
          name="xquery-phantom-sortby"><u>xquery-phantom-sortby</u>:
          Sorting by Non-exposed Data</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
            Priority: <b>o-1</b> Status: <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Sorting by
            Non-exposed Data

            <h3><a id="id-issue-d1e3306"
            name="id-issue-d1e3306"></a>Description</h3>

            <div>
              <p>Should we make it easier to sort by data that is
              not exposed in the result? Although the current
              language allows this, it is difficult to define
              complex sort orders in which some items are not
              exposed in the result and others are computed in the
              expression that is sorted. Is there a more convenient
              syntax for this that would be useful in XQuery?</p>
            </div>

            <h3><a id="id-issue-d1e3311"
            name="id-issue-d1e3311"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e3315"
            name="id-issue-d1e3315"></a>Proposed Resolution</h3>

            <div>
              <div class="exampleInner">
<pre>
Here is an example:

FOR $e IN //employee
WHERE ...
RETURN
  &lt;newe&gt;$e/name&lt;/newe&gt;
SORTBY
  -- Now I would like to sort by salary but cannot.

Instead, the query would have to be written as

FOR $e IN (FOR $x IN //employee RETURN $x SORTBY employee/salary/data())
WHERE ...
RETURN
  &lt;newe&gt;$e/name&lt;/newe&gt;

Which seems awkward.

The question is of course how we can integrate the SORTBY in an other
way.

For example, could we say

FOR $e IN //employee
WHERE ...
SORTBY $e/salary/data()
RETURN
   &lt;newe&gt;$e/name&lt;/newe&gt;

?

Best regards
Michael
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e3320"
            name="id-issue-d1e3320"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-18
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-10
              ([link to member only information]
              )</small>Confirming that there are no concerns for
              the resolution of this XQuery only issue.</p>

              <p>Resolved by the adoption of the proposal to add
              "orderby" to the FLWR expression and to drop the
              previous "sortby" syntax/</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>157. <a id="xquery-function-library"
          name="xquery-function-library"><u>xquery-function-library</u>:
          Function Libraries</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>functions</b>
            Priority: <b>o-1</b> Status: <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>Function
            Libraries

            <h3><a id="id-issue-d1e3362"
            name="id-issue-d1e3362"></a>Description</h3>

            <div>
              <p>XQuery needs a mechanism to allow function
              definitions to be shared by multiple queries. The
              XQuery grammar allows function definitions to occur
              without a query expression.</p>

              <p>We must provide a way for queries to access
              functions in libraries. For instance, we might add an
              IMPORT statement to XQuery, with the URI of the
              functions to be imported. It must be possible to
              specify either that (1) local definitions replace the
              imported definitions, or (2) imported definitions
              replace the local ones.</p>
            </div>

            <h3><a id="id-issue-d1e3370"
            name="id-issue-d1e3370"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>191. <a id="whitespace-in-element-constructors"
          name="whitespace-in-element-constructors"><u>whitespace-in-element-constructors</u>:
          Whitespace handling in element constructors</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
            Priority: <b>o-1</b> Status: <b>decided</b><br />
             Originator: <b>XPath Editors</b></small>Whitespace
            handling in element constructors

            <h3><a id="id-issue-d1e4132"
            name="id-issue-d1e4132"></a>Description</h3>

            <div>
              <p>How is whitespace handled in element
              constructors?</p>

              <p>Issue is for material in sec 2.8. in Working Draft
              2001-11-28.</p>
            </div>

            <h3><a id="id-issue-d1e4140"
            name="id-issue-d1e4140"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Michael Kay:</p>

              <div style="margin-left: 2em; margin-right: 2em;">
                <div class="exampleInner">
<pre>
The XQuery WG requested information from XSL WG
as to how we currently deal with whitespace, in the hope that we can provide
an off-the-shelf solution to the problem.

In response to the action, here's a description of what XSLT does.

The stylesheet is an XML document. In constructing its infoset, all
processing instructions, comments, and whitespace-only text nodes are
discarded. (To be absolutely precise, PIs and comments are discarded; then
adjacent text nodes are merged; then whitespace-only text nodes are removed
from the tree). Whitespace text nodes are retained however, in two
circumstances: (a) if the whitespace text node is a child of an &lt;xsl:text&gt;
element, and (b) if an ancestor element specifies xml:space="preserve".

Certain elements in the stylesheet (for example, xsl:element) contain a
"content constructor". A content constructor is a sequence of XSLT
instructions, literal result elements, and literal text nodes. In evaluating
a content constructor, XSLT instructions do whatever the semantics of the
particular instruction say, while literal result elements and literal text
nodes are copied to the result tree.

The effect of this is that a whitespace-only text node in the stylesheet is
copied to the result tree only if either (a) it appears immediately inside
&lt;xsl:text&gt;, or (b) it is within the scope of an xml:space="preserve"
attribute.

Whitespace that is adjacent to non-white text in a literal text node is
copied to the result tree.

The effect of these rules is as follows:

=======================================
&lt;a&gt;  &lt;/a&gt;
generates an empty element:
&lt;a/&gt;
=======================================
&lt;a xml-space="preserve"&gt;  &lt;/a&gt;
generates:
&lt;a xml-space="preserve"&gt;  &lt;/a&gt;
=======================================
&lt;a&gt;&lt;xsl:text&gt;  &lt;/xsl:text&gt;&lt;/a&gt;
generates:
&lt;a&gt;  &lt;/a&gt;
=======================================
&lt;a&gt;
  &lt;b/&gt;
&lt;a&gt;
generates:
&lt;a&gt;&lt;b/&gt;&lt;/a&gt;
=======================================
&lt;a&gt;Some text
  &lt;b/&gt;
&lt;/a&gt;
generates:
&lt;a&gt;Some text
  &lt;b/&gt;&lt;/a&gt;
=======================================

There are other complications with whitespace. Whitespace in the result tree
can come from the source document as well as from the stylesheet; XSLT
provides control over whether whitespace-only text nodes in the source
document are significant or not. Whitespace can also be generated in the
output during serialization, if the xsl:output option indent="yes" is
specified.

Also of course the XSLT rules apply in addition to the XML rules. XML for
example normalizes line endings and normalizes whitespace (but not 

character references) in attribute values. This happens outside XSLT's
control. Whitespace character references such as   are treated
differently from literal whitespace by the XML processor, but are treated
identically to literal whitespace by the XSLT processor.

It's fair to say that these rules create a fair bit of confusion. It usually
doesn't matter for generating HTML, because whitespace in HTML is rarely
significant. For generating text files, it can be quite tricky. However, the
rules are well-defined and a user who understands the rules can always get
the required output.

What should XQuery do? I'd suggest mimicking these rules as closely as
possible, if only because users then only have to learn one set of confusing
rules rather than two. I can't think of any obvious improvements that would
make the system less confusing. Where the user wants to explicitly output
whitespace, of course, &lt;a&gt;{'  '}&lt;/a&gt; provides a suitable alternative to
XSLT's &lt;xsl:text&gt; instruction.

This analogy would suggest that &lt;a&gt;  {'x'}  &lt;/a&gt; should output &lt;a&gt;x&lt;/a&gt;,
while &lt;a&gt;z {'x'} y&lt;/a&gt; should output &lt;a&gt;z x y&lt;/a&gt;: that is, the characters
between &lt;a&gt; and "{" are ignored if they consist entirely of whitespace, but
are all significant if any of them is non-whitespace. &lt;a&gt; &lt;/a&gt; should output
&lt;a/&gt;, as should &lt;a&gt; &lt;/a&gt;. This is only a suggestion, of course, the
decision is entirely for XQuery to make.

Mike Kay
</pre>
                </div>
              </div>
            </div>

            <h3><a id="id-issue-d1e4148"
            name="id-issue-d1e4148"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-11
              ([link to member only information] )</small></p>

              <p>Decided: Resolve this by adopting the whitespace
              proposal.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>206. <a id="xpath-datatype-support"
          name="xpath-datatype-support"><u>xpath-datatype-support</u>:
          Typing support in XPath</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>Mike Kay</b></small>Typing support in
            XPath

            <h3><a id="id-issue-d1e4471"
            name="id-issue-d1e4471"></a>Description</h3>

            <div>
              <p>Which of these type productions (CAST, TREAT,
              ASSERT, TYPESWITCH...) belong in XPath? (ie common to
              XQuery and XPath)</p>

              <p>The list is now (2002-10): CAST, TREAT, VALIDATE,
              INSTANCE OF, types on variable bindings,
              TYPESWITCH.</p>
            </div>

            <h3><a id="id-issue-d1e4479"
            name="id-issue-d1e4479"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-04-07
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-04-09
              ([link to member only information] )</small></p>

              <p>Decided to remove "validate" from XPath.
              ("typeswitch" was removed already)</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>223. <a id="external-function-definition"
          name="external-function-definition"><u>external-function-definition</u>:
          We need a way to declare external functions</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>functions
            external</b> Priority: <b>o-1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>We need a way to
            declare external functions

            <h3><a id="id-issue-d1e4839"
            name="id-issue-d1e4839"></a>Description</h3>

            <div>
              <p>Should we allow external functions to be defined
              using a syntax like this?</p>

              <div class="exampleInner">
<pre>
       [71a] ExternalFnDef ::= {"define" S "external" S "function"}
            QName "(" ParamList? ")" ("returns" Datatype)?
 
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e4847"
            name="id-issue-d1e4847"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e4851"
            name="id-issue-d1e4851"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>224. <a id="function-return-datatype"
          name="function-return-datatype"><u>function-return-datatype</u>:
          Why do we want to allow optional returns and
          DataType?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>types</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Why do we want
            to allow optional returns and DataType?

            <h3><a id="id-issue-d1e4863"
            name="id-issue-d1e4863"></a>Description</h3>

            <div>
              <p>Would we prefer a syntax that requires explicit
              declaration of a general type when a function is to
              be loosely typed, rather than use the current syntax
              in which the type is omitted when the function is
              untyped.</p>
            </div>

            <h3><a id="id-issue-d1e4868"
            name="id-issue-d1e4868"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Decided that the default is item*.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>228. <a id="default-namespace-functions"
          name="default-namespace-functions"><u>default-namespace-functions</u>:
          Should we keep the default function namespace, and the
          xf: namespace?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>namespace
            functions</b> Priority: <b>o-2</b> Status:
            <b>decided</b><br />
             Originator: <b>Scott Boag</b></small>Should we keep
            the default function namespace, and the xf: namespace?

            <h3><a id="id-issue-d1e4950"
            name="id-issue-d1e4950"></a>Description</h3>

            <div>
              <p>The question was raised of whether the Query WG
              and F&amp;O TF have 1) a good rationale for putting
              built-in functions in a namespace, and 2) a
              consistent story about how this will relate to
              default namespace declarations and user-defined
              functions.</p>

              <p>It would seem odd to have to have all user defined
              functions put in the FandO namespace if a namespace
              is not declared for it. If you do not do that, then
              user defined functions that don't require a prefix
              will not match the QName.</p>

              <p>And, if there is not a good rational that provides
              user benifits, then it seems like we are going
              through a lot of additional complexity for little or
              no benefit.</p>
            </div>

            <h3><a id="id-issue-d1e4961"
            name="id-issue-d1e4961"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Kristoffer
              Rose:</p>
            </div>

            <h3><a id="id-issue-d1e4967"
            name="id-issue-d1e4967"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-22
              ([link to member only information]
              )</small>Unqualified, user-defined functions are
              placed in the default namespace for the scope of the
              query *only*.</p>

              <p><small>Decision by: <b>xsl</b> on 2003-01-16
              ([link to member only information] )</small></p>

              <p>This issue is identical to XSLT issue 155.
              Decision:</p>

              <p>- no controls on default function namespace</p>

              <p>- XSLT functions are in F&amp;O namespace</p>

              <p>- User defined function must be in a namespace</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>243. <a id="sort-disappearing"
          name="sort-disappearing"><u>sort-disappearing</u>:
          Provide an example of sorting "disappearing"</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>sort</b>
            Priority: <b>3</b> Status: <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Provide an
            example of sorting "disappearing"

            <h3><a id="id-issue-d1e5261"
            name="id-issue-d1e5261"></a>Description</h3>

            <div>
              <p>Provide an example of</p>

              <div class="exampleInner">
<pre>
   (employee sortby data(salary))/name
 
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e5269"
            name="id-issue-d1e5269"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-11
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-10
              ([link to member only information] )</small></p>

              <p>Decided to leave this to editorial discretion.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>244. <a id="cdata-serialization"
          name="cdata-serialization"><u>cdata-serialization</u>:
          CDATA sections and serialization</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>serialization</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>CDATA sections
            and serialization

            <h3><a id="id-issue-d1e5280"
            name="id-issue-d1e5280"></a>Description</h3>

            <div>
              <p>What are the semantics of CDATA sections in
              XQuery? Are they preserved in the data model for
              serialization?</p>
            </div>

            <h3><a id="id-issue-d1e5285"
            name="id-issue-d1e5285"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Decided to close, with document changes as
              described by Mike Kay in <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
              including editorial comments.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>246. <a id="nested-comments"
          name="nested-comments"><u>nested-comments</u>: Nested
          XQuery comments allowed?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
            Priority: <b>2</b> Status: <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Nested XQuery
            comments allowed?

            <h3><a id="id-issue-d1e5317"
            name="id-issue-d1e5317"></a>Description</h3>

            <div>
              <p>Nested XQuery comments allowed?</p>
            </div>

            <h3><a id="id-issue-d1e5322"
            name="id-issue-d1e5322"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Permit nested comments. Use "(:" and ":)"
              syntax.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>247. <a id="namespace-default-affecting"
          name="namespace-default-affecting"><u>namespace-default-affecting</u>:
          What does default namespace(s) affect?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>namespaces</b>
            Priority: <b>2</b> Status: <b>decided</b><br />
             Originator: <b>XPath TF</b></small>What does default
            namespace(s) affect?

            <h3><a id="id-issue-d1e5335"
            name="id-issue-d1e5335"></a>Description</h3>

            <div>
              <p>What is effect of default namespace declarations
              on unprefixed QNames that may occur in element
              constructors, attribute constructors, and name tests
              (or anywhere else).</p>

              <p>In XPath 1.0, in-scope namespace decls effect
              prefixed QNames, but default namespace decl does not
              effect unprefixed names in a name test. In XSLT 2.0,
              we introduced multiple default namespace decls :one
              for constructed elements, one for names in xpath
              expressions.</p>
            </div>

            <h3><a id="id-issue-d1e5343"
            name="id-issue-d1e5343"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-11
              ([link to member only information] )</small></p>

              <p>Decided to accept status quo:</p>

              <p>- default element namespace defines a namespace
              URI that is associated with unprefixed names of
              elements and types.</p>

              <p>- default function namespace defines a namespace
              URI that is associated with unprefixed names of
              functions.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>250. <a id="declaring-variables-in-prolog"
          name="declaring-variables-in-prolog"><u>declaring-variables-in-prolog</u>:
          Declaring Variables in Prolog</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>variables</b>
            Priority: <b>2</b> Status: <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>Declaring
            Variables in Prolog

            <h3><a id="id-issue-d1e5392"
            name="id-issue-d1e5392"></a>Description</h3>

            <div>
              <p>Functions in a function library often need to
              access the same variables. For instance, a function
              library that manipulates a grammar may need to use
              the following variables in many functions:</p>

              <div class="exampleInner">
<pre>
$grammar := document("xpath-grammar.xml")/g:grammar
$target := "xquery"
</pre>
              </div>

              <p>One possible syntax for this is:</p>

              <div class="exampleInner">
<pre>
'define' ''variable' varname ':=' expr
</pre>
              </div>

              <p>The above production would occur only in the
              prolog.</p>
            </div>

            <h3><a id="id-issue-d1e5409"
            name="id-issue-d1e5409"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>251. <a id="sort-by" name="sort-by"><u>sort-by</u>:
          Sorting "input to loop", not the result</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
            Priority: <b>2</b> Status: <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>Sorting "input
            to loop", not the result

            <h3><a id="id-issue-d1e5421"
            name="id-issue-d1e5421"></a>Description</h3>

            <div>
              <p>Consider this query:</p>

              <div class="exampleInner">
<pre>
   for $x in /books/book, $y in /reviews/review
   where $x/isbn = $y/isbn
   return &lt;newbook&gt;{ $x/title, $x/author, $y/reviewer }&lt;/newbook&gt;
   sortby isbn
</pre>
              </div>

              <p>This is an error, since isbn doesn't appear in
              newbook. (The static type system would catch this
              error.) What you have to write is</p>

              <div class="exampleInner">
<pre>
   for $z in
     for $x in book, $y in review
     where $x/isbn = $y/isbn
     return &lt;dummy&gt;{ $x/title, $x/author, $y/reviewer, $x/isbn }&lt;/dummy&gt;
     sortby isbn
   return &lt;newbook&gt;{ $z/title, $z/author, $z/reviewer }&lt;/newbook&gt;
</pre>
              </div>

              <p>This is painful.</p>

              <p>I think that XQuery should support this syntax, or
              something similar:</p>

              <div class="exampleInner">
<pre>
   for $x in book, $y in review
   where $x/isbn = $y/isbn
   sortby $x/isbn
   return &lt;newbook&gt;{ $x/title, $x/author, $y/reviewer }&lt;/newbook&gt;
</pre>
              </div>

              <p>Our plate is full with more important matters just
              now, but I hope we could fix this before we finalize
              XQuery.</p>
            </div>

            <h3><a id="id-issue-d1e5447"
            name="id-issue-d1e5447"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-18
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-10
              ([link to member only information]
              )</small>Confirming that there are no concerns for
              the resolution of this XQuery only issue.</p>

              <p>Resolved by the adoption of the proposal to add
              "orderby" to the FLWR expression and to drop the
              previous "sortby" syntax.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>257. <a id="collection-always-return-same"
          name="collection-always-return-same"><u>collection-always-return-same</u>:
          Does collection() always return same result?</a></h2>

          <div>
            <small>Issue Class: <b>D</b> Locus: <b>xpath</b>
            Cluster: <b>collections</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>XPath TF</b></small>Does collection()
            always return same result?

            <h3><a id="id-issue-d1e5582"
            name="id-issue-d1e5582"></a>Description</h3>

            <div>
              <p>Does collection() always return same result for
              the same URI? The same within the scope of a
              query/transformation? Are the nodes in the sequence
              identical?</p>
            </div>

            <h3><a id="id-issue-d1e5587"
            name="id-issue-d1e5587"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-10-23
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-31
              ([link to member only information] )</small></p>

              <p>It should return the same answer every time.
              Applies also to input(). We should use the same
              language as we use for document() and for
              current-dateTime().</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>258. <a id="document-nodes-identity"
          name="document-nodes-identity"><u>document-nodes-identity</u>:
          Identity of Document Nodes</a></h2>

          <div>
            <small>Issue Class: <b>D</b> Locus: <b>xpath</b>
            Cluster: <b>documents</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>Identity of
            Document Nodes

            <h3><a id="id-issue-d1e5599"
            name="id-issue-d1e5599"></a>Description</h3>

            <div>
              <p>Consider the following query:</p>

              <div class="exampleInner">
<pre>
        if (document("foo.com") == document("foo.com"))
                then &lt;yep/&gt;
                else &lt;nope/&gt;
</pre>
              </div>

              <p>I would like the following output:</p>

              <div class="exampleInner">
<pre>
        &lt;yep/&gt;
</pre>
              </div>

              <p>I think we can achieve this if we say that the URI
              of a resource is used as its identity. However, one
              resource can be identified by more than one URI.
              Suppose that "foo.com/here/there/hi.xml" and
              "file://c:/temp/limerick-tei.xml" refer to the same
              resource. What does the following return?</p>

              <div class="exampleInner">
<pre>
if (document("foo.com/here/there/hi.xml") ==
document("file://c:/temp/limerick-tei.xml"))
        then &lt;yep/&gt;
        else &lt;nope/&gt;
</pre>
              </div>

              <p>Should we simply use the URI of the parameter to
              establish identity and say that the two do not match?
              Should we make the result
              implementation-dependent?</p>
            </div>

            <h3><a id="id-issue-d1e5622"
            name="id-issue-d1e5622"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-10-23
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-31
              ([link to member only information] )</small></p>

              <p>This is already covered by the existing spec, but
              we may want to review the language as part of the
              actions for issue 257.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>265. <a id="lang-inheritance"
          name="lang-inheritance"><u>lang-inheritance</u>: How do
          we determine the xml:lang for a node if it inherits
          xml:lang from a higher-level node?</a></h2>

          <div>
            <small>Locus: <b>xpath-fulltext</b> Cluster:
            <b>FTTF-xml:lang</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>FTTF</b></small>How do we determine the
            xml:lang for a node if it inherits xml:lang from a
            higher-level node?

            <h3><a id="id-issue-d1e5897"
            name="id-issue-d1e5897"></a>Description</h3>

            <div>
              <p>How do we determine the xml:lang for a node if it
              inherits xml:lang from a higher-level node?</p>
            </div>

            <h3><a id="id-issue-d1e5902"
            name="id-issue-d1e5902"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Decided to close issue with no change to
              documents, since user-written expressions or
              functions can determine the value of xml:lang that a
              node inherits.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>266. <a id="lang-sublanguage-support"
          name="lang-sublanguage-support"><u>lang-sublanguage-support</u>:
          Do we support the sublanguage portion of
          xml:lang?</a></h2>

          <div>
            <small>Locus: <b>xpath-fulltext</b> Cluster:
            <b>FTTF-xml:lang</b> Priority: <b>2</b> Status:
            <b>decided</b><br />
             Originator: <b>FTTF</b></small>Do we support the
            sublanguage portion of xml:lang?

            <h3><a id="id-issue-d1e5912"
            name="id-issue-d1e5912"></a>Description</h3>

            <div>
              <p>Do we support the sublanguage portion of xml:lang?
              If so, how?</p>
            </div>

            <h3><a id="id-issue-d1e5917"
            name="id-issue-d1e5917"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>A user-written expression of function has to
              determine the value of xml:lang and then do the
              appropriate analysis of the value. No change to
              document.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>272. <a id="external-functions"
          name="external-functions"><u>external-functions</u>:
          External Functions</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>external-functions</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>External
            Functions

            <h3><a id="id-issue-d1e6040"
            name="id-issue-d1e6040"></a>Description</h3>

            <div>
              <p>The ability to call external functions is an
              established feature of XSLT 1.0, and is retained in
              XSLT 2.0. The facility is widely used, and some
              significant libraries of external functions have been
              developed by third parties. We made an attempt to
              standardize language bindings for external functions
              in the XSLT 1.1 working draft, but this proved highly
              controversial and has been dropped. The facility
              remains, however, even though the binding mechanisms
              remain implementation-defined.</p>

              <p>The XPath 2.0 specification continues to tolerate
              external functions, though it doesn't really
              acknowledge their existence properly. All we say is
              that the repertoire of functions that can be called
              is part of the context.</p>

              <p>The issue is: should the function
              function-available() function be transferred from
              XSLT to XPath?</p>

              <p>This function tests whether a named function is
              available, and returns true if it is, and false if it
              isn't. A typical call is:</p>

              <div class="exampleInner">
<pre>
if  (function-available('my:debug')) then my:debug('Hi!') else ()
</pre>
              </div>

              <p>This has two implications:</p>

              <p>(a) a call on my:debug must not be a static error
              if the function is not available</p>

              <p>(b) the names of functions (and the in-scope
              namespaces needed to resolve their QNames) must be
              available at run-time.</p>

              <p>Logically the function-available() function has no
              dependencies on XSLT so it should be transferred to
              XPath.</p>
            </div>

            <h3><a id="id-issue-d1e6069"
            name="id-issue-d1e6069"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-12-10
              ([link to member only information] )</small></p>

              <p>Proposed to resolve by stating that the XPath
              specification to state that at the discretion of the
              host language, a call to a function that is not in
              the static context may generate a dynamic error
              rather than a static error.</p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>This issue is also impacted by the following
              decision:</p>

              <p>Decided to adopt 1B and 2A in proposal for issue
              <a
              href="#xquery-module-syntax">#xquery-module-syntax</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>273. <a id="external-objests"
          name="external-objests"><u>external-objests</u>: External
          Objects</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>external-objects</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>External Objects

            <h3><a id="id-issue-d1e6086"
            name="id-issue-d1e6086"></a>Description</h3>

            <div>
              <p>Part of the strength of external functions is that
              they can return objects that are outside the scope of
              the XPath type system. For example, a function
              library for performing SQL database access may have a
              function sql:connect() that returns an object
              representing a database connection. This object may
              be passed as an argument to calls on other functions
              in the SQL function library.</p>

              <p>The way this is handled in XPath 1.0 is that the
              XPath specification defines four data-types, and
              explicitly leaves the host language free to define
              additional data types. We could probably live with a
              similar solution for XPath 2.0, but it's a fudge, and
              I think we ought to try and do better.</p>

              <p>Note that the only things you can do with an
              external object (under the XSLT 1.0 rules) are to
              assign it to a variable, or pass it as the argument
              to another function. In practice I think
              implementations also allow external objects to have
              additional behavior, for example they might allow
              conversion to a string when used in a context where a
              string is required. I think we should leave such
              behavior implementation-defined rather than saying
              that it is always an error.</p>

              <p>The question arises as to where external objects
              should fit into the type hierarchy. Should they be a
              top-level thing at the same level as "sequence", or
              should they be one level down, along with "node" and
              "atomic value"? I think it makes most sense to
              preserve the principle "everything is a sequence",
              which means that there are now three kinds of item:
              nodes, atomic values, and external objects.</p>

              <p>Handling this rigorously sounds like quite a
              pervasive change to the spec, but I don't think it's
              as bad as it seems. I don't think we should add any
              language features to support external objects, with
              the possible exception of a keyword "external" in the
              type syntax so that one can test for it using
              "instance of". Functions and operators that work on
              any sequence (for example, count) should treat an
              external object like any other item in the sequence.
              Operations that expect nodes will fail if presented
              with an external object; operations that expect
              atomic values will also fail, except that
              implementations may define fallback conversions from
              external objects to atomic values.</p>
            </div>

            <h3><a id="id-issue-d1e6103"
            name="id-issue-d1e6103"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e6109"
            name="id-issue-d1e6109"></a>Proposed Resolution</h3>

            <div>
              <p>Technically, I believe we could close the issue
              with no change to the documents, on the basis that
              the definition for the static context (in both XPath
              and XQuery) states: "Additional type definitions may
              be added to the in-scope type definitions by the
              language environment." I think an implementation
              could take this as sufficient authority to extend the
              type hierarchy with additional types, including types
              needed to represent objects returned by extension
              functions (such as "an SQL database connection").</p>

              <p>Editorially, I think it would be a good idea if we
              state this explicitly in a Note, as follows:</p>

              <p>NOTE: an implementation may allow function calls
              in a Query/Expression to bind to functions written in
              languages that use a different type system (these are
              known as "extension functions" in XSLT, "external
              functions" in XQuery). In this case, the way in which
              the arguments and results of such functions are
              mapped between the two type systems is
              implementation-defined. An implementation may define
              new types anywhere within the type hierarchy of the
              [Data Model] that are designed to facilitate
              interworking with other languages, for example a type
              that encapsulates an object returned by an external
              function; or it may provide mechanisms for the user
              to define such types.</p>
            </div>

            <h3><a id="id-issue-d1e6120"
            name="id-issue-d1e6120"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-11
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-19
              ([link to member only information] )</small></p>

              <p>Proposal accepted.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>279. <a id="xpath-lightweight-cast"
          name="xpath-lightweight-cast"><u>xpath-lightweight-cast</u>:
          Should there be a lightweight cast?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>type-semantics</b> Priority: <b>1</b>
            Status: <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>Should there
            be a lightweight cast?

            <h3><a id="id-issue-d1e6218"
            name="id-issue-d1e6218"></a>Description</h3>

            <div>
              <p>Should there be any provision for a lightweight
              cast that does not observe facets? Phil Wadler has
              suggested that 'validate' be used whenever full
              schema validation is desired, and 'cast' be used as a
              lightweight validation, which can be used for either
              simple or complex types, but which does not supply
              defaults, enforce facets, or check integrity
              constraints. It may be easier to optimize through
              cast than through validate, but supporting both
              constructs may confuse users due to their similarity.
              He suggests the following syntax for these
              expressions:</p>

              <div class="exampleInner">
<pre>
('cast'|'validate') as SequenceType ()
('cast'|'validate') 'in' ContextExpr { Expr }
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e6226"
            name="id-issue-d1e6226"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-11
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-10
              ([link to member only information] )</small></p>

              <p>Decided to reject this proposal. Cast checks all
              facets.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>286. <a id="element-construction-vs-streaming"
          name="element-construction-vs-streaming"><u>element-construction-vs-streaming</u>:
          Element Construction vs Streaming</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>constructor-expr</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Element
            Construction vs Streaming

            <h3><a id="id-issue-d1e6355"
            name="id-issue-d1e6355"></a>Description</h3>

            <div>
              <p>The element construction rules in 2.8 make
              efficient streaming of element construction
              difficult/impossible. For example, we execute the
              following expression on a stream and serialize the
              result in a streaming processing (such as XSLT like
              applications):</p>

              <p>&lt;foo&gt;{"foo", "bar", if (expr) then "baz"
              else &lt;baz/&gt;}&lt;/foo&gt;</p>

              <p>If expr is true, then this is serialized:</p>

              <p>&lt;foo&gt;foo bar baz&lt;/foo&gt;</p>

              <p>If expr is false, then this is serialized:
              &lt;foo&gt;foobar&lt;baz/&gt;&lt;/foo&gt;</p>

              <p>The implementation must cache up the "foo" and
              "bar" strings, just in case a sub-element node is
              constructed. If not, then I must insert a space
              between "foo" and "bar". This seems to contradict one
              of our explicit use scenarios in the XML Query
              Requirements (section 2.5).</p>
            </div>

            <h3><a id="id-issue-d1e6375"
            name="id-issue-d1e6375"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e6381"
            name="id-issue-d1e6381"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-09-04
              ([link to member only information] )</small></p>

              <p>This issue has been addressed by the recent
              changes to the element constructor.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>290. <a id="element-attribute-constructor-name-type"
          name="element-attribute-constructor-name-type"><u>element-attribute-constructor-name-type</u>:
          Element Attribute Constructor Name Type</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>constructor-expr</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Element
            Attribute Constructor Name Type

            <h3><a id="id-issue-d1e6488"
            name="id-issue-d1e6488"></a>Description</h3>

            <div>
              <p>Does the name expression on dynamically computed
              names in element/attribute constructors be of type
              QName without implicit cast from string, QName with
              implicit cast from string, or string?</p>
            </div>

            <h3><a id="id-issue-d1e6493"
            name="id-issue-d1e6493"></a>Proposed Resolution</h3>

            <div>
              <p>If the name is constructed by an expression, the
              expected type is xs:QName. Xs:string is in general
              implicitly cast to xs:QName (and xs:anyURI).</p>
            </div>

            <h3><a id="id-issue-d1e6498"
            name="id-issue-d1e6498"></a>Proposed Resolution</h3>

            <div>
              <p>(1) In Section 3.7.1 ("Direct Element
              Constructors"), modify the paragraph below the first
              example as follows:</p>

              <p>"Unqualified element names used in a direct
              element constructor are implicitly qualified by the
              default namespace for element names. In a direct
              element constructor, the name used in the end tag
              must exactly match the name used in the corresponding
              start tag (including its prefix or absence of a
              prefix)."</p>

              <p>(2) In Section 3.7.2.1 ("Computed Element
              Constructors"), add a new first paragraph as
              follows:</p>

              <p>"The name expression of a computed element
              constructor is processed as follows:</p>

              <p>1. If the name expression returns a QName, that
              QName is used as the name of the constructed element.
              If the QName returned by the name expression is
              unqualified, the name of the constructed element is
              in default namespace for element names.</p>

              <p>2. If the name expression returns a string, that
              string is implicitly cast to a QName by using the
              fn:QName-in-context function with its $use-default
              parameter set to True. The resulting QName is used as
              the name of the constructed element.</p>

              <p>3. If the name expression does not return a QName
              or a string, a dynamic error is raised."</p>

              <p>(3) In Section 3.7.2.2 ("Computed Attribute
              Constructors"), add a new first paragraph as
              follows:</p>

              <p>"The name expression of a computed attribute
              constructor is processed as follows:</p>

              <p>1. If the name expression returns a QName, that
              QName is used as the name of the constructed
              attribute. If the QName returned by the name
              expression is unqualified, the name of the
              constructed attribute is in no namespace.</p>

              <p>2. If the name expression returns a string, that
              string is implicitly cast to a QName by using the
              fn:QName-in-context function with its $use-default
              parameter set to True. The resulting QName is used as
              the name of the constructed attribute.</p>

              <p>3. If the name expression does not return a QName
              or a string, a dynamic error is raised."</p>
            </div>

            <h3><a id="id-issue-d1e6536"
            name="id-issue-d1e6536"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>x-editors</b> on 2003-02-05
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Recommend Don's proposal as the closure of this
              issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>293. <a id="cdata-charref-semantics"
          name="cdata-charref-semantics"><u>cdata-charref-semantics</u>:
          Cdata and CharRef Semantics</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:  Priority:
            <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Cdata and
            CharRef Semantics

            <h3><a id="id-issue-d1e6580"
            name="id-issue-d1e6580"></a>Description</h3>

            <div>
              <p>The data model cannot represent CDATA or CharRef,
              since the Information Set looses this
              information.</p>
            </div>

            <h3><a id="id-issue-d1e6585"
            name="id-issue-d1e6585"></a>Proposed Resolution</h3>

            <div>
              <p>The XQuery document should make it clear that:</p>

              <p>1. CDATA sections and CharRefs inside XQueries
              that are not embedded inside XML (which is what the
              XQuery document only talks about), are syntactic
              helps to write queries that otherwise would need
              entitization (in the case if CDATA sections) or a
              unicode input device (CharRefs).</p>

              <p>2. Implementations can chose to use this
              information as serialization hints to preserve the
              CDATA and entitization.</p>
            </div>

            <h3><a id="id-issue-d1e6596"
            name="id-issue-d1e6596"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Decided to close, with document changes as
              described by Mike Kay in <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
              including editorial comments.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>295. <a id="lexical-representation-of-atomic-values"
          name="lexical-representation-of-atomic-values"><u>lexical-representation-of-atomic-values</u>:
          Lexical Representation of Atomic Values</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>lexical-representation</b> Priority: <b>1</b>
            Status: <b>decided</b><br />
             Originator: <b>xquery/xsl f2f</b></small>Lexical
            Representation of Atomic Values

            <h3><a id="id-issue-d1e6631"
            name="id-issue-d1e6631"></a>Description</h3>

            <div>
              <p>The wording in section 2.8.3 needs to be aligned
              with Data model and F&amp;O; 'lexical representation'
              needs to be defined differently and be consistent in
              XQuery, Datamodel, F&amp;O. It probably needs to be
              string value (canonical value of integer in W3C
              Schema has a "." so not appropriate [or we need to
              have our own definition of the canonical
              value...]).</p>
            </div>

            <h3><a id="id-issue-d1e6636"
            name="id-issue-d1e6636"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>3.7.2.4 "text node constructors", that's the one
              that should be aligned to "string-value".</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>297. <a id="binding" name="binding"><u>binding</u>:
          Should XPath have "type binding" in variable?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>XQuery Editors</b></small>Should XPath
            have "type binding" in variable?

            <h3><a id="id-issue-d1e6670"
            name="id-issue-d1e6670"></a>Description</h3>

            <div>
              <p>The 2002-06-24 grammar introduces the "binding"
              production. "assert" is removed from both XQuery and
              XPath. "binding" currently requires reserved words.
              Should "binding" be in XPath?</p>

              <p>Several reasons NOT to include it in XPath:</p>

              <p>- grammar</p>

              <p>- semantics don't match function call
              semantics</p>

              <p>- rarely useful</p>

              <p>- reads oddly for range variables if (some integer
              $x in (1,2,"fred") satisfies $x=1)</p>

              <p>- biggest of all, users are asking us to simplify.
              We will get a very adverse reaction if we make "for"
              expressions more complicated.</p>

              <p>But it is worrying to have such a big split
              between XPath and XQuery.</p>
            </div>

            <h3><a id="id-issue-d1e6696"
            name="id-issue-d1e6696"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-11-12
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-11-14
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-01-09
              ([link to member only information] )</small></p>

              <p>Closed based on the XSLT recommendation to not
              include type declarations in XPath.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>306. <a id="PSVI-Data-Model-mapping-normative"
          name="PSVI-Data-Model-mapping-normative"><u>PSVI-Data-Model-mapping-normative</u>:
          PSVI to Data Model mapping part of normative
          text?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Don Chamberlin</b></small>PSVI to Data
            Model mapping part of normative text?

            <h3><a id="id-issue-d1e6846"
            name="id-issue-d1e6846"></a>Description</h3>

            <div>
              <p>Should the mapping from PSVI to Query Data Model
              be part of the normative language specification? (The
              mapping is affected by the presence or absence of the
              Schema Import Feature).</p>
            </div>

            <h3><a id="id-issue-d1e6851"
            name="id-issue-d1e6851"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Close issue: mapping already exists and is
              Normative).</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>307. <a id="schema-types-from-input-documents"
          name="schema-types-from-input-documents"><u>schema-types-from-input-documents</u>:
          Schema Types from input documents?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Don Chamberlin</b></small>Schema Types
            from input documents?

            <h3><a id="id-issue-d1e6861"
            name="id-issue-d1e6861"></a>Description</h3>

            <div>
              <p>During the analysis phase, in-scope schema
              definitions are derived from schemas named in Schema
              Import clauses.</p>

              <p>Should there be additional in-scope schema
              definitions that are part of the static context?
              Should there be another set of in-scope schema
              definitions that are part of the dynamic context?
              What would that do to static typing? Would this
              interfere with interoperability?</p>

              <p>In particular:</p>

              <p>1. Should an environment be allowed to statically
              predefine schema definitions for a query? This would
              allow queries on fixed collections or known message
              types to provide strong type information without
              forcing users to explicitly import the corresponding
              schemas.</p>

              <p>2. How does type information found dynamically in
              queried documents affect the query environment?</p>

              <p>Does data() dynamically use the type information
              found in the instances that are queried, even when
              the types have not been declared in imported schemas?
              Note that Basic XQuery does not work properly if this
              is not true, since it must be able to discover the
              types of elements without importing their
              definition.</p>

              <p>May an instance contain types that have not been
              imported into the static environment? If we say it
              may not, then schema imports are needed to query any
              document that contains types that are not predefined
              in XQuery.</p>

              <p>May documents that are queried have different
              definitions for the same names? Note that solutions
              that dynamically load type information from a
              document into the in-scope schema definitions may try
              to introduce all such definitions into the static
              environment, which should cause an error according to
              our current rules.</p>
            </div>

            <h3><a id="id-issue-d1e6889"
            name="id-issue-d1e6889"></a>Proposed Resolution</h3>

            <div>
              <p>If we want Basic XQuery to be able to query
              documents that have types that are not predefined,
              then data() must be able to use type information from
              instances. But if we want to be able to query
              validated documents that have different schemas this
              information must not be added to the static
              environment (or else we must find a way to add more
              than one schema definition for a given name to the
              static environment, or say that the static
              environment is dynamic, or....).</p>

              <p>My tentative conclusions:</p>

              <p>1. The in-scope schema definitions should be
              determined statically.</p>

              <p>2. data() and many operators must be able to
              utilize the type information found in a document.</p>

              <p>3. As a matter of convenience, it should be
              possible to import the schemas associated with a
              single document or with all documents in a
              collection. For instance, a syntax like the following
              may be useful:</p>

              <div class="exampleInner">
<pre>
import schema from collection
"jdbc:datadirect:sqlserver://localhost:1433;database='airports'"
</pre>
              </div>

              <p>or</p>

              <div class="exampleInner">
<pre>
import schema from document
"file:///C:/projects/query/requirements/xml-spec.xsd"
</pre>
              </div>

              <p>4. Implementations should be allowed to implicitly
              import schemas into the environment before executing
              a query, using any of the approved ways above.</p>
            </div>

            <h3><a id="id-issue-d1e6918"
            name="id-issue-d1e6918"></a>Proposed Resolution</h3>

            <div>
              <p>Proposal (3): Types in Queries, Types in
              Documents</p>

              <p>This proposal distinguishes the relationship
              between types known statically in the query and types
              that are discovered dynamically in documents during
              query processing. This version of the proposal
              follows the results of a telcon on the subject, as
              recorded in:</p>

              <p>Re: Issue 307 Telcon: Friday, 15 Nov, 12:00 EST
              From: Jonathan Robie
              (jonathan.robie@datadirect-technologies.com) Date:
              Fri, Nov 15 2002
              http://lists.w3.org/Archives/Member/w3c-query-editors/2002Nov/0148.html</p>

              <p>This proposal addresses the following issue:</p>

              <p>Issue 307 schema-types-from-input-documents:
              Schema Types from input documents?</p>

              <p>And here is the proposal itself:</p>

              <p>1. Static Types in Queries</p>

              <p>Implementations are allowed to implicitly import
              schemas into the environment before executing a
              query. The in-scope schema definitions are determined
              statically, containing the built-in type definitions,
              any schemas imported explicitly into the query, and
              any schemas imported implicitly from the query
              environment.</p>

              <p>In a query, it is a static error to use a name in
              a SequenceType production if the name is not found in
              the in-scope schema definitions.</p>

              <p>2. Types in Input Documents</p>

              <p>An input document may be accessed via an input
              function or via an externally defined variable that
              is bound to the input document by the query
              environment. An input document may refer to type
              names that have not been imported into the in-scope
              schema definitions, but it must not contain types
              that have the same names as types in the static
              environment, but conflicting definitions. Input
              functions and the query environment must promote
              unknown type names to the nearest type name in the
              in-scope schema definitions that is known to be
              substitutable for the unknown type name. If the
              unknown type name is derived from a known type by
              extension, list, or union, then the type name is
              changed to xs:anySimpleType if it is a simple type,
              or to xs:anyType if it is a complex type. This loses
              type information, but ensures that all type names in
              input documents are also in the in-scope schema
              definitions.</p>

              <p>Note: This approach guarantees that the built-in
              types and the static in-scope-schema definitions are
              the only types found in an input document. As a
              result, there is no need to extend the known types
              when a new document is read.</p>

              <p>Note: One ramification of this approach is that
              types derived by extension are not substitutable for
              their base types unless the schemas defining these
              types are imported into the query. We consider this a
              fair tradeoff for type safety. If people want to
              exploit the full type hierarchy, they need to import
              the schema that defines it.</p>

              <p>Note: Mapping all the types when an input function
              is called is obviously an inefficient implementation
              strategy. Many implementations will take a different
              approach, but this is a simple way to specify the
              desired behavior.</p>
            </div>

            <h3><a id="id-issue-d1e6962"
            name="id-issue-d1e6962"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-04
              ([link to member only information] )</small> Proposal
              (3) accepted.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-25
              ([link to member only information] )</small> Revoke
              resolution of Issue 307. Type annotations are not
              "dumbed down".</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>308. <a id="type-soundness"
          name="type-soundness"><u>type-soundness</u>: Type
          Soundness</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Don Chamberlin</b></small>Type
            Soundness

            <h3><a id="id-issue-d1e6973"
            name="id-issue-d1e6973"></a>Description</h3>

            <div>
              <p>The Static Typing Feature is claimed to have a
              property called "type soundness." However, Dana says
              she has counterexamples to the claim of type
              soundness as described in this section (Section
              2.4.2.3). (At least sequence type matching breaks
              TYPE SOUNDNESS so what else breaks it?) We need to
              examine the claim and make sure it is stated
              correctly.</p>
            </div>

            <h3><a id="id-issue-d1e6978"
            name="id-issue-d1e6978"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-11-12
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2002-11-14
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-01-09
              ([link to member only information] )</small></p>

              <p>Closed due to the definition of type errors in
              language and FS books.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>310. <a id="type-annotations-child-of-element"
          name="type-annotations-child-of-element"><u>type-annotations-child-of-element</u>:
          Are the children of a newly constructed element
          typed?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Dana F</b></small>Are the children of a
            newly constructed element typed?

            <h3><a id="id-issue-d1e7006"
            name="id-issue-d1e7006"></a>Description</h3>

            <div>
              <p>What happens with the type annotation of the
              children of a newly constructed element? Type
              annotation kept or given xs:anyType.</p>
            </div>

            <h3><a id="id-issue-d1e7011"
            name="id-issue-d1e7011"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-18
              ([link to member only information] )</small></p>

              <p>Decision to accept the propsal of Phil Wadler in
              <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>

              <p><small>Decision by: <b>xquery</b> on 2003-01-29
              ([link to member only information] )</small></p>

              <p>Decided to reopen the issue.</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small></p>

              <p>Decided NOT to reopen the issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>311. <a id="whitespace-attribute-constructors"
          name="whitespace-attribute-constructors"><u>whitespace-attribute-constructors</u>:
          Whitespace and Attribute Constructors</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator:</small> Whitespace and Attribute
            Constructors

            <h3><a id="id-issue-d1e7029"
            name="id-issue-d1e7029"></a>Description</h3>

            <div>
              <p>Whitespace in an XSLT attribute value template is
              significant insofar as it survives the XML rules for
              normalization of attributes. This means that CRLF
              combinations and tabs are normalized to x20 spaces,
              unless they are written as XML character references.
              I think it's an open question whether XQuery wants to
              emulate the XML attribute normalization rules.</p>

              <p>In XSLT,</p>

              <div class="exampleInner">
<pre>
&lt;foo bar="
   {'x'}
"/&gt;
</pre>
              </div>

              <p>will produce the result &lt;foo bar=" x "/&gt;</p>

              <p>while &lt;foo bar=""/&gt; produces an element
              containing an attribute whose value is a single CR
              character.</p>

              <p>If XQuery wants to reproduce this behavior
              exactly, then it's going to have to reproduce the XML
              treatment of whitespace as well as the XSLT
              treatment.</p>

              <p>But whether it does so or not, I think Mary is
              right that</p>

              <div class="exampleInner">
<pre>
&lt;foo bar=" {'x'} "/&gt;
</pre>
              </div>

              <p>should produce lt;foo bar=" x "/&gt; and not
              &lt;foo bar="x"/&gt;. There is a difference between
              element and attribute constructors: attributes have
              quotes around them, and this sets a different
              expectation.</p>
            </div>

            <h3><a id="id-issue-d1e7058"
            name="id-issue-d1e7058"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-04
              ([link to member only information] )</small></p>

              <p>Confirmed that Mary's proposal for whitespace,
              that was accepted 2002-11-27, closes this issue.</p>

              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Resolved by the recent adoption of the revised
              text on attribute constructors.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>316. <a id="cardinality-typed-comparison"
          name="cardinality-typed-comparison"><u>cardinality-typed-comparison</u>:
          Is anySimpleType = anySimpleType*?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Is anySimpleType
            = anySimpleType*?

            <h3><a id="id-issue-d1e7137"
            name="id-issue-d1e7137"></a>Description</h3>

            <div>
              <p>Given the following function:</p>

              <div class="exampleInner">
<pre>
define function foo(xs:anySimpleType $x) returns xs:anySimpleType {$x}
</pre>
              </div>

              <p>and the untyped data</p>

              <div class="exampleInner">
<pre>
&lt;a a="1"/&gt;&lt;a a="2"/&gt;&lt;a a="3"/&gt;
</pre>
              </div>

              <p>should the following be a (static or dyamic) type
              error or should it work?</p>

              <div class="exampleInner">
<pre>
foo(/a/@a)
</pre>
              </div>

              <p>If it should work, what should the following query
              return?</p>

              <div class="exampleInner">
<pre>
count(data(&lt;e&gt;1 2&lt;/e&gt;))
count(data(&lt;a b="1 2"/&gt;/@b))
</pre>
              </div>

              <p>Should it be 1 or 2?</p>
            </div>

            <h3><a id="id-issue-d1e7166"
            name="id-issue-d1e7166"></a>Proposed Resolution</h3>

            <div>
              <p>anySimpleType is the base type of all the
              *primitive* XML Schema datatypes.</p>

              <p>List and union types are *generated* (my word,
              Schema uses the word *derived*) from primitive types
              and thus, not included in anySimpleType. See the
              extract from the XML Schema datatypes spec below.</p>

              <p>"[Definition:] There exists a conceptual datatype,
              whose name is anySimpleType, that is the simple
              version of the ur-type definition from [XML Schema
              Part 1: Structures]. anySimpleType can be considered
              as the *base type* of all *primitive* types. The
              *value space* of anySimpleType can be considered to
              be the *union* of the *value space*s of all
              *primitive* datatypes."</p>

              <p>Thus, the function call above should result in a
              (static or dynamic, depending on typing conformance)
              type error.</p>

              <p>The count expressions would always return 1.</p>
            </div>

            <h3><a id="id-issue-d1e7183"
            name="id-issue-d1e7183"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
              ([link to member only information] )</small></p>

              <p>Decided that anySimpleType is a list one. This
              needs to be carried out clearly in the documents.</p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>To solve issues 316 and 524 we need to do
              eliminate three constructor functions from F&amp;O,
              and integrating with the changes described in the
              message:
              http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0021.html.</p>

              <p>This was agreed.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>317. <a id="extension-mechanism"
          name="extension-mechanism"><u>extension-mechanism</u>:
          XQuery Extension Mechanisms</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>extensions</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Andrew Eisenberg</b></small>XQuery
            Extension Mechanisms

            <h3><a id="id-issue-d1e7201"
            name="id-issue-d1e7201"></a>Description</h3>

            <div>
              <p>Issue: XQuery has not determined what extension
              mechanisms might be supported. XQuery may support the
              following:</p>

              <ul>
                <li>implementation-defined extensions to the XQuery
                grammar</li>

                <li>an XQuery-flagger that identifies extensions to
                XQuery 1.0</li>

                <li>implementation-defined extensions to the
                functions that are available to</li>

                <li>an XQuery author. The author would be required
                to explicitly declare the</li>

                <li>namespaces of any extension functions that are
                used</li>
              </ul>
            </div>

            <h3><a id="id-issue-d1e7218"
            name="id-issue-d1e7218"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e7226"
            name="id-issue-d1e7226"></a>Proposed Resolution</h3>

            <div>
              <div class="exampleInner">
<pre>
This proposal adds the following to the XQuery language document (in
section 2.5 Errors and Conformance):


2.5.5 Extensions

Conforming XQuery implementations are permitted to make two different kinds
of extensions to the specifications: grammar extensions and semantic
extensions. There are two types of grammar extensions: pragmas and
must-understand extensions. While an XQuery implementation may support some
or all of these types of extensions, this does not negate the requirement
to support the XQuery functionality defined in this specification.


2.5.5.1 Pragmas

A pragma may be used to provide additional information to an XQuery
implementation.

[x1]  Pragma            ::=   "(::" "pragma" PragmaQName PragmaContents
"::)"

[x2]  PragmaQName       ::=   ExplicitQName

[x3]  ExplicitQName     ::=   QName

[x4]  PragmaContents    ::=   .*

An ExplicitQName requires that QName contain a Prefix. Pragmas may be used
anywhere that ignorable whitespace is allowed, and within element content.
See A.1 Lexical structure for the exact lexical states where pragmas are
recognized. A pragma is identified by its PragmaQName.

If an implementation does not support a pragma, then that pragma shall be
ignored. If an implementation does support a pragma and the implementation
determines that the PragmaContents are invalid, then a static error is
raised. Otherwise, the effect of the pragma on the result of the Query is
implementation-defined.

The following example shows how a pragma might be used:

   declare namespace exq = "http://example.org/XQueryImplementation"

   (:: pragma exq:timeout 1000 ::)

   count(input()//author)

An implementation that supports the exq:timeout pragma might raise a
dynamic  error if it is unable to count the authors within 1000 seconds. An
implementation that did not support this pragma would execute as long as
necessary to count the authors.


2.5.5.2 Must-Understand Extensions

An implementation may extend the XQuery grammar by supporting
must-understand extensions.

[y1]  MustUnderstandExtension ::=
            "(::" "extension" ExtensionQName ExtensionContents "::)"

[y2]  ExtensionQName          ::=   ExplicitQName

[y3]  ExtensionContents ::=   .*

A MustUnderstandExtension may be used anywhere that ignorable whitespace is
allowed, and within element content. See A.1 Lexical structure for the
exact lexical states where pragmas are recognized. A must-understand
extension is identified by its ExtensionQName.

If an implementation does not support a must-understand extension, then a
static error is raised. If an implementation does support an
must-understand extension and the implementation determines that the
ExtensionContents are invalid, then a static error is raised. Otherwise,
the effect of the must-understand extension on the result of the Query
being executed is implementation-defined.

The following example shows how a must-understand extension might be used:

   declare namespace exq = "http://example.org/XQueryImplementation"

   for $e in doc("employees.xml")//employee
   order by $e/lastname (:: extension exq:RightToLeft ::)
   return $e

An implementation that supports the exq:RightToLeft must-understand
extension might order the last names by examining characters from right to
left instead of left to right. An implementation that did not support this
must-understand extension would raise a static error.


2.5.5.3 Semantic Extensions

An implementation may extend XQuery by supporting semantic extensions. A
semantic extension allows a conforming Query to be processed in a
non-conforming way. The way in which such semantic extensions are enabled
is implementation-defined.

The effect of a semantic extension on the result of a Query is
implementation-defined.

The following example shows how a command line might be used to enable a
semantic extension:

   xquery q12.xquery
   98

   xquery q12.xquery -EmptyIdentity=on
   100

The execution of the query contained in q12.xquery might treat an empty
sequence as 0 when it is being used in addition and subtraction and treat
it as 1 when it is being used in multiplication and division.


2.5.5.4 XQuery Flagger

An XQuery Flagger is a facility that is provided by an implementation that
is able to identify queries that contain extensions other than pragmas. If
an implementation supports extensions other than pragmas, then an XQuery
Flagger must be provided. The XQuery Flagger is disabled by default; the
mechanism by which the XQuery Flagger is enabled is implementation-defined.
When enabled, the XQuery Flagger will raise a static error for an otherwise
valid Query that contains either must-understand extensions or semantic
extensions.

An XQuery Flagger is provided to assist programmers in producing queries
that are portable among multiple conforming XQuery implementations.

The following examples show how an XQuery Flagger might be used:

   xquery q10.xquery
   &lt;employee&gt; ... &lt;/employee&gt;

   xquery q10.xquery -Flagger=on
   [static error] A must-understand extension is being used:
   exq:RightToLeft

   xquery q12.xquery -EmptyIdentity=on
   100

   xquery q12.xquery -EmptyIdentity=on -Flagger=on
   [static error] A semantic extension is being used: EmptyIdentity
</pre>
              </div>

              <p>Updates to proposal:</p>

              <p>- Usage of (:: ::) syntax.</p>

              <p>- must-understand extension.</p>
            </div>

            <h3><a id="id-issue-d1e7240"
            name="id-issue-d1e7240"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-03-12
              ([link to member only information] )</small></p>

              <p>#1 PRAGMAS: Adopted Unanimously.</p>

              <p>#2 MUST-UNDERSTAND EXTENSIONS: Adopted.</p>

              <p>#3 SEMANTIC EXTENSIONS: Rejected.</p>

              <p>#4 FLAGGER: Adopted.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>318. <a id="sort-in-FLWR"
          name="sort-in-FLWR"><u>sort-in-FLWR</u>: Add 'order by'
          clause to FLWR?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>Add 'order
            by' clause to FLWR?

            <h3><a id="id-issue-d1e7256"
            name="id-issue-d1e7256"></a>Description</h3>

            <div>
              <p>Four issues were raised in a proposal to
              restructure sorting in XQuery [1]:</p>

              <p>1. Should we add an 'order by' clause to FLWR?</p>

              <p>The following syntax has been proposed:</p>

              <div class="exampleInner">
<pre>
FLWRExpr ::= (ForClause |  LetClause)+ SortClause? WhereClause?
"return"  Expr
OrderClause ::=  "order by" stable? SortSpecList
SortSpecList ::= Expr SortModifier ("," SortSpecList)?
SortModifier ::= ("ascending" |  "descending")? ("empty" "greatest"
|  "empty" "least")?
</pre>
              </div>

              <p>The OrderClause sorts the tuple stream based on
              the conditions specified in the SortSpecList.</p>

              <p>In the status quo, 'sortby' is a standalone
              postfix expression. FLWR is used to iterate, and
              'sortby' is used to sort. This causes certain
              difficulties, because iteration and sorting are not
              distinct, unrelated operations - in general, the
              order in which the output sequence is ordered
              determines the best order to choose when iterating
              over the input.</p>

              <p>When sorting data created with element
              constructors, it can sometimes be quite tricky to
              determine the original source of data in a
              constructed element. The more complex the expressions
              that construct the element, the more tricky this
              becomes. It is also tricky to iterate in an order
              determined by data that is not returned in a
              generated sequence.</p>

              <p>If we add this clause, should a FLWOR expression
              that contains an OrderClause but no ForClause result
              in a semantic error, since there is no tuple stream
              to sort?</p>

              <p>2. If we add an 'order by' clause, should we keep
              the sortby() expression, or remove it from our
              language?</p>

              <p>Keeping it is convenient for some expressions.
              Removing it leaves us with a simpler language, and
              does not require us to explain to our users why we
              have two ways of doing the same thing.</p>

              <p>3. How should we formalize 'order by' - or should
              we formalize it in Version 1.0?</p>

              <p>The most straightforward way to formalize 'order
              by' is to use tuples, which do not exist in our Data
              Model, and these would cause significant change to
              our Formal Semantics. However, the semantics of
              'order by' are straightforward.</p>

              <p>Our options seem to be:</p>

              <p>3.a. Ensure that we know how it would be
              formalized using tuples, but postpone including this
              in the Formal Semantics until after Version 1.</p>

              <p>3.b. Refuse to add the feature unless it can be
              formalized with our current Data Model.</p>

              <p>3.c. Restrict the feature to functionality easily
              formalized with our current Data Model.</p>

              <p>I believe there was significant enthusiasm for
              3.a. in today's telcon.</p>

              <p>4. Is the 'order by' clause part of the XPath
              spec, or is it only in XQuery?</p>

              <p>Jonathan</p>

              <p>[1]
              http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Jul/0177.html</p>
            </div>

            <h3><a id="id-issue-d1e7318"
            name="id-issue-d1e7318"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e7322"
            name="id-issue-d1e7322"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
              ([link to member only information] )</small></p>

              <p>'order by' has been added.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>319. <a id="namespace-definitions-and-validate"
          name="namespace-definitions-and-validate"><u>namespace-definitions-and-validate</u>:
          Namespace definitions and in-scope namespaces</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>namespaces</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XPath TF</b></small>Namespace
            definitions and in-scope namespaces

            <h3><a id="id-issue-d1e7332"
            name="id-issue-d1e7332"></a>Description</h3>

            <div>
              <p>Addition of namespaces in the query prolog to the
              in-scope namespaces; how is this information carried
              through to provide input to validation?</p>

              <p>Additional aspecs are:</p>

              <p>(a) the whole question of how the namesapce
              context is affected by namespace declarations in
              element constructors</p>

              <p>(b) the general notion (in XQuery, specifically),
              that the static context can vary for different parts
              of a query</p>

              <p>(c) what information gets through to act as input
              to validation</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>320. <a id="types-conformancelevels-same-results"
          name="types-conformancelevels-same-results"><u>types-conformancelevels-same-results</u>:
          Should different conformance levels give the same result
          for the same query and data?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Anders Berglund</b></small>Should
            different conformance levels give the same result for
            the same query and data?

            <h3><a id="id-issue-d1e7355"
            name="id-issue-d1e7355"></a>Description</h3>

            <div>
              <p>Are different conformance levels going to give the
              same results? Is it possible to get different results
              for the same query? The principle should be that you
              either get the same result or a failure. Currently
              this isn't the case.</p>
            </div>

            <h3><a id="id-issue-d1e7360"
            name="id-issue-d1e7360"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Anders
              Berglund:</p>

              <p>[link to member only information] Kristoffer
              Rose:</p>
            </div>

            <h3><a id="id-issue-d1e7370"
            name="id-issue-d1e7370"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>proc-mod-tf</b> on
              2003-02-11 ([link to member only information]
              )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-19
              ([link to member only information] )</small></p>

              <p>Given that types add semantics, there is no way to
              achieve the proposed principle between basic XQuery
              and schema import without adding additional
              specification in the query.</p>

              <p>It is decided not to add any such functionality
              and close this issue without action.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>321. <a id="validate-lax-strict"
          name="validate-lax-strict"><u>validate-lax-strict</u>: Is
          validate strict or lax?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>validate</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XSL/XQuery joint</b></small>Is validate
            strict or lax?

            <h3><a id="id-issue-d1e7383"
            name="id-issue-d1e7383"></a>Description</h3>

            <div>
              <p>Does "validate" do strict or lax validation?</p>
            </div>

            <h3><a id="id-issue-d1e7388"
            name="id-issue-d1e7388"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-18
              ([link to member only information] )</small></p>

              <p>Decision to accept the propsal of Phil Wadler in
              <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>322. <a id="validate-lax-strict-override"
          name="validate-lax-strict-override"><u>validate-lax-strict-override</u>:
          "validate" strict/lax override?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>validate</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XSL/XQuery joint</b></small>"validate"
            strict/lax override?

            <h3><a id="id-issue-d1e7400"
            name="id-issue-d1e7400"></a>Description</h3>

            <div>
              <p>Should the user should be able to override which
              type (strict/lax) of validation "validate" does?</p>
            </div>

            <h3><a id="id-issue-d1e7405"
            name="id-issue-d1e7405"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-18
              ([link to member only information] )</small></p>

              <p>Decision to accept the propsal of Phil Wadler in
              <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>325. <a id="element-def-not-in-in-scope"
          name="element-def-not-in-in-scope"><u>element-def-not-in-in-scope</u>:
          Refering to element that is not in the in-scope schema
          def.</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>XQuery</b></small>Refering to element
            that is not in the in-scope schema def.

            <h3><a id="id-issue-d1e7451"
            name="id-issue-d1e7451"></a>Description</h3>

            <div>
              <p>In recent discussions on the type system and when
              reviewing the documents I noticed that many people
              interpret</p>

              <div class="exampleInner">
<pre>
element foo
</pre>
              </div>

              <p>differently than the spec indicates it needs to be
              interpreted. This seems to indicate that we have a
              problem.</p>

              <p>The semantics that people expect seems to be:</p>

              <p>element foo is the same as element foo of type
              xs:anyType and matches all elements with the given
              name (regardless where or whether the element was
              declared in the schema).</p>

              <p>attribute foo is the same as attribute foo of type
              xs:anySimpleType and matches all attributes with the
              given name regardless where or whether it was
              declared in the schema).</p>

              <p>However our spec [1] says:</p>

              <p>Another form of ElemOrAttrType is simply a QName,
              which is interpreted as the required name of the
              element or attribute. The QName must be an element or
              attribute name that is found in the in-scope schema
              definitions. The match is successful only if the
              given element or attribute has the required name and
              also conforms to the schema definition for the
              required name. This can be verified in either of the
              following ways:</p>

              <p>If the schema definition for the required name has
              a named type, the given element or attribute must
              have a type annotation that is the same as that named
              type or is known (in the in-scope schema definitions)
              to be derived from that named type. For example,
              suppose that a schema declares the element named
              location to have the type State. Then the
              SequenceType element location will match a given
              element only if its name is location and its type
              annotation is State or some named type that is
              derived from State.</p>

              <p>If the schema definition for the required name has
              an anonymous (unnamed) type definition, the actual
              content of the given element or attribute must
              structurally comply with this type definition. For
              example, suppose that a schema declares the element
              named shippingAddress to have an anonymous complex
              type consisting of a street element followed by a
              city element. Then the SequenceType element
              shippingAddress will match a given element only if
              its name is shippingAddress and its content is a
              street element followed by a city element.</p>

              <p>The constraint that an element must have a
              required name is considered to be satisfied if the
              element has been validated and found to be a member
              of a substitution group whose head element has the
              required name. Substitution groups are described in
              [XML Schema].</p>

              <p>which seems to indicate that this is not the
              case.</p>

              <p>I would like to open an issue on this. I think
              even if people do not want to use schema types, they
              may still want to restrict the argument type of a
              function to an element with a given name.</p>

              <p>In addition, many people are surprised to see the
              SchemaContext in the SequenceType production for
              other usages than for validate in ...</p>

              <p>While there is a use case, I wonder whether this
              needs to be a required feature for XQuery V1 given
              the leap in complexity. Maybe it would be useful to
              solve the above problem by saying that you have to
              use</p>

              <div class="exampleInner">
<pre>
element foo in /
</pre>
              </div>

              <p>to force the name to be in the in-scope schema
              definition? This would mean that / becomes allowed in
              the SchemaGlobalContext production.</p>
            </div>

            <h3><a id="id-issue-d1e7504"
            name="id-issue-d1e7504"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p><small>Decision by: <b>xsl</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p>In sequence type it is an error, it is valid in a
              path expression.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>327. <a id="functions-parameter-evaluation"
          name="functions-parameter-evaluation"><u>functions-parameter-evaluation</u>:
          Evaluate unused function parameters?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>functions</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XSL/XQuery joint</b></small>Evaluate
            unused function parameters?

            <h3><a id="id-issue-d1e7535"
            name="id-issue-d1e7535"></a>Description</h3>

            <div>
              <p>Is an implementation obligated to evaluate all its
              parameters (and raise any errors doing so) even when
              they're not needed in the function body?</p>
            </div>

            <h3><a id="id-issue-d1e7540"
            name="id-issue-d1e7540"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-10-29
              ([link to member only information] )</small>as part
              of Agendum 1.</p>

              <p>There is no need to evaluate "non needed"
              expressions.</p>

              <p><small>Decision by: <b>xquery</b> on 2002-10-30
              ([link to member only information] )</small>accepting
              text for next publication, but keep issue active.</p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-31
              ([link to member only information] )</small>accepting
              text for next publication, but keep issue active.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-18
              ([link to member only information] )</small></p>

              <p>No adverse public comments received. Close issue
              with no change.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>328. <a id="cdata-section"
          name="cdata-section"><u>cdata-section</u>: What does
          CDATA section constructor construct?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>cdata
            section</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>What does CDATA
            section constructor construct?

            <h3><a id="id-issue-d1e7558"
            name="id-issue-d1e7558"></a>Description</h3>

            <div>
              <p>Section 3.7.5 describes CDATA section constructor,
              but these cannot be represented in the data
              model.</p>
            </div>

            <h3><a id="id-issue-d1e7563"
            name="id-issue-d1e7563"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Decided to close, with document changes as
              described by Mike Kay in <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
              including editorial comments.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>329. <a id="duplicate-attribute-constructors"
          name="duplicate-attribute-constructors"><u>duplicate-attribute-constructors</u>:
          Duplicate attribute constructors</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>constructors</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>Duplicate
            attribute constructors

            <h3><a id="id-issue-d1e7575"
            name="id-issue-d1e7575"></a>Description</h3>

            <div>
              <p>If there are multiple constructors for the same
              attribute on an element; which one is taken or is it
              an error?</p>
            </div>

            <h3><a id="id-issue-d1e7580"
            name="id-issue-d1e7580"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Decided to make it an error for an element
              constructor to specify two attributes with the same
              name. Error to be documented in XQuery Section
              3.7.4.1.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>334. <a id="xquery-failed-validation"
          name="xquery-failed-validation"><u>xquery-failed-validation</u>:
          How are documents for which validation has failed
          processed?</a></h2>

          <div>
            <small>Issue Class: <b>T</b> Locus: <b>xpath</b>
            Cluster: <b>type-semantics</b> Priority: <b>1</b>
            Status: <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>How are
            documents for which validation has failed processed?

            <h3><a id="id-issue-d1e7688"
            name="id-issue-d1e7688"></a>Description</h3>

            <div>
              <p>What is the result of a failed validation? Can you
              inspect the result to detect this? Do you just get
              anySimpleType and anyType?</p>
            </div>

            <h3><a id="id-issue-d1e7693"
            name="id-issue-d1e7693"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e7699"
            name="id-issue-d1e7699"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Access to documents that fail validation is not
              supported.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>335. <a id="semantics-interfering-with-optimization"
          name="semantics-interfering-with-optimization"><u>semantics-interfering-with-optimization</u>:
          XPath/XQuery's current semantics greatly interferes with
          optimization</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>formal-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>XPath/XQuery's
            current semantics greatly interferes with optimization

            <h3><a id="id-issue-d1e7713"
            name="id-issue-d1e7713"></a>Description</h3>

            <div>
              <p>Current semantics basically defines the semantics
              by mapping FLWRs and path expression to go top-down.
              Errors are normative. Problem is that we can not
              apply many optimizations. Simple query rewrites such
              as pushing or pulling filters, etc. Like to be able
              to push predicates down and evaluate them.
              Potentially the predicate might raise an error you
              would not have gotten if you processed top down. Want
              to allow implementations to do bottom up
              evaluations.</p>

              <p>Suggested resolution:</p>

              <p>The formal semantics defines dynamic evaluation in
              terms of a naive, top-down reduction of a core
              expression to a data-model value. Implementations may
              choose alternative evaluation strategies, which, for
              example, may reduce a core expression bottom-up. If
              an evaluation of a core expression yields a value
              (i.e., it does not raise an error), the value must be
              the same value as would be produced by the dynamic
              semantics defined in this document. The evaluation of
              a core expression may raise an error that may not be
              raised by the dynamic semantics as defined in this
              document.</p>
            </div>

            <h3><a id="id-issue-d1e7724"
            name="id-issue-d1e7724"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-10-29
              ([link to member only information] )</small>as part
              of Agendum 1.</p>

              <p>Expressions, with the exception of "if", may be
              reordered and thus some errors may be raised that
              using another evaluation strategy may not have
              occurred.</p>

              <p><small>Decision by: <b>xquery</b> on 2002-10-30
              ([link to member only information] )</small>accepting
              text for next publication, but keep issue active.</p>

              <p><small>Decision by: <b>xsl</b> on 2002-10-31
              ([link to member only information] )</small>accepting
              text for next publication, but keep issue active.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-18
              ([link to member only information] )</small></p>

              <p>No adverse public comments received. Close issue
              with no change.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>338. <a id="whitespace-character-reference"
          name="whitespace-character-reference"><u>whitespace-character-reference</u>:
          Handling of whitespace and character references</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>Handling of
            whitespace and character references

            <h3><a id="id-issue-d1e7764"
            name="id-issue-d1e7764"></a>Description</h3>

            <div>
              <p>The effect of CharRef in Element or Attribute
              content is underspecified. For example, if the value
              of the CharRef is whitespace, does it behave like
              whitespace in Element or Attribute content, or does
              it behave like ordinary characters? Either way, it is
              hard to make it behave exactly like the XML construct
              that it mimics: in XML, a character reference such as
              suppresses certain effects such as whitespace
              normalization. It is not clear whether such
              normalization happens in XQuery.</p>
            </div>

            <h3><a id="id-issue-d1e7769"
            name="id-issue-d1e7769"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e7775"
            name="id-issue-d1e7775"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-04
              ([link to member only information] )</small></p>

              <p>Confirmed that Mary's proposal for whitespace,
              that was accepted 2002-11-27, closes this issue.</p>

              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>Resolved by the recent adoption of the revised
              text on attribute constructors.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>339. <a id="element-attribute-construction-order"
          name="element-attribute-construction-order"><u>element-attribute-construction-order</u>:
          Error type for attributes constructed too late</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>errors</b>
            Priority: <b>2</b> Status: <b>decided</b><br />
             Originator: <b>Don Chamberlin</b></small>Error type
            for attributes constructed too late

            <h3><a id="id-issue-d1e7788"
            name="id-issue-d1e7788"></a>Description</h3>

            <div>
              <p>What kind of error should be raised by an element
              constructor in which an attribute is encountered
              after other element content?</p>
            </div>

            <h3><a id="id-issue-d1e7793"
            name="id-issue-d1e7793"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2002-12-11
              ([link to member only information] )</small></p>

              <p>This a type error. Type error to be documented in
              XQuery Section 3.7.2.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>340. <a id="errors-unique-identification"
          name="errors-unique-identification"><u>errors-unique-identification</u>:
          How to identify errors?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>errors</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XPath TF</b></small>How to identify
            errors?

            <h3><a id="id-issue-d1e7803"
            name="id-issue-d1e7803"></a>Description</h3>

            <div>
              <p>How should we allocate codes or identifiers to
              errors defined in the spec? We should not use
              "explanatory sentences" as these are not appropriate
              for I18N reasons.</p>
            </div>

            <h3><a id="id-issue-d1e7808"
            name="id-issue-d1e7808"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p><small>Decision by: <b>xsl</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p>(not really an issue); Ashok and Norm will
              investigate whether we can editorially markup errors
              consistently.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-01-07
              ([link to member only information] )</small></p>

              <p>Issue should remain open pending proposal on:
              ACTION XPATH-091-11 Mary adds herself to
              XPATH-091-11.</p>

              <p><small>Decision by: <b>xpath-tf</b> on 2003-04-08
              ([link to member only information] )</small></p>

              <p>1. All occurrences of static and dynamic errors
              should be identified in the F&amp;O, DM, language,
              and FS specs using distinguished error markup.</p>

              <p>2. Error markup should include unique
              alpha-numeric identifier for each error which permits
              the source to refer to unique error definitions and
              to include reverse indices on errors.</p>

              <p>3. In first cut, alpha-numeric error codes will
              not be revealed in printed documents, but we can
              reveal them at a later time if we decide to make
              error codes part of conformance requirements.</p>

              <p>4. Until we consider an API for conveying errors
              to the evaluation environment, we recommend *not*
              requiring implementations to return specific error
              codes (and possibly additional context info such as
              location of error in query body or name of built-in
              function, etc.)</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>341. <a id="SequenceType-problems"
          name="SequenceType-problems"><u>SequenceType-problems</u>:
          Problems with SequenceType</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>Problems with
            SequenceType

            <h3><a id="id-issue-d1e7834"
            name="id-issue-d1e7834"></a>Description</h3>

            <div>
              <p>Using the "instance of SequenceType" construct
              within a predicate of a path expression, or in an
              XSLT match pattern, is very unwieldy: the verbose
              English-like syntax of a SequenceType does not go
              well with the terse syntax of path expressions,
              leading to inelegant constructs like</p>

              <div class="exampleInner">
<pre>
select="//*[.instance of element of type address]"
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e7842"
            name="id-issue-d1e7842"></a>Interactions and Input</h3>

            <div>
              <p>[link to member only information] Michael Kay:</p>
            </div>

            <h3><a id="id-issue-d1e7846"
            name="id-issue-d1e7846"></a>Proposed Resolution</h3>

            <div>
              <div class="exampleInner">
<pre>
1. Motivation

Many people have asked for the ability to test for elements of a given
type in path expressions, and to be able to write path expressions
that would retrieve nodes with types that match the declared types of
function parameters. For instance, consider the following query in the
syntax of our current Working Draft:

       define function name($e as element person)
         returns element name
       {
            $e/name
       }

       for $p in input()//person
       return name($p)

This query can fail at runtime, because the path expression matches
any element named person, and the function parameter requires a valid
element conforming to a globally declared element named person.

This proposal adds ElementType and AttributeType nodetests to path
expressions, and aligns the syntax of SequenceType with the syntax of
type tests done in path expressions. For instance, in the following
syntax, the KindTest "element(person)" matches only person elements
that are valid instances of the globally declared person element, and
the same test is used for the function's parameter type:

       define function name($e as element(person))
         returns element name
       {
            $e/name
       }

       for $p in input()//element(person)
       return name($p)

Using the same syntax and semantics for these tests in both path
expressions and SequenceType ensures that they are well aligned, and
reduces the number of expressions users of the language must learn. In
addition, it allows us to fix some problems with SequenceType that
have made the grammar complex to maintain.

ElementType and AttributeType nodetests also allow the names of types
to be used to select nodes, eg:

       define function name($e as element(person, surgeon))
         returns element name
       {
            $e/name
       }


       for $p in input()//element(person, surgeon)
       return name($p)

Or:

      for $date in input()//element(*, xs:date)
      return &lt;date&gt;{ $date }&lt;/date&gt;

Note that the above queries provide enough type information to be
statically valid without 'treat as'. If a NameTest were used instead
of the ElementType nodetest, the above query would not be statically
valid, and the query writer would need to use treat as to make it so.

Using this proposal, the most convenient way to match locally declared
types in a path expression is to use the globally declared types in
which they are contained to establish a type context; eg, the
following query from use case STRONG is statically valid as modified
below:


define function names-match(
    $s as element(ipo:purchaseOrder/ipo:shipTo),
    $b as element(ipo:purchaseOrder/ipo:billTo)
    as xs:boolean
{
        $s/ipo:name = $b/ipo:name
}

for $p in document("ipo.xml")//element(ipo:purchaseOrder)
where not( names-match( $p/ipo:shipTo, $p/ipo:billTo ) )
return $p


ElementType and AttributeType nodetests can also be used in match
patterns on XSLT stylesheets, eg:

     &lt;xsl:template match="element(person)"&gt;

     &lt;xsl:template match="attribute(*,xs:date)"&gt;

For more examples of ElementType and AttributeType nodetests in match
patterns, see [1].

This proposal steals liberally from proposals by Phil Wadler, Jeni
Tennison, Michael Rys, and Mike Kay. Don Chamberlin gave detailed
review and pointed out important problems and their solutions.  Scott
Boag tested the grammar.


========================================================================
2. Examples of ElementTypeTest and AttributeTypeTest

Informally, the principles for matching an ElementTypeTest or
AttributeTypeTest are as follows:

- element() matches elements, attribute() matches attributes.

- names in ElementTypeTest and AttributeTypeTest test the name of a
   node. If the name of an element identifies a Corresponding Element
   Declaration which is the head of a substitution group, the name of
   an ElementTypeTest also matches other names in the substitution
   group.

- types in ElementTypeTest and AttributeTypeTest match type
   annotations.  If no type is supplied, there must be a Corresponding
   Element Declaration or a Corresponding Attribute Declaration, which
   is used to nominate a type.

The following examples illustrate these semantics by stating what
nodes an ElementTypeTest would match.

  element()
  element(*)
  element(*,*)

    Matches any element. These three forms are equivalent.

  element( person )

    Matches any element named 'person' with the type corresponding to
    the globally declared 'person' element; if this element is
    nillable, also matches any empty element named person containing an
    xsi:nil attribute with the value 'true'. If the globally declared
    'person' element is the head of a substitution group, also matches
    element names from the substitution group. If there is no globally
    declared 'person' element, a type error is raised.

  element( person, * )

    Matches any element named person or any element whose name is in
    the substitution group of the globally declared element person, if
    one exists. This is equivalent to the earlier ~person syntax, which
    we feel is no longer needed.

  element( person, personType nillable )

    Matches any element named 'person' with the type 'personType',
    including any empty element named person containing an xsi:nil
    attribute with the value 'true'. If the globally declared 'person'
    element is the head of a substitution group, also matches element
    names from the substitution group.

  element( *, xs:integer nillable )

   Matches any element of type xs:integer, including any such element
   with xs:nil="true" and no content.

  element( foo/bar/person )

    Matches any element named 'person' with the type of the
    corresponding element declaration.

  element( foo/bar/person, personType )

    Syntax Error.

  attribute()

    Matches any attribute.

  attribute( foo/bar/person/@id )

    Matches any attribute named 'id' with the type of the corresponding
    attribute declaration.

  element( @*, xs:integer )

   Matches any attribute of type xs:integer.

  attribute( @price, xs:integer )

   Matches any attribute named price of type xs:integer.


========================================================================
3. Syntax


Tokens

Scott currently has the following as tokens, and is working on making
them productions:

[22]    SchemaGlobalContext    ::=    QName |  ("type" "(" QName ")")
[23]    SchemaContextStep    ::=    QName

Productions

[112]    SequenceType    ::=    (SequenceSingleType OccurrenceIndicator?)
                              |  &lt;"empty" "(" ")"&gt;
[113]    SequenceSingleType    ::=    AtomicType |  ItemType
[114]    AtomicType    ::=    QName
[115]    ItemType    ::=   KindTest |  &lt;"item" "(" ")"&gt;
[116]    KindTest    ::=   DocumentTest
                         |  ElementTypeTest
                         |  AttributeTypeTest
                         |  ProcessingInstructionTest
                         |  CommentTest
                         |  TextTest
                         |  AnyKindTest


[117]    DocumentTest    ::=    &lt;"document" "(" ")"&gt;
[118]    ElementTypeTest ::=    &lt;"element" "("&gt; ((SchemaContextPath LocalName)
                             |  (NodeName ("," TypeName "nillable"?)?))? ")"
[119]    AttributeTypeTest ::=  &lt;"attribute" "("&gt; ((SchemaContextPath "@"
LocalName)
                             |  ("@" NodeName ("," TypeName)?))? ")"
[120]    SchemaContextPath ::=  &lt;SchemaGlobalContext "/"&gt;
&lt;SchemaContextStep "/"&gt;*
[122]    LocalName    ::=    QName
[123]    NodeName    ::=    QName |  "*"
[124]    TypeName    ::=    QName |  "*"
[125]    OccurrenceIndicator    ::=    "*" |  "+" |  "?"


========================================================================
4. Semantics

A ContextName identifies a valid path from a globally declared element
declaration or type definition in the in-scope schema definitions. For
instance, the following indicates a shipTo element on a purchaseOrder:

   purchaseOrder/shipTo

If a ContextName begins with type(t), then the path starts with a
global named type in the in-scope schema definitions. For instance,
the following indicates a shipTo element in a complex type called
purchaseOrderType:

   type(purchaseOrderType)/shipTo

The rules for matching an ElementTypeTest depend on the Corresponding
Element Declaration, which is determined as follows:

   An ElementName is the first argument of an ElementTypeTest.

   If the ElementName has the form NodeName, and it matches the name of
   a globally declared element declaration in the in-scope schema
   definitions, it is the "Corresponding Element Declaration". If the
   ElementName has the form SchemaContextPath LocalName, then the
   element declaration which would correspond to an element named
   LocalName in the given context is the "Corresponding Element
   Declaration".

The rules for matching an AttributeTypeTest depend on the
Corresponding Attribute Declaration,

   An AttributeName is the first argument of an AttributeTypeTest.

   If the AttributeName has the form NodeName, and it matches the name
   of a globally declared element declaration in the in-scope schema
   definitions, it is the "Corresponding Element Declaration". If the
   AttributeName has the form SchemaContextPath LocalName, then the
   element declaration which would correspond to an element named
   LocalName in the given context is the "Corresponding Attribute
   Declaration".

An ElementTypeTest matches a node if the node is an element, the
element's name matches the ElementName of the ElementTypeTest, and the
element's type matches the type and nillability of the
ElementTypeTest.

An ElementName is matched as follows:

   If the ElementName is absent or "*", it matches an
   element of any name.

   If the ElementName has the form NodeName, it matches an element if
   the expanded-QNames of the element and the ElementName match. If the
   ElementName has the form SchemaContextPath LocalName, it matches an
   element if the expanded-QNames of the element and the LocalName
   match.

   If the Corresponding Element Declaration is the head of a
   substitution group, then the ElementName also matches an element if
   the expanded-QNames of the element and any element in the
   substitution group match.

   Otherwise, the ElementName does not match the element's name.

An element's TypeName is matched as follows:

   If the TypeName is "*", it matches an element of any type.

   If the TypeName is absent, then the default TypeName is selected,
   which is the type of the Corresponding Element Declaration. The
   default nillability is also selected, which is the nillability of
   the Corresponding Element Declaration.

   If the expanded-QName of the TypeName matches the element's type or
   any of its subtypes, then the TypeName matches the element's type if
   the type nillability is also satisfied.

   If the element's type name is an anonymous local type, the TypeName
   must be a default type chosen from the Corresponding Element
   Declaration, and they match if the element's type is the same as or
   derived by restriction or extension from the type of the TypeName,
   provided the type nillability is also satisfied.

   An element's type nillability is not satisified when the type is not
   nillable, and the element's dm:nil property is 'true'; otherwise, it
   is satisfied.

The semantics of AttributeTypeTest are parallel, substituting the word
'attribute' for 'element' in the above description and eliminating
substitution groups and nillable, which do not apply to attributes. An
AttributeTypeTest matches a node if the node is an attribute, the
attribute's name matches the AttributeName of the AttributeTypeTest, and
the attribute's type matches the type and nillability of the
AttributeTypeTest.


An AttributeName is matched as follows:

   If the AttributeName is absent or "*", it matches any attribute.

   If the AttributeName has the form NodeName, it matches an element if
   the expanded-QNames of the element and the AttributeName match. If
   the AttributeName has the form SchemaContextPath LocalName, it
   matches an element if the expanded-QNames of the element and the
   LocalName match.

   Otherwise, the AttributeName does not match the attribute's name.

An attribute's TypeName is matched as follows:

   If the TypeName is "*", it matches an attribute of any type.

   If the TypeName is absent, then the default TypeName is selected,
   which is the type of the corresponding attribute declaration.

   If the expanded-QName of the TypeName matches the attribute's type
   or any of its subtypes, then the TypeName matches the attribute.

   If the attribute's type name is an anonymous local type, the
   TypeName must be a default type chosen from the Corresponding
   Attribute Declaration, and they match if the attribute's type is the
   same as or derived by restriction or extension from the type of the
   TypeName.


========================================================================
6. attribute() and default axes

To allow attribute() to be used in path expressions, abbreviated steps
need to be modified as follows:

Current text:


   &gt;     The most important abbreviation is that child:: can be omitted
   &gt;     from a step. In effect, child is the default axis. For example,
   &gt;     a path expression section/para is short for
   &gt;     child::section/child::para.


Proposed text:


   &gt;     The most important abbreviation is that child:: can be omitted
   &gt;     from a step, or attribute:: can be omitted from a step that
   &gt;     contains an AttributeTypeTest. In most cases, child is the
   &gt;     default axis. For example, a path expression section/para is
   &gt;     short for child::section/child::para. However, if the step
   &gt;     contains an AttributeType, the default axis is attribute::. For
   &gt;     example, child::section/attribute( id ) is short for
   &gt;     child::section/attribute::attribute( id ).



========================================================================
7. Static Semantics

    To be supplied.


========================================================================
8. Issues

Issue:

     Should a WildCard be allowed for the names of attributes and
     elements? For instance, one might imagine wanting to select only
     HTML elements of type xs:string:

         element(html:*, xs:string)
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e7851"
            name="id-issue-d1e7851"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Proposal accepted resolving issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>343. <a id="namespaces-functions"
          name="namespaces-functions"><u>namespaces-functions</u>:
          Do functions in the null namespace clash with functions
          in the default namespace?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>namespaces</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XPath TF</b></small>Do functions in the
            null namespace clash with functions in the default
            namespace?

            <h3><a id="id-issue-d1e7881"
            name="id-issue-d1e7881"></a>Description</h3>

            <div>
              <p>If you define the DFN (default function namespace)
              to be the null namespace, which you must do if you
              are going to call functions in this namespace, can
              you still use unprefixed names to refer to functions
              in the built-in namespace?</p>
            </div>

            <h3><a id="id-issue-d1e7886"
            name="id-issue-d1e7886"></a>Interactions and Input</h3>

            <h3><a id="id-issue-d1e7890"
            name="id-issue-d1e7890"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-22
              ([link to member only information] )</small>A static
              error is raised when there is a clash between a
              user-defined function in the default namespace and
              any other function of the same name in the default
              namespace.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>437. <a id="FS-Issue-0094"
          name="FS-Issue-0094"><u>FS-Issue-0094</u>: Static type
          errors and warnings</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Don Chamberlin</b></small>Static type
            errors and warnings

            <h3><a id="id-issue-d1e9713"
            name="id-issue-d1e9713"></a>Description</h3>

            <div>
              <p>Static type errors and warnings are not specified.
              We need to enumerate in both the [XPath/XQuery] and
              formal semantics documents what kinds of static type
              errors and warnings are produced by the type system.
              See also [resolved issue #FS-Issue-0090].</p>
            </div>

            <h3><a id="id-issue-d1e9722"
            name="id-issue-d1e9722"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft describes the semantics of
              errors.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>441. <a id="FS-Issue-0098"
          name="FS-Issue-0098"><u>FS-Issue-0098</u>: Implementation
          of and conformance levels for static type
          checking</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Don
            Chamberlin</b></small>Implementation of and conformance
            levels for static type checking

            <h3><a id="id-issue-d1e9782"
            name="id-issue-d1e9782"></a>Description</h3>

            <div>
              <p>This issue is related to [resolved issue
              #FS-Issue-0059] Static type checking may be difficult
              and/or expensive to implement. Some discussion of
              algorithmic issues of type checking are needed. In
              addition, we may want to define "conformance levels"
              for [XPath/XQuery], in which some processors (or some
              processing modes) are more permissive about types.
              This would allow [XPath/XQuery] implementations that
              do not understand all of Schema, and it would allow
              customers some control over the cost/benefit tradeoff
              of type checking.</p>
            </div>

            <h3><a id="id-issue-d1e9789"
            name="id-issue-d1e9789"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Close issue 441 with no further work.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>443. <a id="FS-Issue-0100"
          name="FS-Issue-0100"><u>FS-Issue-0100</u>: Namespace
          resolution</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics?</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>FS Editors</b></small>Namespace
            resolution

            <h3><a id="id-issue-d1e9814"
            name="id-issue-d1e9814"></a>Description</h3>

            <div>
              <p>The way (when? where?) namespace prefixes are
              resolved is still an open issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>444. <a id="FS-Issue-0101"
          name="FS-Issue-0101"><u>FS-Issue-0101</u>: Support for
          mixed content in the type system</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster: 
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>FS Editors</b></small>Support for mixed
            content in the type system

            <h3><a id="id-issue-d1e9823"
            name="id-issue-d1e9823"></a>Description</h3>

            <div>
              <p>Support for mixed content in the type system is an
              open issue. This reopens issue [resolved issue
              #FS-Issue-0016]. Dealing with mixed content with
              interleaving raises complexity issue. See also <a
              href="#FS-Issue-0103">#FS-Issue-0103</a>.</p>
            </div>

            <h3><a id="id-issue-d1e9832"
            name="id-issue-d1e9832"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>The formal semantics is a specification of the
              behavior of an XQuery processor, not a recipe for
              implementation. The uses of interleaving in the
              specification are sufficiently restricted that a
              practical implementation can be written.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>446. <a id="FS-Issue-0103"
          name="FS-Issue-0103"><u>FS-Issue-0103</u>: Complexity of
          interleaving</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>FS Editors</b></small>Complexity of
            interleaving

            <h3><a id="id-issue-d1e9862"
            name="id-issue-d1e9862"></a>Description</h3>

            <div>
              <p>The current type system allows interleaving is
              allowed on arbitrary types. Interleaving is an
              expensive operation and it is not clear how to define
              subtyping for it. Should we restrict use of
              interleaving on (optional) atomic types ? Should this
              restriction reflects the one in XML schema ? Related
              to [resolved issue #FS-Issue-0077].</p>
            </div>

            <h3><a id="id-issue-d1e9869"
            name="id-issue-d1e9869"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>The formal semantics is a specification of the
              behavior of an XQuery processor, not a recipe for
              implementation. The uses of interleaving in the
              specification are sufficiently restricted that a
              practical implementation can be written.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>449. <a id="FS-Issue-0106"
          name="FS-Issue-0106"><u>FS-Issue-0106</u>: Constraint on
          attribute and element content models</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome</b></small>Constraint on
            attribute and element content models

            <h3><a id="id-issue-d1e9936"
            name="id-issue-d1e9936"></a>Description</h3>

            <div>
              <p>The [XPath/XQuery] type system allows more content
              model than what XML Schema allows. For instance, the
              current type grammar allows the following types:</p>

              <div class="exampleInner">
<pre>
   element d { (attribute a | element b, attribute c)* }
   attribute a { element b }
</pre>
              </div>

              <p>Section <a
              href="http://www.w3.org/TR/2003/WD-xquery-semantics-20030502/#sec_types">#FS-sec_types</a>
              indicates corresponding constraints on the
              [XPath/XQuery] type system to avoid that problem. The
              status of these constraints is unclear. When are they
              enforced and checked?</p>
            </div>

            <h3><a id="id-issue-d1e9949"
            name="id-issue-d1e9949"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Closed following the semantics of element
              constructors agreed at the December f2f meeting.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>450. <a id="FS-Issue-0107"
          name="FS-Issue-0107"><u>FS-Issue-0107</u>: Semantics of
          data()</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>FS Editors</b></small>Semantics of
            data()

            <h3><a id="id-issue-d1e9962"
            name="id-issue-d1e9962"></a>Description</h3>

            <div>
              <p>What is the semantics of data() applied to
              anything else than an element or attribute node ?</p>
            </div>

            <h3><a id="id-issue-d1e9967"
            name="id-issue-d1e9967"></a>Proposed Resolution</h3>

            <div>
              <div class="exampleInner">
<pre>
XQuery 1.0 and XPath 2.0 Data Model
W3C Working Draft 17 January 2003
http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0251.html

4.1.5 string-value Accessor
----------------------------

1. REPLACE entire section WITH:

    Every node has a string value; the way in which the string value
    is computed is different for each kind of node and is specified in
    the sections on nodes below.

4.1.6 typed-value Accessor
--------------------------

1. REPLACE:
      Otherwise, xs:anyType for elements or xs:anySimpleType for
attributes.

   WITH:
      Otherwise, xs:anyType for elements or xdt:untypedAtomic for
attributes.

2. REPLACE :

    * If the item is an element node with type xs:anyType, then its
      typed value is equal to its string value, as an instance of
      xdt:untypedAtomic.

  WITH:

    * If the node is an element node with type xs:anyType, then its
      typed value is equal to its string value, as an instance of
      xdt:untypedAtomic.

3. REPLACE :

    * The typed value of an element node with a simple type is derived
      from its string value and type in a way that is consistent with
      XML Schema validation.

  WITH:

    * If the node is an element node with a simple type or with a
      complex type of simple content, then its typed value is
      derived from its string value and type in a way that is
      consistent with XML Schema validation.

4. ADD:

    * If the item is an element node with complex type of empty
      content, then its typed value is the empty sequence.

    * If the node is an element node with a complex type of mixed
      content, then its typed value is its string value as an instance
      of xdt:untypedAtomic.

5. REPLACE:

    * If the item is an element node with complex content,
      dm:typed-value returns the empty sequence.

  WITH:

    * If the item is an element node with complex type of complex
      content, then its typed value is the empty sequence.

*************************************************
XQuery 1.0 and XPath 2.0 Functions and Operators
W3C Working Draft 10 December 2002
http://lists.w3.org/Archives/Member/w3c-archive/2002Dec/att-0035/02-xquery-operators.html

2.4 fn:data
-----------

1. REWRITE entire section as described in:
   http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0391.html

This text incorporates changes for nodes with complex type of mixed
content:

  fn:data($srcval as item*) as atomic value*

  The fn:data function takes a sequence of items and returns a
  sequence of atomic values.

  The result of fn:data is the sequence of atomic values produced by
  applying the following rules to each item in $srcval:

    If the item is an atomic value, it is returned.

    If the item is a node, fn:data returns the typed value of the
    node, as defined by the accessor function dm:typed-value defined
    for that kind of node in [XQuery 1.0 and XPath 2.0 Data Model].

    If the item is a comment, document, namespace,
    processing-instruction, or text node, then its typed value is
    equal to its string value, as an instance of xdt:untypedAtomic.

    If the item is an attribute node with type annotation
    xs:anySimpleType, then its typed value is equal to its string
    value, as an instance of xdt:untypedAtomic. The typed value of any
    other attribute node is derived from its string value and type
    annotation in a way that is consistent with XML Schema validation,
    as described in [XQuery 1.0 and XPath 2.0 Data Model].

    If the item is an element node whose type annotation
    denotes a complex type of empty content, then its typed value
    is equal to the empty sequence.

    If the item is an element node whose type annotation is xs:anyType
    or denotes a complex type of mixed content, then its typed value
    is equal to its string value, as an instance of xs:untypedAtomic.

    If the item is an element node whose type annotation denotes a
    simple type or a complex type of simple content, then its typed
    value is derived from its string value and type in a way that is
    consistent with XML Schema validation, as described in [XQuery 1.0
    and XPath 2.0 Data Model].

    If the item is an element node whose type annotation denotes a
    complex type with complex content (i.e., a type that permits
    subelements), fn:data raises a type error.

    [ Ed note: The typed-value accessor returns an empty sequence when
      applied to an element node with complex type of comple content,
      whereas fn:data() raises a type error, because type errors are a
      characteristic of the language, not the data model. ]

************************************************************************
XQuery 1.0: An XML Query Language
W3C Working Draft 15 November 2002
http://www.w3.org/TR/xquery/

and

XPath 2.0
W3C Working Draft 15 November 2002
http://www.w3.org/TR/xpath20/

2.3.2 Typed Value and String Value
----------------------------------

1. ADD definition of fn:data() as given above following:

  The typed value and string value for each kind of node are defined
  by the dm:typed-value and dm:string-value accessors in [XQuery 1.0
  and XPath 2.0 Data Model].

  The normative definitions are in the [XQuery 1.0 and XPath 2.0 Data
  Model] and is repeated here for convenience:

*****************************************************************************
XQuery 1.0 and XPath 2.0 Formal Semantics
W3C Working Draft 15 December 2002
http://lists.w3.org/Archives/Member/w3c-archive/2003Jan/0033.html

7.2.5 The fn:data function
--------------------------

1. This section is entirely rewritten to align with new semantics.

Introduction

  The fn:data function converts a sequence of items to a sequence of
  atomic values.

Notation

  Infering the type for the fn:data function is done by applying the
  fn:data function as a Filter, using the same approach as for the
  XPath steps.

    statEnv |- fn:data on Type1 : Type2

Static Type Analysis
--------------------

  The general rule for the function fn:data is to apply the filter
  [fn:data on] to the prime type of its argument type, then apply the
  quantifier to the result:

                 statEnv |- Expr : Type
          statEnv |- [fn:data on] prime(Type) : Type1
  ----------------------------------------------------
  statEnv |- fn:data(Expr) :  Type1 o quantifier(Type)


  The rules for the [fn:data on] filter always take a prime type
  (i.e., a union of item types) as an argument.

  When applied to none, [fn:data on] yields none.

    ---------------------------------
    statEnv |- [fn:data on] none : none


  When applied to the union of two types, [fn:data on] is applied to
each
  of the two types.  The resulting types are combined into a factored
  type.  This rule is necessary because [fn:data on] may return a
sequence
  of atomic types.


             statEnv |- [fn:data on] Type1 : Type3
             statEnv |- [fn:data on] Type2 : Type4
    ------------------------------------------------
    statEnv |- [fn:data on] Type1 | Type2 :
      prime(Type3 | Type4) o quantifier(Type3 | Type4)

  When applied to an atomic type, the [fn:data on] filter simply
  returns the atomic type:

                   Type &lt;: xdt:anyAtomicType
               ---------------------------------
               statEnv |- [fn:data on] Type : Type

  When applied to comment, processing instruction, text, and document
  node types, the [fn:data on] filter returns xdt:untypedAtomic.

   Type &lt;: comment | processing-instruction | text | document
  -----------------------------------------------------------
       statEnv |- [fn:data on] Type : xdt:untypedAtomic

  When applied to attribute node types with type annotation
  xs:anySimpleType or element node types with type annotation
  xs:anyType, the [fn:data on] filter returns xdt:untypedAtomic.

  statEnv |- AttributeType static lookup (of type xs:anySimpleType)
  -----------------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : xdt:untypedAtomic

  statEnv |- ElementType static lookup (of type xs:anyType)
  -----------------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : xdt:untypedAtomic

  When applied to an attribute type with any type annotation other
  than xs:anySimpleType, the [fn:data on] filter returns the attribute's
  simple type.

  statEnv |- AttributeType static lookup (of type TypeName)
             not(TypeName = xs:anySimpleType)
  statEnv |- (of type TypeName) expands to Type
  ----------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : Type

  When applied to an element type whose type annotation denotes a
  simple type or a complex type of simple content or a complex type of
  empty content, the [fn:data on] filter returns the element's simple
  type.

     statEnv |- ElementType static lookup TypeReference
     statEnv |- TypeReference expands to Type
                 Type &lt;: (Type1, Type2)
                 Type1 &lt;: AttributeType*
                Type2 &lt;: xs:anySimpleType
  ----------------------------------------------------------
          statEnv |- [fn:data on] ElementType : Type2

  When applied to an element type whose type annotation denotes a
  complex type of mixed content, the [fn:data on] filter returns
  xdt:untypedAtomic.

     statEnv |- ElementType static lookup (of type TypeName)
statEnv.typeDefn(TypeName) =&gt; define type TypeName Derivation? Mixed {
Type1? }
-------------------------------------------------------------------------------
        statEnv |- [fn:data on] ElementType : xdt:untypedAtomic

  The [fn:data on] filter is not defined on any element type whose
  type annotation denotes a complex type of complex content and
  therefore raises a static error.

Dynamic Evaluation
------------------

The dynamic semantics of fn:data() are specified in [2.4 fn:data] of
[XQuery 1.0 and XPath 2.0 Functions and Operators].
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e9972"
            name="id-issue-d1e9972"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-02-11
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-19
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-02-27
              ([link to member only information] )</small></p>

              <p>Proposal accepted.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>452. <a id="FS-Issue-0109"
          name="FS-Issue-0109"><u>FS-Issue-0109</u>: Semantics of
          order by</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome</b></small>Semantics of order by

            <h3><a id="id-issue-d1e10001"
            name="id-issue-d1e10001"></a>Description</h3>

            <div>
              <p>The precise semantics of order by is still open
              issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>453. <a id="FS-Issue-0110"
          name="FS-Issue-0110"><u>FS-Issue-0110</u>: Semantics of
          element and attribute constructors</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome</b></small>Semantics of element
            and attribute constructors

            <h3><a id="id-issue-d1e10012"
            name="id-issue-d1e10012"></a>Description</h3>

            <div>
              <p>The precise semantics of element constructors is
              still an open issue.</p>
            </div>

            <h3><a id="id-issue-d1e10017"
            name="id-issue-d1e10017"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Closed following the semantics of element
              constructors agreed at the December f2f meeting.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>455. <a id="FS-Issue-0112"
          name="FS-Issue-0112"><u>FS-Issue-0112</u>: Typing for the
          "typeswitch" default clause</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome</b></small>Typing for the
            "typeswitch" default clause

            <h3><a id="id-issue-d1e10050"
            name="id-issue-d1e10050"></a>Description</h3>

            <div>
              <p>There is an asymetry in the typing for the default
              clause in typeswitch vs. the other case clauses. This
              results in a less precise type when the default
              clause can be applied.</p>

              <p>It would be nicer to be able to have the type be
              more precise, like for the other case clauses.</p>

              <p>The technical problem is the need for some form of
              negation. I think one could define a
              "non-common-primes" function that would do the trick,
              but I leave that as open for now until further review
              of the new typeswitch section is made.</p>
            </div>

            <h3><a id="id-issue-d1e10061"
            name="id-issue-d1e10061"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-02-13 ([link to member only information]
              )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-19
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-02-27
              ([link to member only information] )</small></p>

              <p>Accepting proposal in <a
              href="#FS-Issue-0173">#FS-Issue-0173</a> resolves
              this issue.</p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Reaffirming decision.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>457. <a id="FS-Issue-0114"
          name="FS-Issue-0114"><u>FS-Issue-0114</u>: Dynamic
          context for current date and time</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome</b></small>Dynamic context for
            current date and time

            <h3><a id="id-issue-d1e10098"
            name="id-issue-d1e10098"></a>Description</h3>

            <div>
              <p>The following components dynamic contexts have no
              formal representation yet: current date and time.</p>

              <p>Related question: where are these context
              components used?</p>
            </div>

            <h3><a id="id-issue-d1e10106"
            name="id-issue-d1e10106"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Add current date and time in the Dynamic
              Environment.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>458. <a id="FS-Issue-0115"
          name="FS-Issue-0115"><u>FS-Issue-0115</u>: What is in the
          default context?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome</b></small>What is in the
            default context?

            <h3><a id="id-issue-d1e10119"
            name="id-issue-d1e10119"></a>Description</h3>

            <div>
              <p>What do the default namespace and type
              environments contain? I believe at least the default
              namespace environment should contain the "xs", "fn"
              and "op" prefixes, as well as the default namespaces
              bound to the empty namespace. Should the default type
              environment contain wildcard types?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>459. <a id="FS-Issue-0116"
          name="FS-Issue-0116"><u>FS-Issue-0116</u>:
          Serialization</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome</b></small>Serialization

            <h3><a id="id-issue-d1e10139"
            name="id-issue-d1e10139"></a>Description</h3>

            <div>
              <p>Serialization of data model instances, and XQuery
              results is still an open issue.</p>
            </div>

            <h3><a id="id-issue-d1e10144"
            name="id-issue-d1e10144"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Serialization is implemented in the data
              model.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>461. <a id="FS-Issue-0118"
          name="FS-Issue-0118"><u>FS-Issue-0118</u>: Data model
          syntax and literal values</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>Data model
            syntax and literal values

            <h3><a id="id-issue-d1e10175"
            name="id-issue-d1e10175"></a>Description</h3>

            <div>
              <p>Phil suggests the data model should support
              primitive literals in their lexical form, in which
              case no explicit dynamic semantic rule would be
              necessary.</p>

              <p>More generally, should the data model support a
              constructor syntax?</p>
            </div>

            <h3><a id="id-issue-d1e10183"
            name="id-issue-d1e10183"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>The corresponding syntax is going to be
              implemented in the formal semantics.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>472. <a id="FS-Issue-0129"
          name="FS-Issue-0129"><u>FS-Issue-0129</u>: Static typing
          of union</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Static typing of
            union

            <h3><a id="id-issue-d1e10398"
            name="id-issue-d1e10398"></a>Description</h3>

            <div>
              <p>What should be the semantics of arithmetics
              expressions over unions. Right now, it would raise a
              dynamic error. Do we want to raise a static
              error?</p>

              <p>Should operators and functions consistenly with
              respect to typing?</p>

              <p>With the current semantics in Section 4.5 expr1 +
              expr2 raises a static type error if (e.g.) expr1 has
              type string and expr2 has type integer. It raises
              only a dynamic error, if expr1 has type (string |
              integer) and expr2 has type integer, and expr1
              actually evaluates to a string. An alternative would
              be that this raises also a static error, because it
              cannot be guarantueed to succeed on all
              instances.</p>
            </div>

            <h3><a id="id-issue-d1e10409"
            name="id-issue-d1e10409"></a>Proposed Resolution</h3>

            <div>
              <p>For user-defined functions there is no issue and
              the current static typing rules work fine.</p>

              <p>There is an issue about static typing for built-in
              overloaded functions (arithmetic and comparison
              operators). In that case, the following algorithm is
              proposed:</p>

              <p>If one or both of the types of the operands are a
              union, static typing is performed for each par of
              item types in the union. If any of the cases raises a
              static type error, the whole static typing raises a
              static type error. Otherwise each resulting static
              type is unioned to form the final result type.</p>

              <p>Here are examples for the expression (E1 + E2) in
              the case of various input types:</p>

              <div class="exampleInner">
<pre>
     E1 : int and E2 : int
then E1 + E2 : int

     E1 : float and E2 : int
then E1 + E2 : float
</pre>
              </div>

              <p>those cases did not change. In case there is a
              union:</p>

              <div class="exampleInner">
<pre>
     E1 : (float | int) and E2 : int
then E1 + E2 : (float | int)
</pre>
              </div>

              <p>since both cases (int + int) and (float | int)
              could occur.</p>

              <div class="exampleInner">
<pre>
E1 : (float | int) and E2 : (int | string)
</pre>
              </div>

              <p>raises a static error since (int + string) raises
              a static error.</p>
            </div>

            <h3><a id="id-issue-d1e10441"
            name="id-issue-d1e10441"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Proposal accepted.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>473. <a id="FS-Issue-0130"
          name="FS-Issue-0130"><u>FS-Issue-0130</u>: When to
          process the query prolog</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome</b></small>When to process the
            query prolog

            <h3><a id="id-issue-d1e10451"
            name="id-issue-d1e10451"></a>Description</h3>

            <div>
              <p>The query prolog needs to be processed before the
              normalization phase. This is not reflected yet in the
              processing model.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>475. <a id="FS-Issue-0132"
          name="FS-Issue-0132"><u>FS-Issue-0132</u>: Typing for
          descendant</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Peter Fankhauser</b></small>Typing for
            descendant

            <h3><a id="id-issue-d1e10480"
            name="id-issue-d1e10480"></a>Description</h3>

            <div>
              <p>The current static typing for descendant is still
              under review and the inferences rules in that version
              are probably containing bugs.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>478. <a id="FS-Issue-0135"
          name="FS-Issue-0135"><u>FS-Issue-0135</u>: Semantics of
          special functions</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Kay</b></small>Semantics of
            special functions

            <h3><a id="id-issue-d1e10539"
            name="id-issue-d1e10539"></a>Description</h3>

            <div>
              <p>The current semantics does not completely cover
              built-in functions. Some functions used in the Formal
              semantics, or some functions from the XQuery 1.0 and
              XPath 2.0 Functions and Operators document need
              additional semantics specification.</p>
            </div>

            <h3><a id="id-issue-d1e10544"
            name="id-issue-d1e10544"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Ashok has posted a list of functions for which we
              need special typing rules:
              http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0027.html</p>

              <p>It is now editorial just to implement those typing
              rules in the formal semantics document.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>479. <a id="FS-Issue-0136"
          name="FS-Issue-0136"><u>FS-Issue-0136</u>:
          Non-determinism in the semantics</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Mary
            Fernandez</b></small>Non-determinism in the semantics

            <h3><a id="id-issue-d1e10559"
            name="id-issue-d1e10559"></a>Description</h3>

            <div>
              <p>Some operations, such as logical operations and
              quantified operations are not deterministics
              ("early-out" semantics allowing not to evaluate all
              of the expressions). The formal semantics cannot
              capture the non-determinism in those operations.</p>
            </div>

            <h3><a id="id-issue-d1e10564"
            name="id-issue-d1e10564"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft describes non deterministic
              semantics.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>481. <a id="FS-Issue-0138"
          name="FS-Issue-0138"><u>FS-Issue-0138</u>: Semantics of
          Schema Context</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>Semantics of
            Schema Context

            <h3><a id="id-issue-d1e10599"
            name="id-issue-d1e10599"></a>Description</h3>

            <div>
              <p>The semantics of Schema Context types in the
              SequenceType production is still an open issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>482. <a id="FS-Issue-0139"
          name="FS-Issue-0139"><u>FS-Issue-0139</u>: Type
          equivalence rules</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Type equivalence
            rules

            <h3><a id="id-issue-d1e10610"
            name="id-issue-d1e10610"></a>Description</h3>

            <div>
              <p>Should we add back equivalence rules for types
              (e.g., <code>T1** == T1*</code> or <code>(T1 | T1) ==
              T1</code>). They are useful in practical
              implementations (e.g., to print an infered type or
              reduce complexity of infered types), and could be
              added in an appendix.</p>
            </div>

            <h3><a id="id-issue-d1e10621"
            name="id-issue-d1e10621"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>Decided to add back equivalence rules.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>484. <a id="FS-Issue-0141"
          name="FS-Issue-0141"><u>FS-Issue-0141</u>: Treatment of
          nillability and xsi:nil</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Treatment of
            nillability and xsi:nil

            <h3><a id="id-issue-d1e10646"
            name="id-issue-d1e10646"></a>Description</h3>

            <div>
              <p>Nillability on an element declaration indicates
              that content of the corresponding element can be
              empty. The current data model preserves the xsi:nil
              attribute and this is used in the semantics at the
              type level. An alternative design would be to remove
              the xsi:nil attribute and add a 'nillable' marker in
              the schema component in the data model. This might be
              helping when we perform updates.</p>
            </div>

            <h3><a id="id-issue-d1e10651"
            name="id-issue-d1e10651"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
              ([link to member only information] )</small></p>

              <p>Guided by Jerome the following was decided:</p>

              <p>Assume: an element of type T may be nillable.
              Another element of type T may not be nillable.</p>

              <p>There is a Bug in language book re. type matching.
              Element with nil='true' does not have content
              according to the given type.</p>

              <p>Question 1 - Yes 10 Abstain 1, Recorded No from
              Vassilis</p>

              <p>Question 4 - Yes (unanimous) Do not know Vasillis
              votes.</p>

              <p>Question 3 - nil marker in datamodel and keep
              xsi:nil (both) Votes:1, 0, 8 MRys abstains as he
              wants update case clarified.</p>

              <p>Question 2 - Not relevant due to Yes answer to
              4.</p>

              <p><small>Decision by: <b>xquery</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p><small>Decision by: <b>xsl</b> on 2002-12-19
              ([link to member only information] )</small>Joint
              F2F</p>

              <p>Decided to accept Jerome's proposal in <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0352.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0352.html</a>.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>486. <a id="FS-Issue-0143"
          name="FS-Issue-0143"><u>FS-Issue-0143</u>: Support for
          PI, comment and namespace nodes</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>FS Editors</b></small>Support for PI,
            comment and namespace nodes

            <h3><a id="id-issue-d1e10696"
            name="id-issue-d1e10696"></a>Description</h3>

            <div>
              <p>The [XPath/XQuery] type system does not currently
              support PI nodes, comment nodes and namespace
              nodes.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>487. <a id="FS-Issue-0144"
          name="FS-Issue-0144"><u>FS-Issue-0144</u>: Representation
          of text nodes in formal values</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jonathan
            Robie</b></small>Representation of text nodes in formal
            values

            <h3><a id="id-issue-d1e10707"
            name="id-issue-d1e10707"></a>Description</h3>

            <div>
              <p>Formal Values described in section <a
              href="http://www.w3.org/TR/2003/WD-xquery-semantics-20030502/#sec_values">#FS-sec_values</a> represents
              either text nodes for well-formed documents or values
              for validated documents. Do we need to support a dual
              representation with both text nodes and values in the
              formal semantics?</p>
            </div>

            <h3><a id="id-issue-d1e10714"
            name="id-issue-d1e10714"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>The formal semantics will keep the current
              formalism for values which uses either atomic values
              or text, but not both. The current version is easier
              to read and understand.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>488. <a id="FS-Issue-0145"
          name="FS-Issue-0145"><u>FS-Issue-0145</u>: Static typing
          of path expressions in the presence of derivation by
          extension</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Static typing
            of path expressions in the presence of derivation by
            extension

            <h3><a id="id-issue-d1e10727"
            name="id-issue-d1e10727"></a>Description</h3>

            <div>
              <p>The current static type analysis rules for Step
              expressions is broken in the presence of derivation
              by extension. This bug is impacting section <a
              href="http://www.w3.org/TR/2003/WD-xquery-semantics-20030502/#sec_steps">#FS-sec_steps</a>.</p>
            </div>

            <h3><a id="id-issue-d1e10734"
            name="id-issue-d1e10734"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft fixes the static semantics
              of path expressions in the presence of derivation by
              extension.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>491. <a id="FS-Issue-0148"
          name="FS-Issue-0148"><u>FS-Issue-0148</u>: Validation of
          an empty string against a string list</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Validation of
            an empty string against a string list

            <h3><a id="id-issue-d1e10777"
            name="id-issue-d1e10777"></a>Description</h3>

            <div>
              <p>The formal semantics assumes that the result of
              validating an element with empty content or with an
              empty text node against a list of strings is the
              empty sequence, not the empty string. Is that
              consistent with XML Schema?</p>
            </div>

            <h3><a id="id-issue-d1e10782"
            name="id-issue-d1e10782"></a>Proposed Resolution</h3>

            <div>
              <p>I think XML Schema is clear that validating and
              empty element validated against a list type yields an
              empty element in the PSVI and therefore an empty
              element in the data model. In the formal semantics
              that corresponds to validating the content of the
              element to result in an empty sequence.</p>

              <p>I think this issue should be closed and that the
              current Formal Semantics documents is correct
              here.</p>
            </div>

            <h3><a id="id-issue-d1e10790"
            name="id-issue-d1e10790"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-12
              ([link to member only information] )</small></p>

              <p>JS's proposal ACCEPTED. No changes to the
              document.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>492. <a id="FS-Issue-0149"
          name="FS-Issue-0149"><u>FS-Issue-0149</u>: Derivation by
          extension in XQuery</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>Derivation by
            extension in XQuery

            <h3><a id="id-issue-d1e10800"
            name="id-issue-d1e10800"></a>Description</h3>

            <div>
              <p>If type u is derived from type t by extension,
              then the formal semantics document specifies that
              type u may appear wherever type t is expected. It is
              not clear what the XQuery document says on this
              point.</p>
            </div>

            <h3><a id="id-issue-d1e10805"
            name="id-issue-d1e10805"></a>Proposed Resolution</h3>

            <div>
              <p>The relevant text in the XQuery document can be
              found in Section 2.4.2.1, "SequenceType Matching",
              under the description of "ElemOrAttrType", Rules 1
              and 2.</p>

              <p>Rule 1 describes matching by type-name. It says
              "The match is successful only if the given element or
              attribute has a type annotation that is the same as
              the required type or ... derived from the required
              type."</p>

              <p>Rule 2 describes matching by element-name. It says
              "The match is successful only if the name of the
              given element or attribute is equal to the required
              name or ... derived from the required name, and if
              the element or attribute has been validated."</p>

              <p>Rules 1 and 2 do not distinguish between
              derivation by extension or by restriction, so by
              implication they apply to both kinds of derivation. I
              do not believe that Rules 1 and 2 were intended to
              apply to derivation by list or union. I believe this
              should be clarified by changing "derived" to "derived
              by restriction or extension" in Rules 1 and 2.</p>

              <p>I believe that this change will close Issue
              492.</p>
            </div>

            <h3><a id="id-issue-d1e10822"
            name="id-issue-d1e10822"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-29
              ([link to member only information] )</small></p>

              <p>Decided to accept proposal and thus resolving
              issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>493. <a id="FS-Issue-0150"
          name="FS-Issue-0150"><u>FS-Issue-0150</u>: May the
          content of a text node be the empty string?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>May the content
            of a text node be the empty string?

            <h3><a id="id-issue-d1e10832"
            name="id-issue-d1e10832"></a>Description</h3>

            <div>
              <p>May the content of a text node be the empty
              string? None of the formal semantics, the datamodel,
              or the XQuery document addresses this point.</p>
            </div>

            <h3><a id="id-issue-d1e10837"
            name="id-issue-d1e10837"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Add a constraint that a text node must consist of
              at least one character information items to the Data
              Model.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>496. <a id="FS-Issue-0153"
          name="FS-Issue-0153"><u>FS-Issue-0153</u>: Support for
          lax and strict wildcards</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>FS Editors</b></small>Support for lax
            and strict wildcards

            <h3><a id="id-issue-d1e10878"
            name="id-issue-d1e10878"></a>Description</h3>

            <div>
              <p>The Formal Semantics does not currently model lax
              and strict wildcards. The mapping in Section 7, only
              describes how XML Schema wilcards with the 'skip
              validation' semantics are imported into the XQuery
              Type System.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>499. <a id="FS-Issue-0156"
          name="FS-Issue-0156"><u>FS-Issue-0156</u>: Casting and
          validation</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>Casting and
            validation

            <h3><a id="id-issue-d1e10928"
            name="id-issue-d1e10928"></a>Description</h3>

            <div>
              <p>Validation from text to simple type performs an
              operation similar to casting. Should validation of
              simple type values and 'cast as' in [XPath/XQuery] be
              aligned?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>501. <a id="FS-Issue-0158"
          name="FS-Issue-0158"><u>FS-Issue-0158</u>: Support for
          XML Schema groups</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Support for
            XML Schema groups

            <h3><a id="id-issue-d1e10957"
            name="id-issue-d1e10957"></a>Description</h3>

            <div>
              <p>How to support XML Schema groups during the schema
              import phase is not clear. If the mapping is based on
              the XML Schema syntax, then it should be handled
              durin the mapping phase. Should we have support for
              XML Schema groups in the XQuery type system?</p>
            </div>

            <h3><a id="id-issue-d1e10962"
            name="id-issue-d1e10962"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>XML Schema groups are mapped in the type system.
              There is no need for a syntax for schema group in the
              type system.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>503. <a id="FS-Issue-0160"
          name="FS-Issue-0160"><u>FS-Issue-0160</u>: Collations in
          the static environment</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Collations in
            the static environment

            <h3><a id="id-issue-d1e10997"
            name="id-issue-d1e10997"></a>Description</h3>

            <div>
              <p>The Formal Semantics does not represent collations
              in the static environment. Should it?</p>
            </div>

            <h3><a id="id-issue-d1e11002"
            name="id-issue-d1e11002"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Add collations in the Dynamic Environment.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>508. <a id="FS-Issue-0165"
          name="FS-Issue-0165"><u>FS-Issue-0165</u>: Namespaces in
          element constructors</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Denise Draper</b></small>Namespaces in
            element constructors

            <h3><a id="id-issue-d1e11075"
            name="id-issue-d1e11075"></a>Description</h3>

            <div>
              <p>We do not supply either namespaces or
              schema-components to the constructor. We cannot do
              these things because of the bottom-up nature of
              element construction: we do not, in general, know
              either the namespaces in scope or the
              validation-associated schema type until this element
              has been "seated" in some containing element (and so
              on recursively).</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>509. <a id="FS-Issue-0166"
          name="FS-Issue-0166"><u>FS-Issue-0166</u>: Static typing
          for validate</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Static typing
            for validate

            <h3><a id="id-issue-d1e11086"
            name="id-issue-d1e11086"></a>Description</h3>

            <div>
              <p>Although validate should always return a typed
              value, there is no way to do static analysis for it,
              since the type against which it is validated cannot
              be known at static type (it depends on the result of
              evaluation for the input expression).</p>
            </div>

            <h3><a id="id-issue-d1e11091"
            name="id-issue-d1e11091"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Ignore content's type. Assign static type using
              element name and validation context.</p>

              <p>May raise type error if element content will NEVER
              validate successfully.</p>

              <div class="exampleInner">
<pre>
&lt;fixbrain&gt;{ validate { input()/fixsink/person } }&lt;/fixbrain&gt;
</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>510. <a id="FS-Issue-0167"
          name="FS-Issue-0167"><u>FS-Issue-0167</u>: Is validate
          working on sequences?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Language</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>Is validate
            working on sequences?

            <h3><a id="id-issue-d1e11109"
            name="id-issue-d1e11109"></a>Description</h3>

            <div>
              <p>We have not yet reached consensus on the semantics
              of validate for all sequences. In particular:</p>

              <p>1. Can validate be applied to a sequence, or only
              to a single item?</p>

              <p>2. Can validate be applied to any item? Some
              believe that it should apply only to elements and
              document nodes - the two kinds of nodes for which it
              is well defined - and raise an error if other items
              are encountered. Others believe that validate should
              validate elements and document nodes, returning other
              items without change. Should an attribute node be
              validated? Note that XML Schema does not define
              stand-alone validation for attribute nodes.</p>

              <p>We need to carefully consider the usage scenarios
              in which validation might be applied to sequences or
              items that are not elements or document nodes to
              determine which behavior is most desirable.</p>

              <p>Should validate work on sequences of nodes, or
              only on a single node?</p>
            </div>

            <h3><a id="id-issue-d1e11126"
            name="id-issue-d1e11126"></a>Proposed Resolution</h3>

            <div>
              <p>At today's Query telcon, we discussed the
              semantics of the validate expression. We need to
              decide whether it applies to a sequence, or only to a
              single node. We also need to define its semantics for
              various kinds of nodes (and for atomic values, if
              they occur in a validated sequence).</p>

              <p>Most people agreed that the validate operator,
              applied to an attribute node, should raise an error.
              This is because we rely on the XML Schema
              specification for the semantics of validation, and
              XML Schema does not specify how to validate a
              stand-alone attribute node.</p>

              <p>For text, comment, and PI nodes and atomic values,
              some people believe that validate should raise an
              error, and others believe that validate should simply
              return the original node or value unchanged. We did
              not reach a consensus on this.</p>

              <p>If validate is defined to operate on a sequence,
              the sequence may contain some items for which
              validate is well-defined and others for which it is
              not well-defined. In order for users to invoke
              validate on a sequence, they will first need to
              filter the sequence to keep only items for which
              validate is well-defined. If users need to do this
              work anyway, they might as well invoke validate
              expressions only on the individual items for which
              validation is well-defined. This was considered a
              strong argument for not allowing sequences to be
              passed to a validate expression.</p>

              <p>At the end of the discussion, a consensus seemed
              to be emerging around the following points:</p>

              <p>(1) The operand of validate must be a single
              element node or a single document node (anything else
              raises a type error).</p>

              <p>(2) The semantics of validate on an element node
              are as defined in Section 3.13 ("Validate
              Expressions") of the current language document.</p>

              <p>(3) The semantics of validate on a document node
              are as defined in Karun's proposal,
              http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0015.html,
              approved by the Query working group on 2/12/03.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>512. <a id="FS-Issue-0169"
          name="FS-Issue-0169"><u>FS-Issue-0169</u>: Conformance
          Levels</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>Conformance
            Levels

            <h3><a id="id-issue-d1e11176"
            name="id-issue-d1e11176"></a>Description</h3>

            <div>
              <p>[XPath/XQuery] supports several conformance
              levels. Whether the formal semantics need to
              distinguish those conformance levels is an open
              issue. If yes, how to distinguish those conformance
              levels in the formal semantics is an open issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>513. <a id="FS-Issue-0170"
          name="FS-Issue-0170"><u>FS-Issue-0170</u>: Imprecise
          static type of constructed elements</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Static typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Mary Fernandez</b></small>Imprecise
            static type of constructed elements

            <h3><a id="id-issue-d1e11187"
            name="id-issue-d1e11187"></a>Description</h3>

            <div>
              <p>Implementation of Alternative 1 means that the
              static type for constructed elements and attributes
              is very imprecise. E.g., the type of {(1,2,3)} is
              element a { xs: anyType }. See remark by Denise in
              section on element constructors for possible fix.</p>
            </div>

            <h3><a id="id-issue-d1e11192"
            name="id-issue-d1e11192"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Applies to literal element constructor and
              computed element constructor with literal name</p>

              <p>Raise type error if element content will NEVER
              validate successfully.</p>

              <p>If static typing is enabled, it is a static type
              error if the type of the content of the element is
              NOT a subtype of type declared for the element.
              Untyped content treated "liberally".</p>

              <p>Parallels semantics of static typing rules for
              function calls.</p>

              <div class="exampleInner">
<pre>
type plumber { element name of type xs:string }
type surgeon { element name of type xs:string }
element fixsink { element person of type plumber }
element fixbrain { element person of type surgeon }

&lt;fixbrain&gt;{ input()/fixsink/person }&lt;/fixbrain&gt;
</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>514. <a id="FS-Issue-0171"
          name="FS-Issue-0171"><u>FS-Issue-0171</u>: Raising
          errors</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Mary Fernandez</b></small>Raising
            errors

            <h3><a id="id-issue-d1e11214"
            name="id-issue-d1e11214"></a>Description</h3>

            <div>
              <p>The semantics of raising errors in [XPath/XQuery]
              is not formally specified.</p>
            </div>

            <h3><a id="id-issue-d1e11219"
            name="id-issue-d1e11219"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft describes the semantics of
              errors.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>516. <a id="FS-Issue-0173"
          name="FS-Issue-0173"><u>FS-Issue-0173</u>: Typeswitch and
          type substitutability</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>XSL Working Group</b></small>Typeswitch
            and type substitutability

            <h3><a id="id-issue-d1e11248"
            name="id-issue-d1e11248"></a>Description</h3>

            <div>
              <p>It seems that some examples of typeswitch with
              xs:anySimpleType might break type
              substitutability.</p>
            </div>

            <h3><a id="id-issue-d1e11253"
            name="id-issue-d1e11253"></a>Proposed Resolution</h3>

            <div>
              <div class="exampleInner">
<pre>
The required changes include the new (simpler!) normalization and typing
rules below, plus:

  1. A new formal-semantics function fs:cast-untypedAtomic, which
     takes two arguments and :

     a. If the first argument is the empty sequence, returns the empty
        sequence.

     b. If first argument is untypedAtomic, and

        b1. If the second argument is untypedAtomic, returns the first
            argument cast to string;

        b2. Else if the second argument is numeric, returns the first
            argument cast to double;

        b3. Otherwise, returns the first argument cast to the type of
            the *second* argument.

     c. Otherwise, returns the first argument, unchanged.

     Thus fs:cast-untypedAtomic encapsulates the implicit coercion
     semantics of the arithmetic and general comparision operators.

     The "generic" signature of fs:cast-untypedAtomic is:

       fs:cast-untypedAtomic ($v1 as xdt:anyAtomicType?, $v2 as
       xdt:anyAtomicType?) as xdt:anyAtomicType?

     The specific type rules for fs:cast-untypedAtomic are below.

  2. New signatures for the overloaded (op:numeric-OP) operators such
     that they are all defined on the empty sequence.  If either
     argument is the empty sequence, these operators return the
     empty sequence.

     E.g., here's the new signature for op:numeric-add (similar
     signatures for the other op:numeric-op functions):

     op:numeric-add($operand1 as numeric?, $operand2 as numeric?) as
numeric?

New normalization rules:
~~~~~~~~~~~~~~~~~~~~~~~
Given the changes above, here are the normalization rules for the plus
and the general less-than operators.  (The general rules for any
arithmetic or general comparison operator are similar -- it's just
easier to explain by example).

Plus:

  [Expr1 + Expr2]_Expr   ==
    let $e1 := fn:data ( [Expr1]_Expr ) return
    let $e2 := fn:data ( [Expr2]_Expr ) return
    let $v1 := fs:cast-untypedAtomic ($e1, 1.0e0) return
    let $v2 := fs:cast-untypedAtomic ($e2, 1.0e0) return
      op:numeric-add($v1, $v2)

Note that arithmetic operators always cast an untypedAtomic argument
to a double -- the call to fs:cast-untypedAtomic above performs this
cast.

Less-than:

  [Expr1 &lt; Expr2]_Expr   ==
    some $v1 in fn:data( [Expr1]_Expr ) satisfies
    some $v2 in fn:data( [Expr2]_Expr ) satisfies
      let $v1' := fs:cast-untypedAtomic($v1, $v2) return
      let $v2' := fs:cast-untypedAtomic($v2, $v1) return
        op:less-than($v1', $v2')

Note that general comparison operators always cast an untypedAtomic
argument to the type of the other argument -- the call to
fs:cast-untypedAtomic performs this cast.

Static type rules for fs:cast-untypedAtomic:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rule (a) above:

              statEnv |- Expr1 : ()
  ----------------------------------------------------
  statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : ()

Rule (b1) above:

  statEnv |- Expr1 : Type1   statEnv |- Type1 &lt;: xdt:untypedAtomic
  statEnv |- Expr2 : Type2   statEnv |- Type2 &lt;: xdt:untypedAtomic
  -----------------------------------------------------------------
  statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : xs:string

Rule (b2) above:

  statEnv |- Expr1 : Type1   statEnv |- Type1 &lt;: xdt:untypedAtomic
statEnv |- Expr2 : Type2   statEnv |- Type2 &lt;: (xs:decimal | xs:float |
xs:double)
----------------------------------------------------------------------------------
     statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : xs:double

Rule (b3) above:

      statEnv |- Expr1 : Type1   Type1 &lt;: xdt:untypedAtomic
                 statEnv |- Expr2 : Type2
statEnv |-  not(Type2 &lt;: xdt:untypedAtomic | xs:decimal | xs:float |
xs:double)
--------------------------------------------------------------------------------
          statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : Type2

Rule (c) above:

             statEnv |- Expr1 : Type1
           not(Type1 &lt;: xdt:untypedAtomic)
   ---------------------------------------------
   fs:cast-untyped-atomic(Expr1, Expr2) : Type1

Static type rules for typeswitch:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The static rules for typeswitch are now very simple. We type each case
expression and take the union of these types:

     statEnv |- Expr0 : Type0
     statEnv |- Type0 [case] case Variable1 as SequenceType1 return
Expr1 : Type1
        ...
     statEnv |- Type0 [case] case Variablen as SequenceTypen return
Exprn : Typen
     statEnv |- Type0 [case] default Variablen+1 return Exprn+1 :
Typen+1

--------------------------------------------------------------------------------
     statEnv |-
       (typeswitch (Expr0)
        case Variable1 as SequenceType1 return Expr1
        ...
        case Variablen as SequenceTypen return Exprn
        default Variablen+1 return Exprn+1)
     : Type1 | ... | Typen+1


The type of the case clauses is inferred based on the CaseType, independently
of the typeswitch expression type.

             CaseType = [ SequenceType ]_sequencetype
        statEnv + varType(Variable : CaseType) |- Expr : Type1
-------------------------------------------------------------------------
statEnv |- Type0 [case] case Variable as SequenceType return Expr : Type1


The type of the default branch is inferred based on the typeswitch expression
type.

        statEnv + varType(Variable : Type0) |- Expr : Type1
      ------------------------------------------------------------
      statEnv |- Type0 [case] default Variable return Expr : Type1
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e11258"
            name="id-issue-d1e11258"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-02-13 ([link to member only information]
              )</small></p>

              <p><small>Decision by: <b>xquery</b> on 2003-02-19
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-02-27
              ([link to member only information] )</small></p>

              <p>Proposal accepted resolving this issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>519. <a id="FS-Issue-0176"
          name="FS-Issue-0176"><u>FS-Issue-0176</u>: Type of
          document node</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Typing</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Type of
            document node

            <h3><a id="id-issue-d1e11300"
            name="id-issue-d1e11300"></a>Description</h3>

            <div>
              <p>What should the type of a document node be? Should
              a document node be described by a type name?</p>
            </div>

            <h3><a id="id-issue-d1e11305"
            name="id-issue-d1e11305"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>SequenceType extended to include
              document-node(ElementTypeTest)</p>

              <p>Formal types extended to include document { Type
              }</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>520. <a id="FS-Issue-0177"
          name="FS-Issue-0177"><u>FS-Issue-0177</u>: Coercion
          between untyped and atomic values</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Coercion
            between untyped and atomic values

            <h3><a id="id-issue-d1e11321"
            name="id-issue-d1e11321"></a>Description</h3>

            <div>
              <p>Function calls, arithmetics expressions, etc.
              should cast untyped data to values. This is not
              currently formally specified.</p>
            </div>

            <h3><a id="id-issue-d1e11326"
            name="id-issue-d1e11326"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft describes coercion between
              untyped and atomic values in function calls.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>521. <a id="FS-Issue-0178"
          name="FS-Issue-0178"><u>FS-Issue-0178</u>: Semantics of
          XPath 1.0 compatibility</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Semantics of
            XPath 1.0 compatibility

            <h3><a id="id-issue-d1e11336"
            name="id-issue-d1e11336"></a>Description</h3>

            <div>
              <p>The semantics is not specified in the case the
              XPath 1.0 compatibility flag is on.</p>
            </div>

            <h3><a id="id-issue-d1e11341"
            name="id-issue-d1e11341"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-01-12 ([link to member only information]
              )</small></p>

              <p>Dec. FS working draft describes xpath 1.0 backward
              compatibility semantics.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>523. <a id="input-and-schema-validation"
          name="input-and-schema-validation"><u>input-and-schema-validation</u>:
          input(), collection(), document(); validation
          semantics</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>XPath TF</b></small>input(),
            collection(), document(); validation semantics

            <h3><a id="id-issue-d1e11369"
            name="id-issue-d1e11369"></a>Description</h3>

            <div>
              <p>What are the semantics of the functions input(),
              collection(), document(), and the implicit context
              that binds variables to documents with respect to
              schema validation.</p>
            </div>

            <h3><a id="id-issue-d1e11374"
            name="id-issue-d1e11374"></a>Interactions and
            Input</h3>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>524. <a id="schema-plural-data-types"
          name="schema-plural-data-types"><u>schema-plural-data-types</u>:
          Plural datatypes different from Singular *?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>type
            semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>XPath TF</b></small>Plural datatypes
            different from Singular *?

            <h3><a id="id-issue-d1e11386"
            name="id-issue-d1e11386"></a>Description</h3>

            <div>
              <p>Is there any semantic difference between eg
              NMTOKEN* and NMTOKENS? Statically? Dynamically?</p>
            </div>

            <h3><a id="id-issue-d1e11391"
            name="id-issue-d1e11391"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>To solve issues 316 and 524 we need to do
              eliminate three constructor functions from F&amp;O,
              and integrating with the changes described in the
              message:
              http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0021.html.</p>

              <p>This was agreed.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>525. <a id="FS-Issue-0180"
          name="FS-Issue-0180"><u>FS-Issue-0180</u>: Static context
          accessible from the dynamic context</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>Semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jerome Simeon</b></small>Static context
            accessible from the dynamic context

            <h3><a id="id-issue-d1e11406"
            name="id-issue-d1e11406"></a>Description</h3>

            <div>
              <p>The formal semantics states that the static
              context is available from the dynamic context at run
              time. This should only be the case for part of the
              static context. Moreover certain parts of the dynamic
              context must be updated appropriately from during the
              dynamic evaluation (e.g., namespaces).</p>
            </div>

            <h3><a id="id-issue-d1e11411"
            name="id-issue-d1e11411"></a>Proposed Resolution</h3>

            <div>
              <p>My recollection is that Mary implemented some
              changes in the internal FS document. I think we never
              reported that change to the working group.</p>

              <p>I'm not sure how to deal with this one. Maybe Mary
              can explain the change and the issue be closed?</p>
            </div>

            <h3><a id="id-issue-d1e11419"
            name="id-issue-d1e11419"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>fs-editors</b> on
              2003-04-07 ([link to member only information]
              )</small></p>

              <p>The new formal semantics working draft clarifies
              which part of the static context is available from
              the dynamic context.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>526. <a
          id="static-semantics-anySimpleType-untypedAtomic"
          name="static-semantics-anySimpleType-untypedAtomic"><u>static-semantics-anySimpleType-untypedAtomic</u>:
          Semantics for anySimpleType and untypedAtomic</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>types</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XPath TF</b></small>Semantics for
            anySimpleType and untypedAtomic

            <h3><a id="id-issue-d1e11429"
            name="id-issue-d1e11429"></a>Description</h3>

            <div>
              <p>1. If you statically infer xs:anySimpleType, can
              you error if the expected type is a subtype or do you
              handle it as xdt:untypedAtomic at runtime?</p>

              <p>2. If you statically infer xdt:untypedAtomic, can
              you recast into expected type statically?</p>
            </div>

            <h3><a id="id-issue-d1e11437"
            name="id-issue-d1e11437"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-04-09
              ([link to member only information] )</small></p>

              <p>The two questions are answered in the current
              draft of the formal semantics.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>527. <a id="static-typing-index-expressions"
          name="static-typing-index-expressions"><u>static-typing-index-expressions</u>:
          Static typing of XPath index expressions</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>types</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Algebra Editors</b></small>Static
            typing of XPath index expressions

            <h3><a id="id-issue-d1e11447"
            name="id-issue-d1e11447"></a>Description</h3>

            <div>
              <p>Typing for XPath predicate expressions of the form
              E1[Integer] is not precise (often of the form
              ItemType* instead of ItemType or ItemType?). Should
              we have specific typing rules for XPath predicate
              expressions of the form E1[Integer], or is the use of
              'type relief' functions, as described in: <a
              href="http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Nov/0161.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Nov/0161.html</a>
              sufficient?</p>
            </div>

            <h3><a id="id-issue-d1e11454"
            name="id-issue-d1e11454"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-01-22
              ([link to member only information] )</small></p>

              <p>The general static type of the general
              expression:</p>

              <div class="exampleInner">
<pre>
Expr1[Expr2]
</pre>
              </div>

              <p>Is (assuming normalization has taken place)</p>

              <div class="exampleInner">
<pre>
TYPE{Expr1[Expr2]} == IF TYPE{Expr2} &lt;: numeric THEN TYPE{Expr1}
</pre>
              </div>

              <p>Decided that if Expr2 is a literal number, then do
              cardinality reduction, otherwise don't.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>528. <a id="text-constructor-empty-sequence"
          name="text-constructor-empty-sequence"><u>text-constructor-empty-sequence</u>:
          Semantics of text constructor on empty sequence</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>semantics</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XPath TF</b></small>Semantics of text
            constructor on empty sequence

            <h3><a id="id-issue-d1e11472"
            name="id-issue-d1e11472"></a>Description</h3>

            <div>
              <p>Semantics of text constructor on empty sequence:
              should it return empty sequence or raise an
              error?</p>
            </div>

            <h3><a id="id-issue-d1e11477"
            name="id-issue-d1e11477"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-02-26
              ([link to member only information] )</small></p>

              <p>Change the language document, adding that a text
              node constructor on empty sequence returns the empty
              sequence.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>529. <a id="node-identity-modeling"
          name="node-identity-modeling"><u>node-identity-modeling</u>:
          Node identity in the formal semantics</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>constructor-expr</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>Node identity in
            the formal semantics

            <h3><a id="id-issue-d1e11487"
            name="id-issue-d1e11487"></a>Description</h3>

            <div>
              <p>The fs currently does not model node identity. The
              position of the formal semantics editors is that a
              formal semantics need not model everything. So it is
              not absolutely required that we model node identity,
              though it would be desirable for us to do so, not
              least because a clear description of node identity
              may help clarify the semantics of update. The formal
              semantics should include a mode of node identity if
              time permits.</p>
            </div>

            <h3><a id="id-issue-d1e11492"
            name="id-issue-d1e11492"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Decided to define node identity in the Formal
              Semantics. Required some editorial work to be
              done.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>530. <a id="default-validation-mode"
          name="default-validation-mode"><u>default-validation-mode</u>:
          Default default validation mode</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>validation</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Jim Melton</b></small>Default default
            validation mode

            <h3><a id="id-issue-d1e11505"
            name="id-issue-d1e11505"></a>Description</h3>

            <div>
              <p>The adoption of implicit validation of element
              constructors specified that syntax be provided to
              allow query authors to specify the validation mode
              (skip, lax, or strict) for a given constructor, as
              well as syntax to allow query authors to specify in
              the query prolog the default validation for all
              constructors in the query. If neither syntax is used,
              there must be a "default default" mode. That mode can
              be specified by the XQuery specification itself, or
              it can be made implementation-defined to account for
              varying implementation requirements. Specifying the
              default mode in the XQuery specification would seem
              to improve interoperability, but there are strong
              user requirements that are best satisfied by allowing
              the XQuery implementation determine the default mode
              based on customer needs and other factors. In order
              to improve interoperability, XQuery authors can
              specify their default mode in their XQuery
              prologs.</p>
            </div>

            <h3><a id="id-issue-d1e11510"
            name="id-issue-d1e11510"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small></p>

              <p>This issue is an example of a more generic issue:
              how should the default value be determined for the
              parts of the static context and evaluation context
              that are not explicitly assigned values in the query
              prolog? I believe that this generic issue should be
              addressed by a well-defined and uniform policy that
              is documented in the language books. I propose the
              following resolution:</p>

              <p>(1) Section 2.1.1, "Static Context": Add the
              following sentence just before the bullet-list of
              context items (XQuery only): "Any part of the Static
              Context that is not assigned a value in the Query
              Prolog may be assigned a default value by the XQuery
              implementation."</p>

              <p>(2) Section 2.1.2, "Evaluation Context": Add the
              following sentence just before the bullet-list of
              context items: "Any part of the Evaluation Context
              may be assigned an initial value by the XPath/XQuery
              implementation."</p>

              <p>Proposal accepted.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>531. <a id="type-copied-subelement"
          name="type-copied-subelement"><u>type-copied-subelement</u>:
          Should discard the type of copied subelement</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>Should discard
            the type of copied subelement

            <h3><a id="id-issue-d1e11526"
            name="id-issue-d1e11526"></a>Description</h3>

            <div>
              <p>Currently element construction untypes all simple
              content (untypedAtomic) but preserves the type of
              subnodes.</p>

              <p>This is seen as inconsistent by some and thus an
              issue.</p>

              <p>The proposed resolution would be to erase the type
              for any node under the new element (make it
              element/attribute of type
              xs:anyType/xdt:untypedAtomic or potentially (and
              preferably) untypedComplex for elements).</p>
            </div>

            <h3><a id="id-issue-d1e11537"
            name="id-issue-d1e11537"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Element construction should behave like skip
              validation and erase the type of all subnodes.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>532. <a id="sequence-type-path-alignment"
          name="sequence-type-path-alignment"><u>sequence-type-path-alignment</u>:
          Alignment between path expressions and sequence
          types</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Phil Wadler</b></small>Alignment
            between path expressions and sequence types

            <h3><a id="id-issue-d1e11550"
            name="id-issue-d1e11550"></a>Description</h3>

            <div>
              <p>Should there be better alignment between path
              expressions and sequence types?</p>
            </div>

            <h3><a id="id-issue-d1e11555"
            name="id-issue-d1e11555"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Proposal in issue <a
              href="#SequenceType-problems">#SequenceType-problems</a>
              accepted resolving issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>533. <a id="automatic-coersion-strict-or-not"
          name="automatic-coersion-strict-or-not"><u>automatic-coersion-strict-or-not</u>:
          Strict static typing for automatic coercion of untyped
          atomic to atomic values</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Mary Fernandez</b></small>Strict static
            typing for automatic coercion of untyped atomic to
            atomic values

            <h3><a id="id-issue-d1e11571"
            name="id-issue-d1e11571"></a>Description</h3>

            <div>
              <p>Should static typing for automatic coercion of
              untyped atomic to atomic values be strict or not? For
              instance:</p>

              <p>Should the following function call:</p>

              <div class="exampleInner">
<pre>
define function f($x as xs:integer)  ....

let $x := &lt;a&gt;1&lt;/a&gt; return f($x/node())
</pre>
              </div>

              <p>be allowed or not?</p>
            </div>

            <h3><a id="id-issue-d1e11585"
            name="id-issue-d1e11585"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>In principle, xdt:untypedAtomic is typed liberally
              rather than conservatively. That is, it is made
              statically well-typed whenever possible.</p>

              <p>Thus, addition of xdt:untypedAtomic to xs:integer
              is well-typed and has type xs:double. Comparing
              xdt:untypedAtomic to any other type is
              well-typed.</p>

              <p>This resolution applies only to the general
              comparison (=, &lt;), not to value comparison (eq,
              lt), so that the latter retains transitivity.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>534. <a id="function-calls-and-expected-type"
          name="function-calls-and-expected-type"><u>function-calls-and-expected-type</u>:
          Semantics of function calls and notion of "expected
          type"</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Kristoffer Rose</b></small>Semantics of
            function calls and notion of "expected type"

            <h3><a id="id-issue-d1e11603"
            name="id-issue-d1e11603"></a>Description</h3>

            <div>
              <p>While the "expected type" is well defined for user
              and non-overloaded standard functions, it is not so
              for the overloaded built-in functions. For general
              [XQuery/XPath] use (without XPath 1.0 compatibility
              flag) we must ensure that each overloaded argument is
              either always atomic or non-atomic so it is
              unambiguous for every function argment which of the
              two normalization choices to pick. With XPath 1.0
              compatibility flag some other solution must be found
              as several functions are now overloaded with, e.g.,
              numeric and non-numeric types allowed for the same
              argument.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>535. <a id="lexical-state-tables"
          name="lexical-state-tables"><u>lexical-state-tables</u>:
          Lexical state tables</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Scott Boag</b></small>Lexical state
            tables

            <h3><a id="id-issue-d1e11614"
            name="id-issue-d1e11614"></a>Description</h3>

            <div>
              <p>Should the state tables be removed or made non
              normative?</p>
            </div>

            <h3><a id="id-issue-d1e11619"
            name="id-issue-d1e11619"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xsl</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-07
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Decided to keep them normative.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>536. <a id="datamodel-infoset-types"
          name="datamodel-infoset-types"><u>datamodel-infoset-types</u>:
          Data model to infoset mapping and type
          information</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>types</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>Michael Rys</b></small>Data model to
            infoset mapping and type information

            <h3><a id="id-issue-d1e11632"
            name="id-issue-d1e11632"></a>Description</h3>

            <div>
              <p>When mapping from a data model to the infoset (as
              it is used in the definition of validate), we need to
              loose any type properties that may be part of the
              data model. In particular, this means that the
              infoset will not populate the attribute's type
              property. We need to make sure that the documents
              reflect this.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>537. <a
          id="imported-schemas-used-function-signatures"
          name="imported-schemas-used-function-signatures"><u>imported-schemas-used-function-signatures</u>:
          What happens to imported schemas that are used in
          function signatures?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>modules</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Michael Rys</b></small>What happens to
            imported schemas that are used in function signatures?

            <h3><a id="id-issue-d1e11643"
            name="id-issue-d1e11643"></a>Description</h3>

            <div>
              <p>If a function module imports a schema and uses it
              in the function signature, is the import of the
              function module implicitly importing the schema
              components needed by the function signatures?</p>

              <p>Example:</p>

              <p>The module says:</p>

              <div class="exampleInner">
<pre>
import schema namespace foo = "abc"
namespace f = "xyz"
define function f:foo($x as foo:bar) as xs:int { ... }
</pre>
              </div>

              <p>Does</p>

              <div class="exampleInner">
<pre>
import module namespace f = "xyz"
</pre>
              </div>

              <p>import the schema and one only needs to bind a
              prefix to the schema namespace or does the schema
              have to be explicitly imported?</p>
            </div>

            <h3><a id="id-issue-d1e11666"
            name="id-issue-d1e11666"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small></p>

              <p>The adopted module proposal implicitly resolves
              this issue. An example showing this clearly needs to
              be added.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>538. <a id="keyword-extensions"
          name="keyword-extensions"><u>keyword-extensions</u>: Can
          (and should) keyword extensions be allowed in XQuery by
          equipping them with a namespace prefix?</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>extensions</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>Peter Fankhauser</b></small>Can (and
            should) keyword extensions be allowed in XQuery by
            equipping them with a namespace prefix?

            <h3><a id="id-issue-d1e11676"
            name="id-issue-d1e11676"></a>Description</h3>

            <div>
              <p>Can (and should) keyword extensions be allowed in
              XQuery by equipping them with a namespace prefix?</p>

              <p>Example:</p>

              <div class="exampleInner">
<pre>
declare namespace my = http://example.com/myextensions

for $e in document ("employees.xml")//employee
order by $e/lastname my:fastorder
return $e
</pre>
              </div>

              <p>The advantage of this is that namespaces are a
              well-established concept for extending vocabularies,
              and different prefixes may be used for multiple
              extensions (my:fastorder vs. real:fastorder). The
              possible disadvantage may be that namespaces are
              regarded as too clumsy for this purpose.</p>

              <p>Note that using namespaces for keyword extensions
              does not appear to provide a generic mechanism to
              make the XQuery grammar extensible (one cannot simply
              allow a sequence of Qnames at arbitrary places
              without running into ambiguities). An implementation
              providing some extensions still needs to modify the
              XQuery grammar accordingly. However this also holds
              for the other two options, unless "x-" is added to
              the reserved keywords.</p>
            </div>

            <h3><a id="id-issue-d1e11693"
            name="id-issue-d1e11693"></a>Interactions and
            Input</h3>

            <h3><a id="id-issue-d1e11699"
            name="id-issue-d1e11699"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-03-12
              ([link to member only information] )</small></p>

              <p>The decision for <a
              href="#extension-mechanism">#extension-mechanism</a>
              also covers this issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>539. <a
          id="cast-untypedAtomic-backward-compatibility-mode"
          name="cast-untypedAtomic-backward-compatibility-mode"><u>cast-untypedAtomic-backward-compatibility-mode</u>:
          Semantics of fs:cast-untypedAtomic in backward
          compatibility mode</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>types</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>Semantics of
            fs:cast-untypedAtomic in backward compatibility mode

            <h3><a id="id-issue-d1e11711"
            name="id-issue-d1e11711"></a>Description</h3>

            <div>
              <p>What should be the semantics of
              fs:cast-untypedAtomic in the XPath 1.0 backward
              compatibility mode?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>540. <a id="static-semantics-input-unions"
          name="static-semantics-input-unions"><u>static-semantics-input-unions</u>:
          How does the static semantics works in the case where the
          input types are unions?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>types</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Jerome Simeon</b></small>How does the
            static semantics works in the case where the input
            types are unions?

            <h3><a id="id-issue-d1e11722"
            name="id-issue-d1e11722"></a>Description</h3>

            <div>
              <p>How does the static semantics works in the case
              where the input types are unions? (union propagation)
              For instance, what is the static type obtained for an
              input (untypedAtomic | int) + (float) [the expected
              result is (double | float)].</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>541. <a id="static-type-empty-error"
          name="static-type-empty-error"><u>static-type-empty-error</u>:
          Should it be a static error if an expression other than
          () has type empty?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>static typing task
            force</b></small>Should it be a static error if an
            expression other than () has type empty? 

            <h3><a id="id-issue-d1e11733"
            name="id-issue-d1e11733"></a>Description</h3>

            <div>
              <p>Motivation: This catches common errors such as
              $x/e when there is no e element.</p>
            </div>

            <h3><a id="id-issue-d1e11738"
            name="id-issue-d1e11738"></a>Interactions and
            Input</h3>

            <h3><a id="id-issue-d1e11742"
            name="id-issue-d1e11742"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Yes this should be a static error.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>542. <a id="type-of-well-formed"
          name="type-of-well-formed"><u>type-of-well-formed</u>:
          What should be the type of an attribute or element that
          is well-formed but not validated, or is validated in skip
          mode?</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Phil Wadler</b></small>What should be
            the type of an attribute or element that is well-formed
            but not validated, or is validated in skip mode?

            <h3><a id="id-issue-d1e11756"
            name="id-issue-d1e11756"></a>Description</h3>

            <div>
              <p>Currently, attributes are given type
              xs:anySimpleType and elements are given type
              xs:anyType. In order to do a better job of static
              typing for well-formed data, it might be better to
              give attributes type xdt:untypedAtomic and to give
              elements type xdt:anyUntyped (where the latter is a
              newly minted type).</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>543. <a id="xpath-matching-substitution-groups"
          name="xpath-matching-substitution-groups"><u>xpath-matching-substitution-groups</u>:
          How can a path expression match elements in the
          substitution group of a given element?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>How can a
            path expression match elements in the substitution
            group of a given element?

            <h3><a id="id-issue-d1e11767"
            name="id-issue-d1e11767"></a>Description</h3>

            <div>
              <p>How can a path expression match elements in the
              substitution group of a given element?</p>
            </div>

            <h3><a id="id-issue-d1e11772"
            name="id-issue-d1e11772"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Proposal in issue <a
              href="#SequenceType-problems">#SequenceType-problems</a>
              accepted resolving issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>544. <a id="xpath-matching-types"
          name="xpath-matching-types"><u>xpath-matching-types</u>:
          How can a path expression match nodes of a given
          type?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>type-semantics</b> Priority: <b>1</b> Status:
            <b>decided</b><br />
             Originator: <b>Jonathan Robie</b></small>How can a
            path expression match nodes of a given type?

            <h3><a id="id-issue-d1e11788"
            name="id-issue-d1e11788"></a>Description</h3>

            <div>
              <p>How can a path expression match nodes of a given
              type?</p>
            </div>

            <h3><a id="id-issue-d1e11793"
            name="id-issue-d1e11793"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
              ([link to member only information] )</small></p>

              <p><small>Decision by: <b>xsl</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p><small>Decision by: <b>xquery</b> on 2003-03-06
              ([link to member only information] )</small>Joint
              meeting</p>

              <p>Proposal in issue <a
              href="#SequenceType-problems">#SequenceType-problems</a>
              accepted resolving issue.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>545. <a id="implicitly-element-attribute"
          name="implicitly-element-attribute"><u>implicitly-element-attribute</u>:
          Are XS element/attribute declarations implicitly added to
          the schema context?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>types</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>Processing Model TF</b></small>Are XS
            element/attribute declarations implicitly added to the
            schema context?

            <h3><a id="id-issue-d1e11809"
            name="id-issue-d1e11809"></a>Description</h3>

            <div>
              <p>Are XS element/attribute declarations implicitly
              added to the schema context?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>546. <a id="conformance-levels"
          name="conformance-levels"><u>conformance-levels</u>: Are
          there more processing model options that could make sense
          as consistent features and thus as conformance
          levels?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster:
            <b>conformance-levels</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Processing Model TF</b></small>Are
            there more processing model options that could make
            sense as consistent features and thus as conformance
            levels?

            <h3><a id="id-issue-d1e11820"
            name="id-issue-d1e11820"></a>Description</h3>

            <div>
              <p>Are there more processing model options that could
              make sense as consistent features and thus as
              conformance levels? What types can these "predefine"
              in the static context? Do these options have the
              desired/expected interoperability
              characteristics?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>547. <a id="grammar-declare"
          name="grammar-declare"><u>grammar-declare</u>: Use
          "declare" for declarations</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>Michael Rys</b></small>Use "declare"
            for declarations

            <h3><a id="id-issue-d1e11831"
            name="id-issue-d1e11831"></a>Description</h3>

            <div>
              <p>G3. Section 4.3 Validation Declaration</p>

              <div class="exampleInner">
<pre>
[118]     ValidationDecl

   ::=     &lt;"validation" "lax"&gt; |  &lt;"validation" "strict"&gt; |
&lt;"validation" "skip"&gt;
</pre>
              </div>

              <p>Add declare keyword in order to align with general
              declaration syntax</p>

              <p>Proposal:</p>

              <div class="exampleInner">
<pre>
&lt;"declare" "validation" ("lax" |  "strict" |  "skip")&gt;
</pre>
              </div>

              <p>G4. Section 4.4 Xmlspace Declaration</p>

              <div class="exampleInner">
<pre>
[104]     XMLSpaceDecl

   ::=     &lt;"declare" "xmlspace"&gt; "=" ("preserve" |  "strip")
</pre>
              </div>

              <p>drop "=" in order to align with general
              declaration syntax (this is an option and not a value
              like in namespace declarations)</p>

              <p>Proposal:</p>

              <div class="exampleInner">
<pre>
&lt;"declare" "xmlspace"&gt; ("preserve" |  "strip")
</pre>
              </div>

              <p>G5. Section 4.5 Default Collation</p>

              <div class="exampleInner">
<pre>
[105]     DefaultCollationDecl

   ::=     &lt;"default" "collation" "="&gt; StringLiteral
</pre>
              </div>

              <p>drop "=" and add "declare" in order to align with
              general declaration syntax.</p>

              <p>Proposal:</p>

              <div class="exampleInner">
<pre>
&lt;"declare" "default" "collation"&gt; StringLiteral
</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>548. <a id="lexical-rules"
          name="lexical-rules"><u>lexical-rules</u>: Lexical Rules:
          states normative?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>Michael Rys</b></small>Lexical Rules:
            states normative?

            <h3><a id="id-issue-d1e11884"
            name="id-issue-d1e11884"></a>Description</h3>

            <div>
              <p>G6. Section A.1.2 Lexical Rules</p>

              <p>Current wording: "The lexical contexts and
              transitions between lexical contexts is described in
              terms of a series of states and transitions between
              those states."</p>

              <p>Make all states non-normative except those that
              are needed for XML construction, string literal and
              XQuery context.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: green; background-color: white">
          <h2>549. <a id="namespace-constructor"
          name="namespace-constructor"><u>namespace-constructor</u>:
          Computed namespace-constructor</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>namespaces</b>
            Priority: <b>1</b> Status: <b>decided</b><br />
             Originator: <b>XQuery WG</b></small>Computed
            namespace-constructor

            <h3><a id="id-issue-d1e11901"
            name="id-issue-d1e11901"></a>Description</h3>

            <div>
              <p>Is the following construction is a valid XQuery
              expression or not:</p>

              <div class="exampleInner">
<pre>
element foo:bar {
  attribute a1 {"foo"},
  attribute xmlns:foo {"urn1"},
  element e1 {"goo"}
}
</pre>
              </div>

              <p>The XML Query WG has decided to forbid the above
              construct by defining an explicit constructor for
              namespaces in computed constructor syntax, and to
              disallow the use of computed attribute constructors
              for declaring namespaces. The WG also believes that
              there should be a constructor for comments.</p>

              <p>The WG also agreed that the namesapce constructor
              should have a syntax parallel to that of attribute
              constructors, be restricted to constant namespace
              prefixes and URLs, and should appear first in the
              children of an element constructor, as in the
              following example:</p>

              <div class="exampleInner">
<pre>
element foo:bar {
     namespace test { "urn1" },
     attribute a1 {"foo"},
     element e1 {"goo"}
}
</pre>
              </div>

              <p>The above example is precisely equivalent to:</p>

              <div class="exampleInner">
<pre>
&lt;foo:bar xmlns:test="urn1"&gt;{
      attribute a1 {"foo"},
      element e1 {"goo"}
}&lt;/foo:bar&gt;
</pre>
              </div>
            </div>

            <h3><a id="id-issue-d1e11924"
            name="id-issue-d1e11924"></a>Proposed Resolution</h3>

            <div>
              <p>The proposal itself is quite simple:</p>

              <p>Syntax:</p>

              <div class="exampleInner">
<pre>
ComputedElementConstructor    ::=    (&lt;"element" QName "{"&gt;
      |  (&lt;"element" "{"&gt; Expr "}" "{")) NamespaceCList? ExprSequence?
"}"

NamespaceCList ::= ComputedNamespaceConstructor (","
ComputedNamespaceConstructor)* ","

ComputedNamespaceConstructor ::= (&lt;"namespace" NCName "{"&gt; StringLiteral
"}"
</pre>
              </div>

              <p>A NamespaceCList may appear as the first
              expressions in the ExprSequence of an element
              constructor, using either computed or XML element
              constructor syntax. It is syntactically impossible
              for ComputedNamespaceConstructors to appear in any
              other context.</p>

              <p>Semantics:</p>

              <p>If two ComputedNamespaceConstructors in the same
              element declare the same prefix, a type error is
              raised. A namespace declared using a
              ComputedNamespaceconstructor is in scope within the
              constructed element, including the name of the
              element itself.</p>

              <p>If the name of an attribute in a computed
              attribute constructor begins with the string "xmlns",
              a type error is raised.</p>

              <p>In an ElementConstructor, if an attribute in an
              AttributeList begins with the string "xmlns", then it
              is treated as a namespace declaration, and is
              equivalent to a computed namespace constructor that
              declares the same prefix and URI.</p>
            </div>

            <h3><a id="id-issue-d1e11950"
            name="id-issue-d1e11950"></a>Actual Resolution</h3>

            <div>
              <p><small>Decision by: <b>xquery</b> on 2003-03-12
              ([link to member only information] )</small></p>

              <p>Adoption of the proposal.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>550. <a id="comments-location"
          name="comments-location"><u>comments-location</u>:
          Location of Comments</a></h2>

          <div>
            <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>Don Chamberlin</b></small>Location of
            Comments

            <h3><a id="id-issue-d1e11960"
            name="id-issue-d1e11960"></a>Description</h3>

            <div>
              <p>XQuery 1.0 states "Comments may be used anywhere
              that ignorable whitespace is allowed, and within
              element content." I am trying to understand what that
              means and whether it is still true.</p>

              <p>What does this mean?</p>

              <div class="exampleInner">
<pre>
&lt;a&gt;A (:big:) cat&lt;/a&gt;
</pre>
              </div>

              <p>Does (:big:) get recognized as a comment and
              removed from the element content, and then the two
              surrounding pieces of text get coalesced into a
              single text node with the content "A cat"?</p>

              <p>Or does the tag get a text node containing the
              string "A (:big:) cat"? If this is not the case, then
              how would I construct an element that actually has
              this content?</p>

              <p>Have we thought carefully about whether we want
              comments to be recognized inside tag content? In most
              other ways, element-content is treated much like a
              string. I believe that comments are not recognized
              inside strings, right? Is this a strong argument for
              not recognizing comments inside element content? Is
              there any argument for recognizing them?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>551. <a id="constructor-functions-user-types"
          name="constructor-functions-user-types"><u>constructor-functions-user-types</u>:
          Constructor functions for unprefixed user defined
          types</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>types</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XSL WG</b></small>Constructor functions
            for unprefixed user defined types

            <h3><a id="id-issue-d1e11986"
            name="id-issue-d1e11986"></a>Description</h3>

            <div>
              <p>We state that there is (implicitly) a constuctor
              function in the static context for each user defined
              type. How do you refer to such a constructor function
              for a non-prefixed type?</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>552. <a id="processing-instruction-quotes"
          name="processing-instruction-quotes"><u>processing-instruction-quotes</u>:
          Should the quotes in processing-instruction("...") be
          optional?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XSL WG</b></small>Should the quotes in
            processing-instruction("...") be optional?

            <h3><a id="id-issue-d1e11997"
            name="id-issue-d1e11997"></a>Description</h3>

            <div>
              <p>Do we want to make the quotes in
              processing-instruction() optional? It is always a
              string literal and we have introduced element() and
              attribute() that already do not look like
              functions...</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>553. <a id="dynamic-errors-reported-statically"
          name="dynamic-errors-reported-statically"><u>dynamic-errors-reported-statically</u>:
          Rules for reporting dynamic errors statically</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>errors</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XSL WG</b></small>Rules for reporting
            dynamic errors statically

            <h3><a id="id-issue-d1e12008"
            name="id-issue-d1e12008"></a>Description</h3>

            <div>
              <p>Under what circumstances can a dynamic error
              detected early be reported statically, for example if
              it occurs in code that might not be executed. A host
              language may determine this, e.g. an &lt;xsl:if&gt;
              construct.</p>
            </div>

            <h3><a id="id-issue-d1e12013"
            name="id-issue-d1e12013"></a>Interactions and
            Input</h3>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>554. <a id="what-is-normative"
          name="what-is-normative"><u>what-is-normative</u>: What
          is the really normative text?</a></h2>

          <div>
            <small>Locus: <b>xpath</b> Cluster: <b>editorial</b>
            Priority: <b>1</b> Status: <b>active</b><br />
             Originator: <b>XPath TF</b></small>What is the really
            normative text?

            <h3><a id="id-issue-d1e12023"
            name="id-issue-d1e12023"></a>Description</h3>

            <div>
              <p>Some normative material in XPath/XQuery
              specifications occurs in more than one location. The
              specifications need to be clear which of the
              replicated material is the unique normative
              definition to ensure ease of implementation and avoid
              conflicts.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>555. <a id="module-import-fs"
          name="module-import-fs"><u>module-import-fs</u>: Formal
          Semantics of Module Import</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>formal semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>fs editors</b></small>Formal Semantics
            of Module Import

            <h3><a id="id-issue-d1e12034"
            name="id-issue-d1e12034"></a>Description</h3>

            <div>
              <p>The semantics of Module Import is not formally
              specified.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>556. <a id="variable-definitions-fs"
          name="variable-definitions-fs"><u>variable-definitions-fs</u>:
          Formal Semantics of Variable Definitions</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>formal semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>fs editors</b></small>Formal Semantics
            of Variable Definitions

            <h3><a id="id-issue-d1e12045"
            name="id-issue-d1e12045"></a>Description</h3>

            <div>
              <p>The semantics of Variables Definitions in the
              XQuery prolog is not formally specified.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>557. <a id="validation-declaration-fs"
          name="validation-declaration-fs"><u>validation-declaration-fs</u>:
          Formal semantics of Validation Declaration</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>formal semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>fs editors</b></small>Formal semantics
            of Validation Declaration

            <h3><a id="id-issue-d1e12056"
            name="id-issue-d1e12056"></a>Description</h3>

            <div>
              <p>The semantics of Validation Declaration in the
              XQuery prolog is not formally specified.</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>558. <a id="FS-allow-PIs-comments"
          name="FS-allow-PIs-comments"><u>FS-allow-PIs-comments</u>:
          The content of element types should always allow PI's and
          comment node types</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>formal semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Michael Rys</b></small>The content of
            element types should always allow PI's and comment node
            types

            <h3><a id="id-issue-d1e12067"
            name="id-issue-d1e12067"></a>Description</h3>

            <div>
              <p>The content of element types should always allow
              PI's and comment node types. This is not currently
              taken into account in the FS document. The best way
              to deal with that problem is still an open issue. Two
              possible options are to add PI and comment types
              during XML Schema import into the XQuery type system
              (Section 8). Another option is to add PI and comment
              types during type expansion (judgment expands_to in
              7.2.7 Type expansion).</p>
            </div>
          </div>
        </div>

        <div class="issue"
        style="color: red; background-color: white">
          <h2>559. <a id="FS-support-new-sequence-type"
          name="FS-support-new-sequence-type"><u>FS-support-new-sequence-type</u>:
          New Sequence Type needs to be fully implemented in Formal
          Semantics</a></h2>

          <div>
            <small>Locus: <b>formal-semantics</b> Cluster:
            <b>formal semantics</b> Priority: <b>1</b> Status:
            <b>active</b><br />
             Originator: <b>Michael Rys</b></small>New Sequence
            Type needs to be fully implemented in Formal Semantics

            <h3><a id="id-issue-d1e12078"
            name="id-issue-d1e12078"></a>Description</h3>

            <div>
              <p>The formal semantics of the new form of sequence
              types is incomplete and is still under work.</p>
            </div>
          </div>
        </div>
      </div>

      <div class="div1">
        <h2><a name="id-revisions-log" id="id-revisions-log"></a>H
        Revision Log (Non-Normative)</h2>

        <div class="div2">
          <h3><a name="d0e10182" id="d0e10182"></a>H.1 18 April
          2003</h3>

          <ul>
            <li>
              <p>Extensive changes have been made in the syntax for
              specifying a type, for example in a function
              signature or in a cast expression.</p>
            </li>

            <li>
              <p>New options have been added to <b>KindTest</b> in
              a path expression, enabling elements and attributes
              to be selected by their type as well as by their
              name.</p>
            </li>

            <li>
              <p>A "validation mode" (strict, lax, or skip) has
              been added to the validate expression.</p>
            </li>

            <li>
              <p>The definition of the value comparison operators
              has changed to make these operators transitive. The
              relationship between the value comparison and general
              comparison operators has been affected by this
              change.</p>
            </li>

            <li>
              <p>The syntax of the "cast" and "treat" expressions
              has changed so that the operator and target type
              follow the operand expression, as in <code>5 cast as
              decimal</code>.</p>
            </li>

            <li>
              <p>Certain changes have been made to the grammar. An
              expression that may include a concatenation operator
              is now called Expr (formerly ExprSequence). An
              expression that may not contain a concatenation
              operator is now called ExprSingle (formerly Expr).
              Some changes have also been made in the precedence of
              operators (see grammar for details).</p>
            </li>

            <li>
              <p>Comment delimiters have been changed from
              <code>{-- --}</code> to <code>(: :)</code>.</p>
            </li>

            <li>
              <p>A new predefined namespace prefix,
              <code>xdt</code>, has been created for predefined
              types, and two new types,
              <code>xdt:untypedAtomic</code> and
              <code>xdt:anyAtomicType</code>, have been
              introduced.</p>
            </li>

            <li>
              <p>Changes have been made in the definition of typed
              value for certain kinds of nodes.</p>
            </li>

            <li>
              <p>Certain changes have been made in the conversion
              rules for operands of arithmetic operators (for
              example, <code>idiv</code> casts its operands to
              integer rather than double). Also, the result of the
              <code>div</code> operator on two integers is decimal
              rather than double.</p>
            </li>

            <li>
              <p>Implementations are now allowed to provide default
              initial values for all components of the static
              context and evaluation context.</p>
            </li>

            <li>
              <p>The former section 2.5 on the scope of variable
              bindings has been replaced by more specific material
              distributed throughout the document.</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </body>
</html>

