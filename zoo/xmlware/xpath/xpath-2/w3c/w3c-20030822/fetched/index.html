<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 1st July 2003), see www.w3.org" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <meta content="text/html; charset=us-ascii" http-equiv=
  "Content-Type" />

  <title>XML Path Language (XPath) 2.0</title>
  <style type="text/css">
  /*<![CDATA[*/
  code           { font-family: monospace; }

  div.constraint,
  div.issue,
  div.note,
  div.notice     { margin-left: 2em; }

  ol.enumar      { list-style-type: decimal; }
  ol.enumla      { list-style-type: lower-alpha; }
  ol.enumlr      { list-style-type: lower-roman; }
  ol.enumua      { list-style-type: upper-alpha; }
  ol.enumur      { list-style-type: upper-roman; }


  div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
  div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
  div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
  div.exampleWrapper { margin: 4px }
  div.exampleHeader { font-weight: bold;
                    margin: 4px}

  table.small    { font-size: x-small; }
  /*]]>*/
  </style>
  <link type="text/css" rel="stylesheet" href=
  "http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>

<body>
  <div class="head">
    <p><a href="http://www.w3.org/"><img width="72" height="48"
    alt="W3C" src="http://www.w3.org/Icons/w3c_home" /></a></p>

    <h1><a id="title" name="title"></a>XML Path Language (XPath)
    2.0</h1>

    <h2><a id="w3c-doctype" name="w3c-doctype"></a>W3C Working
    Draft 22 August 2003</h2>

    <dl>
      <dt>This version:</dt>

      <dd><span class="xpath"><a href=
      "http://www.w3.org/TR/2003/WD-xpath20-20030822">http://www.w3.org/TR/2003/WD-xpath20-20030822</a></span></dd>

      <dt>Latest version:</dt>

      <dd><span class="xpath"><a href=
      "http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></dd>

      <dt>Previous versions:</dt>

      <dd><span class="xpath"><a href=
      "http://www.w3.org/TR/2003/WD-xpath20-20030502/">http://www.w3.org/TR/2003/WD-xpath20-20030502/</a></span>
      <span class="xpath"><a href=
      "http://www.w3.org/TR/2002/WD-xpath20-20021115/">http://www.w3.org/TR/2002/WD-xpath20-20021115/</a></span>
      <span class="xpath"><a href=
      "http://www.w3.org/TR/2002/WD-xpath20-20020816/">http://www.w3.org/TR/2002/WD-xpath20-20020816/</a></span>
      <span class="xpath"><a href=
      "http://www.w3.org/TR/2002/WD-xpath20-20020430/">http://www.w3.org/TR/2002/WD-xpath20-20020430/</a></span>
      <span class="xpath"><a href=
      "http://www.w3.org/TR/2001/WD-xpath20-20011220/">http://www.w3.org/TR/2001/WD-xpath20-20011220/</a></span></dd>

      <dt>Editors:</dt>

      <dd class="xpath">Anders Berglund (XSL WG), IBM Research
      <a href=
      "mailto:%20alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd>

      <dd>Scott Boag (XSL WG), IBM Research <a href=
      "mailto:%20scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>

      <dd>Don Chamberlin (XML Query WG), IBM Almaden Research
      Center <a href=
      "mailto:%20chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>

      <dd>Mary F. Fern&#225;ndez (XML Query WG), AT&amp;T Labs
      <a href=
      "mailto:%20mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>

      <dd class="xpath">Michael Kay (XSL WG), Software AG <a href=
      "mailto:%20Michael.Kay@softwareag.com">&lt;Michael.Kay@softwareag.com&gt;</a></dd>

      <dd>Jonathan Robie (XML Query WG), DataDirect Technologies
      <a href=
      "mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>

      <dd>J&#233;r&#244;me Sim&#233;on (XML Query WG), Bell Labs,
      Lucent Technologies <a href=
      "mailto:%20simeon@research.bell-labs.com">&lt;simeon@research.bell-labs.com&gt;</a></dd>
    </dl>

    <p class="copyright"><a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;&#169;&#160;2003&#160;<a href="http://www.w3.org/"><acronym title=
    "World Wide Web Consortium">W3C</acronym></a><sup>&#174;</sup>
    (<a href="http://www.lcs.mit.edu/"><acronym title=
    "Massachusetts Institute of Technology">MIT</acronym></a>,
    <a href="http://www.ercim.org/"><acronym title=
    "European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
    <a href="http://www.keio.ac.jp/">Keio</a>), All Rights
    Reserved. W3C <a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>,
    <a href=
    "http://www.w3.org/Consortium/Legal/copyright-documents">document
    use</a> and <a href=
    "http://www.w3.org/Consortium/Legal/copyright-software">software
    licensing</a> rules apply.</p>
  </div>
  <hr />

  <div>
    <h2><a id="abstract" name="abstract"></a>Abstract</h2>

    <div class="xpath">
      <p class="xpath">XPath is a language for addressing parts of
      an XML document.</p>
    </div>
  </div>

  <div>
    <h2><a id="status" name="status"></a>Status of this
    Document</h2>

    <p><em>This section describes the status of this document at
    the time of its publication. Other documents may supersede this
    document. A list of current W3C publications and the latest
    revision of this technical report can be found in the <a href=
    "http://www.w3.org/TR/">W3C technical reports index</a> at
    http://www.w3.org/TR/.</em></p>

    <p>This is a public W3C Working Draft for review by W3C Members
    and other interested parties. Publication as a Working Draft
    does not imply endorsement by the W3C Membership. This is a
    draft document and may be updated, replaced or obsoleted by
    other documents at any time. It is inappropriate to cite this
    document as other than work in progress. A list of current
    public W3C technical reports can be found at <a href=
    "http://www.w3.org/TR/">http://www.w3.org/TR/</a>.</p>

    <p><span class="xpath"><span class="xpath">This document is the
    result of joint work by the XSL and XML Query Working
    Groups,</span></span> which are jointly responsible for XPath
    2.0, a language derived from both XPath 1.0 and XQuery. The
    XPath 2.0 and XQuery 1.0 Working Drafts are generated from a
    common source. These languages are closely related, sharing
    much of the same expression syntax and semantics, and much of
    the text found in the two Working Drafts is identical.</p>

    <p>This version contains a new section entitled "Processing
    Model" that provides a more complete and detailed description
    of expression processing. It also contains specific error codes
    for various error conditions, and a glossary in which many
    terms are defined. The section on Optional Features has been
    rewritten. The term Basic XPath is no longer used. Changes have
    been made in the details of certain kinds of expressions. A
    complete list of changes can be found in <a href=
    "#id-revisions-log"><b>J Revision Log</b></a>.</p>

    <p>Public comments on this document are welcome. Feedback is
    especially requested on the remaining open XPath issues: Issues
    <span class="force"><a href=
    "#schema-types-from-input-documents">307</a></span> and
    <span class="force"><a href=
    "#schema-import-multiple-times">564</a></span>. Comments should
    be sent to the W3C XPath/XQuery mailing list, <span class=
    "force"><a href=
    "mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a></span>
    (archived at <span class="force"><a href=
    "http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a></span>).</p>

    <p>This Working Draft references the Last Call Working Drafts
    of <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
    Model]</a> and <a href="#FunctionsAndOperators">[XQuery 1.0 and
    XPath 2.0 Functions and Operators]</a>. Since these Last Call
    Working Drafts are not being re-published along with this
    Working Draft, it is possible that some differences may exist
    between this Working Draft and the Last Call Working Drafts.
    The public is encouraged to provide feedback on any differences
    that they find. The Working Groups are planning to publish a
    set of synchronized documents as early as possible.</p>

    <p>This document is a work in progress. It contains many open
    issues, and should not be considered to be fully stable.
    Vendors who wish to create preview implementations based on
    this document do so at their own risk. While this document
    reflects the general consensus of the working groups, there are
    still controversial areas that may be subject to change.</p>

    <p>XPath 2.0 has been defined jointly by the <a href=
    "http://www.w3.org/XML/Query">XML Query Working Group</a> and
    the <a href="http://www.w3.org/Style/XSL/">XSL Working
    Group</a> (both part of the <a href=
    "http://www.w3.org/XML/Activity.html">XML Activity</a>).</p>

    <p>Patent disclosures relevant to this specification may be
    found on the XML Query Working Group's patent disclosure page
    at <a href=
    "http://www.w3.org/2002/08/xmlquery-IPR-statements">http://www.w3.org/2002/08/xmlquery-IPR-statements</a>
    and the XSL Working Group's patent disclosure page at <a href=
    "http://www.w3.org/Style/XSL/Disclosures">http://www.w3.org/Style/XSL/Disclosures</a>.</p>
  </div>

  <div class="toc">
    <h2><a id="contents" name="contents"></a>Table of Contents</h2>

    <p class="toc">1 <a href=
    "#id-introduction">Introduction</a><br />
    2 <a href="#id-basics">Basics</a><br />
    &#160;&#160;&#160;&#160;2.1 <a href="#context">Expression
    Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
    "#static_context">Static Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1.1
    <a href="#id-predefined-types">Predefined Types</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
    "#eval_context">Dynamic Context</a><br />
    &#160;&#160;&#160;&#160;2.2 <a href=
    "#id-processing-model">Processing Model</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
    "#id-data-model-generation">Data Model Generation</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
    "#id-schema-import-processing">Schema Import
    Processing</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
    "#id-expression-processing">Expression Processing</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1
    <a href="#id-static-analysis">Static Analysis Phase</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2
    <a href="#id-dynamic-evaluation">Dynamic Evaluation
    Phase</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
    "#id-serialization">Serialization</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
    "#id-consistency-constraints">Consistency Constraints</a><br />
    &#160;&#160;&#160;&#160;2.3 <a href=
    "#id-important-concepts">Important Concepts</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
    "#N1078F">Document Order</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
    "#id-typed-value">Typed Value and String Value</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
    "#id-input-sources">Input Sources</a><br />
    &#160;&#160;&#160;&#160;2.4 <a href=
    "#id-type-conversion">Types</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
    "#id-sequencetype">SequenceType</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1.1
    <a href="#id-sequencetype-matching">SequenceType
    Matching</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
    "#id-type-conversions">Type Conversions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2.1
    <a href="#id-atomization">Atomization</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2.2
    <a href="#id-ebv">Effective Boolean Value</a><br />
    &#160;&#160;&#160;&#160;2.5 <a href="#errors">Error
    Handling</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
    "#id-kinds-of-errors">Kinds of Errors</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
    "#id-handling-dynamic">Handling Dynamic Errors</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
    "#id-errors-and-opt">Errors and Optimization</a><br />
    &#160;&#160;&#160;&#160;2.6 <a href=
    "#id-optional-features">Optional Features</a><br />
    3 <a href="#id-expressions">Expressions</a><br />
    &#160;&#160;&#160;&#160;3.1 <a href=
    "#id-primary-expressions">Primary Expressions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
    "#id-literals">Literals</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
    "#id-variables">Variables</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
    "#id-paren-expressions">Parenthesized Expressions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
    "#id-context-item-expression">Context Item Expression</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href=
    "#id-function-calls">Function Calls</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.6 <a href=
    "#comments">XPath Comments</a><br />
    &#160;&#160;&#160;&#160;3.2 <a href="#id-path-expressions">Path
    Expressions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
    "#id-axis-steps">Steps</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.1
    <a href="#axes">Axes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.2
    <a href="#node-tests">Node Tests</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
    "#id-predicates">Predicates</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
    "#unabbrev">Unabbreviated Syntax</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
    "#abbrev">Abbreviated Syntax</a><br />
    &#160;&#160;&#160;&#160;3.3 <a href=
    "#id-sequence-expressions">Sequence Expressions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
    "#construct_seq">Constructing Sequences</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
    "#combining_seq">Combining Sequences</a><br />
    &#160;&#160;&#160;&#160;3.4 <a href="#id-arithmetic">Arithmetic
    Expressions</a><br />
    &#160;&#160;&#160;&#160;3.5 <a href=
    "#id-comparisons">Comparison Expressions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href=
    "#id-value-comparisons">Value Comparisons</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href=
    "#id-general-comparisons">General Comparisons</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href=
    "#id-node-comparisons">Node Comparisons</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.4 <a href=
    "#id-order-comparisons">Order Comparisons</a><br />
    &#160;&#160;&#160;&#160;3.6 <a href=
    "#id-logical-expressions">Logical Expressions</a><br />
    &#160;&#160;&#160;&#160;3.7 <a href="#id-for-expressions">For
    Expressions</a><br />
    &#160;&#160;&#160;&#160;3.8 <a href=
    "#id-conditionals">Conditional Expressions</a><br />
    &#160;&#160;&#160;&#160;3.9 <a href=
    "#id-quantified-expressions">Quantified Expressions</a><br />
    &#160;&#160;&#160;&#160;3.10 <a href=
    "#id-expressions-on-datatypes">Expressions on
    SequenceTypes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
    "#id-instance-of">Instance Of</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
    "#id-cast">Cast</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href=
    "#id-castable">Castable</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a href=
    "#id-constructor-functions">Constructor Functions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a href=
    "#id-treat">Treat</a></p>

    <h3><a id="appendices" name="appendices"></a>Appendices</h3>

    <p class="toc">A <a href="#nt-bnf">XPath Grammar</a><br />
    &#160;&#160;&#160;&#160;A.1 <a href=
    "#id-grammar">EBNF</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href=
    "#notes-on-parsing">Grammar Notes</a><br />
    &#160;&#160;&#160;&#160;A.2 <a href=
    "#lexical-structure">Lexical structure</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href=
    "#whitespace-rules">White Space Rules</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href=
    "#id-lexical-states">Lexical Rules</a><br />
    &#160;&#160;&#160;&#160;A.3 <a href="#N12C92">Reserved Function
    Names</a><br />
    &#160;&#160;&#160;&#160;A.4 <a href=
    "#id-precedence-order">Precedence Order</a><br />
    B <a href="#N12D96">Type Promotion and Operator
    Mapping</a><br />
    &#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type
    Promotion</a><br />
    &#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator
    Mapping</a><br />
    C <a href="#id-xp-context-components">Context
    Components</a><br />
    &#160;&#160;&#160;&#160;C.1 <a href=
    "#id-xp-static-context-components">Static Context
    Components</a><br />
    &#160;&#160;&#160;&#160;C.2 <a href=
    "#id-xp-evaluation-context-components">Dynamic Context
    Components</a><br />
    D <a href="#id-references">References</a><br />
    &#160;&#160;&#160;&#160;D.1 <a href=
    "#id-normative-references">Normative References</a><br />
    &#160;&#160;&#160;&#160;D.2 <a href=
    "#id-non-normative-references">Non-normative
    References</a><br />
    &#160;&#160;&#160;&#160;D.3 <a href=
    "#id-background-references">Background References</a><br />
    &#160;&#160;&#160;&#160;D.4 <a href=
    "#id-informative-material">Informative Material</a><br />
    E <a href="#id-glossary">Glossary</a><br />
    F <a href="#id-errors">Summary of Error Conditions</a><br />
    G <a href="#N13D90">Conformance</a><br />
    H <a href="#id-backwards-compatibility">Backwards Compatibility
    with XPath 1.0</a> (Non-Normative)<br />
    &#160;&#160;&#160;&#160;H.1 <a href="#N13DB2">Incompatibilities
    when Compatibility Mode is true</a><br />
    &#160;&#160;&#160;&#160;H.2 <a href="#N13E65">Incompatibilities
    when Compatibility Mode is false</a><br />
    &#160;&#160;&#160;&#160;H.3 <a href="#N13EA2">Incompatibilities
    when using a Schema</a><br />
    I <a href="#id-issues">XPath 2.0 and XQuery 1.0 Issues</a>
    (Non-Normative)<br />
    J <a href="#id-revisions-log">Revision Log</a>
    (Non-Normative)<br />
    &#160;&#160;&#160;&#160;J.1 <a href="#N13EDA">22 August
    2003</a></p>
  </div>
  <hr />

  <div class="body">
    <div class="div1">
      <h2><a id="id-introduction" name="id-introduction"></a>1
      Introduction</h2>

      <div class="xpath">
        <p class="xpath">The primary purpose of XPath is to address
        parts of an <a href="#XML">[XML]</a> document. XPath uses a
        compact, non-XML syntax to facilitate use of XPath within
        URIs and XML attribute values. XPath gets its name from its
        use of a path notation as in URLs for navigating through
        the hierarchical structure of an XML document.</p>
      </div>

      <p>[<a title="data model" id="dt-datamodel" name=
      "dt-datamodel">Definition</a>: XPath operates on the
      abstract, logical structure of an XML document, rather than
      its surface syntax. This logical structure is known as the
      <b>data model</b>, which is defined in the <a href=
      "#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>
      document.]</p>

      <div class="xpath">
        <p class="xpath">XPath is designed to be embedded in a
        <b>host language</b> such as <a href="#XSLT">[XSLT 2.0]</a>
        or <a href="#xquery">[XQuery]</a>. XPath has a natural
        subset that can be used for matching (testing whether or
        not a node matches a pattern); this use of XPath is
        described in <a href="#XSLT">[XSLT 2.0]</a>.</p>
      </div>

      <p>XQuery Version 1.0 is an extension of XPath Version 2.0.
      Any expression that is syntactically valid and executes
      successfully in both XPath 2.0 and XQuery 1.0 will return the
      same result in both languages. Since these languages are so
      closely related, their grammars and language descriptions are
      generated from a common source to ensure consistency, and the
      editors of these specifications work together closely.</p>

      <p>XPath also depends on and is closely related to the
      following specifications:</p>

      <ul>
        <li>
          <p>The XPath data model defines the information in an XML
          document that is available to an XPath processor. The
          data model is defined in <a href="#datamodel">[XQuery 1.0
          and XPath 2.0 Data Model]</a>.</p>
        </li>

        <li>
          <p>The static and dynamic semantics of XPath are formally
          defined in <a href="#XQueryFormalSemantics">[XQuery 1.0
          and XPath 2.0 Formal Semantics]</a>. This document is
          useful for implementors and others who require a rigorous
          definition of XPath.</p>
        </li>

        <li>
          <p>The type system of XPath is based on <a href=
          "#XMLSchema">[XML Schema]</a>.</p>
        </li>

        <li>
          <p>The default library of functions and operators
          supported by XPath is defined in <a href=
          "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
          Functions and Operators]</a>.</p>
        </li>
      </ul>

      <p>This document specifies a grammar for XPath, using the
      same Basic EBNF notation used in <a href="#XML">[XML]</a>,
      except that grammar symbols always have initial capital
      letters. Unless otherwise noted (see <a href=
      "#lexical-structure"><b>A.2 Lexical structure</b></a>),
      whitespace is not significant in the grammar. Grammar
      productions are introduced together with the features that
      they describe, and a complete grammar is also presented in
      the appendix [<a href="#nt-bnf"><b>A XPath
      Grammar</b></a>].</p>

      <p>In the grammar productions in this document, nonterminal
      symbols are underlined and literal text is enclosed in double
      quotes. Certain productions (including the productions that
      define DecimalLiteral, DoubleLiteral, and StringLiteral)
      employ a regular-expression notation. The following example
      production describes the syntax of a function call:</p>

      <table summary="Scrap" class="scrap">
        <tbody>
          <tr valign="baseline">
            <td><a id="fakeid_doc-FunctionCall" name=
            "fakeid_doc-FunctionCall"></a>[60]&#160;&#160;&#160;</td>

            <td><code>FunctionCall</code></td>

            <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

            <td><code><a href="#prod-QName">QName</a> "(" (<a href=
            "#doc-ExprSingle">ExprSingle</a> ("," <a href=
            "#doc-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
          </tr>
        </tbody>
      </table>

      <p>The production should be read as follows: A function call
      consists of a QName followed by an open-parenthesis. The
      open-parenthesis is followed by an optional argument list.
      The argument list (if present) consists of one or more
      expressions, separated by commas. The optional argument list
      is followed by a close-parenthesis. The symbol
      <code>ExprSingle</code> denotes an expression that does not
      contain any top-level commas (since top-level commas in a
      function call are used to separate the function
      arguments).</p>

      <p>Certain aspects of language processing are described in
      this specification as <b>implementation-defined</b> or
      <b>implementation-dependent</b>.</p>

      <ul>
        <li>
          <p>[<a title="implementation defined" id=
          "dt-implementation-defined" name=
          "dt-implementation-defined">Definition</a>:
          <b>Implementation-defined</b> indicates an aspect that
          may differ between implementations, but must be specified
          by the implementor for each particular
          implementation.]</p>
        </li>

        <li>
          <p>[<a title="implementation dependent" id=
          "dt-implementation-dependent" name=
          "dt-implementation-dependent">Definition</a>:
          <b>Implementation-dependent</b> indicates an aspect that
          may differ between implementations, is not specified by
          this or any W3C specification, and is not required to be
          specified by the implementor for any particular
          implementation.]</p>
        </li>
      </ul>
    </div>

    <div class="div1">
      <h2><a id="id-basics" name="id-basics"></a>2 Basics</h2>

      <p>The basic building block of XPath is the
      <b>expression</b>. The language provides several kinds of
      expressions which may be constructed from keywords, symbols,
      and operands. In general, the operands of an expression are
      other expressions. [<a title="functional langauge" id=
      "dt-functional-language" name=
      "dt-functional-language">Definition</a>: XPath is a
      <b>functional language</b> which means that expressions can
      be nested with full generality. ] [<a title="strongly typed"
      id="dt-strongly-typed" name=
      "dt-strongly-typed">Definition</a>: XPath is also a
      <b>strongly-typed language</b> in which the operands of
      various expressions, operators, and functions must conform to
      the expected types.]</p>

      <p>Like XML, XPath is a case-sensitive language. All keywords
      in XPath use lower-case characters.</p>

      <p>The value of an expression is always a <a title="sequence"
      href="#dt-sequence">sequence</a>.[<a title="sequence" id=
      "dt-sequence" name="dt-sequence">Definition</a>: A
      <b>sequence</b> is an ordered collection of zero or more
      <a title="item" href="#dt-item">items</a>.] [<a title="item"
      id="dt-item" name="dt-item">Definition</a>: An <b>item</b> is
      either an <a title="atomic value" href=
      "#dt-atomic-value">atomic value</a> or a <a title="node"
      href="#dt-node">node</a>.] [<a title="atomic value" id=
      "dt-atomic-value" name="dt-atomic-value">Definition</a>: An
      <b>atomic value</b> is a value in the value space of an XML
      Schema <b>atomic type</b>, as defined in <a href=
      "#XMLSchema">[XML Schema]</a> (that is, a simple type that is
      not a list type or a union type).] [<a title="node" id=
      "dt-node" name="dt-node">Definition</a>: A <b>node</b> is an
      instance of one of the seven <b>node kinds</b> described in
      <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
      Model]</a>.] Each node has a unique <b>node identity</b>.
      Some kinds of nodes have typed values, string values, and
      names, which can be extracted from the node. The <a title=
      "typed value" href="#dt-typed-value">typed value</a> of a
      node is a sequence of zero or more atomic values. The
      <a title="string value" href="#dt-string-value">string
      value</a> of a node is a value of type
      <code>xs:string</code>. The <b>name</b> of a node is a value
      of type <code>xs:QName</code>.</p>

      <p>[<a title="singleton sequence" id="dt-singleton-sequence"
      name="dt-singleton-sequence">Definition</a>: A sequence
      containing exactly one item is called a <b>singleton
      sequence</b>.] An item is identical to a singleton sequence
      containing that item. Sequences are never nested--for
      example, combining the values 1, (2, 3), and ( ) into a
      single sequence results in the sequence (1, 2, 3). [<a title=
      "empty sequence" id="dt-empty-sequence" name=
      "dt-empty-sequence">Definition</a>: A sequence containing
      zero items is called an <b>empty sequence</b>.]</p>

      <p>In this document, the namespace prefixes <code>xs:</code>
      and <code>xsi:</code> are considered to be bound to the XML
      Schema namespaces
      <code>http://www.w3.org/2001/XMLSchema</code> and
      <code>http://www.w3.org/2001/XMLSchema-instance</code>,
      respectively (as described in <a href="#XMLSchema">[XML
      Schema]</a>), and the prefix <code>fn:</code> is considered
      to be bound to the namespace of XPath/XQuery functions,
      <code>http://www.w3.org/2003/05/xpath-functions</code>
      (described in <a href="#FunctionsAndOperators">[XQuery 1.0
      and XPath 2.0 Functions and Operators]</a>). In some cases,
      where the meaning is clear and namespaces are not important
      to the discussion, built-in XML Schema typenames such as
      <code>integer</code> and <code>string</code> are used without
      a namespace prefix. Also, this document assumes that the
      <a title="default function namespace" href=
      "#dt-def-fn-ns">default function namespace</a> is set to the
      namespace of XPath/XQuery functions, so function names
      appearing without a namespace prefix can be assumed to be in
      this namespace.</p>

      <div class="div2">
        <h3><a id="context" name="context"></a>2.1 Expression
        Context</h3>

        <p>[<a title="expression context" id=
        "dt-expression-context" name=
        "dt-expression-context">Definition</a>: The <b>expression
        context</b> for a given expression consists of all the
        information that can affect the result of the expression.]
        This information is organized into two categories called
        the <a title="static context" href=
        "#dt-static-context">static context</a> and the <a title=
        "dynamic context" href="#dt-dynamic-context">dynamic
        context</a>.</p>

        <div class="div3">
          <h4><a id="static_context" name=
          "static_context"></a>2.1.1 Static Context</h4>

          <p>[<a title="static context" id="dt-static-context"
          name="dt-static-context">Definition</a>: The <b>static
          context</b> of an expression is the information that is
          available during static analysis of the expression, prior
          to its evaluation.] This information can be used to
          decide whether the expression contains a <a title=
          "static error" href="#dt-static-error">static error</a>.
          If analysis of an expression relies on some component of
          the <a title="static context" href=
          "#dt-static-context">static context</a> that has not been
          assigned a value, a <a title="static error" href=
          "#dt-static-error">static error</a> is raised.[<a title=
          "err:XP0001" href="#ERRXP0001">err:XP0001</a>]</p>

          <p>The individual components of the <a title=
          "static context" href="#dt-static-context">static
          context</a> are summarized below. Further rules governing
          the semantics of these components can be found in
          <a href="#id-xp-static-context-components"><b>C.1 Static
          Context Components</b></a>.</p>

          <ul>
            <li>
              <p>[<a title="XPath 1.0 compatibility mode" id=
              "dt-xpath-compat-mode" name=
              "dt-xpath-compat-mode">Definition</a>: <b>XPath 1.0
              compatibility mode.</b> <span class=
              "xpath"><span class="xpath">This value is
              <code>true</code> if rules for backward compatibility
              with XPath Version 1.0 are in effect; otherwise it is
              <code>false</code>.</span></span>]</p>
            </li>

            <li>
              <p>[<a title="in-scope namespaces" id=
              "dt-is-namespaces" name=
              "dt-is-namespaces">Definition</a>: <b>In-scope
              namespaces.</b> This is a set of (prefix, URI) pairs.
              The in-scope namespaces are used for resolving
              prefixes used in QNames within the expression.]</p>
            </li>

            <li>
              <p>[<a title="default element/type namespace" id=
              "dt-def-elemtype-ns" name=
              "dt-def-elemtype-ns">Definition</a>: <b>Default
              element/type namespace.</b> This is a namespace URI.
              This namespace is used for any unprefixed QName
              appearing in a position where an element or type name
              is expected.] The initial default element/type
              namespace may be provided by the external
              environment.</p>
            </li>

            <li>
              <p>[<a title="default function namespace" id=
              "dt-def-fn-ns" name="dt-def-fn-ns">Definition</a>:
              <b>Default function namespace.</b> This is a
              namespace URI. This namespace URI is used for any
              unprefixed QName appearing as the function name in a
              function call. The initial default function namespace
              may be provided by the external environment.]</p>
            </li>

            <li>
              <p>[<a title="in-scope schema definitions" id=
              "dt-issd" name="dt-issd">Definition</a>: <b>In-scope
              schema definitions.</b> This is a generic term for
              all the element, attribute, and type definitions that
              are in scope during processing of an expression.] It
              includes the following three parts:</p>

              <ul>
                <li>
                  <p>[<a title="in-scope type definitions" id=
                  "dt-is-types" name="dt-is-types">Definition</a>:
                  <b>In-scope type definitions.</b> The in-scope
                  type definitions always include the predefined
                  types listed in <a href=
                  "#id-predefined-types"><b>2.1.1.1 Predefined
                  Types</b></a>. <span class="xpath"><span class=
                  "xpath">Additional type definitions may be
                  provided by the host language
                  environment.</span></span>]</p>

                  <p>XML Schema distinguishes <b>named types</b>,
                  which are given a QName by the schema designer,
                  must be declared at the top level of a schema,
                  and are uniquely identified by their QName, from
                  <b>anonymous types</b>, which are not given a
                  name by the schema designer, must be local, and
                  are identified in an implementation-dependent
                  way. Both named types and anonymous types can be
                  present in the in-scope type definitions.</p>
                </li>

                <li>
                  <p>[<a title="in-scope element declarations" id=
                  "dt-is-elems" name="dt-is-elems">Definition</a>:
                  <b>In-scope element declarations.</b> Each
                  element declaration is identified either by a
                  QName (for a top-level element) or by an
                  implementation-defined element identifier (for a
                  local element). An element declaration includes
                  information about the <b>substitution groups</b>
                  to which this element belongs.]</p>
                </li>

                <li>
                  <p>[<a title="in-scope attribute declarations"
                  id="dt-is-attrs" name=
                  "dt-is-attrs">Definition</a>: <b>In-scope
                  attribute declarations.</b> Each attribute
                  declaration is identified either by a QName (for
                  a top-level attribute) or by an
                  implementation-defined attribute identifier (for
                  a local attribute). ]</p>
                </li>
              </ul>
            </li>

            <li>
              <p>[<a title="in-scope variables" id="dt-is-vars"
              name="dt-is-vars">Definition</a>: <b>In-scope
              variables.</b> This is a set of (QName, type) pairs.
              It defines the set of variables that are available
              for reference within an expression. The QName is the
              name of the variable, and the type is the <a title=
              "static type" href="#dt-static-type">static type</a>
              of the variable.]</p>

              <p>An expression that binds a variable (such as a
              <code>for</code>, <code>some</code>, or
              <code>every</code> expression) extends the in-scope
              variables of its subexpressions with the new bound
              variable and its type.</p>
            </li>

            <li>
              <p>[<a title="in-scope functions" id="dt-is-funcs"
              name="dt-is-funcs">Definition</a>: <b>In-scope
              functions.</b> This component defines the set of
              functions that are available to be called from within
              an expression. Each function is uniquely identified
              by its expanded QName and its arity (number of
              parameters). Each function in <b>in-scope
              functions</b> has a <a title="function signature"
              href="#dt-function-signature">function signature</a>
              and a <a title="function implementation" href=
              "#dt-function-implementation">function
              implementation.</a>] [<a title="function signature"
              id="dt-function-signature" name=
              "dt-function-signature">Definition</a>: The
              <b>function signature</b> specifies the name of the
              function and the <a title="static type" href=
              "#dt-static-type">static types</a> of its parameters
              and its result.] [<a title="function implementation"
              id="dt-function-implementation" name=
              "dt-function-implementation">Definition</a>: The
              <b>function implementation</b> enables the function
              to map instances of its parameter types into an
              instance of its result type. ]</p>

              <p>For each atomic type in the <a title=
              "in-scope type definitions" href=
              "#dt-is-types">in-scope type definitions</a>, there
              is a constructor function in the in-scope functions.
              Constructor functions are discussed in <a href=
              "#id-constructor-functions"><b>3.10.4 Constructor
              Functions</b></a>.</p>
            </li>

            <li>
              <p>[<a title="in-scope collations" id=
              "dt-is-collations" name=
              "dt-is-collations">Definition</a>: <b>In-scope
              collations.</b> This is a set of (URI, collation)
              pairs. It defines the names of the collations that
              are available for use in function calls that take a
              collation name as an argument.] A collation may be
              regarded as an object that supports two functions: a
              function that given a set of strings, returns a
              sequence containing those strings in sorted order;
              and a function that given two strings, returns true
              if they are considered equal, and false if not.</p>
            </li>

            <li>
              <p>[<a title="default collation" id=
              "dt-def-collation" name=
              "dt-def-collation">Definition</a>: <b>Default
              collation.</b> This collation is used by string
              comparison functions when no explicit collation is
              specified.]</p>
            </li>

            <li>
              <p>[<a title="base URI" id="dt-base-uri" name=
              "dt-base-uri">Definition</a>: <b>Base URI.</b> This
              is an absolute URI, used when necessary in the
              resolution of relative URIs (for example, by the
              <code>fn:resolve-uri</code> function.)]</p>
            </li>

            <li>
              <p>[<a title="statically-known documents" id=
              "dt-known-docs" name="dt-known-docs">Definition</a>:
              <b>Statically-known documents.</b> This is a mapping
              from strings onto types. The string represents the
              absolute URI of a resource that is potentially
              accessible using the <code>fn:doc</code> function.
              The type is the type of the document node that would
              result from calling the <code>fn:doc</code> function
              with this URI as its argument. ] If the argument to
              <code>fn:doc</code> is anthing other than a string
              literal that is present in statically-known
              documents, then the <a title="static type" href=
              "#dt-static-type">static type</a> of
              <code>fn:doc</code> is
              <code>document-node()?</code>.</p>
            </li>

            <li>
              <p>[<a title="statically-known collections" id=
              "dt-known-collections" name=
              "dt-known-collections">Definition</a>:
              <b>Statically-known collections.</b> This is a
              mapping from strings onto types. The string
              represents the absolute URI of a resource that is
              potentially accessible using the
              <code>fn:collection</code> function. The type is the
              type of the sequence of nodes that would result from
              calling the <code>fn:collection</code> function with
              this URI as its argument.] If the argument to
              <code>fn:collection</code> is anthing other than a
              string literal that is present in statically-known
              collections, then the <a title="static type" href=
              "#dt-static-type">static type</a> of
              <code>fn:collection</code> is
              <code>node()?</code>.</p>
            </li>
          </ul>

          <div class="div4">
            <h5><a id="id-predefined-types" name=
            "id-predefined-types"></a>2.1.1.1 Predefined Types</h5>

            <p>The <a title="in-scope type definitions" href=
            "#dt-is-types">in-scope type definitions</a> in the
            <a title="static context" href=
            "#dt-static-context">static context</a> are initialized
            with certain predefined types, including all the
            built-in types of <a href="#XMLSchema">[XML
            Schema]</a>. These built-in types are in the namespace
            <code>http://www.w3.org/2001/XMLSchema</code>,
            <span class="xpath"><span class="xpath">which is
            represented in this document by the
            prefix</span></span> <code>xs</code>. Some examples of
            built-in schema types include <code>xs:integer</code>,
            <code>xs:string</code>, and <code>xs:date</code>.
            Element and attribute definitions in the
            <code>xs</code> namespace are not implicitly included
            in the static context.</p>

            <p>In addition, the predefined types of XPath include
            the types listed below. All these predefined types are
            in the namespace
            <code>http://www.w3.org/2003/05/xpath-datatypes</code>,
            <span class="xpath"><span class="xpath">which is
            represented in this document by the
            prefix</span></span> <code>xdt</code>.</p>

            <ol class="enumar">
              <li>
                <p><code>xdt:anyAtomicType</code> is an abstract
                type that includes all atomic values (and no values
                that are not atomic). It is a subtype of
                <code>xs:anySimpleType</code>, which is the base
                type for all simple types, including atomic, list,
                and union types. All specific atomic types such as
                <code>xs:integer</code>, <code>xs:string</code>,
                and <code>xdt:untypedAtomic</code>, are subtypes of
                <code>xdt:anyAtomicType</code>.</p>
              </li>

              <li>
                <p><code>xdt:untypedAtomic</code> is a specific
                atomic type used for untyped data, such as text
                that is not given a specific type by schema
                validation. It has no subtypes.</p>
              </li>

              <li>
                <p><code>xdt:dayTimeDuration</code> is a subtype of
                <code>xs:duration</code> whose lexical
                representation contains only day, hour, minute, and
                second components.</p>
              </li>

              <li>
                <p><code>xdt:yearMonthDuration</code> is a subtype
                of <code>xs:duration</code> whose lexical
                representation is restricted to contain only year
                and month components.</p>
              </li>
            </ol>

            <p>For more details about predefined types, see
            <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
            2.0 Functions and Operators]</a>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a id="eval_context" name="eval_context"></a>2.1.2
          Dynamic Context</h4>

          <p>[<a title="dynamic context" id="dt-dynamic-context"
          name="dt-dynamic-context">Definition</a>: The <b>dynamic
          context</b> of an expression is defined as information
          that is available at the time the expression is
          evaluated.] If evaluation of an expression relies on some
          part of the <a title="dynamic context" href=
          "#dt-dynamic-context">dynamic context</a> that has not
          been assigned a value, a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> is
          raised.[<a title="err:XP0002" href=
          "#ERRXP0002">err:XP0002</a>]</p>

          <p>The individual components of the <a title=
          "dynamic context" href="#dt-dynamic-context">dynamic
          context</a> are summarized below. Further rules governing
          the semantics of these components can be found in
          <a href="#id-xp-evaluation-context-components"><b>C.2
          Dynamic Context Components</b></a>.</p>

          <p>The <a title="dynamic context" href=
          "#dt-dynamic-context">dynamic context</a> consists of all
          the components of the <a title="static context" href=
          "#dt-static-context">static context</a>, and the
          additional components listed below.</p>

          <p>[<a title="focus" id="dt-focus" name=
          "dt-focus">Definition</a>: The first three components of
          the <a title="dynamic context" href=
          "#dt-dynamic-context">dynamic context</a> (context item,
          context position, and context size) are called the
          <b>focus</b> of the expression. ] The focus enables the
          processor to keep track of which nodes are being
          processed by the expression.</p>

          <p>Certain language constructs, notably the path
          expression <code>E1/E2</code> and the predicate
          expression <code>E1[E2]</code>, create a new focus for
          the evaluation of a sub-expression. In these constructs,
          <code>E2</code> is evaluated once for each item in the
          sequence that results from evaluating <code>E1</code>.
          Each time <code>E2</code> is evaluated, it is evaluated
          with a different focus. The focus for evaluating
          <code>E2</code> is referred to below as the <b>inner
          focus</b>, while the focus for evaluating <code>E1</code>
          is referred to as the <b>outer focus</b>. The inner focus
          exists only while <code>E2</code> is being evaluated.
          When this evaluation is complete, evaluation of the
          containing expression continues with its original focus
          unchanged.</p>

          <ul>
            <li>
              <p>[<a title="context item" id="dt-context-item"
              name="dt-context-item">Definition</a>: The <b>context
              item</b> is the item currently being processed in a
              path expression. An item is either an atomic value or
              a node.][<a title="context node" id="dt-context-node"
              name="dt-context-node">Definition</a>: When the
              context item is a node, it can also be referred to as
              the <b>context node</b>.] The context item is
              returned by the expression "<code>.</code>". When an
              expression <code>E1/E2</code> or <code>E1[E2]</code>
              is evaluated, each item in the sequence obtained by
              evaluating <code>E1</code> becomes the context item
              in the inner focus for an evaluation of
              <code>E2</code>.</p>
            </li>

            <li>
              <p>[<a title="context position" id=
              "dt-context-position" name=
              "dt-context-position">Definition</a>: The <b>context
              position</b> is the position of the context item
              within the sequence of items currently being
              processed in a path expression. ]It changes whenever
              the context item changes. Its value is always an
              integer greater than zero. The context position is
              returned by the expression
              <code>fn:position()</code>. When an expression
              <code>E1/E2</code> or <code>E1[E2]</code> is
              evaluated, the context position in the inner focus
              for an evaluation of <code>E2</code> is the position
              of the context item in the sequence obtained by
              evaluating <code>E1</code>. The position of the first
              item in a sequence is always 1 (one). The context
              position is always less than or equal to the context
              size.</p>
            </li>

            <li>
              <p>[<a title="context size" id="dt-context-size"
              name="dt-context-size">Definition</a>: The <b>context
              size</b> is the number of items in the sequence of
              items currently being processed in a path
              expression.] Its value is always an integer greater
              than zero. The context size is returned by the
              expression <code>last()</code>. When an expression
              <code>E1/E2</code> or <code>E1[E2]</code> is
              evaluated, the context size in the inner focus for an
              evaluation of <code>E2</code> is the number of items
              in the sequence obtained by evaluating
              <code>E1</code>.</p>
            </li>

            <li>
              <p>[<a title="Dynamic variables" id="dt-dyn-vars"
              name="dt-dyn-vars">Definition</a>: <b>Dynamic
              variables</b>. This is a set of (QName, value) pairs.
              It contains the same QNames as the <a title=
              "in-scope variables" href="#dt-is-vars">in-scope
              variables</a> in the <a title="static context" href=
              "#dt-static-context">static context</a> for the
              expression. The QName is the name of the variable and
              the value is the dynamic value of the variable.]</p>
            </li>

            <li>
              <p>[<a title="current date and time" id=
              "dt-date-time" name="dt-date-time">Definition</a>:
              <b>Current date and time.</b> This information
              represents an implementation-dependent point in time
              during processing of a query or transformation. It
              can be retrieved by the <code>fn:current-date</code>,
              <code>fn:current-time</code>, and
              <code>fn:current-dateTime</code> functions. If
              invoked multiple times during the execution of a
              query or transformation, these functions always
              returns the same result.]</p>
            </li>

            <li>
              <p>[<a title="implicit timezone" id="dt-timezone"
              name="dt-timezone">Definition</a>: <b>Implicit
              timezone.</b> This is the timezone to be used when a
              date, time, or dateTime value that does not have a
              timezone is used in a comparison or in any other
              operation. This value is an instance of
              <code>xdt:dayTimeDuration</code> that is <a title=
              "implementation defined" href=
              "#dt-implementation-defined">implementation
              defined</a>. See <a href="#ISO8601">[ISO 8601]</a>
              for the range of legal values of a timezone.]</p>
            </li>

            <li>
              <p>[<a title="accessible documents" id=
              "dt-accessible-docs" name=
              "dt-accessible-docs">Definition</a>: <b>Accessible
              documents.</b> This is a mapping of strings onto
              document nodes. The string represents the absolute
              URI of a resource. The document node is the
              representation of that resource as an instance of the
              data model, as returned by the <code>fn:doc</code>
              function when applied to that URI. ]The set of
              accessible documents may be the same as, or a subset
              or superset of, the set of statically-known
              documents, and it may be empty.</p>
            </li>

            <li>
              <p>[<a title="accessible collections" id=
              "dt-accessible-collections" name=
              "dt-accessible-collections">Definition</a>:
              <b>Accessible collections.</b> This is a mapping of
              strings onto sequences of nodes. The string
              represents the absolute URI of a resource. The
              sequence of nodes represents the result of the
              <code>fn:collection</code> function when that URI is
              supplied as the argument. ] The set of accessible
              collections may be the same as, or a subset or
              superset of, the set of statically-known collections,
              and it may be empty.</p>
            </li>
          </ul>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-processing-model" name=
        "id-processing-model"></a>2.2 Processing Model</h3>

        <p>XPath is defined in terms of the <a title="data model"
        href="#dt-datamodel">data model</a> and in terms of the
        <a title="expression context" href=
        "#dt-expression-context">expression
        context</a>.</p><img src="ProcMod-XPath.gif" alt=
        "Processing Model Overview" />

        <p>Figure 1: Processing Model Overview</p>

        <p>Figure 1 provides a schematic overview of the processing
        steps that are discussed in detail below. XPath
        distinguishes between the external processing domain, which
        includes generation of the data model (see <a href=
        "#id-data-model-generation"><b>2.2.1 Data Model
        Generation</b></a>), schema import processing (see <a href=
        "#id-schema-import-processing"><b>2.2.2 Schema Import
        Processing</b></a>) and serialization (see <a href=
        "#id-serialization"><b>2.2.4 Serialization</b></a>), and
        the query processing domain, which includes the static
        analysis and dynamic evaluation phases (see <a href=
        "#id-expression-processing"><b>2.2.3 Expression
        Processing</b></a>). Consistency constraints on the query
        processing domain are defined in <a href=
        "#id-consistency-constraints"><b>2.2.5 Consistency
        Constraints</b></a>.</p>

        <table border="1" summary="Editorial note">
          <tr>
            <td width="50%" valign="top" align="left"><b>Editorial
            note</b></td>

            <td width="50%" valign="top" align="right">&#160;</td>
          </tr>

          <tr>
            <td valign="top" align="left" colspan="2">There is an
            open issue on how much of the external processing
            domain is considered normative (open issue 561).</td>
          </tr>
        </table>

        <div class="div3">
          <h4><a id="id-data-model-generation" name=
          "id-data-model-generation"></a>2.2.1 Data Model
          Generation</h4>

          <p>Before an expression can be processed, the input
          documents to be accessed by the expression must be
          represented in the <a title="data model" href=
          "#dt-datamodel">data model</a>. Figure 1 depicts the
          steps by which an XML document may be converted to the
          <a title="data model" href="#dt-datamodel">data
          model</a>:</p>

          <ol class="enumar">
            <li>
              <p>A document may be parsed using an XML parser that
              generates an <b>XML Information Set</b> (see <a href=
              "#XINFO">[XML Infoset]</a>). The parsed document may
              then be validated against one or more schemas. This
              process, which is described in <a href=
              "#XMLSchema">[XML Schema]</a>, results in an abstract
              information structure called the <b>Post-Schema
              Validation Infoset</b> (PSVI). If a document has no
              associated schema, its Information Set is preserved.
              (See DM1 in Fig. 1.)</p>
            </li>

            <li>
              <p>The Information Set or PSVI may be transformed
              into the <a title="data model" href=
              "#dt-datamodel">data model</a> by a process described
              in <a href="#datamodel">[XQuery 1.0 and XPath 2.0
              Data Model]</a>. (See DM2 in Fig. 1.)</p>
            </li>
          </ol>

          <p>The above steps provide an example of how a <a title=
          "data model" href="#dt-datamodel">data model</a> instance
          might be constructed. A <a title="data model" href=
          "#dt-datamodel">data model</a> instance might also be
          synthesized directly from a relational database, or
          constructed in some other way (see DM3 in Fig. 1.) XPath
          is defined in terms of operations on the <a title=
          "data model" href="#dt-datamodel">data model</a>, but it
          does not place any constraints on how the input <a title=
          "data model" href="#dt-datamodel">data model</a> instance
          is constructed.</p>

          <p>Each atomic value, element node, and attribute node in
          the <a title="data model" href="#dt-datamodel">data
          model</a> is annotated with its <a title="dynamic type"
          href="#dt-dynamic-type">dynamic type</a>. The dynamic
          type specifies a range of values -- for example, an
          attribute named <code>version</code> might have the
          dynamic type <code>xs:decimal</code>, indicating that it
          contains a decimal value. For example, if the <a title=
          "data model" href="#dt-datamodel">data model</a> was
          derived from an input XML document, the dynamic types of
          the elements and attributes are derived from schema
          validation.</p>

          <p>The value of an attribute is represented directly
          within the attribute node. An attribute node whose type
          is unknown (such as might occur in a schemaless document)
          is annotated with the dynamic type
          <code>xdt:untypedAtomic</code>.</p>

          <p>The value of an element is represented by the children
          of the element node, which may include text nodes and
          other element nodes. The dynamic type of an element node
          indicates how the values in its child text nodes are to
          be interpreted. An element whose type is unknown (such as
          might occur in a schemaless document) is annotated with
          the type <code>xdt:untypedAny</code>.</p>

          <p>An atomic value of unknown type is annotated with the
          type <code>xdt:untypedAtomic</code>.</p>
        </div>

        <div class="div3">
          <h4><a id="id-schema-import-processing" name=
          "id-schema-import-processing"></a>2.2.2 Schema Import
          Processing</h4>

          <div class="xpath">
            <p class="xpath">The <a title=
            "in-scope schema definitions" href="#dt-issd">in-scope
            schema definitions</a> in the <a title="static context"
            href="#dt-static-context">static context</a> are
            provided by the host language (see step SI1 in Figure
            1) and must satisfy the consistency constraints defined
            in <a href="#id-consistency-constraints"><b>2.2.5
            Consistency Constraints</b></a>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-expression-processing" name=
          "id-expression-processing"></a>2.2.3 Expression
          Processing</h4>

          <p>XPath defines two phases of processing called the
          <a title="static analysis phase" href=
          "#dt-static-analysis">static analysis phase</a> and the
          <a title="dynamic evaluation phase" href=
          "#dt-dynamic-evaluation">dynamic evaluation phase</a>
          (see Fig. 1).</p>

          <div class="div4">
            <h5><a id="id-static-analysis" name=
            "id-static-analysis"></a>2.2.3.1 Static Analysis
            Phase</h5>

            <p>[<a title="static analysis phase" id=
            "dt-static-analysis" name=
            "dt-static-analysis">Definition</a>: The <b>static
            analysis phase</b> depends on the expression itself and
            on the <a title="static context" href=
            "#dt-static-context">static context</a>. The static
            analysis phase does not depend on any input data.]</p>

            <p>During the static analysis phase, the query is
            parsed into an internal representation called the
            <b>operation tree</b> (step SQ1 in Figure 1). A parse
            error is raised as a <a title="static error" href=
            "#dt-static-error">static error</a>.[<a title=
            "err:XP0003" href="#ERRXP0003">err:XP0003</a>] The
            <a title="static context" href=
            "#dt-static-context">static context</a> is initialized
            by the implementation (step SQ2). The <a title=
            "static context" href="#dt-static-context">static
            context</a> is used to resolve type names, function
            names, namespace prefixes and variable names.</p>

            <p>The <b>operation tree</b> is then <b>normalized</b>
            by making explicit the implicit operations such as
            <a title="atomization" href=
            "#dt-atomization">atomization</a>, <b>type
            promotion</b> and extraction of <a title=
            "effective boolean value" href="#dt-ebv">Effective
            Boolean Values</a> (step SQ5). The normalization
            process is described in <a href=
            "#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
            Formal Semantics]</a>. An implementation is free to use
            any strategy or algorithm whose result conforms to
            these specifications.</p>

            <p>If the <a title="" href="#">Static Typing
            Feature</a> is supported, each expression is assigned a
            <a title="static type" href="#dt-static-type">static
            type</a> (step SQ6). [<a title="static type" id=
            "dt-static-type" name="dt-static-type">Definition</a>:
            The <b>static type</b> of an expression may be either a
            named type or a structural description--for example,
            <code>xs:boolean?</code> denotes an optional occurrence
            of the <code>xs:boolean</code> type. The rules for
            inferring the <a title="static type" href=
            "#dt-static-type">static type</a>s of various
            expressions are described in <a href=
            "#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
            Formal Semantics]</a>.] In some cases, the <a title=
            "static type" href="#dt-static-type">static type</a> is
            derived from the lexical form of the expression; for
            example, the <a title="static type" href=
            "#dt-static-type">static type</a> of the literal
            <code>5</code> is <code>xs:integer</code>. In other
            cases, the <a title="static type" href=
            "#dt-static-type">static type</a> of an expression is
            inferred according to rules based on the static types
            of its operands; for example, the <a title=
            "static type" href="#dt-static-type">static type</a> of
            the expression <code>5 + 1.2</code> is
            <code>xs:decimal</code>.</p>

            <p>During the <a title="static analysis phase" href=
            "#dt-static-analysis">analysis phase</a>, if the
            <a title="" href="#">Static Typing Feature</a> is in
            effect and an operand of an expression is found to have
            a <a title="static type" href="#dt-static-type">static
            type</a> that is not appropriate for that operand, a
            <a title="type error" href="#dt-type-error">type
            error</a> is raised.[<a title="err:XQ0004" href=
            "#ERRXQ0004">err:XQ0004</a>] If static type checking
            raises no errors and assigns a <a title="static type"
            href="#dt-static-type">static type</a> T to an
            expression, then execution of the expression on valid
            input data is guaranteed either to produce a value of
            type T or to raise a <a title="dynamic error" href=
            "#dt-dynamic-error">dynamic error</a>.</p>

            <p>During the <a title="static analysis phase" href=
            "#dt-static-analysis">static analysis phase</a>, if the
            <a title="static type" href="#dt-static-type">static
            type</a> assigned to an expression other than
            <code>()</code> is empty, a <a title="static error"
            href="#dt-static-error">static error</a> is
            raised.[<a title="err:XQ0005" href=
            "#ERRXQ0005">err:XQ0005</a>] This catches cases in
            which a query refers to an element or attribute that is
            not present in the <a title=
            "in-scope schema definitions" href="#dt-issd">in-scope
            schema definitions</a>, possibly because of a spelling
            error.</p>

            <p>The purpose of type-checking during the static
            analysis phase is to provide early detection of
            <a title="type error" href="#dt-type-error">type
            errors</a> and to infer type information that may be
            useful in optimizing the evaluation of an
            expression.</p>
          </div>

          <div class="div4">
            <h5><a id="id-dynamic-evaluation" name=
            "id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation
            Phase</h5>

            <p>[<a title="dynamic evaluation phase" id=
            "dt-dynamic-evaluation" name=
            "dt-dynamic-evaluation">Definition</a>: The <b>dynamic
            evaluation phase</b> is performed only after successful
            completion of the <a title="static analysis phase"
            href="#dt-static-analysis">static analysis phase</a>.
            The dynamic evaluation phase depends on the
            <b>operation tree</b> of the expression being evaluated
            (step DQ1), on the input data (step DQ4), and on the
            <a title="dynamic context" href=
            "#dt-dynamic-context">dynamic context</a> (step DQ5),
            which in turn draws information from the external
            environment (step DQ3) and the <a title=
            "static context" href="#dt-static-context">static
            context</a> (step DQ2).] Execution of the evaluation
            phase may create new data-model values (step DQ4) and
            it may extend the <a title="dynamic context" href=
            "#dt-dynamic-context">dynamic context</a> (step
            DQ5)--for example, by binding values to variables.</p>

            <table border="1" summary="Editorial note">
              <tr>
                <td width="50%" valign="top" align="left">
                <b>Editorial note</b></td>

                <td width="50%" valign="top" align="right">
                &#160;</td>
              </tr>

              <tr>
                <td valign="top" align="left" colspan="2">This is
                an open issue. It would be possible to evaluate an
                expression containing a <a title="type error" href=
                "#dt-type-error">static type error</a>, and this
                might be quite useful because static analysis is
                conservative. Static type analysis could be used to
                warn of potential errors without inhibiting
                execution of an expression.</td>
              </tr>
            </table>

            <p>[<a title="dynamic type" id="dt-dynamic-type" name=
            "dt-dynamic-type">Definition</a>: A <b>dynamic type</b>
            is associated with each value as it is computed. The
            dynamic type of a value may be either a structural type
            (such as "sequence of integers") or a named type. The
            dynamic type of a value may be more specific than the
            <a title="static type" href="#dt-static-type">static
            type</a> of the expression that computed it (for
            example, the <a title="static type" href=
            "#dt-static-type">static type</a> of an expression
            might be "zero or more integers or strings," but at
            evaluation time its value may have the dynamic type
            "integer.")]</p>

            <p>If an operand of an expression is found to have a
            dynamic type that is not appropriate for that operand,
            a <a title="type error" href="#dt-type-error">type
            error</a> is raised.[<a title="err:XP0006" href=
            "#ERRXP0006">err:XP0006</a>]</p>

            <p>Even though static typing can catch many <a title=
            "type error" href="#dt-type-error">type errors</a>
            before an expression is executed, it is possible for an
            expression to raise an error during evaluation that was
            not detected by static analysis. For example, an
            expression may contain a cast of a string into an
            integer, which is statically valid. However, if the
            actual value of the string at run time cannot be cast
            into an integer, a <a title="dynamic error" href=
            "#dt-dynamic-error">dynamic error</a> will result.
            Similarly, an expression may apply an arithmetic
            operator to a value whose <a title="static type" href=
            "#dt-static-type">static type</a> is
            <code>xdt:untypedAtomic</code>. This is not a <a title=
            "static error" href="#dt-static-error">static
            error</a>, but at run time, if the value cannot be
            successfully cast to a numeric type, a <a title=
            "dynamic error" href="#dt-dynamic-error">dynamic
            error</a> will be raised.</p>

            <p>It is also possible for static analysis of an
            expression to raise a <a title="type error" href=
            "#dt-type-error">type error</a>, even though execution
            of the expression on certain inputs would be
            successful. For example, an expression might contain a
            function that requires an element as its parameter, and
            the analysis phase might infer the <a title=
            "static type" href="#dt-static-type">static type</a> of
            the function parameter to be an optional element. This
            case would be treated as a <a title="type error" href=
            "#dt-type-error">static type error</a>, even though the
            function call would be successful for input data in
            which the optional element is present.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-serialization" name=
          "id-serialization"></a>2.2.4 Serialization</h4>

          <p>[<a title="serialization" id="dt-serialization" name=
          "dt-serialization">Definition</a>: <b>Serialization</b>
          is the process of converting an instance of the <a href=
          "#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>
          into a sequence of octets (step DM4 in Figure 1.) ] The
          general framework for serialization of the <a title=
          "data model" href="#dt-datamodel">data model</a> is
          described in <a href="#serialization">[XSLT 2.0 and
          XQuery 1.0 Serialization]</a>.</p>

          <div class="xpath">
            <p class="xpath">Details of the serialization process
            are specified by the host language.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-consistency-constraints" name=
          "id-consistency-constraints"></a>2.2.5 Consistency
          Constraints</h4>

          <p>In order for an expression to be well defined, the
          expression, its <a title="static context" href=
          "#dt-static-context">static context</a>, and its
          <a title="dynamic context" href=
          "#dt-dynamic-context">dynamic context</a> must be
          mutually consistent. The consistency constraints listed
          below are prerequisites for correct functioning of an
          XPath implementation. Enforcement of these consistency
          constraints is beyond the scope of this
          specification.</p>

          <ul>
            <li>
              <p>For each item type (i.e., element, attribute, or
              type name) referenced in an instance of the <a title=
              "data model" href="#dt-datamodel">data model</a>
              whose expanded name matches a name in the in-scope
              schema definitions (ISSD), the corresponding element,
              attribute, or type definition in the ISSD must be
              equivalent to the definition originally provided in
              the PSVI from which the <a title="data model" href=
              "#dt-datamodel">data model</a> instance was
              created.</p>
            </li>

            <li>
              <p>Every item type (i.e., every element, attribute,
              or type name) referenced in <a title=
              "in-scope variables" href="#dt-is-vars">in-scope
              variables</a> or <a title="in-scope functions" href=
              "#dt-is-funcs">in-scope functions</a> must be in the
              <a title="in-scope schema definitions" href=
              "#dt-issd">in-scope schema definitions</a>.</p>
            </li>

            <li>
              <p>Every name used in a <a title="SequenceType" href=
              "#dt-sequence-type">SequenceType</a> must be in the
              <a title="in-scope schema definitions" href=
              "#dt-issd">in-scope schema definitions</a>.</p>
            </li>

            <li>
              <p>The element declaration for every element name
              referenced in a <a title="SequenceType" href=
              "#dt-sequence-type">SequenceType</a> or
              <b>KindTest</b> must be in the <a title=
              "in-scope element declarations" href=
              "#dt-is-elems">in-scope element declarations</a>.</p>
            </li>

            <li>
              <p>The attribute declaration for every attribute name
              referenced in a <a title="SequenceType" href=
              "#dt-sequence-type">SequenceType</a> or
              <b>KindTest</b> must be in the <a title=
              "in-scope attribute declarations" href=
              "#dt-is-attrs">in-scope attribute
              declarations</a>.</p>
            </li>

            <li>
              <p>For each mapping of a string to a document node in
              <a title="accessible documents" href=
              "#dt-accessible-docs">accessible documents</a>, if
              there exists a mapping of the same string to a
              document type in <a title=
              "statically-known documents" href=
              "#dt-known-docs">statically-known documents</a>, the
              document node must match the document type, using the
              matching rules in <a href=
              "#id-sequencetype-matching"><b>2.4.1.1 SequenceType
              Matching</b></a>.</p>
            </li>

            <li>
              <p>For each mapping of a string to a sequence of
              nodes in <a title="accessible collections" href=
              "#dt-accessible-collections">accessible
              collections</a>, if there exists a mapping of the
              same string to a type in <a title=
              "statically-known collections" href=
              "#dt-known-collections">statically-known
              collections</a>, the sequence of nodes must match the
              type, using the matching rules in <a href=
              "#id-sequencetype-matching"><b>2.4.1.1 SequenceType
              Matching</b></a>.</p>
            </li>

            <li>
              <p>The <a title="Dynamic variables" href=
              "#dt-dyn-vars">dynamic variables</a> in the <a title=
              "dynamic context" href="#dt-dynamic-context">dynamic
              context</a> and the <a title="in-scope variables"
              href="#dt-is-vars">in-scope variables</a> in the
              <a title="static context" href=
              "#dt-static-context">static context</a> must
              correspond as follows:</p>

              <ul>
                <li>
                  <p>All variables defined in <a title=
                  "in-scope variables" href="#dt-is-vars">in-scope
                  variables</a> must be defined in <a title=
                  "Dynamic variables" href="#dt-dyn-vars">dynamic
                  variables</a>.</p>
                </li>

                <li>
                  <p>For each (variable, type) pair in <b>in-scope
                  variables</b> and the corresponding (variable,
                  value) pair in <a title="Dynamic variables" href=
                  "#dt-dyn-vars">dynamic variables</a> such that
                  the variable names are equal, the value must
                  match the type, using the matching rules in
                  <a href="#id-sequencetype-matching"><b>2.4.1.1
                  SequenceType Matching</b></a>.</p>
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-important-concepts" name=
        "id-important-concepts"></a>2.3 Important Concepts</h3>

        <p>The concepts described in this section are normatively
        defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0
        Data Model]</a> and <a href=
        "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
        Functions and Operators]</a>. They are summarized here
        because they are of particular importance in the processing
        of expressions.</p>

        <div class="div3">
          <h4><a id="N1078F" name="N1078F"></a>2.3.1 Document
          Order</h4>

          <p>[<a title="document order" id="dt-docorder" name=
          "dt-docorder">Definition</a>: <b>Document order</b>
          defines a total ordering among all the nodes seen by the
          language processor and is defined formally in the
          <a title="data model" href="#dt-datamodel">data
          model</a>.] Informally, document order corresponds to a
          pre-order, depth-first, left-to-right traversal of the
          nodes in the <a title="data model" href=
          "#dt-datamodel">data model</a>.</p>

          <p>Within a given document, the document node is the
          first node, followed by element nodes, text nodes,
          comment nodes, and processing instruction nodes in the
          order of their representation in the XML form of the
          document (after expansion of entities). Element nodes
          occur before their children, and the children of an
          element node occur before its following siblings. The
          namespace nodes of an element immediately follow the
          element node, in implementation-defined order. The
          attribute nodes of an element immediately follow its
          namespace nodes, and are also in implementation-defined
          order.</p>

          <p>The relative order of nodes in distinct documents is
          <a title="implementation dependent" href=
          "#dt-implementation-dependent">implementation
          dependent</a> but stable within a given query or
          transformation. Given two distinct documents A and B, if
          a node in document A is before a node in document B, then
          every node in document A is before every node in document
          B. The relative order among free-floating nodes (those
          not in a document) is also <a title=
          "implementation dependent" href=
          "#dt-implementation-dependent">implementation
          dependent</a> but stable.</p>
        </div>

        <div class="div3">
          <h4><a id="id-typed-value" name=
          "id-typed-value"></a>2.3.2 Typed Value and String
          Value</h4>

          <p>Nodes have a <a title="typed value" href=
          "#dt-typed-value">typed value</a> and a <a title=
          "string value" href="#dt-string-value">string value</a>.
          [<a title="typed value" id="dt-typed-value" name=
          "dt-typed-value">Definition</a>: The <b>typed value</b>
          of a node is a sequence of atomic values and can be
          extracted by applying the <code>fn:data</code> function
          to the node. The typed value for each kind of node is
          defined by the <code>dm:typed-value</code> accessor in
          <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
          Model]</a>. ] [<a title="string value" id=
          "dt-string-value" name="dt-string-value">Definition</a>:
          The <b>string value</b> of a node is a string and can be
          extracted by applying the the <code>fn:string</code>
          function to the node. The string value for each kind of
          node is defined by the <code>dm:string-value</code>
          accessor in <a href="#datamodel">[XQuery 1.0 and XPath
          2.0 Data Model]</a>.] [<a title="type annotation" id=
          "dt-type-annotation" name=
          "dt-type-annotation">Definition</a>: Element and
          attribute nodes have a <b>type annotation</b>, which
          represents (in an implementation-dependent way) the
          <a title="dynamic type" href="#dt-dynamic-type">dynamic
          (run-time) type</a> of the node.] XPath does not provide
          a way to directly access the type annotation of an
          element or attribute node.</p>

          <p>The relationship between the typed value and the
          string value for various kinds of nodes is described and
          illustrated by examples below.</p>

          <ol class="enumar">
            <li>
              <p>For text, document, comment, processing
              instruction, and namespace nodes, the typed value of
              the node is the same as its string value, as an
              instance of <code>xdt:untypedAtomic</code>. (The
              string value of a document node is formed by
              concatenating the string values of all its descendant
              text nodes, in document order.)</p>
            </li>

            <li>
              <p>The typed value of an attribute node with the type
              annotation <code>xdt:untypedAtomic</code> is the same
              as its string value, as an instance of
              <code>xdt:untypedAtomic</code>. The typed value of an
              attribute node with any other type annotation is
              derived from its string value and type annotation in
              a way that is consistent with schema validation.</p>

              <p>Example: A1 is an attribute having string value
              <code>"3.14E-2"</code> and type annotation
              <code>xs:double</code>. The typed value of A1 is the
              <code>xs:double</code> value whose lexical
              representation is <code>3.14E-2</code>.</p>

              <p>Example: A2 is an attribute with type annotation
              <code>IDREFS</code>, which is a list type derived
              from <code>IDREF</code>. Its string value is
              "<code>bar baz faz</code>". The typed value of A2 is
              a sequence of three atomic values
              ("<code>bar</code>", "<code>baz</code>",
              "<code>faz</code>"), each of type <code>IDREF</code>.
              The typed value of a node is never treated as an
              instance of a named list type. Instead, if the type
              annotation of a node is a list type (such as
              <code>IDREFS</code>), its typed value is treated as a
              sequence of the underlying base type (such as
              <code>IDREF</code>).</p>
            </li>

            <li>
              <p>For an element node, the relationship between
              typed value and string value depends on the node's
              type annotation, as follows:</p>

              <ol class="enumla">
                <li>
                  <p>If the type annotation is
                  <code>xs:anyType</code>, or denotes a complex
                  type with mixed content, then the typed value of
                  the node is equal to its string value, as an
                  instance of <code>xdt:untypedAtomic</code>.</p>

                  <p>Example: E1 is an element node having type
                  annotation <code>xs:anyType</code> and string
                  value "<code>1999-05-31</code>". The typed value
                  of E1 is "<code>1999-05-31</code>", as an
                  instance of <code>xdt:untypedAtomic</code>.</p>

                  <p>Example: E2 is an element node with the type
                  annotation <code>formula</code>, which is a
                  complex type with mixed content. The content of
                  E2 consists of the character "<code>H</code>", a
                  child element named <code>subscript</code> with
                  string value "<code>2</code>", and the character
                  "<code>O</code>". The typed value of E2 is
                  "<code>H2O</code>" as an instance of
                  <code>xdt:untypedAtomic</code>.</p>
                </li>

                <li>
                  <p>If the type annotation denotes a simple type
                  or a complex type with simple content, then the
                  typed value of the node is derived from its
                  string value and its type annotation in a way
                  that is consistent with schema validation.</p>

                  <p>Example: E3 is an element node with the type
                  annotation <code>cost</code>, which is a complex
                  type that has several attributes and a simple
                  content type of <code>xs:decimal</code>. The
                  string value of E3 is "<code>74.95</code>". The
                  typed value of E3 is <code>74.95</code>, as an
                  instance of <code>xs:decimal</code>.</p>

                  <p>Example: E4 is an element node with the type
                  annotation <code>hatsizelist</code>, which is a
                  simple type derived by list from the type
                  <code>hatsize</code>, which in turn is derived
                  from <code>xs:integer</code>. The string value of
                  E4 is "<code>7 8 9</code>". The typed value of E4
                  is a sequence of three values (<code>7</code>,
                  <code>8</code>, <code>9</code>), each of type
                  <code>hatsize</code>.</p>
                </li>

                <li>
                  <p>If the type annotation denotes a complex type
                  with empty content, then the typed value of the
                  node is the empty sequence.</p>
                </li>

                <li>
                  <p>If the type annotation denotes a complex type
                  with non-mixed complex content, then the typed
                  value of the node is undefined. The
                  <code>fn:data</code> function raises a <a title=
                  "type error" href="#dt-type-error">type error</a>
                  [<a title="err:XP0007" href=
                  "#ERRXP0007">err:XP0007</a>] when applied to such
                  a node.</p>

                  <p>Example: E5 is an element node with the type
                  annotation <code>weather</code>, which is a
                  complex type whose content type specifies
                  <code>elementOnly</code>. E5 has two child
                  elements named <code>temperature</code> and
                  <code>precipitation</code>. The typed value of E5
                  is undefined, and the <code>fn:data</code>
                  function applied to E5 raises an error.</p>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <div class="div3">
          <h4><a id="id-input-sources" name=
          "id-input-sources"></a>2.3.3 Input Sources</h4>

          <p>XPath has a set of functions that provide access to
          input data. These functions are of particular importance
          because they provide a way in which an expression can
          reference a document or a collection of documents. The
          input functions are described informally here, and in
          more detail in <a href="#FunctionsAndOperators">[XQuery
          1.0 and XPath 2.0 Functions and Operators]</a>.</p>

          <p>An expression can access input documents either by
          calling one of the input functions or by referencing some
          part of the expression context that is initialized by the
          external environment, such as a <b>variable</b> or a
          pre-initialized <a title="context item" href=
          "#dt-context-item">context item</a>.</p>

          <p>The input functions supported by XPath are as
          follows:</p>

          <ul>
            <li>
              <p>The <code>fn:doc</code> function takes a string
              containing a URI that refers to an XML document, and
              returns a document node whose content is the
              <a title="data model" href="#dt-datamodel">data
              model</a> representation of the given document.</p>
            </li>

            <li>
              <p>The <code>fn:collection</code> function returns
              the nodes found in a collection. A collection may be
              any sequence of nodes. A collection is identified by
              a string, which must be a valid URI. For example, the
              expression
              <code>fn:collection("http://example.org")//customer</code>
              identifies all the <code>customer</code> elements
              that are descendants of nodes found in the collection
              whose URI is <code>http://example.org</code>.</p>
            </li>
          </ul>

          <p>If a given input function is invoked repeatedly with
          the same arguments during the scope of a single query or
          transformation, each invocation returns the same
          result.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-type-conversion" name=
        "id-type-conversion"></a>2.4 Types</h3>

        <p>XPath is a strongly typed language with a type system
        based on <a href="#XMLSchema">[XML Schema]</a>. The XPath
        type system is formally defined in <a href=
        "#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
        Semantics]</a>. During the analysis phase, if <a title=
        "static type" href="#dt-static-type">static type</a>
        checking is in effect and an expression has a <a title=
        "static type" href="#dt-static-type">static type</a> that
        is not appropriate for the context in which the expression
        is used, a <a title="type error" href="#dt-type-error">type
        error</a> is raised.[<a title="err:XQ0004" href=
        "#ERRXQ0004">err:XQ0004</a>] During the evaluation phase,
        if the type of a value is incompatible with the expected
        type of the context in which the value is used, a <a title=
        "type error" href="#dt-type-error">type error</a> is
        raised.[<a title="err:XP0006" href=
        "#ERRXP0006">err:XP0006</a>] A <a title="type error" href=
        "#dt-type-error">type error</a> may be detected and
        reported either during the <a title="static analysis phase"
        href="#dt-static-analysis">static analysis phase</a> or
        during the <a title="dynamic evaluation phase" href=
        "#dt-dynamic-evaluation">dynamic evaluation phase</a>.</p>

        <div class="div3">
          <h4><a id="id-sequencetype" name=
          "id-sequencetype"></a>2.4.1 SequenceType</h4>

          <p>[<a title="SequenceType" id="dt-sequence-type" name=
          "dt-sequence-type">Definition</a>: When it is necessary
          to refer to a type in an XPath expression, the syntax
          shown below is used. This syntax production is called
          <b>SequenceType</b>, since it describes the type of an
          XPath value, which is a sequence.]</p>

          <h5><a id="N10912" name="N10912"></a>SequenceType</h5>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SequenceType" name=
                "doc-SequenceType"></a>[62]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SequenceType">SequenceType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a href="#doc-ItemType">ItemType</a>
                <a href=
                "#doc-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />

                | ("empty" "(" ")")</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-OccurrenceIndicator" name=
                "doc-OccurrenceIndicator"></a>[77]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-OccurrenceIndicator">OccurrenceIndicator</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"?" | "*" | "+"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ItemType" name=
                "doc-ItemType"></a>[64]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ItemType">ItemType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-AtomicType">AtomicType</a>
                | <a href="#doc-KindTest">KindTest</a> | ("item"
                "(" ")")</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AtomicType" name=
                "doc-AtomicType"></a>[63]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AtomicType">AtomicType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-KindTest" name=
                "doc-KindTest"></a>[65]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-KindTest">KindTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-DocumentTest">DocumentTest</a><br />
                | <a href="#doc-ElementTest">ElementTest</a><br />
                | <a href=
                "#doc-AttributeTest">AttributeTest</a><br />
                | <a href="#doc-PITest">PITest</a><br />
                | <a href="#doc-CommentTest">CommentTest</a><br />
                | <a href="#doc-TextTest">TextTest</a><br />
                | <a href=
                "#doc-AnyKindTest">AnyKindTest</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-PITest" name=
                "doc-PITest"></a>[68]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-PITest">PITest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"processing-instruction" "(" (<a href=
                "#prod-NCName">NCName</a> | <a href=
                "#doc-StringLiteral">StringLiteral</a>)?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-CommentTest" name=
                "doc-CommentTest"></a>[70]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-CommentTest">CommentTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"comment" "(" ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-TextTest" name=
                "doc-TextTest"></a>[71]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-TextTest">TextTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"text" "(" ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AnyKindTest" name=
                "doc-AnyKindTest"></a>[72]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AnyKindTest">AnyKindTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"node" "(" ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-DocumentTest" name=
                "doc-DocumentTest"></a>[69]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-DocumentTest">DocumentTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"document-node" "(" <a href=
                "#doc-ElementTest">ElementTest</a>? ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ElementTest" name=
                "doc-ElementTest"></a>[66]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ElementTest">ElementTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"element" "(" ((<a href=
                "#doc-SchemaContextPath">SchemaContextPath</a>
                <a href="#doc-LocalName">LocalName</a>)<br />
                | (<a href="#doc-NodeName">NodeName</a> (","
                <a href="#doc-TypeName">TypeName</a>
                "nillable"?)?))? ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AttributeTest" name=
                "doc-AttributeTest"></a>[67]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AttributeTest">AttributeTest</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"attribute" "(" ((<a href=
                "#doc-SchemaContextPath">SchemaContextPath</a> "@"
                <a href="#doc-LocalName">LocalName</a>)<br />
                | ("@" <a href="#doc-NodeName">NodeName</a> (","
                <a href="#doc-TypeName">TypeName</a>)?))?
                ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SchemaContextPath" name=
                "doc-SchemaContextPath"></a>[73]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SchemaContextPath">SchemaContextPath</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-SchemaGlobalContext">SchemaGlobalContext</a>
                "/" (<a href=
                "#doc-SchemaContextStep">SchemaContextStep</a>
                "/")*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SchemaGlobalContext" name=
                "doc-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SchemaGlobalContext">SchemaGlobalContext</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> |
                <a href="#doc-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SchemaContextStep" name=
                "doc-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SchemaContextStep">SchemaContextStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SchemaGlobalTypeName" name=
                "doc-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"type" "(" <a href=
                "#prod-QName">QName</a> ")"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-LocalName" name=
                "doc-LocalName"></a>[74]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-LocalName">LocalName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-QName">QName</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-NodeName" name=
                "doc-NodeName"></a>[75]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-NodeName">NodeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> |
                "*"</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-TypeName" name=
                "doc-TypeName"></a>[76]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-TypeName">TypeName</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> |
                "*"</code></td>
              </tr>
            </tbody>
          </table>

          <p>QNames appearing in a SequenceType have their prefixes
          expanded to namespace URIs by means of the <a title=
          "in-scope namespaces" href="#dt-is-namespaces">in-scope
          namespaces</a> and the <a title=
          "default element/type namespace" href=
          "#dt-def-elemtype-ns">default element/type namespace</a>.
          It is a <a title="static error" href=
          "#dt-static-error">static error</a> [<a title=
          "err:XP0008" href="#ERRXP0008">err:XP0008</a>] to use a
          name in a SequenceType if that name is not found in the
          appropriate part of the <a title=
          "in-scope schema definitions" href="#dt-issd">in-scope
          schema definitions</a>. If the name is used as an element
          name, it must appear in the <a title=
          "in-scope element declarations" href=
          "#dt-is-elems">in-scope element declarations</a>; if it
          is used as an attribute name, it must appear in the
          <a title="in-scope attribute declarations" href=
          "#dt-is-attrs">in-scope attribute declarations</a>; and
          if it is used as a type name, it must appear in the
          <a title="in-scope type definitions" href=
          "#dt-is-types">in-scope type definitions</a>.</p>

          <p>Here are some examples of SequenceTypes that might be
          used in XPath expressions:</p>

          <ul>
            <li>
              <p><code>xs:date</code> refers to the built-in Schema
              type <code>date</code></p>
            </li>

            <li>
              <p><code>attribute()?</code> refers to an optional
              attribute</p>
            </li>

            <li>
              <p><code>element()</code> refers to any element</p>
            </li>

            <li>
              <p><code>element(po:shipto, po:address)</code> refers
              to an element that has the name
              <code>po:shipto</code> (or is in the substitution
              group of that element), and has the type annotation
              <code>po:address</code> (or a subtype of that
              type)</p>
            </li>

            <li>
              <p><code>element(po:shipto, *)</code> refers to an
              element named <code>po:shipto</code> (or in the
              substitution group of <code>po:shipto</code>), with
              no restrictions on its type</p>
            </li>

            <li>
              <p><code>element(*, po:address)</code> refers to an
              element of any name that has the type annotation
              <code>po:address</code> (or a subtype of
              <code>po:address</code>). If the keyword
              <code>nillable</code> were used following
              <code>po:address</code>, that would indicate that the
              element may have empty content and the attribute
              <code>xsi:nil="true"</code>, even though the
              declaration of the type <code>po:address</code> has
              required content.</p>
            </li>

            <li>
              <p><code>node()*</code> refers to a sequence of zero
              or more nodes of any type</p>
            </li>

            <li>
              <p><code>item()+</code> refers to a sequence of one
              or more nodes or atomic values</p>
            </li>
          </ul>

          <div class="div4">
            <h5><a id="id-sequencetype-matching" name=
            "id-sequencetype-matching"></a>2.4.1.1 SequenceType
            Matching</h5>

            <p>[<a title="SequenceType matching" id=
            "dt-sequencetype-matching" name=
            "dt-sequencetype-matching">Definition</a>: During
            evaluation of an expression, it is sometimes necessary
            to determine whether a given value matches a type that
            was declared using the SequenceType syntax. This
            process is known as <b>SequenceType matching</b>.] For
            example, an <code>instance of</code> expression returns
            <code>true</code> if a given value matches a given
            type, or <code>false</code> if it does not.</p>

            <table border="1" summary="Editorial note">
              <tr>
                <td width="50%" valign="top" align="left">
                <b>Editorial note</b></td>

                <td width="50%" valign="top" align="right">
                &#160;</td>
              </tr>

              <tr>
                <td valign="top" align="left" colspan="2">The
                definition of SequenceType matching still needs to
                be correlated with the definition of type matching
                in <a href="#XQueryFormalSemantics">[XQuery 1.0 and
                XPath 2.0 Formal Semantics]</a>.</td>
              </tr>
            </table>

            <p><a title="SequenceType matching" href=
            "#dt-sequencetype-matching">SequenceType matching</a>
            between a given value and a given SequenceType is
            performed as follows:</p>

            <p>If the SequenceType is <code>empty()</code>, the
            match succeeds only if the value is an empty sequence.
            If the SequenceType is an ItemType with no
            OccurrenceIndicator, the match succeeds only if the
            value contains precisely one item and that item matches
            the ItemType (see below). If the SequenceType contains
            an ItemType and an OccurrenceIndicator, the match
            succeeds only if the number of items in the value is
            consistent with the OccurrenceIndicator, and each of
            these items matches the ItemType. As a consequence of
            these rules, a value that is an empty sequence matches
            any SequenceType whose occurrence indicator is
            <code>*</code> or <code>?</code>.</p>

            <p>An <b>OccurrenceIndicator</b> indicates the number
            of items in a sequence, as follows:</p>

            <ul>
              <li>
                <p><code>?</code> indicates zero or one items</p>
              </li>

              <li>
                <p><code>*</code> indicates zero or more items</p>
              </li>

              <li>
                <p><code>+</code> indicates one or more items</p>
              </li>
            </ul>

            <p>As stated above, an item may be a node or an atomic
            value. The process of matching a given item against a
            given ItemType is performed as follows</p>

            <ol class="enumar">
              <li>
                <p>The ItemType <code>item()</code> matches any
                single item. For example, <code>item()</code>
                matches the atomic value <code>1</code> or the
                element <code>&lt;a/&gt;</code>.</p>
              </li>

              <li>
                <p>If an ItemType consists simply of a QName, that
                QName must be the name of an atomic type that is in
                the <a title="in-scope type definitions" href=
                "#dt-is-types">in-scope type definitions</a>;
                otherwise a <a title="static error" href=
                "#dt-static-error">static error</a> is raised. An
                ItemType consisting of the QName of an atomic type
                matches a value if the dynamic type of the value is
                the same as the named atomic type, or is derived
                from the named atomic type by restriction. For
                example, the ItemType <code>xs:decimal</code>
                matches the value <code>12.34</code> (a decimal
                literal); it also matches a value whose dynamic
                type is <code>shoesize</code>, if
                <code>shoesize</code> is an atomic type derived by
                restriction from <code>xs:decimal</code>. The named
                atomic type may be a generic type such as
                <code>xdt:anyAtomicType</code>. (Note that names of
                non-atomic types such as <code>xs:IDREFS</code> are
                not accepted in this context, but can often be
                replaced by an atomic type with an occurrence
                indicator, such as <code>xs:IDREF*</code>.)</p>
              </li>

              <li>
                <p>The following ItemTypes (referred to generically
                as <b>KindTests</b>) match nodes:</p>

                <ol class="enumla">
                  <li>
                    <p><code>node()</code> matches any node.</p>
                  </li>

                  <li>
                    <p><code>text()</code> matches any text
                    node.</p>
                  </li>

                  <li>
                    <p><code>processing-instruction()</code>
                    matches any processing instruction node.</p>
                  </li>

                  <li>
                    <p>
                    <code>processing-instruction(</code><em>N</em><code>
                    )</code> matches any processing instruction
                    node whose name (called its "PITarget" in XML)
                    is equal to <em>N</em>, where N is an
                    <b>NCName</b>. Example:
                    <code>processing-instruction(xml-stylesheet)</code>
                    matches any processing instruction whose
                    PITarget is <code>xml-stylesheet</code>.</p>

                    <p>For backward compatibility with XPath 1.0,
                    the PITarget of a processing instruction in a
                    KindTest may also be expressed as a string
                    literal, as in this example:
                    <code>processing-instruction("xml-stylesheet")</code>.</p>
                  </li>

                  <li>
                    <p><code>comment()</code> matches any comment
                    node.</p>
                  </li>

                  <li>
                    <p><code>document-node()</code> matches any
                    document node.</p>
                  </li>

                  <li>
                    <p>
                    <code>document-node(</code><em>E</em><code>)</code>
                    matches any document node whose content
                    consists of exactly one element node that
                    matches <em>E</em>, where <em>E</em> is an
                    <a title="ElementTest" href=
                    "#dt-element-test">ElementTest</a> (see below),
                    mixed with zero or more comments and processing
                    instructions. Example:
                    <code>document-node(element(book))</code>
                    matches any document node whose content
                    contains exactly one element node named
                    <code>book</code>, that conforms to the schema
                    declaration for the top-level element
                    <code>book</code> (possibly mixed with comments
                    and processing instructions).</p>
                  </li>

                  <li>
                    <p>An <a title="ElementTest" href=
                    "#dt-element-test">ElementTest</a> (see below)
                    matches an element node, optionally qualifying
                    the node by its name, its type, or both.</p>
                  </li>

                  <li>
                    <p>An <a title="AttributeTest" href=
                    "#dt-attribute-test">AttributeTest</a> (see
                    below) matches an attribute node, optionally
                    qualifying the node by its name, its type, or
                    both.</p>
                  </li>
                </ol>
              </li>
            </ol>

            <p>[<a title="ElementTest" id="dt-element-test" name=
            "dt-element-test">Definition</a>: An <b>ElementTest</b>
            is used to match an element node by its name and/or
            type.] An ElementTest may take one of the following
            forms:</p>

            <ol class="enumar">
              <li>
                <p><code>element()</code>, or
                <code>element(*)</code>, or
                <code>element(*,*)</code>. All these forms of
                ElementTest are equivalent, and they all match any
                single element node, regardless of its name or
                type.</p>
              </li>

              <li>
                <p><code>element(</code><em>N</em><code>,</code>
                <em>T</em><code>)</code>, where <em>N</em> is a
                QName and <em>T</em> is a QName optionally followed
                by the keyword <code>nillable</code>. In this case,
                <em>T</em> must be the name of a top-level type
                definition in the <a title=
                "in-scope type definitions" href=
                "#dt-is-types">in-scope type definitions</a>. The
                ElementTest matches a given element node if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given element node is equal
                    to <em>N</em> (expanded QNames match), or is
                    equal to the name of any element in a
                    substitution group headed by a top-level
                    element with the name <em>N</em>; and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given element
                    node is <em>T</em>, or is a named type that is
                    derived by restriction or extension from
                    <em>T</em>. However, this test is not satisfied
                    if the given element node has the
                    <code>nilled</code> property and <em>T</em>
                    does not specify <code>nillable</code>.</p>
                  </li>
                </ol>

                <p>The following examples illustrate this form of
                ElementTest, matching an element node whose name is
                <code>person</code> and whose type annotation is
                <code>surgeon</code> (the second example permits
                the element to have
                <code>xsi:nil="true"</code>):</p>

                <div class="exampleInner">
                  <pre>
element(person, surgeon)
element(person, surgeon nillable)
</pre>
                </div>
              </li>

              <li>
                <p><code>element(</code><em>N</em><code>)</code>,
                where <em>N</em> is a QName. This form is very
                similar to the previous form, except that the
                required type, rather than being named explicitly,
                is taken from the top-level declaration of element
                <em>N</em>. In this case, <em>N</em> must be the
                name of a top-level element declaration in the
                <a title="in-scope element declarations" href=
                "#dt-is-elems">in-scope element declarations</a>.
                The ElementTest matches a given element node
                if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given element node is equal
                    to <em>N</em> (expanded QNames match), or is
                    equal to the name of any element in a
                    substitution group headed by <em>N</em>;
                    and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given element
                    node is the same as, or derived by restriction
                    or extension from, the type of the top-level
                    declaration for element <em>N</em>. The types
                    to be compared may be either named types
                    (identified by QNames) or anonymous types
                    (identified in an implementation-dependent
                    way). However, this test is not satisfied if
                    the given element node has an attribute
                    <code>xsi:nil="true"</code> and the top-level
                    declaration for element <em>N</em> does not
                    specify <code>nillable</code>.</p>
                  </li>
                </ol><br />
                <br />

                <p>The following example illustrates this form of
                ElementTest, matching an element node whose name is
                <code>person</code> and whose type annotation
                conforms to the top-level <code>person</code>
                element declaration in the <a title=
                "in-scope element declarations" href=
                "#dt-is-elems">in-scope element
                declarations</a>:</p>

                <div class="exampleInner">
                  <pre>
element(person)
</pre>
                </div>
              </li>

              <li>
                <p><code>element(</code><em>N</em><code>,
                *),</code> where <em>N</em> is a QName. This
                ElementTest matches a given element node if the
                name of the node is equal to <em>N</em> (expanded
                QNames match), or is equal to the name of any
                element in a substitution group headed by a
                top-level element with the name <em>N</em>. The
                given element node may have any type
                annotation.</p>

                <p>The following example illustrates this form of
                ElementTest, matching any element node whose name
                is <code>person</code> or is in the
                <code>person</code> substitution group, regardless
                of its type annotation:</p>

                <div class="exampleInner">
                  <pre>
element(person, *)
</pre>
                </div>
              </li>

              <li>
                <p><code>element(*,</code>
                <em>T</em><code>)</code>, where <em>T</em> is a
                QName optionally followed by the keyword
                <code>nillable</code>. In this case, <em>T</em>
                must be the name of a top-level type definition in
                the <a title="in-scope type definitions" href=
                "#dt-is-types">in-scope type definitions</a>. The
                ElementTest matches a given element node if the
                node's type annotation is <em>T</em>, or is a named
                type that is derived by restriction or extension
                from <em>T</em>. However, this test is not
                satisfied if the given element node has an
                attribute <code>xsi:nil="true"</code> and
                <em>T</em> does not specify
                <code>nillable</code>.</p>

                <p>The following examples illustrate this form of
                ElementTest, matching any element node whose type
                annotation is <code>surgeon</code>, regardless of
                its name (the second example permits the element to
                have <code>xsi:nil="true"</code>):</p>

                <div class="exampleInner">
                  <pre>
element(*, surgeon)
element(*, surgeon nillable)
</pre>
                </div>
              </li>

              <li>
                <p><code>element(</code><em>P</em><code>)</code>,
                where <em>P</em> is a valid schema context path
                beginning with a top-level element name or type
                name in the <a title="in-scope schema definitions"
                href="#dt-issd">in-scope schema definitions</a> and
                ending with an element name. This ElementTest
                matches a given element node if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given element node is equal
                    to the last name in the path (expanded QNames
                    match), and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given element
                    node is the same as the type of the element
                    represented by the schema path <em>P</em>.</p>
                  </li>
                </ol>

                <p>The following examples illustrate this form of
                ElementTest, matching element nodes whose name is
                <code>person</code>. In the first example, the node
                must conform to the schema definition of a
                <code>person</code> element in a <code>staff</code>
                element in a <code>hospital</code> element. In the
                second example, the node must conform to the schema
                definition of a <code>person</code> element within
                the top-level type <code>schedule</code>:</p>

                <div class="exampleInner">
                  <pre>
element(hospital/staff/person)
element(type(schedule)/person)
</pre>
                </div>
              </li>
            </ol>

            <p>[<a title="AttributeTest" id="dt-attribute-test"
            name="dt-attribute-test">Definition</a>: An
            <b>AttributeTest</b> is used to match an attribute node
            by its name and/or type.] An AttributeTest may take one
            of the following forms:</p>

            <ol class="enumar">
              <li>
                <p><code>attribute()</code>, or
                <code>attribute(@*)</code>, or
                <code>attribute(@*,*)</code>. All these forms of
                AttributeTest are equivalent, and they all match
                any single attribute node, regardless of its name
                or type.</p>
              </li>

              <li>
                <p><code>attribute(@</code><em>N</em><code>,</code>
                <em>T</em><code>)</code>, where <em>N</em> and
                <em>T</em> are QNames. In this case, <em>T</em>
                must be the name of a top-level simple type
                definition in the <a title=
                "in-scope type definitions" href=
                "#dt-is-types">in-scope type definitions</a>. This
                AttributeTest matches a given attribute node
                if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given attribute node is
                    equal to <em>N</em> (expanded QNames match),
                    and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given attribute
                    node is <em>T</em>, or is a named type that is
                    derived by restriction from <em>T</em>.</p>
                  </li>
                </ol>

                <p>The following example illustrates this form of
                AttributeTest, matching an attribute node whose
                name is <code>price</code> and whose type
                annotation is <code>currency</code>:</p>

                <div class="exampleInner">
                  <pre>
attribute(@price, currency)
</pre>
                </div>
              </li>

              <li>
                <p>
                <code>attribute(@</code><em>N</em><code>)</code>,
                where <em>N</em> is a QName. This form is very
                similar to the previous form, except that the
                required type, rather than being named explicitly,
                is taken from the top-level attribute declaration
                with name <em>N</em>.In this case, <em>N</em> must
                be the name of a top-level attribute declaration in
                the <a title="in-scope attribute declarations"
                href="#dt-is-attrs">in-scope attribute
                declarations</a>. This AttributeTest matches a
                given attribute node if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given attribute node is
                    equal to <em>N</em> (expanded QNames match),
                    and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given attribute
                    node is the same as, or derived by restriction
                    from, the type of the top-level attribute
                    declaration for <em>N</em>. The types to be
                    compared may be either named types (identified
                    by QNames) or anonymous types (identified in an
                    implementation-dependent way).</p>
                  </li>
                </ol><br />
                <br />

                <p>The following example illustrates this form of
                AttributeTest, matching an attribute node whose
                name is <code>price</code> and whose type
                annotation conforms to the schema declaration for a
                top-level <code>price</code> attribute:</p>

                <div class="exampleInner">
                  <pre>
attribute(@price)
</pre>
                </div>
              </li>

              <li>
                <p><code>attribute(@</code><em>N</em><code>,
                *)</code>, where <em>N</em> is a QName. This
                AttributeTest matches a given attribute node if the
                name of the node is equal to <em>N</em> (expanded
                QNames match). The given attribute node may have
                any type annotation.</p>

                <p>The following example illustrates this form of
                AttributeTest, matching any attribute node whose
                name is <code>price</code>, regardless of its type
                annotation:</p>

                <div class="exampleInner">
                  <pre>
attribute(@price, *)
</pre>
                </div>
              </li>

              <li>
                <p><code>attribute(@*,</code>
                <em>T</em><code>)</code>, where <em>T</em> is a
                QName. In this case, <em>T</em> must be the name of
                a top-level simple type definition in the <a title=
                "in-scope type definitions" href=
                "#dt-is-types">in-scope type definitions</a>. This
                AttributeTest matches a given attribute node if the
                node's type annotation is <span>T</span>, or is a
                named type that is derived by restriction from
                <em>T</em>.</p>

                <p>The following example illustrates this form of
                AttributeTest, matching any attribute node whose
                type annotation is <code>currency</code>,
                regardless of its name:</p>

                <div class="exampleInner">
                  <pre>
attribute(@*, currency)
</pre>
                </div>
              </li>

              <li>
                <p><code>attribute(</code><em>P</em><code>)</code>,
                where <em>P</em> is a valid schema context path
                beginning with a top-level element name or type
                name in the <a title="in-scope schema definitions"
                href="#dt-issd">in-scope schema definitions</a>,
                and ending with an attribute name (preceded by
                <code>@</code>). This AttributeTest matches a given
                attribute node if:</p>

                <ol class="enumla">
                  <li>
                    <p>the name of the given attribute node is
                    equal to the last name in the path (expanded
                    QNames match), and:</p>
                  </li>

                  <li>
                    <p>the type annotation of the given attribute
                    node is the same as the type of the attribute
                    represented by the schema path <em>P</em>.</p>
                  </li>
                </ol>

                <p>The following examples illustrate this form of
                AttributeTest, matching attribute nodes whose name
                is <code>price</code>. In the first example, the
                node must conform to the schema definition of a
                <code>price</code> attribute in a
                <code>product</code> element in a
                <code>catalog</code> element. In the second
                example, the node must conform to the schema
                definition of a <code>price</code> attribute within
                the top-level type <code>plan</code>:</p>

                <div class="exampleInner">
                  <pre>
attribute(catalog/product/@price)
attribute(type(plan)/@price)
</pre>
                </div>
              </li>
            </ol>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-type-conversions" name=
          "id-type-conversions"></a>2.4.2 Type Conversions</h4>

          <p>Some expressions do not require their operands to
          exactly match the expected type. For example, function
          parameters and returns expect a value of a particular
          type, but automatically perform certain type conversions,
          such as extraction of atomic values from nodes, promotion
          of numeric values, and implicit casting of untyped
          values. The conversion rules for function parameters and
          returns are discussed in <a href=
          "#id-function-calls"><b>3.1.5 Function Calls</b></a>.
          Other operators that provide special conversion rules
          include arithmetic operators, which are discussed in
          <a href="#id-arithmetic"><b>3.4 Arithmetic
          Expressions</b></a>, and value comparisons, which are
          discussed in <a href="#id-value-comparisons"><b>3.5.1
          Value Comparisons</b></a>.</p>

          <div class="div4">
            <h5><a id="id-atomization" name=
            "id-atomization"></a>2.4.2.1 Atomization</h5>

            <p>Type conversions sometimes depend on a process
            called <a title="atomization" href=
            "#dt-atomization">atomization</a>. [<a title=
            "atomization" id="dt-atomization" name=
            "dt-atomization">Definition</a>: <b>Atomization</b> is
            applied to a value when the value is used in a context
            in which a sequence of atomic values is required. The
            result of atomization is either a sequence of atomic
            values or a <a title="type error" href=
            "#dt-type-error">type error</a>. Atomization of a
            sequence is defined as the result of invoking the
            <code>fn:data</code> function on the sequence, as
            defined in <a href="#FunctionsAndOperators">[XQuery 1.0
            and XPath 2.0 Functions and Operators]</a>.]</p>

            <p>The semantics of <code>fn:data</code> are repeated
            here for convenience. The result of
            <code>fn:data</code> is the sequence of atomic values
            produced by applying the following rules to each item
            in the input sequence:</p>

            <ul>
              <li>
                <p>If the item is an atomic value, it is
                returned.</p>
              </li>

              <li>
                <p>If the item is a node, it is replaced by its
                <a title="typed value" href="#dt-typed-value">typed
                value</a>.</p>
              </li>
            </ul>

            <p>Atomization may be used in processing the following
            types of expressions:</p>

            <ul>
              <li>
                <p>Arithmetic expressions</p>
              </li>

              <li>
                <p>Comparison expressions</p>
              </li>

              <li>
                <p>Function calls and returns</p>
              </li>

              <li>
                <p>Cast expressions</p>
              </li>
            </ul>
          </div>

          <div class="div4">
            <h5><a id="id-ebv" name="id-ebv"></a>2.4.2.2 Effective
            Boolean Value</h5>

            <p>Under certain circumstances (listed below), it is
            necessary to find the <a title=
            "effective boolean value" href="#dt-ebv">effective
            boolean value</a> of a value. [<a title=
            "effective boolean value" id="dt-ebv" name=
            "dt-ebv">Definition</a>: The <b>effective boolean
            value</b> of a value is defined as the result of
            applying the <code>fn:boolean</code> function to the
            value, as defined in <a href=
            "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a>.]</p>

            <p>The semantics of <code>fn:boolean</code> are
            repeated here for convenience. <code>fn:boolean</code>
            returns <code>false</code> if its operand is any of the
            following:</p>

            <ul>
              <li>
                <p>An empty sequence.</p>
              </li>

              <li>
                <p>The boolean value <code>false</code>.</p>
              </li>

              <li>
                <p>A zero-length string (<code>""</code>).</p>
              </li>

              <li>
                <p>A numeric value that is equal to zero.</p>
              </li>

              <li>
                <p>The <code>double</code> or <code>float</code>
                value <code>NaN</code>.</p>
              </li>
            </ul>

            <p>Otherwise, <code>fn:boolean</code> returns
            <code>true</code>.</p>

            <p>The <a title="effective boolean value" href=
            "#dt-ebv">effective boolean value</a> of a sequence is
            computed implicitly during processing of the following
            types of expressions:</p>

            <ul>
              <li>
                <p>Logical expressions (<code>and</code>,
                <code>or</code>)</p>
              </li>

              <li>
                <p>The <code>fn:not</code> function</p>
              </li>

              <li>
                <p>Certain types of predicates, such as
                <code>a[b]</code>.</p>
              </li>

              <li>
                <p>Conditional expressions (<code>if</code>)</p>
              </li>

              <li>
                <p>Quantified expressions (<code>some</code>,
                <code>every</code>)</p>
              </li>
            </ul>

            <p>Note that the definition of <a title=
            "effective boolean value" href="#dt-ebv">effective
            boolean value</a> is not used when casting a value to
            the type <code>xs:boolean</code>.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a id="errors" name="errors"></a>2.5 Error
        Handling</h3>

        <div class="div3">
          <h4><a id="id-kinds-of-errors" name=
          "id-kinds-of-errors"></a>2.5.1 Kinds of Errors</h4>

          <p>As described in <a href=
          "#id-expression-processing"><b>2.2.3 Expression
          Processing</b></a>, XPath defines an <a title=
          "static analysis phase" href=
          "#dt-static-analysis">analysis phase</a>, which does not
          depend on input data, and an <a title=
          "dynamic evaluation phase" href=
          "#dt-dynamic-evaluation">evaluation phase</a>, which does
          depend on input data. Errors may be raised during each
          phase.</p>

          <p>[<a title="static error" id="dt-static-error" name=
          "dt-static-error">Definition</a>: A <b>static error</b>
          is an error that must be detected during the analysis
          phase. A syntax error is an example of a <a title=
          "static error" href="#dt-static-error">static error</a>.
          The means by which <a title="static error" href=
          "#dt-static-error">static errors</a> are reported during
          the analysis phase is <a title="implementation defined"
          href="#dt-implementation-defined">implementation
          defined</a>. ]</p>

          <p>[<a title="dynamic error" id="dt-dynamic-error" name=
          "dt-dynamic-error">Definition</a>: A <b>dynamic error</b>
          is an error that must be detected during the evaluation
          phase and may be detected during the analysis phase.
          Numeric overflow is an example of a dynamic error. ]</p>

          <p>[<a title="type error" id="dt-type-error" name=
          "dt-type-error">Definition</a>: A <b>type error</b> may
          be raised during the analysis or evaluation phase. During
          the analysis phase, a <a title="type error" href=
          "#dt-type-error">type error</a> occurs when the <a title=
          "static type" href="#dt-static-type">static type</a> of
          an expression does not match the expected type of the
          context in which the expression occurs. During the
          evaluation phase, a <a title="type error" href=
          "#dt-type-error">type error</a> occurs when the dynamic
          type of a value does not match the expected type of the
          context in which the value occurs. ]</p>

          <p>The result of the <a title="static analysis phase"
          href="#dt-static-analysis">analysis phase</a> is either
          success or one or more <a title="type error" href=
          "#dt-type-error">type errors</a> and/or <a title=
          "static error" href="#dt-static-error">static
          errors</a>.</p>

          <p>The result of the <a title="dynamic evaluation phase"
          href="#dt-dynamic-evaluation">evaluation phase</a> is
          either a result value, a <a title="type error" href=
          "#dt-type-error">type error</a>, or a <a title=
          "dynamic error" href="#dt-dynamic-error">dynamic
          error</a>. If evaluation of an expression yields a value
          (that is, it does not raise an error), the value must be
          the value specified by the dynamic semantics defined in
          <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath
          2.0 Formal Semantics]</a>.</p>

          <p>If any expression (at any level) can be evaluated
          during the analysis phase (because all its explicit
          operands are known and it has no dependencies on the
          dynamic context), then any error in performing this
          evaluation may be reported as a static error. However,
          the <code>fn:error()</code> function must not be
          evaluated during the analysis phase. For example, an
          implementation is allowed (but not required) to treat the
          following expression as a static error, because it calls
          a constructor function with a constant string that is not
          in the lexical space of the target type:</p>

          <div class="exampleInner">
            <pre>
xs:date("Next Tuesday")
</pre>
          </div>

          <p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath
          2.0 Formal Semantics]</a> defines the set of static,
          dynamic, and <a title="type error" href=
          "#dt-type-error">type errors</a>. In addition to these
          errors, an XPath implementation may raise <a title=
          "implementation defined" href=
          "#dt-implementation-defined">implementation defined</a>
          <b>warnings</b>, either during the analysis phase or the
          evaluation phase. The circumstances in which warnings are
          raised, and the ways in which warnings are handled, are
          <a title="implementation defined" href=
          "#dt-implementation-defined">implementation
          defined</a>.</p>

          <p>In addition to the errors defined in this
          specification, an implementation may raise a <a title=
          "dynamic error" href="#dt-dynamic-error">dynamic
          error</a> if insufficient resources are available for
          processing a given expression. For example, an
          implementation may specify limitations on the maximum
          numbers or sizes of various objects. These limitations,
          and the consequences of exceeding them, are <a title=
          "implementation defined" href=
          "#dt-implementation-defined">implementation
          defined</a>.</p>
        </div>

        <div class="div3">
          <h4><a id="id-handling-dynamic" name=
          "id-handling-dynamic"></a>2.5.2 Handling Dynamic
          Errors</h4>

          <p>Except as noted in this document, if any operand of an
          expression raises a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a>, the expression
          also raises a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a>. If an expression
          can validly return a value or raise a dynamic error, the
          implementation may choose to return the value or raise
          the <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a>. For example, the
          logical expression <code>expr1 and expr2</code> may
          return the value <code>false</code> if either operand
          returns <code>false</code>, or may raise a <a title=
          "dynamic error" href="#dt-dynamic-error">dynamic
          error</a> if either operand raises a dynamic error.</p>

          <p>If more than one operand of an expression raises an
          error, the implementation may choose which error is
          raised by the expression. For example, in this
          expression:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
($x div $y) + xs:decimal($z)
</pre>
            </div>
          </div>

          <p>both the sub-expressions <code>($x div $y)</code> and
          <code>xs:decimal($z)</code> may raise an error. The
          implementation may choose which error is raised by the
          "<code>+</code>" expression. Once one operand raises an
          error, the implementation is not required, but is
          permitted, to evaluate any other operands.</p>

          <p>A <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> carries an
          <a title="error value" href="#dt-error-value">error
          value</a>. [<a title="error value" id="dt-error-value"
          name="dt-error-value">Definition</a>: An <b>error
          value</b> is a single item or the empty sequence.] For
          example, an error value might be an integer, a string, a
          QName, or an element. An implementation may provide a
          mechanism whereby an application-defined error handler
          can process error values and produce diagnostics; in the
          absence of such an error handler, the <a title=
          "string value" href="#dt-string-value">string-value</a>
          of the error value may be used directly as an error
          message.</p>

          <p>A <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> may be raised by a
          built-in function or operator. For example, the
          <code>div</code> operator raises an error if its second
          operand equals zero.</p>

          <p>An error can be raised explicitly by calling the
          <code>fn:error</code> function, which only raises an
          error and never returns a value. The
          <code>fn:error</code> function takes an optional item as
          its parameter, which is the <a title="error value" href=
          "#dt-error-value">error value</a>. For example, the
          following function call raises a <a title="dynamic error"
          href="#dt-dynamic-error">dynamic error</a> whose error
          value is a string:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
fn:error(fn:concat("Unexpected value ", fn:string($v)))
</pre>
            </div>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-errors-and-opt" name=
          "id-errors-and-opt"></a>2.5.3 Errors and
          Optimization</h4>

          <p>Because different implementations may choose to
          evaluate or optimize an expression in different ways, the
          detection and reporting of <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic errors</a> is <a title=
          "implementation dependent" href=
          "#dt-implementation-dependent">implementation
          dependent</a>.</p>

          <p>When an implementation is able to evaluate an
          expression without evaluating some subexpression, the
          implementation is never required to evaluate that
          subexpression solely to determine whether it raises a
          <a title="dynamic error" href="#dt-dynamic-error">dynamic
          error</a>. For example, if a function parameter is never
          used in the body of the function, an implementation may
          choose whether to evaluate the expression bound to that
          parameter in a function call.</p>

          <p>In some cases, an optimizer may be able to achieve
          substantial performance improvements by rearranging an
          expression so that the underlying operations such as
          projection, restriction, and sorting are performed in a
          different order than that specified in <a href=
          "#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
          Semantics]</a>. In such cases, dynamic errors may be
          raised that would not have been raised if the expression
          were evaluated as written. For example, consider the
          following expression:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
$N[@x castable as xs:date]
      [xs:date(@x) gt xs:date("2000-01-01")]
</pre>
            </div>
          </div>

          <p>This expression cannot raise a casting error if it is
          evaluated exactly as written (i.e., left to right). An
          implementation is permitted, however, to reorder the
          predicates to achieve better performance (for example, by
          taking advantage of an index). This reordering could
          cause the above expression to raise an error. However, an
          expression must not be rearranged in a way that causes it
          to return a result value that is different from the
          result value defined by <a href=
          "#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
          Semantics]</a>.</p>

          <p>To avoid unexpected errors caused by reordering of
          expressions, tests that are designed to prevent dynamic
          errors should be expressed using conditional expressions,
          as in the following example:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre>
            </div>
          </div>

          <p>In the case of a conditional expression, the
          implementation is required not to evaluate the
          <code>then</code> branch if the condition is false, and
          not to evaluate the <code>else</code> branch if the
          condition is true. Conditional expressions are the only
          expressions that provide guaranteed conditions under
          which a particular subexpression will not be
          evaluated.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-optional-features" name=
        "id-optional-features"></a>2.6 Optional Features</h3>

        <div class="xpath">
          <p class="xpath">XPath 2.0 defines an optional feature
          called the <b>Static Typing Feature</b>. An
          implementation that includes this feature is required to
          detect type errors during the <a title=
          "static analysis phase" href="#dt-static-analysis">static
          analysis phase</a>. If an expression contains one or more
          static errors or type errors, then a Static Typing
          implementation must raise at least one of these errors
          during the <a title="static analysis phase" href=
          "#dt-static-analysis">static analysis phase</a>.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a id="id-expressions" name="id-expressions"></a>3
      Expressions</h2>

      <p>This section introduces each of the basic kinds of
      expression. Each kind of expression has a name such as
      <code>PathExpr</code>, which is introduced on the left side
      of the grammar production that defines the expression. Since
      XPath is a composable language, each kind of expression is
      defined in terms of other expressions whose operators have a
      higher precedence. In this way, the precedence of operators
      is represented explicitly in the grammar.</p>

      <p>The order in which expressions are discussed in this
      document does not reflect the order of operator precedence.
      In general, this document introduces the simplest kinds of
      expressions first, followed by more complex expressions. For
      a complete overview of the grammar, see the Appendix
      [<a href="#nt-bnf"><b>A XPath Grammar</b></a>].</p>

      <table summary="Scrap" class="scrap">
        <tbody>
          <tr valign="baseline">
            <td><a id="doc-XPath" name=
            "doc-XPath"></a>[15]&#160;&#160;&#160;</td>

            <td><code><a href="#prod-XPath">XPath</a></code></td>

            <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

            <td><code><a href="#doc-Expr">Expr</a>?</code></td>
          </tr>
        </tbody>

        <tbody>
          <tr valign="baseline">
            <td><a id="doc-Expr" name=
            "doc-Expr"></a>[16]&#160;&#160;&#160;</td>

            <td><code><a href="#prod-Expr">Expr</a></code></td>

            <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

            <td><code><a href="#doc-ExprSingle">ExprSingle</a> (","
            <a href="#doc-ExprSingle">ExprSingle</a>)*</code></td>
          </tr>
        </tbody>

        <tbody>
          <tr valign="baseline">
            <td><a id="doc-ExprSingle" name=
            "doc-ExprSingle"></a>[17]&#160;&#160;&#160;</td>

            <td><code><a href=
            "#prod-ExprSingle">ExprSingle</a></code></td>

            <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

            <td><code><a href="#doc-ForExpr">ForExpr</a><br />
            | <a href=
            "#doc-QuantifiedExpr">QuantifiedExpr</a><br />
            | <a href="#doc-IfExpr">IfExpr</a><br />
            | <a href="#doc-OrExpr">OrExpr</a></code></td>
          </tr>
        </tbody>
      </table>

      <p><span class="xpath"><span class="xpath">The highest-level
      (goal) symbol in the XPath grammar is
      XPath.</span></span></p>

      <p>The XPath operator that has lowest precedence is the comma
      operator, which is used to concatenate two operands to form a
      sequence. As shown in the grammar, a general expression
      (Expr) can consist of two operands (ExprSingle) separated by
      a comma. The name ExprSingle denotes an expression that does
      not contain a top-level comma operator (despite its name, an
      ExprSingle may evaluate to a sequence containing more than
      one item.)</p>

      <p>The symbol ExprSingle is used in various places in the
      grammar where an expression is not allowed to contain a
      top-level comma. For example, each of the arguments of a
      function call must be an ExprSingle, because commas are used
      to separate the arguments of a function call.</p>

      <p>After the comma, the expressions that have next lowest
      precedence are <span class="xpath"><span class=
      "xpath">ForExpr,</span></span> QuantifiedExpr, IfExpr, and
      OrExpr. Each of these expressions is described in a separate
      section of this document.</p>

      <div class="div2">
        <h3><a id="id-primary-expressions" name=
        "id-primary-expressions"></a>3.1 Primary Expressions</h3>

        <p>[<a title="primary expression" id=
        "dt-primary-expression" name=
        "dt-primary-expression">Definition</a>: <b>Primary
        expressions</b> are the basic primitives of the language.
        They include literals, variables, function calls,
        constructors, and the use of parentheses to control
        precedence of operators. ]</p>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-PrimaryExpr" name=
              "doc-PrimaryExpr"></a>[42]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-PrimaryExpr">PrimaryExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-Literal">Literal</a> |
              <a href="#doc-FunctionCall">FunctionCall</a> |
              <a href="#doc-ContextItemExpr">ContextItemExpr</a> |
              ("$" <a href="#doc-VarName">VarName</a>) | <a href=
              "#doc-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-VarName" name=
              "doc-VarName"></a>[12]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-VarName">VarName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a></code></td>
            </tr>
          </tbody>
        </table>

        <div class="div3">
          <h4><a id="id-literals" name="id-literals"></a>3.1.1
          Literals</h4>

          <p>[<a title="literal" id="dt-literal" name=
          "dt-literal">Definition</a>: A <b>literal</b> is a direct
          syntactic representation of an atomic value.] XPath
          supports two kinds of literals: numeric literals and
          string literals.</p>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-Literal" name=
                "doc-Literal"></a>[57]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-Literal">Literal</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-NumericLiteral">NumericLiteral</a> | <a href=
                "#doc-StringLiteral">StringLiteral</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-NumericLiteral" name=
                "doc-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-NumericLiteral">NumericLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-IntegerLiteral">IntegerLiteral</a> | <a href=
                "#doc-DecimalLiteral">DecimalLiteral</a> | <a href=
                "#doc-DoubleLiteral">DoubleLiteral</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-IntegerLiteral" name=
                "doc-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-IntegerLiteral">IntegerLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-Digits">Digits</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-DecimalLiteral" name=
                "doc-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-DecimalLiteral">DecimalLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("." <a href="#doc-Digits">Digits</a>) |
                (<a href="#doc-Digits">Digits</a> "."
                [0-9]*)</code></td>

                <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-DoubleLiteral" name=
                "doc-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-DoubleLiteral">DoubleLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(("." <a href="#doc-Digits">Digits</a>) |
                (<a href="#doc-Digits">Digits</a> ("." [0-9]*)?))
                ("e" | "E") ("+" | "-")? <a href=
                "#doc-Digits">Digits</a></code></td>

                <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-StringLiteral" name=
                "doc-StringLiteral"></a>[6]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-StringLiteral">StringLiteral</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>('"' (('"' '"') | [^"])* '"') | ("'"
                (("'" "'") | [^'])* "'")</code></td>

                <td><i>/* <a href="#ws-significant">ws:
                significant</a> */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-Digits" name=
                "doc-Digits"></a>[10]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-Digits">Digits</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>[0-9]+</code></td>
              </tr>
            </tbody>
          </table>

          <p>The value of a <b>numeric literal</b> containing no
          "<code>.</code>" and no <code>e</code> or <code>E</code>
          character is an atomic value whose type is
          <code>xs:integer</code> and whose value is obtained by
          parsing the numeric literal according to the rules of the
          <code>xs:integer</code> datatype. The value of a numeric
          literal containing "<code>.</code>" but no <code>e</code>
          or <code>E</code> character is an atomic value whose type
          is <code>xs:decimal</code> and whose value is obtained by
          parsing the numeric literal according to the rules of the
          <code>xs:decimal</code> datatype. The value of a numeric
          literal containing an <code>e</code> or <code>E</code>
          character is an atomic value whose type is
          <code>xs:double</code> and whose value is obtained by
          parsing the numeric literal according to the rules of the
          <code>xs:double</code> datatype.</p>

          <p>The value of a <b>string literal</b> is an atomic
          value whose type is <code>xs:string</code> and whose
          value is the string denoted by the characters between the
          delimiting apostrophes or quotation marks. If the literal
          is delimited by apostrophes, two adjacent apostrophes
          within the literal are interpreted as a single
          apostrophe. Similarly, if the literal is delimited by
          quotation marks, two adjacent quotation marks within the
          literal are interpreted as one quotation mark.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>If a string literal is used in an XPath expression
            contained within the value of an XML attribute, the
            characters used to delimit the literal should be
            different from the characters that are used to delimit
            the attribute.</p>
          </div>

          <p>Here are some examples of literal expressions:</p>

          <ul>
            <li>
              <p><code>"12.5"</code> denotes the string containing
              the characters '1', '2', '.', and '5'.</p>
            </li>

            <li>
              <p><code>12</code> denotes the integer value
              twelve.</p>
            </li>

            <li>
              <p><code>12.5</code> denotes the decimal value twelve
              and one half.</p>
            </li>

            <li>
              <p><code>125E2</code> denotes the double value twelve
              thousand, five hundred.</p>
            </li>

            <li>
              <p><code>"He said, ""I don't like it."""</code>
              denotes a string containing two quotation marks and
              one apostrophe.</p>
            </li>
          </ul>

          <p>The boolean values <code>true</code> and
          <code>false</code> can be represented by calls to the
          built-in functions <code>fn:true()</code> and
          <code>fn:false()</code>, respectively.</p>

          <p>Values of other XML Schema built-in types can be
          constructed by calling the constructor for the given
          type. The constructors for XML Schema built-in types are
          defined in <a href="#FunctionsAndOperators">[XQuery 1.0
          and XPath 2.0 Functions and Operators]</a>. In general,
          the name of a constructor function for a given type is
          the same as the name of the type (including its
          namespace). For example:</p>

          <ul>
            <li>
              <p><code>xs:integer("12")</code> returns the integer
              value twelve.</p>
            </li>

            <li>
              <p><code>xs:date("2001-08-25")</code> returns an item
              whose type is <code>xs:date</code> and whose value
              represents the date 25th August 2001.</p>
            </li>

            <li>
              <p><code>xdt:dayTimeDuration("PT5H")</code> returns
              an item whose type is
              <code>xdt:dayTimeDuration</code> and whose value
              represents a duration of five hours.</p>
            </li>
          </ul>

          <p>It is also possible to construct values of various
          types by using a <code>cast</code> expression. For
          example:</p>

          <ul>
            <li>
              <p><code>9 cast as hatsize</code> returns the atomic
              value <code>9</code> whose type is
              <code>hatsize</code>.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="id-variables" name="id-variables"></a>3.1.2
          Variables</h4>

          <p>A <b>variable reference</b> is a QName preceded by a
          $-sign. Two variable references are equivalent if their
          local names are the same and their namespace prefixes are
          bound to the same namespace URI in the <a title=
          "in-scope namespaces" href="#dt-is-namespaces">in-scope
          namespaces</a>. An unprefixed variable reference is in no
          namespace.</p>

          <p>Every variable reference must match a name in the
          <a title="in-scope variables" href="#dt-is-vars">in-scope
          variables</a>, which include variables from the following
          sources:</p>

          <ol class="enumar">
            <li>
              <p>A variable may be added to the in-scope variables
              by the host language environment.</p>
            </li>

            <li>
              <p>A variable may be bound by an XPath expression.
              <span class="xpath"><span class="xpath">The kinds of
              expressions that can bind variables are
              <code>for</code> expressions (<a href=
              "#id-for-expressions"><b>3.7 For Expressions</b></a>)
              and quantified expressions (<a href=
              "#id-quantified-expressions"><b>3.9 Quantified
              Expressions</b></a>).</span></span></p>
            </li>
          </ol><br />
          <br />

          <p>Every variable binding has a static scope. The scope
          defines where references to the variable can validly
          occur. It is a <a title="static error" href=
          "#dt-static-error">static error</a> [<a title=
          "err:XP0016" href="#ERRXP0016">err:XP0016</a>] to
          reference a variable that is not in scope. If a variable
          is bound in the <a title="static context" href=
          "#dt-static-context">static context</a> for an
          expression, that variable is in scope for the entire
          expression.</p>

          <p>If a variable reference matches two or more bindings
          that are in scope, then the reference is taken as
          referring to the inner binding, that is, the one whose
          scope is smaller. At evaluation time, the value of a
          variable reference is the value of the expression to
          which the relevant variable is bound. The scope of a
          variable binding is defined separately for each kind of
          expression that can bind variables.</p>
        </div>

        <div class="div3">
          <h4><a id="id-paren-expressions" name=
          "id-paren-expressions"></a>3.1.3 Parenthesized
          Expressions</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ParenthesizedExpr" name=
                "doc-ParenthesizedExpr"></a>[59]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ParenthesizedExpr">ParenthesizedExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"(" <a href="#doc-Expr">Expr</a>?
                ")"</code></td>
              </tr>
            </tbody>
          </table>

          <p>Parentheses may be used to enforce a particular
          evaluation order in expressions that contain multiple
          operators. For example, the expression <code>(2 + 4) *
          5</code> evaluates to thirty, since the parenthesized
          expression <code>(2 + 4)</code> is evaluated first and
          its result is multiplied by five. Without parentheses,
          the expression <code>2 + 4 * 5</code> evaluates to
          twenty-two, because the multiplication operator has
          higher precedence than the addition operator.</p>

          <p>Empty parentheses are used to denote an empty
          sequence, as described in <a href=
          "#construct_seq"><b>3.3.1 Constructing
          Sequences</b></a>.</p>
        </div>

        <div class="div3">
          <h4><a id="id-context-item-expression" name=
          "id-context-item-expression"></a>3.1.4 Context Item
          Expression</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ContextItemExpr" name=
                "doc-ContextItemExpr"></a>[41]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ContextItemExpr">ContextItemExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"."</code></td>
              </tr>
            </tbody>
          </table>

          <p>A <b>context item expression</b> evaluates to the
          context item, which may be either a node (as in the
          expression
          <code>fn:doc("bib.xml")//book[count(./author)&gt;1]</code>)
          or an atomic value (as in the expression <code>(1 to
          100)[. mod 5 eq 0]</code>).</p>
        </div>

        <div class="div3">
          <h4><a id="id-function-calls" name=
          "id-function-calls"></a>3.1.5 Function Calls</h4>

          <p>A <b>function call</b> consists of a QName followed by
          a parenthesized list of zero or more expressions, called
          <b>arguments</b>. If the QName in the function call has
          no namespace prefix, it is considered to be in the
          <a title="default function namespace" href=
          "#dt-def-fn-ns">default function namespace.</a></p>

          <p>If the expanded QName and number of arguments in a
          function call do not match the name and arity of an
          <a title="in-scope functions" href=
          "#dt-is-funcs">in-scope function</a> in the <a title=
          "static context" href="#dt-static-context">static
          context</a>, <span class="xpath"><span class="xpath">an
          error is raised (the host language environment may define
          this error as either a static or a <a title=
          "dynamic error" href="#dt-dynamic-error">dynamic
          error</a>.)</span></span>[<a title="err:XP0017" href=
          "#ERRXP0017">err:XP0017</a>]</p>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-FunctionCall" name=
                "doc-FunctionCall"></a>[60]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-FunctionCall">FunctionCall</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-QName">QName</a> "("
                (<a href="#doc-ExprSingle">ExprSingle</a> (","
                <a href="#doc-ExprSingle">ExprSingle</a>)*)?
                ")"</code></td>
              </tr>
            </tbody>
          </table>

          <p>A function call is evaluated as follows:</p>

          <ol class="enumar">
            <li>
              <p>Each argument expression is evaluated, producing
              an argument value. The order of argument evaluation
              is implementation-dependent and a function need not
              evaluate an argument if the function can evaluate its
              body without evaluating that argument.</p>
            </li>

            <li>
              <p>Each argument value is converted by applying the
              function conversion rules listed below.</p>
            </li>

            <li class="xpath">
              <p>The function is executed using the converted
              argument values. The result is a value of the
              function's declared return type.</p>
            </li>
          </ol>

          <p>The <b>function conversion rules</b> are used to
          convert an argument value to its expected type; that is,
          to the declared type of the function parameter. The
          expected type is expressed as a <a title="SequenceType"
          href="#dt-sequence-type">SequenceType</a>. The function
          conversion rules are applied to a given value as
          follows:</p>

          <ul>
            <li class="xpath">
              <p>If <b>XPath 1.0 compatibility mode</b> is
              <code>true</code>, then one of the following
              conversions is applied:</p>

              <ol class="enumar">
                <li>
                  <p>If the expected type is <code>xs:string</code>
                  or <code>xs:string?</code>, then the given value
                  <code>V</code> is effectively replaced by
                  <code>fn:string(fn:subsequence(V, 1,
                  1))</code>.</p>
                </li>

                <li>
                  <p>If the expected type is <code>xs:double</code>
                  or <code>xs:double?</code>, then the given value
                  <code>V</code> is effectively replaced by
                  <code>fn:number(fn:subsequence(V, 1,
                  1))</code>.</p>
                </li>

                <li>
                  <p>If the expected type is a (possibly optional)
                  node or item, then the given value <code>V</code>
                  is effectively replaced by
                  <code>fn:subsequence(V, 1, 1)</code>.</p>
                </li>

                <li>
                  <p>Otherwise, the given value is unchanged.</p>
                </li>
              </ol>
            </li>

            <li>
              <p>If the expected type is a sequence of an atomic
              type (possibly with an occurrence indicator
              <code>*</code>, <code>+</code>, or <code>?</code>),
              the following conversions are applied:</p>

              <ol class="enumar">
                <li>
                  <p><a title="atomization" href=
                  "#dt-atomization">Atomization</a> is applied to
                  the given value, resulting in a sequence of
                  atomic values.</p>
                </li>

                <li>
                  <p>Each item in the atomic sequence that is of
                  type <code>xdt:untypedAtomic</code> is cast to
                  the expected atomic type.</p>
                </li>

                <li>
                  <p>For each numeric item in the atomic sequence
                  that can be <b>promoted</b> to the expected
                  atomic type using the promotion rules in <a href=
                  "#promotion"><b>B.1 Type Promotion</b></a>, the
                  promotion is done.</p>
                </li>
              </ol>
            </li>

            <li>
              <p>If, after the above conversions, the resulting
              value does not match the expected type according to
              the rules for <a title="SequenceType matching" href=
              "#dt-sequencetype-matching">SequenceType
              Matching</a>, a <a title="type error" href=
              "#dt-type-error">type error</a> is raised.[<a title=
              "err:XP0006" href="#ERRXP0006">err:XP0006</a>] Note
              that the rules for SequenceType Matching permit a
              value of a derived type to be substituted for a value
              of its base type.</p>
            </li>
          </ul>

          <p>A core library of functions is defined in <a href=
          "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
          Functions and Operators]</a>. <span class=
          "xpath"><span class="xpath">Additional functions may be
          provided in the <a title="static context" href=
          "#dt-static-context">static
          context</a>.</span></span></p>

          <p>Since the arguments of a function call are separated
          by commas, any argument expression that contains a
          top-level comma operator must be enclosed in parentheses.
          Here are some illustrative examples of function
          calls:</p>

          <ul>
            <li>
              <p><code>three-argument-function(1, 2, 3)</code>
              denotes a function call with three arguments.</p>
            </li>

            <li>
              <p><code>two-argument-function((1, 2), 3)</code>
              denotes a function call with two arguments, the first
              of which is a sequence of two values.</p>
            </li>

            <li>
              <p><code>two-argument-function(1, ())</code> denotes
              a function call with two arguments, the second of
              which is an empty sequence.</p>
            </li>

            <li>
              <p><code>one-argument-function((1, 2, 3))</code>
              denotes a function call with one argument that is a
              sequence of three values.</p>
            </li>

            <li>
              <p><code>one-argument-function(( ))</code> denotes a
              function call with one argument that is an empty
              sequence.</p>
            </li>

            <li>
              <p><code>zero-argument-function( )</code> denotes a
              function call with zero arguments.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="comments" name="comments"></a>3.1.6 XPath
          Comments</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ExprComment" name=
                "doc-ExprComment"></a>[1]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ExprComment">ExprComment</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"(:" (<a href=
                "#doc-ExprCommentContent">ExprCommentContent</a> |
                <a href="#doc-ExprComment">ExprComment</a>)*
                ":)"</code></td>

                <td><i>/* <a href="#parse-note-comments">gn:
                comments</a> */</i></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ExprCommentContent" name=
                "doc-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ExprCommentContent">ExprCommentContent</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#prod-Char">Char</a></code></td>

                <td><i>/* <a href="#parse-note-parens">gn:
                parens</a> */</i></td>
              </tr>
            </tbody>
          </table>

          <p>XPath comments can be used to provide informative
          annotation. These comments are lexical constructs only,
          and do not affect the processing of an expression.
          Comments are delimited by the symbols <code>(:</code> and
          <code>:)</code>. Comments may be nested.</p>

          <p>Comments may be used anywhere that ignorable
          whitespace is allowed. See <a href=
          "#lexical-structure"><b>A.2 Lexical structure</b></a> for
          the exact lexical states where comments are
          recognized.</p>

          <p>The following is an example of a comment:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
(: Houston, we have a problem :)
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-path-expressions" name=
        "id-path-expressions"></a>3.2 Path Expressions</h3>

        <p>A <b>path expression</b> can be used to locate nodes
        within a tree.</p>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-PathExpr" name=
              "doc-PathExpr"></a>[36]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-PathExpr">PathExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("/" <a href=
              "#doc-RelativePathExpr">RelativePathExpr</a>?)<br />
              | ("//" <a href=
              "#doc-RelativePathExpr">RelativePathExpr</a>)<br />
              | <a href=
              "#doc-RelativePathExpr">RelativePathExpr</a></code></td>

              <td><i>/* <a href=
              "#parse-note-leading-lone-slash">gn:
              leading-lone-slash</a> */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-RelativePathExpr" name=
              "doc-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-RelativePathExpr">RelativePathExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-StepExpr">StepExpr</a> (("/"
              | "//") <a href=
              "#doc-StepExpr">StepExpr</a>)*</code></td>
            </tr>
          </tbody>
        </table>

        <p>A path expression consists of a series of one or more
        <b>steps</b>, separated by "<code>/</code>" or
        "<code>//</code>", and optionally beginning with
        "<code>/</code>" or "<code>//</code>". An initial
        "<code>/</code>" or "<code>//</code>" is an abbreviation
        for one or more initial steps that are implicitly added to
        the beginning of the path expression, as described
        below.</p>

        <p>A path expression consisting of a single step is
        evaluated as described in <a href="#id-axis-steps"><b>3.2.1
        Steps</b></a>.</p>

        <p>Each occurrence of <code>//</code> in a path expression
        is expanded as described in <a href="#abbrev"><b>3.2.4
        Abbreviated Syntax</b></a>, leaving a sequence of steps
        separated by <code>/</code>. This sequence of steps is then
        evaluated from left to right. Each operation
        <code>E1/E2</code> is evaluated as follows: Expression
        <code>E1</code> is evaluated, and if the result is not a
        sequence of nodes, a <a title="type error" href=
        "#dt-type-error">type error</a> is raised.[<a title=
        "err:XP0019" href="#ERRXP0019">err:XP0019</a>] Each node
        resulting from the evaluation of <code>E1</code> then
        serves in turn to provide an <b>inner focus</b> for an
        evaluation of <code>E2</code>, as described in <a href=
        "#eval_context"><b>2.1.2 Dynamic Context</b></a>. Each
        evaluation of <code>E2</code> must result in a sequence of
        nodes; otherwise, a <a title="type error" href=
        "#dt-type-error">type error</a> is raised.[<a title=
        "err:XP0019" href="#ERRXP0019">err:XP0019</a>] The
        sequences of nodes resulting from all the evaluations of
        <code>E2</code> are merged, eliminating duplicate nodes
        based on node identity and sorting the results in document
        order.</p>

        <p>As an example of a path expression,
        <code>child::div1/child::para</code> selects the
        <code>para</code> element children of the <code>div1</code>
        element children of the context node, or, in other words,
        the <code>para</code> element grandchildren of the context
        node that have <code>div1</code> parents.</p>

        <p>A "<code>/</code>" at the beginning of a path expression
        is an abbreviation for the initial step
        <code>fn:root(self::node()) treat as
        document-node()</code>. The effect of this initial step is
        to begin the path at the root node of the tree that
        contains the context node. If the context item is not a
        node, a <a title="type error" href="#dt-type-error">type
        error</a> is raised.[<a title="err:XP0020" href=
        "#ERRXP0020">err:XP0020</a>] At evaluation time, if the
        root node above the context node is not a document node, a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a> is raised.[<a title="err:XP0050" href=
        "#ERRXP0050">err:XP0050</a>]</p>

        <p>A "<code>//</code>" at the beginning of a path
        expression is an abbreviation for the initial steps
        <code>fn:root(self::node()) treat as
        document-node()/descendant-or-self::node()</code>. The
        effect of these initial steps is to establish an initial
        node sequence that contains all nodes in the same tree as
        the context node. This node sequence is then filtered by
        subsequent steps in the path expression. If the context
        item is not a node, a <a title="type error" href=
        "#dt-type-error">type error</a> is raised.[<a title=
        "err:XP0020" href="#ERRXP0020">err:XP0020</a>] At
        evaluation time, if the root node above the context node is
        not a document node, a <a title="dynamic error" href=
        "#dt-dynamic-error">dynamic error</a> is raised.[<a title=
        "err:XP0050" href="#ERRXP0050">err:XP0050</a>]</p>

        <div class="div3">
          <h4><a id="id-axis-steps" name="id-axis-steps"></a>3.2.1
          Steps</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-StepExpr" name=
                "doc-StepExpr"></a>[38]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-StepExpr">StepExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-AxisStep">AxisStep</a> |
                <a href=
                "#doc-FilterStep">FilterStep</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AxisStep" name=
                "doc-AxisStep"></a>[39]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AxisStep">AxisStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a href=
                "#doc-ForwardStep">ForwardStep</a> | <a href=
                "#doc-ReverseStep">ReverseStep</a>) <a href=
                "#doc-Predicates">Predicates</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-FilterStep" name=
                "doc-FilterStep"></a>[40]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-FilterStep">FilterStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-PrimaryExpr">PrimaryExpr</a> <a href=
                "#doc-Predicates">Predicates</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ForwardStep" name=
                "doc-ForwardStep"></a>[48]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ForwardStep">ForwardStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a href=
                "#doc-ForwardAxis">ForwardAxis</a> <a href=
                "#doc-NodeTest">NodeTest</a>) | <a href=
                "#doc-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ReverseStep" name=
                "doc-ReverseStep"></a>[49]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ReverseStep">ReverseStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>(<a href=
                "#doc-ReverseAxis">ReverseAxis</a> <a href=
                "#doc-NodeTest">NodeTest</a>) | <a href=
                "#doc-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
              </tr>
            </tbody>
          </table>

          <p>A <b>step</b> generates a sequence of items and then
          filters the sequence by zero or more <b>predicates</b>.
          The value of the step consists of those items that
          satisfy the predicates. Predicates are described in
          <a href="#id-predicates"><b>3.2.2 Predicates</b></a>.
          XPath provides two kinds of step, called a <b>filter
          step</b> and an <b>axis step</b>.</p>

          <p>A <b>filter step</b> consists simply of a <b>primary
          expression</b> followed by zero or more predicates. The
          result of the filter expression consists of all the items
          returned by the primary expression for which all the
          predicates are true. If no predicates are specified, the
          result is simply the result of the primary expression.
          This result may contain nodes, atomic values, or any
          combination of these. The ordering of the items returned
          by a filter step is the same as their order in the result
          of the primary expression.</p>

          <p>The result of an <b>axis step</b> is always a sequence
          of zero or more nodes, and these nodes are always
          returned in document order. An axis step may be either a
          <b>forward step</b> or a <b>reverse step</b>, followed by
          zero or more predicates. An axis step might be thought of
          as beginning at the <b>context node</b> and navigating to
          those nodes that are reachable from the context node via
          a specified <b>axis</b>. Such a step has two parts: an
          <b>axis</b>, which defines the "direction of movement"
          for the step, and a <b>node test</b>, which selects nodes
          based on their kind, name, and/or type. If the context
          item is not a node, a <a title="type error" href=
          "#dt-type-error">type error</a> is raised.[<a title=
          "err:XP0020" href="#ERRXP0020">err:XP0020</a>]</p>

          <p>In the <b>abbreviated syntax</b> for a step, the axis
          can be omitted and other shorthand notations can be used
          as described in <a href="#abbrev"><b>3.2.4 Abbreviated
          Syntax</b></a>.</p>

          <p>The unabbreviated syntax for an axis step consists of
          the axis name and node test separated by a double colon.
          The result of the step consists of the nodes reachable
          from the context node via the specified axis that have
          the node kind, name, and/or type specified by the node
          test. For example, the step <code>child::para</code>
          selects the <code>para</code> element children of the
          context node: <code>child</code> is the name of the axis,
          and <code>para</code> is the name of the element nodes to
          be selected on this axis. The available axes are
          described in <a href="#axes"><b>3.2.1.1 Axes</b></a>. The
          available node tests are described in <a href=
          "#node-tests"><b>3.2.1.2 Node Tests</b></a>. Examples of
          steps are provided in <a href="#unabbrev"><b>3.2.3
          Unabbreviated Syntax</b></a> and <a href=
          "#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>

          <div class="div4">
            <h5><a id="axes" name="axes"></a>3.2.1.1 Axes</h5>

            <table summary="Scrap" class="scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a id="doc-ForwardAxis" name=
                  "doc-ForwardAxis"></a>[52]&#160;&#160;&#160;</td>

                  <td><code><a href=
                  "#prod-ForwardAxis">ForwardAxis</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>("child" "::")<br />
                  | ("descendant" "::")<br />
                  | ("attribute" "::")<br />
                  | ("self" "::")<br />
                  | ("descendant-or-self" "::")<br />
                  | ("following-sibling" "::")<br />
                  | ("following" "::")<br />
                  | ("namespace" "::")</code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a id="doc-ReverseAxis" name=
                  "doc-ReverseAxis"></a>[53]&#160;&#160;&#160;</td>

                  <td><code><a href=
                  "#prod-ReverseAxis">ReverseAxis</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"parent" "::"<br />
                  | "ancestor" "::"<br />
                  | "preceding-sibling" "::"<br />
                  | "preceding" "::"<br />
                  | "ancestor-or-self" "::"</code></td>
                </tr>
              </tbody>
            </table>

            <div class="xpath">
              <p class="xpath">XPath defines a set of full set of
              <b>axes</b> for traversing documents, but a <b>host
              language</b> may define a subset of these axes. The
              following axes are defined:</p>
            </div>

            <ul>
              <li>
                <p>the <code>child</code> axis contains the
                children of the context node</p>
              </li>

              <li>
                <p>the <code>descendant</code> axis contains the
                descendants of the context node; a descendant is a
                child or a child of a child and so on; thus the
                descendant axis never contains attribute or
                namespace nodes</p>
              </li>

              <li>
                <p>the <code>parent</code> axis contains the parent
                of the context node, if there is one</p>
              </li>

              <li>
                <p>the <code>ancestor</code> axis contains the
                ancestors of the context node; the ancestors of the
                context node consist of the parent of context node
                and the parent's parent and so on; thus, the
                ancestor axis will always include the root node,
                unless the context node is the root node</p>
              </li>

              <li>
                <p>the <code>following-sibling</code> axis contains
                all the following siblings of the context node; if
                the context node is an attribute node or namespace
                node, the <code>following-sibling</code> axis is
                empty</p>
              </li>

              <li>
                <p>the <code>preceding-sibling</code> axis contains
                all the preceding siblings of the context node; if
                the context node is an attribute node or namespace
                node, the <code>preceding-sibling</code> axis is
                empty</p>
              </li>

              <li>
                <p>the <code>following</code> axis contains all
                nodes, in the same tree as the context node, that
                are after the context node in document order,
                excluding any descendants and excluding attribute
                nodes and namespace nodes</p>
              </li>

              <li>
                <p>the <code>preceding</code> axis contains all
                nodes, in the same tree as the context node, that
                are before the context node in document order,
                excluding any ancestors and excluding attribute
                nodes and namespace nodes</p>
              </li>

              <li>
                <p>the <code>attribute</code> axis contains the
                attributes of the context node; the axis will be
                empty unless the context node is an element</p>
              </li>

              <li>
                <p>the <code>self</code> axis contains just the
                context node itself</p>
              </li>

              <li>
                <p>the <code>descendant-or-self</code> axis
                contains the context node and the descendants of
                the context node</p>
              </li>

              <li>
                <p>the <code>ancestor-or-self</code> axis contains
                the context node and the ancestors of the context
                node; thus, the ancestor-or-self axis will always
                include the root node</p>
              </li>

              <li class="xpath">
                <p>the <code>namespace</code> axis contains the
                namespace nodes of the context node; this axis is
                empty unless the context node is an element node.
                The <code>namespace</code> axis is deprecated in
                XPath 2.0. Whether an implementation supports the
                <code>namespace</code> axis is <a title=
                "implementation defined" href=
                "#dt-implementation-defined">implementation
                defined</a>. An implementation that does not
                support the <code>namespace</code> axis must raise
                a <a title="static error" href=
                "#dt-static-error">static error</a> [<a title=
                "err:XP0021" href="#ERRXP0021">err:XP0021</a>] if
                it is used. Applications needing information about
                the namespaces of an element should use the
                functions <code>fn:get-in-scope-namespaces</code>
                and <code>fn:get-namespace-uri-for-prefix</code>
                defined in <a href="#FunctionsAndOperators">[XQuery
                1.0 and XPath 2.0 Functions and Operators]</a>.</p>
              </li>
            </ul>

            <p>Axes can be categorized as <b>forward axes</b> and
            <b>reverse axes</b>. An axis that only ever contains
            the context node or nodes that are after the context
            node in document order is a forward axis. An axis that
            only ever contains the context node or nodes that are
            before the context node in document order is a reverse
            axis.</p>

            <p>The <code>parent</code>, <code>ancestor</code>,
            <code>ancestor-or-self</code>, <code>preceding</code>,
            and <code>preceding-sibling</code> axes are reverse
            axes; all other axes are forward axes. The
            <code>ancestor</code>, <code>descendant</code>,
            <code>following</code>, <code>preceding</code> and
            <code>self</code> axes partition a document (ignoring
            attribute and namespace nodes): they do not overlap and
            together they contain all the nodes in the
            document.</p>

            <p>In a sequence of nodes selected by a step, the
            context positions of the nodes are determined in a way
            that depends on the axis. If the axis is a forward
            axis, context positions are assigned to the nodes in
            document order. If the axis is a reverse axis, context
            positions are assigned to the nodes in reverse document
            order. In either case, the first context position is
            1.</p>
          </div>

          <div class="div4">
            <h5><a id="node-tests" name="node-tests"></a>3.2.1.2
            Node Tests</h5>

            <p>A <b>node test</b> is a condition that must be true
            for each node selected by a step. The condition may be
            based on the kind of the node (element, attribute,
            text, document, comment, processing instruction, or
            namespace), the name of the node, or (in the case of
            element and attribute nodes), the <a title=
            "type annotation" href="#dt-type-annotation">type
            annotation</a> of the node.</p>

            <table summary="Scrap" class="scrap">
              <tbody>
                <tr valign="baseline">
                  <td><a id="doc-NodeTest" name=
                  "doc-NodeTest"></a>[54]&#160;&#160;&#160;</td>

                  <td><code><a href=
                  "#prod-NodeTest">NodeTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#doc-KindTest">KindTest</a> |
                  <a href="#doc-NameTest">NameTest</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a id="doc-NameTest" name=
                  "doc-NameTest"></a>[55]&#160;&#160;&#160;</td>

                  <td><code><a href=
                  "#prod-NameTest">NameTest</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code><a href="#prod-QName">QName</a> |
                  <a href="#doc-Wildcard">Wildcard</a></code></td>
                </tr>
              </tbody>

              <tbody>
                <tr valign="baseline">
                  <td><a id="doc-Wildcard" name=
                  "doc-Wildcard"></a>[56]&#160;&#160;&#160;</td>

                  <td><code><a href=
                  "#prod-Wildcard">Wildcard</a></code></td>

                  <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                  <td><code>"*"<br />
                  | (<a href="#prod-NCName">NCName</a> ":"
                  "*")<br />
                  | ("*" ":" <a href=
                  "#prod-NCName">NCName</a>)</code></td>

                  <td><i>/* <a href="#ws-explicit">ws: explicit</a>
                  */</i></td>
                </tr>
              </tbody>
            </table>

            <p>Every axis has a <b>principal node kind</b>. If an
            axis can contain elements, then the principal node kind
            is element; otherwise, it is the kind of nodes that the
            axis can contain. Thus:</p>

            <ul>
              <li>
                <p>For the attribute axis, the principal node kind
                is attribute.</p>
              </li>

              <li class="xpath">
                <p>For the namespace axis, the principal node kind
                is namespace.</p>
              </li>

              <li>
                <p>For all other axes, the principal node kind is
                element.</p>
              </li>
            </ul>

            <p>A node test that consists of a QName is called a
            <b>name test</b>. A name test is true if and only if
            the <b>kind</b> of the node is the principal node kind
            and the expanded-QName of the node is equal to the
            expanded-QName specified by the name test. For example,
            <code>child::para</code> selects the <code>para</code>
            element children of the context node; if the context
            node has no <code>para</code> children, it selects an
            empty set of nodes. <code>attribute::abc:href</code>
            selects the attribute of the context node with the
            QName <code>abc:href</code>; if the context node has no
            such attribute, it selects an empty set of nodes.</p>

            <p>A QName in a name test is expanded into an
            expanded-QName using the <a title="in-scope namespaces"
            href="#dt-is-namespaces">in-scope namespaces</a> in the
            expression context. It is a <a title="static error"
            href="#dt-static-error">static error</a> [<a title=
            "err:XP0008" href="#ERRXP0008">err:XP0008</a>] if the
            QName has a prefix that does not correspond to any
            in-scope namespace. An unprefixed QName, when used as a
            name test on an axis whose principal node kind is
            element, has the namespaceURI of the <a title=
            "default element/type namespace" href=
            "#dt-def-elemtype-ns">default element/type
            namespace</a> in the expression context; otherwise, it
            has no namespaceURI.</p>

            <p>A name test is not satisfied by an element node
            whose name does not match the QName of the name test,
            even if it is in a substitution group whose head is the
            named element.</p>

            <p>A node test <code>*</code> is true for any node of
            the principal node kind. For example,
            <code>child::*</code> will select all element children
            of the context node, and <code>attribute::*</code> will
            select all attributes of the context node.</p>

            <p>A node test can have the form <code>NCName:*</code>.
            In this case, the prefix is expanded in the same way as
            with a QName, using the <a title="in-scope namespaces"
            href="#dt-is-namespaces">in-scope namespaces</a> in the
            <a title="static context" href=
            "#dt-static-context">static context</a>. If the prefix
            is not found in the in-scope namespaces, a <a title=
            "static error" href="#dt-static-error">static error</a>
            is raised.[<a title="err:XP0008" href=
            "#ERRXP0008">err:XP0008</a>] The node test is true for
            any node of the principal node kind whose
            expanded-QName has the namespace URI to which the
            prefix is bound, regardless of the local part of the
            name.</p>

            <p>A node test can also have the form
            <code>*:NCName</code>. In this case, the node test is
            true for any node of the principal node kind whose
            local name matches the given NCName, regardless of its
            namespace.</p>

            <p>An alternative form of a node test is called a
            <b>KindTest</b>, which can select nodes based on their
            kind, name, and type annotation. The syntax and
            semantics of a KindTest are described in <a href=
            "#id-sequencetype"><b>2.4.1 SequenceType</b></a>. When
            a KindTest is used in a node test, only those nodes on
            the designated axis that match the KindTest are
            selected. Shown below are several examples of KindTests
            that might be used in path expressions:</p>

            <ul>
              <li>
                <p><code>node()</code> matches any node.</p>
              </li>

              <li>
                <p><code>text()</code> matches any text node.</p>
              </li>

              <li>
                <p><code>comment()</code> matches any comment
                node.</p>
              </li>

              <li>
                <p><code>element()</code> matches any element
                node.</p>
              </li>

              <li>
                <p><code>element(person)</code> matches any element
                node whose name is <code>person</code> (or is in
                the substitution group headed by
                <code>person</code>), and whose type annotation
                conforms to the top-level schema declaration for a
                <code>person</code> element.</p>
              </li>

              <li>
                <p><code>element(person, *)</code> matches any
                element node whose name is <code>person</code> (or
                is in the substitution group headed by
                <code>person</code>), without any restriction on
                type annotation.</p>
              </li>

              <li>
                <p><code>element(person, surgeon)</code> matches
                any element node whose name is <code>person</code>
                (or is in the substitution group headed by
                <code>person</code>), and whose type annotation is
                <code>surgeon</code>.</p>
              </li>

              <li>
                <p><code>element(*, surgeon)</code> matches any
                element node whose type annotation is
                <code>surgeon</code>, regardless of its name.</p>
              </li>

              <li>
                <p><code>element(hospital/staff/person)</code>
                matches any element node whose name and type
                annotation conform to the schema declaration of a
                <code>person</code> element in a <code>staff</code>
                element in a top-level <code>hospital</code>
                element.</p>
              </li>

              <li>
                <p><code>attribute()</code> matches any attribute
                node.</p>
              </li>

              <li>
                <p><code>attribute(@price, *)</code> matches any
                attribute whose name is <code>price</code>,
                regardless of its type annotation.</p>
              </li>

              <li>
                <p><code>attribute(@*, xs:decimal)</code> matches
                any attribute whose type annotation is
                <code>xs:decimal</code>, regardless of its
                name.</p>
              </li>

              <li>
                <p><code>document-node()</code> matches any
                document node.</p>
              </li>

              <li>
                <p><code>document-node(element(book))</code>
                matches any document node whose content consists of
                a single element node that satisfies the KindTest
                <code>element(book)</code>, mixed with zero or more
                comments and processing instructions.</p>
              </li>
            </ul>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-predicates" name="id-predicates"></a>3.2.2
          Predicates</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-Predicates" name=
                "doc-Predicates"></a>[43]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-Predicates">Predicates</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>("[" <a href="#doc-Expr">Expr</a>
                "]")*</code></td>
              </tr>
            </tbody>
          </table>

          <p>A predicate consists of an expression, called a
          <b>predicate expression</b>, enclosed in square brackets.
          A predicate serves to filter a sequence, retaining some
          items and discarding others. For each item in the
          sequence to be filtered, the predicate expression is
          evaluated using an <b>inner focus</b> derived from that
          item, as described in <a href="#eval_context"><b>2.1.2
          Dynamic Context</b></a>. The result of the predicate
          expression is coerced to a Boolean value, called the
          <b>predicate truth value</b>, as described below. Those
          items for which the predicate truth value is
          <code>true</code> are retained, and those for which the
          predicate truth value is <code>false</code> are
          discarded.</p>

          <p>The predicate truth value is derived by applying the
          following rules, in order:</p>

          <ol class="enumar">
            <li>
              <p>If the value of the predicate expression is an
              atomic value of a numeric type, the predicate truth
              value is <code>true</code> if the value of the
              predicate expression is equal to the <b>context
              position</b>, and is false otherwise.</p>
            </li>

            <li>
              <p>Otherwise, the predicate truth value is the
              <a title="effective boolean value" href=
              "#dt-ebv">effective boolean value</a> of the
              predicate expression.</p>
            </li>
          </ol>

          <p>Here are some examples of <b>axis steps</b> that
          contain predicates:</p>

          <ul>
            <li>
              <p>This example selects the second
              <code>chapter</code> element that is a child of the
              context node:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
child::chapter[2]
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This example selects all the descendants of the
              context node whose name is <code>"toy"</code> and
              whose <code>color</code> attribute has the value
              <code>"red"</code>:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
descendant::toy[attribute::color = "red"]
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This example selects all the <code>employee</code>
              children of the context node that have a
              <code>secretary</code> subelement:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
child::employee[secretary]
</pre>
                </div>
              </div>
            </li>
          </ul>

          <p>Here are some examples of <b>filter steps</b> that
          contain predicates:</p>

          <ul>
            <li>
              <p>List all the integers from 1 to 100 that are
              divisible by 5. (See <a href=
              "#construct_seq"><b>3.3.1 Constructing
              Sequences</b></a> for an explanation of the
              <code>to</code> operator.)</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
(1 to 100)[. mod 5 eq 0]
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The result of the following expression is the
              integer 95:</p>

              <div class="exampleInner">
                <pre>
(99 to 0)[5]
</pre>
              </div>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="unabbrev" name="unabbrev"></a>3.2.3
          Unabbreviated Syntax</h4>

          <p>This section provides a number of examples of path
          expressions in which the axis is explicitly specified in
          each step. The syntax used in these examples is called
          the <b>unabbreviated syntax</b>. In many common cases, it
          is possible to write path expressions more concisely
          using an <b>abbreviated syntax</b>, as explained in
          <a href="#abbrev"><b>3.2.4 Abbreviated
          Syntax</b></a>.</p>

          <ul>
            <li>
              <p><code>child::para</code> selects the
              <code>para</code> element children of the context
              node</p>
            </li>

            <li>
              <p><code>child::*</code> selects all element children
              of the context node</p>
            </li>

            <li>
              <p><code>child::text()</code> selects all text node
              children of the context node</p>
            </li>

            <li>
              <p><code>child::node()</code> selects all the
              children of the context node, whatever their node
              type</p>
            </li>

            <li>
              <p><code>attribute::name</code> selects the
              <code>name</code> attribute of the context node</p>
            </li>

            <li>
              <p><code>attribute::*</code> selects all the
              attributes of the context node</p>
            </li>

            <li>
              <p><code>parent::*</code> selects the parent of the
              context node. If the context node is an attribute
              node, this expression returns the element node (if
              any) to which the attribute node is attached.</p>
            </li>

            <li>
              <p><code>descendant::para</code> selects the
              <code>para</code> element descendants of the context
              node</p>
            </li>

            <li>
              <p><code>ancestor::div</code> selects all
              <code>div</code> ancestors of the context node</p>
            </li>

            <li>
              <p><code>ancestor-or-self::div</code> selects the
              <code>div</code> ancestors of the context node and,
              if the context node is a <code>div</code> element,
              the context node as well</p>
            </li>

            <li>
              <p><code>descendant-or-self::para</code> selects the
              <code>para</code> element descendants of the context
              node and, if the context node is a <code>para</code>
              element, the context node as well</p>
            </li>

            <li>
              <p><code>self::para</code> selects the context node
              if it is a <code>para</code> element, and otherwise
              selects nothing</p>
            </li>

            <li>
              <p><code>child::chapter/descendant::para</code>
              selects the <code>para</code> element descendants of
              the <code>chapter</code> element children of the
              context node</p>
            </li>

            <li>
              <p><code>child::*/child::para</code> selects all
              <code>para</code> grandchildren of the context
              node</p>
            </li>

            <li>
              <p><code>/</code> selects the root of the node
              hierarchy that contains the context node</p>
            </li>

            <li>
              <p><code>/descendant::para</code> selects all the
              <code>para</code> elements in the same document as
              the context node</p>
            </li>

            <li>
              <p><code>/descendant::list/child::member</code>
              selects all the <code>member</code> elements that
              have a <code>list</code> parent and that are in the
              same document as the context node</p>
            </li>

            <li>
              <p><code>child::para[fn:position() = 1]</code>
              selects the first <code>para</code> child of the
              context node</p>
            </li>

            <li>
              <p><code>child::para[fn:position() =
              fn:last()]</code> selects the last <code>para</code>
              child of the context node</p>
            </li>

            <li>
              <p><code>child::para[fn:position() =
              fn:last()-1]</code> selects the last but one
              <code>para</code> child of the context node</p>
            </li>

            <li>
              <p><code>child::para[fn:position() &gt; 1]</code>
              selects all the <code>para</code> children of the
              context node other than the first <code>para</code>
              child of the context node</p>
            </li>

            <li>
              <p><code>following-sibling::chapter[fn:position() =
              1]</code>selects the next <code>chapter</code>
              sibling of the context node</p>
            </li>

            <li>
              <p><code>preceding-sibling::chapter[fn:position() =
              1]</code>selects the previous <code>chapter</code>
              sibling of the context node</p>
            </li>

            <li>
              <p><code>/descendant::figure[fn:position() =
              42]</code> selects the forty-second
              <code>figure</code> element in the document</p>
            </li>

            <li>
              <p><code>/child::doc/child::chapter[fn:position() =
              5]/child::section[fn:position() = 2]</code>selects
              the second <code>section</code> of the fifth
              <code>chapter</code> of the <code>doc</code> document
              element</p>
            </li>

            <li>
              <p>
              <code>child::para[attribute::type="warning"]</code>selects
              all <code>para</code> children of the context node
              that have a <code>type</code> attribute with value
              <code>warning</code></p>
            </li>

            <li>
              <p>
              <code>child::para[attribute::type='warning'][fn:position()
              = 5]</code>selects the fifth <code>para</code> child
              of the context node that has a <code>type</code>
              attribute with value <code>warning</code></p>
            </li>

            <li>
              <p><code>child::para[fn:position() =
              5][attribute::type="warning"]</code>selects the fifth
              <code>para</code> child of the context node if that
              child has a <code>type</code> attribute with value
              <code>warning</code></p>
            </li>

            <li>
              <p>
              <code>child::chapter[child::title='Introduction']</code>selects
              the <code>chapter</code> children of the context node
              that have one or more <code>title</code> children
              with string-value equal to
              <code>Introduction</code></p>
            </li>

            <li>
              <p><code>child::chapter[child::title]</code> selects
              the <code>chapter</code> children of the context node
              that have one or more <code>title</code> children</p>
            </li>

            <li>
              <p><code>child::*[self::chapter or
              self::appendix]</code> selects the
              <code>chapter</code> and <code>appendix</code>
              children of the context node</p>
            </li>

            <li>
              <p><code>child::*[self::chapter or
              self::appendix][fn:position() = fn:last()]</code>
              selects the last <code>chapter</code> or
              <code>appendix</code> child of the context node</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="abbrev" name="abbrev"></a>3.2.4 Abbreviated
          Syntax</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AbbrevForwardStep" name=
                "doc-AbbrevForwardStep"></a>[50]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AbbrevForwardStep">AbbrevForwardStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"@"? <a href=
                "#doc-NodeTest">NodeTest</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-AbbrevReverseStep" name=
                "doc-AbbrevReverseStep"></a>[51]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-AbbrevReverseStep">AbbrevReverseStep</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>".."</code></td>
              </tr>
            </tbody>
          </table>

          <p>The abbreviated syntax permits the following
          abbreviations:</p>

          <ol class="enumar">
            <li>
              <p>The most important abbreviation is that the axis
              name can be omitted from an <b>axis step</b>. If the
              axis name is omitted from an axis step, the default
              axis is <code>child</code> unless the axis step
              contains an <a title="AttributeTest" href=
              "#dt-attribute-test">AttributeTest</a>; in that case,
              the default axis is <code>attribute</code>. For
              example, the path expression
              <code>section/para</code> is an abbreviation for
              <code>child::section/child::para</code>, and the path
              expression <code>section/@id</code> is an
              abbreviation for
              <code>child::section/attribute::id</code>. Similarly,
              <code>section/attribute(@id)</code> is an
              abbreviation for
              <code>child::section/attribute::attribute(@id)</code>.
              Note that the latter expression contains both an axis
              specification and a node test.</p>
            </li>

            <li>
              <p>There is also an abbreviation for attributes:
              <code>attribute::</code> can be abbreviated by
              <code>@</code>. For example, a path expression
              <code>para[@type="warning"]</code> is short for
              <code>child::para[attribute::type="warning"]</code>
              and so selects <code>para</code> children with a
              <code>type</code> attribute with value equal to
              <code>warning</code>.</p>
            </li>

            <li>
              <p><code>//</code> is effectively replaced by
              <code>/descendant-or-self::node()/</code> during
              processing of a path expression. For example,
              <code>//para</code> is an abbreviation for
              <code>/descendant-or-self::node()/child::para</code>
              and so will select any <code>para</code> element in
              the document (even a <code>para</code> element that
              is a document element will be selected by
              <code>//para</code> since the document element node
              is a child of the root node); <code>div1//para</code>
              is short for
              <code>div1/descendant-or-self::node()/child::para</code>
              and so will select all <code>para</code> descendants
              of <code>div1</code> children.</p>

              <p>Note that the path expression
              <code>//para[1]</code> does <em>not</em> mean the
              same as the path expression
              <code>/descendant::para[1]</code>. The latter selects
              the first descendant <code>para</code> element; the
              former selects all descendant <code>para</code>
              elements that are the first <code>para</code>
              children of their parents.</p>
            </li>

            <li>
              <p>A step consisting of <code>..</code> is short for
              <code>parent::node()</code>. For example,
              <code>../title</code> is short for
              <code>parent::node()/child::title</code> and so will
              select the <code>title</code> children of the parent
              of the context node.</p>
            </li>
          </ol>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The expression <code>.</code>, known as a <b>context
            item expression</b>, is a <a title="primary expression"
            href="#dt-primary-expression">primary expression</a>,
            and is described in <a href=
            "#id-context-item-expression"><b>3.1.4 Context Item
            Expression</b></a>.</p>
          </div>

          <p>Here are some examples of path expressions that use
          the abbreviated syntax:</p>

          <ul>
            <li>
              <p><code>para</code> selects the <code>para</code>
              element children of the context node</p>
            </li>

            <li>
              <p><code>*</code> selects all element children of the
              context node</p>
            </li>

            <li>
              <p><code>text()</code> selects all text node children
              of the context node</p>
            </li>

            <li>
              <p><code>@name</code> selects the <code>name</code>
              attribute of the context node</p>
            </li>

            <li>
              <p><code>@*</code> selects all the attributes of the
              context node</p>
            </li>

            <li>
              <p><code>para[1]</code> selects the first
              <code>para</code> child of the context node</p>
            </li>

            <li>
              <p><code>para[fn:last()]</code> selects the last
              <code>para</code> child of the context node</p>
            </li>

            <li>
              <p><code>*/para</code> selects all <code>para</code>
              grandchildren of the context node</p>
            </li>

            <li>
              <p><code>/doc/chapter[5]/section[2]</code> selects
              the second <code>section</code> of the fifth
              <code>chapter</code> of the <code>doc</code></p>
            </li>

            <li>
              <p><code>chapter//para</code> selects the
              <code>para</code> element descendants of the
              <code>chapter</code> element children of the context
              node</p>
            </li>

            <li>
              <p><code>//para</code> selects all the
              <code>para</code> descendants of the document root
              and thus selects all <code>para</code> elements in
              the same document as the context node</p>
            </li>

            <li>
              <p><code>//list/member</code> selects all the
              <code>member</code> elements in the same document as
              the context node that have a <code>list</code>
              parent</p>
            </li>

            <li>
              <p><code>.//para</code> selects the <code>para</code>
              element descendants of the context node</p>
            </li>

            <li>
              <p><code>..</code> selects the parent of the context
              node</p>
            </li>

            <li>
              <p><code>../@lang</code> selects the
              <code>lang</code> attribute of the parent of the
              context node</p>
            </li>

            <li>
              <p><code>para[@type="warning"]</code> selects all
              <code>para</code> children of the context node that
              have a <code>type</code> attribute with value
              <code>warning</code></p>
            </li>

            <li>
              <p><code>para[@type="warning"][5]</code> selects the
              fifth <code>para</code> child of the context node
              that has a <code>type</code>attribute with value
              <code>warning</code></p>
            </li>

            <li>
              <p><code>para[5][@type="warning"]</code> selects the
              fifth <code>para</code> child of the context node if
              that child has a <code>type</code> attribute with
              value <code>warning</code></p>
            </li>

            <li>
              <p><code>chapter[title="Introduction"]</code> selects
              the <code>chapter</code> children of the context node
              that have one or more <code>title</code> children
              with string-value equal to
              <code>Introduction</code></p>
            </li>

            <li>
              <p><code>chapter[title]</code> selects the
              <code>chapter</code> children of the context node
              that have one or more <code>title</code> children</p>
            </li>

            <li>
              <p><code>employee[@secretary and @assistant]</code>
              selects all the <code>employee</code> children of the
              context node that have both a <code>secretary</code>
              attribute and an <code>assistant</code> attribute</p>
            </li>

            <li>
              <p><code>book/(chapter|appendix)/section</code>
              selects every <code>section</code> element that has a
              parent that is either a <code>chapter</code> or an
              <code>appendix</code> element, that in turn is a
              child of a <code>book</code> element that is a child
              of the context node.</p>
            </li>

            <li>
              <p><code>book/fn:id(publisher)/name</code> returns
              the same result as
              <code>fn:id(book/publisher)/name</code>.</p>
            </li>

            <li>
              <p>If <code>E</code> is any expression that returns a
              sequence of nodes, then the expression
              <code>E/.</code> returns the same nodes in document
              order, with duplicates eliminated based on node
              identity.</p>
            </li>
          </ul>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-sequence-expressions" name=
        "id-sequence-expressions"></a>3.3 Sequence Expressions</h3>

        <p>XPath supports operators to construct and combine
        <a title="sequence" href="#dt-sequence">sequences</a> of
        <a title="item" href="#dt-item">items</a>. Sequences are
        never nested--for example, combining the values 1, (2, 3),
        and ( ) into a single sequence results in the sequence (1,
        2, 3).</p>

        <div class="div3">
          <h4><a id="construct_seq" name="construct_seq"></a>3.3.1
          Constructing Sequences</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="noid_N11Fdoc-Expr" name=
                "noid_N11Fdoc-Expr"></a>[16]&#160;&#160;&#160;</td>

                <td><code><a href="#prod-Expr">Expr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-ExprSingle">ExprSingle</a>
                ("," <a href=
                "#doc-ExprSingle">ExprSingle</a>)*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-RangeExpr" name=
                "doc-RangeExpr"></a>[29]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-RangeExpr">RangeExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-AdditiveExpr">AdditiveExpr</a> ( "to"
                <a href="#doc-AdditiveExpr">AdditiveExpr</a>
                )?</code></td>
              </tr>
            </tbody>
          </table>

          <p>One way to construct a sequence is by using the comma
          operator, which evaluates each of its operands and
          concatenates the resulting values, in order, into a
          single result sequence. Empty parentheses can be used to
          denote an empty sequence. In places where the grammar
          calls for ExprSingle, such as the arguments of a function
          call, any expression that contains a top-level comma
          operator must be enclosed in parentheses.</p>

          <p>A sequence may contain duplicate values or nodes, but
          a sequence is never an item in another sequence. When a
          new sequence is created by concatenating two or more
          input sequences, the new sequence contains all the items
          of the input sequences and its length is the sum of the
          lengths of the input sequences.</p>

          <p>Here are some examples of expressions that construct
          sequences:</p>

          <ul>
            <li>
              <p>This expression is a sequence of five
              integers:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
(10, 1, 2, 3, 4)
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This expression constructs one sequence from the
              sequences 10, (1, 2), the empty sequence (), and (3,
              4):</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
(10, (1, 2), (), (3, 4))
</pre>
                </div>
              </div>

              <p>It evaluates to the sequence:</p>

              <p><code>10, 1, 2, 3, 4</code></p>
            </li>

            <li>
              <p>This expression contains all <code>salary</code>
              children of the context node followed by all
              <code>bonus</code> children:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
(salary, bonus)
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>Assuming that <code>$price</code> is bound to the
              value <code>10.50</code>, this expression:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
($price, $price)
</pre>
                </div>
              </div>

              <p>evaluates to the sequence</p>

              <p><code>10.50, 10.50</code></p>
            </li>
          </ul>

          <p>A <b>RangeExpr</b> can be used to construct a sequence
          of consecutive integers. Each of the operands of the
          <code>to</code> operator is converted as though it was an
          argument of a function with the expected parameter type
          <code>xs:integer</code>. A <a title="type error" href=
          "#dt-type-error">type error</a> [<a title="err:XP0006"
          href="#ERRXP0006">err:XP0006</a>] is raised if the
          operand cannot be converted to a single integer. A
          sequence is constructed containing the two integer
          operands and every integer between the two operands. If
          the first operand is less than the second, the sequence
          is in increasing order, otherwise it is in decreasing
          order.</p>

          <ul>
            <li>
              <p>This example uses a range expression as one
              operand in constructing a sequence:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
(10, 1 to 4)
</pre>
                </div>
              </div>

              <p>It evaluates to the sequence:</p>

              <p><code>10, 1, 2, 3, 4</code></p>
            </li>

            <li>
              <p>This example constructs a sequence of length
              one:</p>

              <div class="exampleInner">
                <pre>
10 to 10
</pre>
              </div>

              <p>It evaluates to a sequence consisting of the
              single integer <code>10</code>.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="combining_seq" name="combining_seq"></a>3.3.2
          Combining Sequences</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-UnionExpr" name=
                "doc-UnionExpr"></a>[33]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-UnionExpr">UnionExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-IntersectExceptExpr">IntersectExceptExpr</a>
                ( ("union" | "|") <a href=
                "#doc-IntersectExceptExpr">IntersectExceptExpr</a>
                )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-IntersectExceptExpr" name=
                "doc-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-IntersectExceptExpr">IntersectExceptExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-ValueExpr">ValueExpr</a> (
                ("intersect" | "except") <a href=
                "#doc-ValueExpr">ValueExpr</a> )*</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ValueExpr" name=
                "doc-ValueExpr"></a>[35]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-ValueExpr">ValueExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-PathExpr">PathExpr</a></code></td>
              </tr>
            </tbody>
          </table>

          <p>XPath provides several operators for combining
          sequences of nodes. The <code>union</code> and
          <code>|</code> operators are equivalent. They take two
          node sequences as operands and return a sequence
          containing all the nodes that occur in either of the
          operands. The <code>intersect</code> operator takes two
          node sequences as operands and returns a sequence
          containing all the nodes that occur in both operands. The
          <code>except</code> operator takes two node sequences as
          operands and returns a sequence containing all the nodes
          that occur in the first operand but not in the second
          operand. All of these operators return their result
          sequences in document order without duplicates based on
          node identity. If an operand of <code>union</code>,
          <code>intersect</code>, or <code>except</code> contains
          an item that is not a node, a <a title="type error" href=
          "#dt-type-error">type error</a> is raised.[<a title=
          "err:XP0006" href="#ERRXP0006">err:XP0006</a>]</p>

          <p>Here are some examples of expressions that combine
          sequences. Assume the existence of three element nodes
          that we will refer to by symbolic names A, B, and C.
          Assume that <code>$seq1</code> is bound to a sequence
          containing A and B, <code>$seq2</code> is also bound to a
          sequence containing A and B, and <code>$seq3</code> is
          bound to a sequence containing B and C. Then:</p>

          <ul>
            <li>
              <p><code>$seq1 union $seq1</code> evaluates to a
              sequence containing A and B.</p>
            </li>

            <li>
              <p><code>$seq2 union $seq3</code> evaluates to a
              sequence containing A, B, and C.</p>
            </li>

            <li>
              <p><code>$seq1 intersect $seq1</code> evaluates to a
              sequence containing A and B.</p>
            </li>

            <li>
              <p><code>$seq2 intersect $seq3</code> evaluates to a
              sequence containing B only.</p>
            </li>

            <li>
              <p><code>$seq1 except $seq2</code> evaluates to the
              empty sequence.</p>
            </li>

            <li>
              <p><code>$seq2 except $seq3</code> evaluates to a
              sequence containing A only.</p>
            </li>
          </ul>

          <p>In addition to the sequence operators described
          here,<a href="#FunctionsAndOperators">[XQuery 1.0 and
          XPath 2.0 Functions and Operators]</a> includes functions
          for indexed access to items or sub-sequences of a
          sequence, for indexed insertion or removal of items in a
          sequence, and for removing duplicate values or nodes from
          a sequence.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-arithmetic" name="id-arithmetic"></a>3.4
        Arithmetic Expressions</h3>

        <p>XPath provides arithmetic operators for addition,
        subtraction, multiplication, division, and modulus, in
        their usual binary and unary forms.</p>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-AdditiveExpr" name=
              "doc-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-AdditiveExpr">AdditiveExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-MultiplicativeExpr">MultiplicativeExpr</a> (
              ("+" | "-") <a href=
              "#doc-MultiplicativeExpr">MultiplicativeExpr</a>
              )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-MultiplicativeExpr" name=
              "doc-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-MultiplicativeExpr">MultiplicativeExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-UnaryExpr">UnaryExpr</a> (
              ("*" | "div" | "idiv" | "mod") <a href=
              "#doc-UnaryExpr">UnaryExpr</a> )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-UnaryExpr" name=
              "doc-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-UnaryExpr">UnaryExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("-" | "+")* <a href=
              "#doc-UnionExpr">UnionExpr</a></code></td>
            </tr>
          </tbody>
        </table>

        <p>The binary subtraction operator must be preceded by
        whitespace if it could otherwise be interpreted as part of
        the previous token. For example, <code>a-b</code> will be
        interpreted as a name, but <code>a - b</code> will be
        interpreted as an arithmetic operation.</p>

        <p>An arithmetic expression is evaluated by applying the
        following rules, in order, until an error is raised or a
        value is computed:</p>

        <ol class="enumar">
          <li>
            <p><a title="atomization" href=
            "#dt-atomization">Atomization</a> is applied to each
            operand.</p>
          </li>

          <li>
            <p>If either operand is now an empty sequence, the
            result of the operation is an empty sequence.</p>
          </li>

          <li>
            <p>If either operand is now a sequence of length
            greater than one, <span class="xpath"><span class=
            "xpath">then:</span></span></p>

            <div class="xpath">
              <ol class="enumla">
                <li>
                  <p>If <b>XPath 1.0 compatibility mode</b> is
                  <code>true</code>, any items after the first item
                  in the sequence are discarded.</p>
                </li>

                <li>
                  <p>[<a title="err:XP0006" href=
                  "#ERRXP0006">err:XP0006</a>] Otherwise, a
                  <a title="type error" href="#dt-type-error">type
                  error</a> is raised.[<a title="err:XP0006" href=
                  "#ERRXP0006">err:XP0006</a>]</p>
                </li>
              </ol>
            </div>
          </li>

          <li>
            <p>If either operand is now of type
            <code>xdt:untypedAtomic</code>, it is cast to the
            default type for the given operator. The default type
            for the <code>idiv</code> operator is
            <code>xs:integer</code>; the default type for all other
            arithmetic operators is <code>xs:double</code>. If the
            cast fails, a <a title="dynamic error" href=
            "#dt-dynamic-error">dynamic error</a> is
            raised.[<a title="err:XP0021" href=
            "#ERRXP0021">err:XP0021</a>]</p>
          </li>

          <li>
            <p>If the operand types are now valid for the given
            operator, the operator is applied to the operands,
            resulting in an atomic value or a <a title=
            "dynamic error" href="#dt-dynamic-error">dynamic
            error</a> (for example, an error might result from
            dividing by zero.) The combinations of atomic types
            that are accepted by the various arithmetic operators,
            and their respective result types, are listed in
            <a href="#mapping"><b>B.2 Operator Mapping</b></a>
            together with the functions in <a href=
            "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
            Functions and Operators]</a> that define the semantics
            of the operation for each type.</p>
          </li>

          <li class="xpath">
            <p>If the operand types are not valid for the given
            operator, and <b>XPath 1.0 compatibility mode</b> is
            <code>true</code>, and the operator is not
            <code>idiv</code>, then each operand is further
            converted according to the rules in <a href=
            "#id-function-calls"><b>3.1.5 Function Calls</b></a> as
            if it were a function argument with the expected type
            <code>xs:double</code>. The operator is then applied to
            the operands, resulting in an atomic value or a
            <a title="dynamic error" href=
            "#dt-dynamic-error">dynamic error</a>.[<a title=
            "err:XQ0004" href=
            "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
            href="#ERRXP0006">err:XP0006</a>]</p>
          </li>

          <li>
            <p>If the operand types are still not valid for the
            given operator, a <a title="type error" href=
            "#dt-type-error">type error</a> is raised.</p>
          </li>
        </ol>

        <p>XPath supports two division operators named
        <code>div</code> and <code>idiv</code>. The
        <code>div</code> operator accepts operands of any numeric
        types. The type of the result of the <code>div</code>
        operator is the least common type of its operands; however,
        if both operands are of type <code>xs:integer</code>,
        <code>div</code> returns a result of type
        <code>xs:decimal</code>. The <code>idiv</code> operator, on
        the other hand, requires its operands to be of type
        <code>xs:integer</code> and returns a result of type
        <code>xs:integer</code>, rounded toward zero.</p>

        <p>Here are some examples of arithmetic expressions:</p>

        <ul>
          <li>
            <p>The first expression below returns
            <code>-1.5</code>, and the second expressions returns
            <code>-1</code>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
-3 div 2
-3 idiv 2
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>Subtraction of two date values results in a value of
            type <code>xdt:dayTimeDuration</code>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
$emp/hiredate - $emp/birthdate
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>This example illustrates the difference between a
            subtraction operator and a hyphen:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
$unit-price - $unit-discount
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>Unary operators have higher precedence than binary
            operators, subject of course to the use of
            parentheses:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
-($bellcost + $whistlecost)
</pre>
              </div>
            </div>
          </li>
        </ul>
      </div>

      <div class="div2">
        <h3><a id="id-comparisons" name="id-comparisons"></a>3.5
        Comparison Expressions</h3>

        <p>Comparison expressions allow two values to be compared.
        XPath provides four kinds of comparison expressions, called
        value comparisons, general comparisons, node comparisons,
        and order comparisons.</p>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-ComparisonExpr" name=
              "doc-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-ComparisonExpr">ComparisonExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-RangeExpr">RangeExpr</a> (
              (<a href="#doc-ValueComp">ValueComp</a><br />
              | <a href="#doc-GeneralComp">GeneralComp</a><br />
              | <a href="#doc-NodeComp">NodeComp</a><br />
              | <a href="#doc-OrderComp">OrderComp</a>) <a href=
              "#doc-RangeExpr">RangeExpr</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-ValueComp" name=
              "doc-ValueComp"></a>[45]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-ValueComp">ValueComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"eq" | "ne" | "lt" | "le" | "gt" |
              "ge"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-GeneralComp" name=
              "doc-GeneralComp"></a>[44]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-GeneralComp">GeneralComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
              "&gt;="</code></td>

              <td><i>/* <a href="#parse-note-lt">gn: lt</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-NodeComp" name=
              "doc-NodeComp"></a>[46]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-NodeComp">NodeComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"is" | "isnot"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-OrderComp" name=
              "doc-OrderComp"></a>[47]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-OrderComp">OrderComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"&lt;&lt;" | "&gt;&gt;"</code></td>
            </tr>
          </tbody>
        </table>

        <div class="xpath">
          <p class="xpath">When an XPath expression is written
          within an XML document, the XML escaping rules for
          special characters must be followed; thus
          "<code>&lt;</code>" must be written as
          "<code>&amp;lt;</code>".</p>
        </div>

        <div class="div3">
          <h4><a id="id-value-comparisons" name=
          "id-value-comparisons"></a>3.5.1 Value Comparisons</h4>

          <p>Value comparisons are intended for comparing single
          values. The result of a value comparison is defined by
          applying the following rules, in order:</p>

          <ol class="enumar">
            <li>
              <p><a title="atomization" href=
              "#dt-atomization">Atomization</a> is applied to each
              operand. If the result, called an <b>atomized
              operand</b>, does not contain exactly one atomic
              value, a <a title="type error" href=
              "#dt-type-error">type error</a> is raised.[<a title=
              "err:XQ0004" href=
              "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
              href="#ERRXP0006">err:XP0006</a>]</p>
            </li>

            <li>
              <p>Any atomized operand that has the dynamic type
              <code>xdt:untypedAtomic</code> is cast to the type
              <code>xs:string</code>.</p>
            </li>

            <li>
              <p>The result of the comparison is <code>true</code>
              if the value of the first operand is (equal, not
              equal, less than, less than or equal, greater than,
              greater than or equal) to the value of the second
              operand; otherwise the result of the comparison is
              <code>false</code>. <a href="#mapping"><b>B.2
              Operator Mapping</b></a> describes which combinations
              of atomic types are comparable, and how comparisons
              are performed on values of various types. If the
              value of the first atomized operand is not comparable
              with the value of the second atomized operand, a
              <a title="type error" href="#dt-type-error">type
              error</a> is raised.[<a title="err:XQ0004" href=
              "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
              href="#ERRXP0006">err:XP0006</a>]</p>
            </li>
          </ol>

          <p>Here are some examples of value comparisons:</p>

          <ul>
            <li>
              <p>The following comparison is true only if
              <code>$book1</code> has a single <code>author</code>
              subelement and its value is "Kennedy":</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
$book1/author eq "Kennedy"
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The following comparison is true if
              <code>hatsize</code> and <code>shoesize</code> are
              both user-defined types that are derived by
              restriction from a primitive numeric type:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
hatsize(5) eq shoesize(5)
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="id-general-comparisons" name=
          "id-general-comparisons"></a>3.5.2 General
          Comparisons</h4>

          <p>General comparisons are existentially quantified
          comparisons that may be applied to operand sequences of
          any length. The result of a general comparison that does
          not raise an error is always <code>true</code> or
          <code>false</code>.</p>

          <p><a title="atomization" href=
          "#dt-atomization">Atomization</a> is applied to each
          operand of a general comparison. The result of the
          comparison is <code>true</code> if and only if there is a
          pair of atomic values, one belonging to the result of
          atomization of the first operand and the other belonging
          to the result of atomization of the second operand, that
          have the required <b>magnitude relationship</b>.
          Otherwise the result of the general comparison is
          <code>false</code>. The <b>magnitude relationship</b>
          between two atomic values is determined as follows:</p>

          <ol class="enumar">
            <li>
              <p>If either atomic value has the dynamic type
              <code>xdt:untypedAtomic</code>, that value is cast to
              a required type, which is determined as follows:</p>

              <ol class="enumla">
                <li>
                  <p>If the dynamic type of the other atomic value
                  is a numeric type, the required type is
                  <code>xs:double</code>.</p>
                </li>

                <li>
                  <p>If the dynamic type of the other atomic value
                  is <code>xdt:untypedAtomic</code>, the required
                  type is <code>xs:string</code>.</p>
                </li>

                <li>
                  <p>Otherwise, the required type is the dynamic
                  type of the other atomic value.</p>
                </li>
              </ol>

              <p>If the cast to the required type fails, a
              <a title="dynamic error" href=
              "#dt-dynamic-error">dynamic error</a> is
              raised.[<a title="err:XP0021" href=
              "#ERRXP0021">err:XP0021</a>]</p>
            </li>

            <li class="xpath">
              <p>If <b>XPath 1.0 compatibility mode</b> is
              <code>true</code>, and at least one of the atomic
              values has a numeric type, then both atomic values
              are cast to to the type <code>xs:double</code>.</p>
            </li>

            <li>
              <p>After any necessary casting, the atomic values are
              compared using one of the value comparison operators
              <code>eq</code>, <code>ne</code>, <code>lt</code>,
              <code>le</code>, <code>gt</code>, or <code>ge</code>,
              depending on whether the general comparison operator
              was <code>=</code>, <code>!=</code>,
              <code>&lt;</code>, <code>&lt;=</code>,
              <code>&gt;</code>, or <code>&gt;=</code>. The values
              have the required <b>magnitude relationship</b> if
              the result of this value comparison is
              <code>true</code>.</p>
            </li>
          </ol>

          <p>When evaluating a general comparison in which either
          operand is a sequence of items, an implementation may
          return <code>true</code> as soon as it finds an item in
          the first operand and an item in the second operand for
          which the underlying value comparison is
          <code>true</code>. Similarly, a general comparison may
          raise a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> as soon as it
          encounters an error in evaluating either operand, or in
          comparing a pair of items from the two operands. As a
          result of these rules, the result of a general comparison
          is not deterministic in the presence of errors.</p>

          <p>Here are some examples of general comparisons:</p>

          <ul>
            <li>
              <p>The following comparison is true if the value of
              any <code>author</code> subelement of
              <code>$book1</code> has the string value
              "Kennedy":</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
$book1/author = "Kennedy"
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>The following example contains three general
              comparisons. The value of the first two comparisons
              is <code>true</code>, and the value of the third
              comparison is <code>false</code>. This example
              illustrates the fact that general comparisons are not
              transitive.</p>

              <div class="exampleInner">
                <pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre>
              </div>
            </li>

            <li>
              <p>Suppose that <code>$a</code>, <code>$b</code>, and
              <code>$c</code> are bound to element nodes with type
              annotation <code>xdt:untypedAtomic</code>, with
              string values "<code>1</code>", "<code>2</code>", and
              "<code>2.0</code>" respectively. Then <code>($a, $b)
              = ($c, 3.0)</code> returns <code>false</code>,
              because <code>$b</code> and <code>$c</code> are
              compared as strings. However, <code>($a, $b) = ($c,
              2.0)</code> returns <code>true</code>, because
              <code>$b</code> and <code>2.0</code> are compared as
              numbers.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="id-node-comparisons" name=
          "id-node-comparisons"></a>3.5.3 Node Comparisons</h4>

          <p>The result of a node comparison is defined by applying
          the following rules, in order:</p>

          <ol class="enumar">
            <li>
              <p>Each operand must be either a single node or an
              empty sequence; otherwise a <a title="type error"
              href="#dt-type-error">type error</a> is
              raised.[<a title="err:XQ0004" href=
              "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
              href="#ERRXP0006">err:XP0006</a>]</p>
            </li>

            <li>
              <p>If either operand is an empty sequence, the result
              of the comparison is an empty sequence.</p>
            </li>

            <li>
              <p>A comparison with the <code>is</code> operator is
              <code>true</code> if the two operands are nodes that
              have the same identity; otherwise it is
              <code>false</code>. A comparison with the
              <code>isnot</code> operator is <code>true</code> if
              the two operands are nodes that have different
              identities; otherwise it is <code>false</code>. See
              <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
              Model]</a> for a discussion of node identity.</p>
            </li>
          </ol>

          <p>Use of the <code>is</code> operator is illustrated
          below.</p>

          <ul>
            <li>
              <p>The following comparison is true only if the left
              and right sides each evaluate to exactly the same
              single node:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
//book[isbn="1558604820"] is //book[call="QA76.9 C3845"]
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="id-order-comparisons" name=
          "id-order-comparisons"></a>3.5.4 Order Comparisons</h4>

          <p>The result of an order comparison is defined by
          applying the following rules, in order:</p>

          <ol class="enumar">
            <li>
              <p>Both operands must be either a single node or an
              empty sequence; otherwise a <a title="type error"
              href="#dt-type-error">type error</a> is
              raised.[<a title="err:XQ0004" href=
              "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
              href="#ERRXP0006">err:XP0006</a>]</p>
            </li>

            <li>
              <p>If either operand is an empty sequence, the result
              of the comparison is an empty sequence.</p>
            </li>

            <li>
              <p>A comparison with the <code>&lt;&lt;</code>
              operator returns <code>true</code> if the first
              operand node is earlier than the second operand node
              in document order; otherwise it returns
              <code>false</code>.</p>
            </li>

            <li>
              <p>A comparison with the <code>&gt;&gt;</code>
              operator returns <code>true</code> if the first
              operand node is later than the second operand node in
              document order; otherwise it returns
              <code>false</code>.</p>
            </li>
          </ol>

          <p>Here is an example of an order comparison:</p>

          <ul>
            <li>
              <p>The following comparison is true only if the node
              identified by the left side occurs before the node
              identified by the right side in document order:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
//purchase[parcel="28-451"] &lt;&lt; //sale[parcel="33-870"]
</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-logical-expressions" name=
        "id-logical-expressions"></a>3.6 Logical Expressions</h3>

        <p>A <b>logical expression</b> is either an
        <b>and-expression</b> or an <b>or-expression</b>. If a
        logical expression does not raise an error, its value is
        always one of the boolean values <code>true</code> or
        <code>false</code>.</p>

        <h5><a id="N11DED" name="N11DED"></a>Logical
        Expressions</h5>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-OrExpr" name=
              "doc-OrExpr"></a>[22]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-OrExpr">OrExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#doc-AndExpr">AndExpr</a> ( "or"
              <a href="#doc-AndExpr">AndExpr</a> )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="doc-AndExpr" name=
              "doc-AndExpr"></a>[23]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-AndExpr">AndExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-InstanceofExpr">InstanceofExpr</a> ( "and"
              <a href="#doc-InstanceofExpr">InstanceofExpr</a>
              )*</code></td>
            </tr>
          </tbody>
        </table>

        <p>The first step in evaluating a logical expression is to
        find the <a title="effective boolean value" href=
        "#dt-ebv">effective boolean value</a> of each of its
        operands (see <a href="#id-ebv"><b>2.4.2.2 Effective
        Boolean Value</b></a>).</p>

        <p>The value of an and-expression is determined by the
        effective boolean values (EBV's) of its operands. If an
        error is raised during computation of one of the effective
        boolean values, an and-expression <em>may</em> raise a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a>, as shown in the following table:</p>

        <table border="1" cellpadding="4" cellspacing="1" width=
        "80%" summary="AND EBV">
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">AND:</td>

              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
              true</td>

              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
              false</td>

              <td rowspan="1" colspan="1">error in
              EBV<sub>2</sub></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
              true</td>

              <td rowspan="1" colspan="1">true</td>

              <td rowspan="1" colspan="1">false</td>

              <td rowspan="1" colspan="1">error</td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
              false</td>

              <td rowspan="1" colspan="1">false</td>

              <td rowspan="1" colspan="1">false</td>

              <td rowspan="1" colspan="1">false or error</td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">error in
              EBV<sub>1</sub></td>

              <td rowspan="1" colspan="1">error</td>

              <td rowspan="1" colspan="1">false or error</td>

              <td rowspan="1" colspan="1">error</td>
            </tr>
          </tbody>
        </table>

        <p>The value of an or-expression is determined by the
        effective boolean values (EBV's) of its operands. If an
        error is raised during computation of one of the effective
        boolean values, an or-expression <em>may</em> raise a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a>, as shown in the following table:</p>

        <table border="1" cellpadding="4" cellspacing="1" width=
        "80%" summary="OR EBV">
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">OR:</td>

              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
              true</td>

              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
              false</td>

              <td rowspan="1" colspan="1">error in
              EBV<sub>2</sub></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
              true</td>

              <td rowspan="1" colspan="1">true</td>

              <td rowspan="1" colspan="1">true</td>

              <td rowspan="1" colspan="1">true or error</td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
              false</td>

              <td rowspan="1" colspan="1">true</td>

              <td rowspan="1" colspan="1">false</td>

              <td rowspan="1" colspan="1">error</td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">error in
              EBV<sub>1</sub></td>

              <td rowspan="1" colspan="1">true or error</td>

              <td rowspan="1" colspan="1">error</td>

              <td rowspan="1" colspan="1">error</td>
            </tr>
          </tbody>
        </table>

        <p>The order in which the operands of a logical expression
        are evaluated is implementation-dependent. The tables above
        are defined in such a way that an or-expression can return
        <code>true</code> if the first expression evaluated is
        true, and it can raise an error if evaluation of the first
        expression raises an error. Similarly, an and-expression
        can return <code>false</code> if the first expression
        evaluated is false, and it can raise an error if evaluation
        of the first expression raises an error. As a result of
        these rules, a logical expression is not deterministic in
        the presence of errors, as illustrated in the examples
        below.</p>

        <p>Here are some examples of logical expressions:</p>

        <ul>
          <li>
            <p>The following expressions return
            <code>true</code>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
1 eq 1 and 2 eq 2
</pre>
              </div>
            </div>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
1 eq 1 or 2 eq 3
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>The following expression may return either
            <code>false</code> or raise a <a title="dynamic error"
            href="#dt-dynamic-error">dynamic error</a>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
1 eq 2 and 3 idiv 0 = 1
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>The following expression may return either
            <code>true</code> or raise a <a title="dynamic error"
            href="#dt-dynamic-error">dynamic error</a>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
1 eq 1 or 3 idiv 0 = 1
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>The following expression must raise a <a title=
            "dynamic error" href="#dt-dynamic-error">dynamic
            error</a>:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
1 eq 1 and 3 idiv 0 = 1
</pre>
              </div>
            </div>
          </li>
        </ul>

        <p>In addition to and- and or-expressions, XPath provides a
        function named <code>not</code> that takes a general
        sequence as parameter and returns a boolean value. The
        <code>not</code> function reduces its parameter to an
        <a title="effective boolean value" href="#dt-ebv">effective
        boolean value</a>. It then returns <code>true</code> if the
        effective boolean value of its parameter is
        <code>false</code>, and <code>false</code> if the effective
        boolean value of its parameter is <code>true</code>. If an
        error is encountered in finding the effective boolean value
        of its operand, <code>not</code> raises the same <a title=
        "dynamic error" href="#dt-dynamic-error">dynamic error</a>.
        The <code>not</code> function is described in <a href=
        "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
        Functions and Operators]</a>.</p>
      </div>

      <div class="xpath">
        <div class="div2">
          <h3><a id="id-for-expressions" name=
          "id-for-expressions"></a>3.7 For Expressions</h3>

          <p>XPath provides an iteration facility called a <b>for
          expression</b>.</p>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-ForExpr" name=
                "doc-ForExpr"></a>[18]&#160;&#160;&#160;</td>

                <td><code><a href="#prod-ForExpr" class=
                "xpath">ForExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-SimpleForClause">SimpleForClause</a> "return"
                <a href=
                "#doc-ExprSingle">ExprSingle</a></code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SimpleForClause" name=
                "doc-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>

                <td><code><a href="#prod-SimpleForClause" class=
                "xpath">SimpleForClause</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>"for" "$" <a href=
                "#doc-VarName">VarName</a> "in" <a href=
                "#doc-ExprSingle">ExprSingle</a> ("," "$" <a href=
                "#doc-VarName">VarName</a> "in" <a href=
                "#doc-ExprSingle">ExprSingle</a>)*</code></td>
              </tr>
            </tbody>
          </table>

          <p>A <code>for</code> expression is evaluated as
          follows:</p>

          <ol class="enumar">
            <li>
              <p>If the <code>for</code> expression uses multiple
              variables, it is first expanded to a set of nested
              <code>for</code> expressions, each of which uses only
              one variable. For example, the expression <code>for
              $x in X, $y in Y return $x + $y</code> is expanded to
              <code>for $x in X return for $y in Y return $x +
              $y</code>.</p>
            </li>

            <li>
              <p>In a single-variable <code>for</code> expression,
              the variable is called the <b>range variable</b>, the
              value of the expression that follows the
              <code>in</code> keyword is called the <b>input
              sequence</b>, and the expression that follows the
              <code>return</code> keyword is called the <b>return
              expression</b>. The result of the <code>for</code>
              expression is obtained by evaluating the
              <code>return</code> expression once for each item in
              the input sequence, with the range variable bound to
              that item. The resulting sequences are concatenated
              in the order of the items in the input sequence from
              which they were derived.</p>
            </li>
          </ol>

          <div class="xpath">
            <p class="xpath">The following example illustrates the
            use of a <code>for</code> expression in restructuring
            an input document. The example is based on the
            following input:</p>
          </div>

          <div class="exampleInner">
            <pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Unix Programming&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre>
          </div>

          <p>The following example transforms the input document
          into a list in which each author's name appears only
          once, followed by a list of titles of books written by
          that author. This example assumes that the context item
          is the <code>bib</code> element in the input
          document.</p>

          <div class="exampleInner">
            <pre>
<span class="parse-test"><span class=
"parse-test">for $a in distinct-values(//author)
return ($a,
        for $b in //book[author = $a]
        return $b/title)</span></span>
</pre>
          </div>

          <p>The result of the above expression consists of the
          following sequence of elements. The ordering of
          <code>author</code> elements in the result is
          implementation-dependent.</p>

          <div class="exampleInner">
            <pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre>
          </div>

          <p>The following example illustrates a <code>for</code>
          expression containing more than one variable:</p>

          <div class="exampleInner">
            <pre>
<span class="parse-test"><span class=
"parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span>
</pre>
          </div>

          <p>The result of the above expression, expressed as a
          sequence of numbers, is as follows: <code>11, 12, 21,
          22</code></p>

          <p>The scope of a variable bound in a <code>for</code>
          expression comprises all subexpressions of the
          <code>for</code> expression that appear after the
          variable binding. The scope does not include the
          expression to which the variable is bound. The following
          example illustrates how a variable binding may reference
          another variable bound earlier in the same
          <code>for</code> expression:</p>

          <div class="exampleInner">
            <pre>
<span class="parse-test"><span class=
"parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></span>
</pre>
          </div>

          <p>Note that the focus for evaluation of the
          <code>return</code> clause of a <code>for</code>
          expression is the same as the focus for evaluation of the
          <code>for</code> expression itself. The following
          example, which attempts to find the total value of a set
          of order-items, is therefore incorrect:</p>

          <div class="exampleInner">
            <pre>
sum(for $i in order-item return @price * @qty)
</pre>
          </div>

          <p>Instead, the expression must be written to use the
          variable bound in the <code>for</code> clause:</p>

          <div class="exampleInner">
            <pre>
sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a id="id-conditionals" name="id-conditionals"></a>3.8
        Conditional Expressions</h3>

        <p>XPath supports a conditional expression based on the
        keywords <code>if</code>, <code>then</code>, and
        <code>else</code>.</p>

        <h5><a id="N12004" name="N12004"></a>Conditional
        Expression</h5>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-IfExpr" name=
              "doc-IfExpr"></a>[21]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-IfExpr">IfExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"if" "(" <a href="#doc-Expr">Expr</a> ")"
              "then" <a href="#doc-ExprSingle">ExprSingle</a>
              "else" <a href=
              "#doc-ExprSingle">ExprSingle</a></code></td>
            </tr>
          </tbody>
        </table>

        <p>The expression following the <code>if</code> keyword is
        called the <b>test expression</b>, and the expressions
        following the <code>then</code> and <code>else</code>
        keywords are called the <b>then-expression</b> and
        <b>else-expression</b>, respectively.</p>

        <p>The first step in processing a conditional expression is
        to find the <a title="effective boolean value" href=
        "#dt-ebv">effective boolean value</a> of the test
        expression, as defined in <a href="#id-ebv"><b>2.4.2.2
        Effective Boolean Value</b></a>.</p>

        <p>The value of a conditional expression is defined as
        follows: If the effective boolean value of the test
        expression is <code>true</code>, the value of the
        then-expression is returned. If the effective boolean value
        of the test expression is <code>false</code>, the value of
        the else-expression is returned.</p>

        <p>Conditional expressions have a special rule for
        propagating <a title="dynamic error" href=
        "#dt-dynamic-error">dynamic errors</a>. If the effective
        value of the test expression is <code>true</code>, the
        conditional expression ignores (does not raise) any dynamic
        errors encountered in the else-expression. In this case,
        since the else-expression can have no observable effect, it
        need not be evaluated. Similarly, if the effective value of
        the test expression is <code>false</code>, the conditional
        expression ignores any <a title="dynamic error" href=
        "#dt-dynamic-error">dynamic errors</a> encountered in the
        then-expression, and the then-expression need not be
        evaluated.</p>

        <p>Here are some examples of conditional expressions:</p>

        <ul>
          <li>
            <p>In this example, the test expression is a comparison
            expression:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>In this example, the test expression tests for the
            existence of an attribute named
            <code>discounted</code>, independently of its
            value:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre>
              </div>
            </div>
          </li>
        </ul>
      </div>

      <div class="div2">
        <h3><a id="id-quantified-expressions" name=
        "id-quantified-expressions"></a>3.9 Quantified
        Expressions</h3>

        <p>Quantified expressions support existential and universal
        quantification. The value of a quantified expression is
        always <code>true</code> or <code>false</code>.</p>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="doc-QuantifiedExpr" name=
              "doc-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-QuantifiedExpr">QuantifiedExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(("some" "$") | ("every" "$")) <a href=
              "#doc-VarName">VarName</a> "in" <a href=
              "#doc-ExprSingle">ExprSingle</a> ("," "$" <a href=
              "#doc-VarName">VarName</a> "in" <a href=
              "#doc-ExprSingle">ExprSingle</a>)* "satisfies"
              <a href="#doc-ExprSingle">ExprSingle</a></code></td>
            </tr>
          </tbody>
        </table>

        <p>A <b>quantified expression</b> begins with a
        <b>quantifier</b>, which is the keyword <code>some</code>
        or <code>every</code>, followed by one or more in-clauses
        that are used to bind variables, followed by the keyword
        <code>satisfies</code> and a test expression. Each
        in-clause associates a variable with an expression that
        returns a sequence of values. The in-clauses generate
        tuples of variable bindings, using values drawn from the
        Cartesian product of the sequences returned by the binding
        expressions. Conceptually, the test expression is evaluated
        for each tuple of variable bindings. Results depend on the
        <b>effective boolean values</b> of the test expressions, as
        defined in <a href="#id-ebv"><b>2.4.2.2 Effective Boolean
        Value</b></a>. The value of the quantified expression is
        defined by the following rules:</p>

        <ol class="enumar">
          <li>
            <p>If the quantifier is <code>some</code>, the
            quantified expression is <code>true</code> if at least
            one evaluation of the test expression has the
            <b>effective boolean value</b> <code>true</code>;
            otherwise the quantified expression is
            <code>false</code>. This rule implies that, if the
            in-clauses generate zero binding tuples, the value of
            the quantified expression is <code>false</code>.</p>
          </li>

          <li>
            <p>If the quantifier is <code>every</code>, the
            quantified expression is <code>true</code> if every
            evaluation of the test expression has the <b>effective
            boolean value</b> <code>true</code>; otherwise the
            quantified expression is <code>false</code>. This rule
            implies that, if the in-clauses generate zero binding
            tuples, the value of the quantified expression is
            <code>true</code>.</p>
          </li>
        </ol>

        <p>The scope of a variable bound in a quantified expression
        comprises all subexpressions of the quantified expression
        that appear after the variable binding. The scope does not
        include the expression to which the variable is bound.</p>

        <p>The order in which test expressions are evaluated for
        the various binding tuples is <a title=
        "implementation defined" href=
        "#dt-implementation-defined">implementation defined</a>. If
        the quantifier is <code>some</code>, an implementation may
        return <code>true</code> as soon as it finds one binding
        tuple for which the test expression has an effective
        Boolean value of <code>true</code>, and it may raise a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a> as soon as it finds one binding tuple for which
        the test expression raises an error. Similarly, if the
        quantifier is <code>every</code>, an implementation may
        return <code>false</code> as soon as it finds one binding
        tuple for which the test expression has an effective
        Boolean value of <code>false</code>, and it may raise a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a> as soon as it finds one binding tuple for which
        the test expression raises an error. As a result of these
        rules, the value of a quantified expression is not
        deterministic in the presence of errors, as illustrated in
        the examples below.</p>

        <p>Here are some examples of quantified expressions:</p>

        <ul>
          <li>
            <p>This expression is <code>true</code> if every
            <code>part</code> element has a <code>discounted</code>
            attribute (regardless of the values of these
            attributes):</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
every $part in //part satisfies $part/@discounted
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>This expression is <code>true</code> if at least one
            <code>employee</code> element satisfies the given
            comparison expression:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
some $emp in //employee satisfies ($emp/bonus &gt; 0.25 * $emp/salary)
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>In the following examples, each quantified
            expression evaluates its test expression over nine
            tuples of variable bindings, formed from the Cartesian
            product of the sequences <code>(1, 2, 3)</code> and
            <code>(2, 3, 4)</code>. The expression beginning with
            <code>some</code> evaluates to <code>true</code>, and
            the expression beginning with <code>every</code>
            evaluates to <code>false</code>.</p>

            <div class="exampleInner">
              <pre>
<span class="parse-test"><span class=
"parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre>
            </div>

            <div class="exampleInner">
              <pre>
<span class="parse-test"><span class=
"parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre>
            </div>
          </li>

          <li>
            <p>This quantified expression may either return
            <code>true</code> or raise a <a title="type error"
            href="#dt-type-error">type error</a>, since its test
            expression returns <code>true</code> for one variable
            binding and raises a <a title="type error" href=
            "#dt-type-error">type error</a> for another:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre>
              </div>
            </div>
          </li>

          <li>
            <p>This quantified expression may either return
            <code>false</code> or raise a <a title="type error"
            href="#dt-type-error">type error</a>, since its test
            expression returns <code>false</code> for one variable
            binding and raises a <a title="type error" href=
            "#dt-type-error">type error</a> for another:</p>

            <div class="parse-test">
              <div class="exampleInner">
                <pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre>
              </div>
            </div>
          </li>
        </ul>
      </div>

      <div class="div2">
        <h3><a id="id-expressions-on-datatypes" name=
        "id-expressions-on-datatypes"></a>3.10 Expressions on
        SequenceTypes</h3>

        <p><b>SequenceTypes</b> are used in <code>instance
        of</code>, <code>cast</code>, <code>castable</code>, and
        <code>treat</code> expressions.</p>

        <div class="div3">
          <h4><a id="id-instance-of" name=
          "id-instance-of"></a>3.10.1 Instance Of</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-InstanceofExpr" name=
                "doc-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-InstanceofExpr">InstanceofExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-TreatExpr">TreatExpr</a> (
                "instance" "of" <a href=
                "#doc-SequenceType">SequenceType</a> )?</code></td>
              </tr>
            </tbody>
          </table>

          <p>The boolean operator <code>instance of</code> returns
          <code>true</code> if the value of its first operand
          matches the type named in its second operand, according
          to the rules for <b>SequenceType Matching</b>; otherwise
          it returns <code>false</code>. For example:</p>

          <ul>
            <li>
              <p><code>5 instance of xs:integer</code></p>

              <p>This example returns <code>true</code> because the
              given value is an instance of the given type.</p>
            </li>

            <li>
              <p><code>5 instance of xs:decimal</code></p>

              <p>This example returns <code>true</code> because the
              given value is an integer literal, and
              <code>xs:integer</code> is derived by restriction
              from <code>xs:decimal</code>.</p>
            </li>

            <li>
              <p><code>. instance of element()</code></p>

              <p>This example returns <code>true</code> if the
              context item is an element node.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a id="id-cast" name="id-cast"></a>3.10.2 Cast</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-CastExpr" name=
                "doc-CastExpr"></a>[27]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-CastExpr">CastExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-ComparisonExpr">ComparisonExpr</a> ( "cast"
                "as" <a href="#doc-SingleType">SingleType</a>
                )?</code></td>
              </tr>
            </tbody>

            <tbody>
              <tr valign="baseline">
                <td><a id="doc-SingleType" name=
                "doc-SingleType"></a>[61]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-SingleType">SingleType</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-AtomicType">AtomicType</a>
                "?"?</code></td>
              </tr>
            </tbody>
          </table>

          <p>Occasionally it is necessary to convert a value to a
          specific datatype. For this purpose, XPath provides a
          <code>cast</code> expression that creates a new value of
          a specific type based on an existing value. A
          <code>cast</code> expression takes two operands: an
          <b>input expression</b> and a <b>target type</b>. The
          type of the input expression is called the <b>input
          type</b>. The target type must be a named atomic type,
          represented by a QName, optionally followed by the
          occurrence indicator <code>?</code> if an empty sequence
          is permitted. If the target type has no namespace prefix,
          it is considered to be in the <b>default element/type
          namespace</b>. The semantics of the <code>cast</code>
          expression are as follows:</p>

          <ol class="enumar">
            <li>
              <p><a title="atomization" href=
              "#dt-atomization">Atomization</a> is performed on the
              input expression.</p>
            </li>

            <li>
              <p>If the result of atomization is a sequence of more
              than one atomic value, a <a title="type error" href=
              "#dt-type-error">type error</a> is raised.[<a title=
              "err:XQ0004" href=
              "#ERRXQ0004">err:XQ0004</a>][<a title="err:XP0006"
              href="#ERRXP0006">err:XP0006</a>]</p>
            </li>

            <li>
              <p>If the result of atomization is an empty
              sequence:</p>

              <ol class="enumla">
                <li>
                  <p>If <code>?</code> is specified after the
                  target type, the result of the <code>cast</code>
                  expression is an empty sequence.</p>
                </li>

                <li>
                  <p>If <code>?</code> is not specified after the
                  target type, a <a title="type error" href=
                  "#dt-type-error">type error</a> is
                  raised.[<a title="err:XQ0004" href=
                  "#ERRXQ0004">err:XQ0004</a>][<a title=
                  "err:XP0006" href=
                  "#ERRXP0006">err:XP0006</a>]</p>
                </li>
              </ol>
            </li>

            <li>
              <p>If the result of atomization is a single atomic
              value, the result of the cast expression depends on
              the input type and the target type. In general, the
              cast expression attempts to create a new value of the
              target type based on the input value. Only certain
              combinations of input type and target type are
              supported. The rules are listed below. For the
              purpose of these rules, we use the terms
              <b>subtype</b> and <b>supertype</b> in the following
              sense: if type B is derived from type A by
              restriction, then B is a <b>subtype</b> of A, and A
              is a <b>supertype</b> of B.</p>

              <ol class="enumla">
                <li>
                  <p><code>cast</code> is supported for the
                  combinations of input type and target type listed
                  in <a href="#FunctionsAndOperators">[XQuery 1.0
                  and XPath 2.0 Functions and Operators]</a>. For
                  each of these combinations, both the input type
                  and the target type are built-in schema types.
                  For example, a value of type
                  <code>xs:string</code> can be cast into the type
                  <code>xs:decimal</code>. For each of these
                  built-in combinations, the semantics of casting
                  are specified in <a href=
                  "#FunctionsAndOperators">[XQuery 1.0 and XPath
                  2.0 Functions and Operators]</a>.</p>
                </li>

                <li>
                  <p><code>cast</code> is supported if the input
                  type is a derived atomic type and the target type
                  is a supertype of the input type. In this case,
                  the input value is mapped into the value space of
                  the target type, unchanged except for its type.
                  For example, if <code>shoesize</code> is derived
                  by restriction from <code>xs:integer</code>, a
                  value of type <code>shoesize</code> can be cast
                  into the type <code>xs:integer</code>.</p>
                </li>

                <li>
                  <p><code>cast</code> is supported if the target
                  type is a derived atomic type and the input type
                  is <code>xs:string</code> or
                  <code>xdt:untypedAtomic</code>. The input value
                  is first converted to a value in the lexical
                  space of the target type by applying the
                  whitespace normalization rules for the target
                  type; a <a title="dynamic error" href=
                  "#dt-dynamic-error">dynamic error</a> [<a title=
                  "err:XP0029" href="#ERRXP0029">err:XP0029</a>] is
                  raised if the resulting lexical value does not
                  satisfy the pattern facet of the target type. The
                  lexical value is then converted to the value
                  space of the target type using the schema-defined
                  rules for the target type; a <a title=
                  "dynamic error" href="#dt-dynamic-error">dynamic
                  error</a>[<a title="err:XP0029" href=
                  "#ERRXP0029">err:XP0029</a>] is raised if the
                  resulting value does not satisfy all the facets
                  of the target type.</p>
                </li>

                <li>
                  <p><code>cast</code> is supported if the target
                  type is a derived atomic type and the input type
                  is a supertype of the target type. The input
                  value must satisfy all the facets of the target
                  type (in the case of the pattern facet, this is
                  checked by generating a string representation of
                  the input value, using the rules for casting to
                  <code>xs:string</code>). The resulting value is
                  the same as the input value, but with a different
                  dynamic type.</p>
                </li>

                <li>
                  <p>If a primitive type P1 can be cast into a
                  primitive type P2, then any subtype of P1 can be
                  cast into any subtype of P2, provided that the
                  facets of the target type are satisfied. First
                  the input value is cast to P1 using rule (b)
                  above. Next, the value of type P1 is cast to the
                  type P2, using rule (a) above. Finally, the value
                  of type P2 is cast to the target type, using rule
                  (d) above.</p>
                </li>

                <li>
                  <p>For any combination of input type and target
                  type that is not in the above list, a
                  <code>cast</code> expression raises a <a title=
                  "type error" href="#dt-type-error">type
                  error</a>.[<a title="err:XQ0004" href=
                  "#ERRXQ0004">err:XQ0004</a>][<a title=
                  "err:XP0006" href=
                  "#ERRXP0006">err:XP0006</a>]</p>
                </li>
              </ol>
            </li>
          </ol>

          <p>If casting from the input type to the target type is
          supported but nevertheless it is not possible to cast the
          input value into the value space of the target type, a
          <a title="dynamic error" href="#dt-dynamic-error">dynamic
          error</a> is raised.[<a title="err:XP0021" href=
          "#ERRXP0021">err:XP0021</a>] This includes the case when
          any facet of the target type is not satisfied. For
          example, the expression <code>"2003-02-31" cast as
          xs:date</code> would raise a <a title="dynamic error"
          href="#dt-dynamic-error">dynamic error</a>.</p>
        </div>

        <div class="div3">
          <h4><a id="id-castable" name="id-castable"></a>3.10.3
          Castable</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-CastableExpr" name=
                "doc-CastableExpr"></a>[26]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-CastableExpr">CastableExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#doc-CastExpr">CastExpr</a> (
                "castable" "as" <a href=
                "#doc-SingleType">SingleType</a> )?</code></td>
              </tr>
            </tbody>
          </table>

          <p>XPath provides a form of Boolean expression that tests
          whether a given value is castable into a given target
          type. The expression <code>V castable as T</code> returns
          <code>true</code> if the value <code>V</code> can be
          successfully cast into the target type <code>T</code> by
          using a <code>cast</code> expression; otherwise it
          returns <code>false</code>. The <code>castable</code>
          predicate can be used to avoid errors at evaluation time.
          It can also be used to select an appropriate type for
          processing of a given value, as illustrated in the
          following example:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
if ($x castable as hatsize)
then $x cast as hatsize
else if ($x castable as IQ)
then $x cast as IQ
else $x cast as xs:string
</pre>
            </div>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-constructor-functions" name=
          "id-constructor-functions"></a>3.10.4 Constructor
          Functions</h4>

          <p>Constructor functions provide an alternative syntax
          for casting.</p>

          <p>For every built-in atomic type <em>T</em> that is
          defined in <a href="#XMLSchema">[XML Schema]</a>, as well
          as the predefined types <code>xdt:dayTimeDuration</code>,
          <code>xdt:yearMonthDuration</code>, and
          <code>xdt:untypedAtomic</code>, a built-in constructor
          function is provided. The signature of the built-in
          constructor function for type <em>T</em> is as
          follows:</p>

          <div class="exampleInner">
            <pre>
<em>T</em>($x as item) as <em>T</em>
</pre>
          </div>

          <p>The constructor function for type <em>T</em> accepts
          any single item (either a node or an atomic value) as
          input, and returns a value of type <em>T</em> (or raises
          a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a>). Its semantics are
          exactly the same as a <code>cast</code> expression with
          target type <em>T</em>. The built-in constructor
          functions are described in more detail in <a href=
          "#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
          Functions and Operators]</a>. The following are examples
          of built-in constructor functions:</p>

          <ul>
            <li>
              <p>This example is equivalent to <code>"2000-01-01"
              cast as xs:date</code>.</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
xs:date("2000-01-01")
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This example is equivalent to <code>($floatvalue *
              0.2E-5) cast as xs:decimal</code>.</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
xs:decimal($floatvalue * 0.2E-5)
</pre>
                </div>
              </div>
            </li>

            <li>
              <p>This example returns a
              <code>dayTimeDuration</code> value equal to 21 days.
              It is equivalent to <code>"P21D" cast as
              xdt:dayTimeDuration</code>.</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
xdt:dayTimeDuration("P21D")
</pre>
                </div>
              </div>
            </li>
          </ul>

          <p>For each user-defined top-level atomic type <em>T</em>
          in the <a title="in-scope type definitions" href=
          "#dt-is-types">in-scope type definitions</a> that is in a
          namespace, a constructor function is effectively defined.
          Like the built-in constructor functions, the constructor
          functions for user-defined types have the same name
          (including namespace) as the type, accept any item as
          input, and have semantics identical to a
          <code>cast</code> expression with the user-defined type
          as target type. For example, if <code>usa:zipcode</code>
          is a user-defined top-level atomic type in the <a title=
          "in-scope type definitions" href="#dt-is-types">in-scope
          type definitions</a>, then the expression
          <code>usa:zipcode("12345")</code> is equivalent to the
          expression <code>"12345" cast as usa:zipcode</code>.</p>

          <p>User-defined atomic types that are not in a namespace
          do not have implicit constructor functions. To construct
          an instance of such a type, it is necessary to use a
          <code>cast</code> expression. For example, if the
          user-defined type <code>apple</code> is derived from
          <code>xs:integer</code> but is not in a namespace, an
          instance of this type can be constructed as follows:</p>

          <div class="parse-test">
            <div class="exampleInner">
              <pre>
17 cast as apple
</pre>
            </div>
          </div>
        </div>

        <div class="div3">
          <h4><a id="id-treat" name="id-treat"></a>3.10.5
          Treat</h4>

          <table summary="Scrap" class="scrap">
            <tbody>
              <tr valign="baseline">
                <td><a id="doc-TreatExpr" name=
                "doc-TreatExpr"></a>[25]&#160;&#160;&#160;</td>

                <td><code><a href=
                "#prod-TreatExpr">TreatExpr</a></code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#doc-CastableExpr">CastableExpr</a> ( "treat" "as"
                <a href="#doc-SequenceType">SequenceType</a>
                )?</code></td>
              </tr>
            </tbody>
          </table>

          <p>XPath provides an expression called <code>treat</code>
          that can be used to modify the <a title="static type"
          href="#dt-static-type">static type</a> of its
          operand.</p>

          <p>Like <code>cast</code>, the <code>treat</code>
          expression takes two operands: an expression and a
          <a title="SequenceType" href=
          "#dt-sequence-type">SequenceType</a>. Unlike
          <code>cast</code>, however, <code>treat</code> does not
          change the dynamic type or value of its operand. Instead,
          the purpose of <code>treat</code> is to ensure that an
          expression has an expected type at evaluation time.</p>

          <p>The semantics of <code>expr1 treat as type1</code> are
          as follows:</p>

          <ul>
            <li>
              <p>During static analysis:</p>

              <p>The <a title="static type" href=
              "#dt-static-type">static type</a> of the
              <code>treat</code> expression is <code>type1</code>.
              This enables the expression to be used as an argument
              of a function that requires a parameter of
              <code>type1</code>.</p>
            </li>

            <li>
              <p>During expression evaluation:</p>

              <p>If <code>expr1</code> matches <code>type1</code>,
              using the SequenceType Matching rules in <a href=
              "#id-sequencetype"><b>2.4.1 SequenceType</b></a>, the
              <code>treat</code> expression returns the value of
              <code>expr1</code>; otherwise, it raises a <a title=
              "dynamic error" href="#dt-dynamic-error">dynamic
              error</a>.[<a title="err:XP0006" href=
              "#ERRXP0006">err:XP0006</a>] If the value of
              <code>expr1</code> is returned, its identity is
              preserved. The <code>treat</code> expression ensures
              that the value of its expression operand conforms to
              the expected type at run-time.</p>
            </li>

            <li>
              <p>Example:</p>

              <div class="parse-test">
                <div class="exampleInner">
                  <pre>
$myaddress treat as element(*, USAddress)
</pre>
                </div>
              </div>

              <p>The <a title="static type" href=
              "#dt-static-type">static type</a> of
              <code>$myaddress</code> may be <code>element(*,
              Address)</code>, a less specific type than
              <code>element(*, USAddress)</code>. However, at
              run-time, the value of <code>$myaddress</code> must
              match the type <code>element(*, USAddress)</code>
              using SequenceType Matching rules; otherwise a
              <a title="dynamic error" href=
              "#dt-dynamic-error">dynamic error</a> is
              raised.[<a title="err:XP0050" href=
              "#ERRXP0050">err:XP0050</a>]</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="back">
    <div class="div1">
      <h2><a id="nt-bnf" name="nt-bnf"></a>A XPath Grammar</h2>

      <div class="div2">
        <h3><a id="id-grammar" name="id-grammar"></a>A.1 EBNF</h3>

        <p>The following grammar uses the same Basic Extended
        Backus-Naur Form (EBNF) notation as <a href=
        "#XML">[XML]</a>, except that grammar symbols always have
        initial capital letters. The notation "&lt; ... &gt;" is
        used to indicate a grouping of terminals that together may
        help disambiguate the individual symbols. To help
        readability, this "&lt; ... &gt;" notation is absent in the
        EBNF in the main body of this document.</p>

        <p>Comments on grammar productions are between '/*' and
        '*/' symbols. A 'gn:' prefix means a 'Grammar Note', and
        are meant as clarifications for parsing rules, and are
        explained in <a href="#notes-on-parsing"><b>A.1.1 Grammar
        Notes</b></a>. A 'ws:' prefix explains the white space
        rules for the production, the details of which are
        explained in <a href="#whitespace-rules"><b>A.2.1 White
        Space Rules</b></a></p>

        <h5><a id="N123E2" name="N123E2"></a>Named Terminals</h5>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ExprComment" name=
              "prod-ExprComment"></a>[1]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ExprComment">ExprComment</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"(:" (<a href=
              "#prod-ExprCommentContent">ExprCommentContent</a> |
              <a href="#prod-ExprComment">ExprComment</a>)*
              ":)"</code></td>

              <td><i>/* <a href="#parse-note-comments">gn:
              comments</a> */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ExprCommentContent" name=
              "prod-ExprCommentContent"></a>[2]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ExprCommentContent">ExprCommentContent</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-Char">Char</a></code></td>

              <td><i>/* <a href="#parse-note-parens">gn: parens</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-IntegerLiteral" name=
              "prod-IntegerLiteral"></a>[3]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-IntegerLiteral">IntegerLiteral</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-Digits">Digits</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-DecimalLiteral" name=
              "prod-DecimalLiteral"></a>[4]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-DecimalLiteral">DecimalLiteral</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("." <a href="#prod-Digits">Digits</a>) |
              (<a href="#prod-Digits">Digits</a> "."
              [0-9]*)</code></td>

              <td><i>/* <a href="#ws-explicit">ws: explicit</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-DoubleLiteral" name=
              "prod-DoubleLiteral"></a>[5]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-DoubleLiteral">DoubleLiteral</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(("." <a href="#prod-Digits">Digits</a>) |
              (<a href="#prod-Digits">Digits</a> ("." [0-9]*)?))
              ("e" | "E") ("+" | "-")? <a href=
              "#prod-Digits">Digits</a></code></td>

              <td><i>/* <a href="#ws-explicit">ws: explicit</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-StringLiteral" name=
              "prod-StringLiteral"></a>[6]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-StringLiteral">StringLiteral</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>('"' (('"' '"') | [^"])* '"') | ("'" (("'"
              "'") | [^'])* "'")</code></td>

              <td><i>/* <a href="#ws-significant">ws:
              significant</a> */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SchemaGlobalTypeName" name=
              "prod-SchemaGlobalTypeName"></a>[7]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"type" "(" <a href="#prod-QName">QName</a>
              ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SchemaGlobalContext" name=
              "prod-SchemaGlobalContext"></a>[8]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SchemaGlobalContext">SchemaGlobalContext</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a> | <a href=
              "#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SchemaContextStep" name=
              "prod-SchemaContextStep"></a>[9]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SchemaContextStep">SchemaContextStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Digits" name=
              "prod-Digits"></a>[10]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-Digits">Digits</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>[0-9]+</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NCName" name=
              "prod-NCName"></a>[11]&#160;&#160;&#160;</td>

              <td><code>NCName</code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-VarName" name=
              "prod-VarName"></a>[12]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-VarName">VarName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-QName" name=
              "prod-QName"></a>[13]&#160;&#160;&#160;</td>

              <td><code>QName</code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Char" name=
              "prod-Char"></a>[14]&#160;&#160;&#160;</td>

              <td><code>Char</code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "http://www.w3.org/TR/REC-xml#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a></code></td>
            </tr>
          </tbody>
        </table>

        <h5><a id="BNF-Grammar" name=
        "BNF-Grammar"></a>Non-Terminals</h5>

        <table summary="Scrap" class="scrap">
          <tbody>
            <tr valign="baseline">
              <td><a id="prod-XPath" name=
              "prod-XPath"></a>[15]&#160;&#160;&#160;</td>

              <td><code><a href="#doc-XPath">XPath</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-Expr">Expr</a>?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Expr" name=
              "prod-Expr"></a>[16]&#160;&#160;&#160;</td>

              <td><code><a href="#doc-Expr">Expr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-ExprSingle">ExprSingle</a>
              ("," <a href=
              "#prod-ExprSingle">ExprSingle</a>)*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ExprSingle" name=
              "prod-ExprSingle"></a>[17]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ExprSingle">ExprSingle</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-ForExpr">ForExpr</a><br />
              | <a href=
              "#prod-QuantifiedExpr">QuantifiedExpr</a><br />
              | <a href="#prod-IfExpr">IfExpr</a><br />
              | <a href="#prod-OrExpr">OrExpr</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ForExpr" name=
              "prod-ForExpr"></a>[18]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ForExpr">ForExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-SimpleForClause">SimpleForClause</a> "return"
              <a href="#prod-ExprSingle">ExprSingle</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SimpleForClause" name=
              "prod-SimpleForClause"></a>[19]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SimpleForClause">SimpleForClause</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"for" "$"&gt; <a href=
              "#prod-VarName">VarName</a> "in" <a href=
              "#prod-ExprSingle">ExprSingle</a> ("," "$" <a href=
              "#prod-VarName">VarName</a> "in" <a href=
              "#prod-ExprSingle">ExprSingle</a>)*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-QuantifiedExpr" name=
              "prod-QuantifiedExpr"></a>[20]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-QuantifiedExpr">QuantifiedExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(&lt;"some" "$"&gt; | &lt;"every" "$"&gt;)
              <a href="#prod-VarName">VarName</a> "in" <a href=
              "#prod-ExprSingle">ExprSingle</a> ("," "$" <a href=
              "#prod-VarName">VarName</a> "in" <a href=
              "#prod-ExprSingle">ExprSingle</a>)* "satisfies"
              <a href="#prod-ExprSingle">ExprSingle</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-IfExpr" name=
              "prod-IfExpr"></a>[21]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-IfExpr">IfExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"if" "("&gt; <a href=
              "#prod-Expr">Expr</a> ")" "then" <a href=
              "#prod-ExprSingle">ExprSingle</a> "else" <a href=
              "#prod-ExprSingle">ExprSingle</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-OrExpr" name=
              "prod-OrExpr"></a>[22]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-OrExpr">OrExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-AndExpr">AndExpr</a> ( "or"
              <a href="#prod-AndExpr">AndExpr</a> )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AndExpr" name=
              "prod-AndExpr"></a>[23]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AndExpr">AndExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-InstanceofExpr">InstanceofExpr</a> ( "and"
              <a href="#prod-InstanceofExpr">InstanceofExpr</a>
              )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-InstanceofExpr" name=
              "prod-InstanceofExpr"></a>[24]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-InstanceofExpr">InstanceofExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-TreatExpr">TreatExpr</a> (
              &lt;"instance" "of"&gt; <a href=
              "#prod-SequenceType">SequenceType</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-TreatExpr" name=
              "prod-TreatExpr"></a>[25]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-TreatExpr">TreatExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-CastableExpr">CastableExpr</a> ( &lt;"treat"
              "as"&gt; <a href=
              "#prod-SequenceType">SequenceType</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-CastableExpr" name=
              "prod-CastableExpr"></a>[26]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-CastableExpr">CastableExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-CastExpr">CastExpr</a> (
              &lt;"castable" "as"&gt; <a href=
              "#prod-SingleType">SingleType</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-CastExpr" name=
              "prod-CastExpr"></a>[27]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-CastExpr">CastExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-ComparisonExpr">ComparisonExpr</a> (
              &lt;"cast" "as"&gt; <a href=
              "#prod-SingleType">SingleType</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ComparisonExpr" name=
              "prod-ComparisonExpr"></a>[28]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ComparisonExpr">ComparisonExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-RangeExpr">RangeExpr</a> (
              (<a href="#prod-ValueComp">ValueComp</a><br />
              | <a href="#prod-GeneralComp">GeneralComp</a><br />
              | <a href="#prod-NodeComp">NodeComp</a><br />
              | <a href="#prod-OrderComp">OrderComp</a>) <a href=
              "#prod-RangeExpr">RangeExpr</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-RangeExpr" name=
              "prod-RangeExpr"></a>[29]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-RangeExpr">RangeExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-AdditiveExpr">AdditiveExpr</a> ( "to" <a href=
              "#prod-AdditiveExpr">AdditiveExpr</a> )?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AdditiveExpr" name=
              "prod-AdditiveExpr"></a>[30]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AdditiveExpr">AdditiveExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-MultiplicativeExpr">MultiplicativeExpr</a> (
              ("+" | "-") <a href=
              "#prod-MultiplicativeExpr">MultiplicativeExpr</a>
              )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-MultiplicativeExpr" name=
              "prod-MultiplicativeExpr"></a>[31]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-MultiplicativeExpr">MultiplicativeExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-UnaryExpr">UnaryExpr</a> (
              ("*" | "div" | "idiv" | "mod") <a href=
              "#prod-UnaryExpr">UnaryExpr</a> )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-UnaryExpr" name=
              "prod-UnaryExpr"></a>[32]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-UnaryExpr">UnaryExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("-" | "+")* <a href=
              "#prod-UnionExpr">UnionExpr</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-UnionExpr" name=
              "prod-UnionExpr"></a>[33]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-UnionExpr">UnionExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-IntersectExceptExpr">IntersectExceptExpr</a> (
              ("union" | "|") <a href=
              "#prod-IntersectExceptExpr">IntersectExceptExpr</a>
              )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-IntersectExceptExpr" name=
              "prod-IntersectExceptExpr"></a>[34]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-IntersectExceptExpr">IntersectExceptExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-ValueExpr">ValueExpr</a> (
              ("intersect" | "except") <a href=
              "#prod-ValueExpr">ValueExpr</a> )*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ValueExpr" name=
              "prod-ValueExpr"></a>[35]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ValueExpr">ValueExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-PathExpr">PathExpr</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-PathExpr" name=
              "prod-PathExpr"></a>[36]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-PathExpr">PathExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("/" <a href=
              "#prod-RelativePathExpr">RelativePathExpr</a>?)<br />
              | ("//" <a href=
              "#prod-RelativePathExpr">RelativePathExpr</a>)<br />
              | <a href=
              "#prod-RelativePathExpr">RelativePathExpr</a></code></td>

              <td><i>/* <a href=
              "#parse-note-leading-lone-slash">gn:
              leading-lone-slash</a> */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-RelativePathExpr" name=
              "prod-RelativePathExpr"></a>[37]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-RelativePathExpr">RelativePathExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-StepExpr">StepExpr</a> (("/"
              | "//") <a href=
              "#prod-StepExpr">StepExpr</a>)*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-StepExpr" name=
              "prod-StepExpr"></a>[38]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-StepExpr">StepExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-AxisStep">AxisStep</a> |
              <a href="#prod-FilterStep">FilterStep</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AxisStep" name=
              "prod-AxisStep"></a>[39]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AxisStep">AxisStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(<a href=
              "#prod-ForwardStep">ForwardStep</a> | <a href=
              "#prod-ReverseStep">ReverseStep</a>) <a href=
              "#prod-Predicates">Predicates</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-FilterStep" name=
              "prod-FilterStep"></a>[40]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-FilterStep">FilterStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-PrimaryExpr">PrimaryExpr</a>
              <a href="#prod-Predicates">Predicates</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ContextItemExpr" name=
              "prod-ContextItemExpr"></a>[41]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ContextItemExpr">ContextItemExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"."</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-PrimaryExpr" name=
              "prod-PrimaryExpr"></a>[42]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-PrimaryExpr">PrimaryExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-Literal">Literal</a> |
              <a href="#prod-FunctionCall">FunctionCall</a> |
              <a href="#prod-ContextItemExpr">ContextItemExpr</a> |
              ("$" <a href="#prod-VarName">VarName</a>) | <a href=
              "#prod-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Predicates" name=
              "prod-Predicates"></a>[43]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-Predicates">Predicates</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>("[" <a href="#prod-Expr">Expr</a>
              "]")*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-GeneralComp" name=
              "prod-GeneralComp"></a>[44]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-GeneralComp">GeneralComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
              "&gt;="</code></td>

              <td><i>/* <a href="#parse-note-lt">gn: lt</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ValueComp" name=
              "prod-ValueComp"></a>[45]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ValueComp">ValueComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"eq" | "ne" | "lt" | "le" | "gt" |
              "ge"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NodeComp" name=
              "prod-NodeComp"></a>[46]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-NodeComp">NodeComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"is" | "isnot"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-OrderComp" name=
              "prod-OrderComp"></a>[47]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-OrderComp">OrderComp</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"&lt;&lt;" | "&gt;&gt;"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ForwardStep" name=
              "prod-ForwardStep"></a>[48]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ForwardStep">ForwardStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(<a href=
              "#prod-ForwardAxis">ForwardAxis</a> <a href=
              "#prod-NodeTest">NodeTest</a>) | <a href=
              "#prod-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ReverseStep" name=
              "prod-ReverseStep"></a>[49]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ReverseStep">ReverseStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(<a href=
              "#prod-ReverseAxis">ReverseAxis</a> <a href=
              "#prod-NodeTest">NodeTest</a>) | <a href=
              "#prod-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AbbrevForwardStep" name=
              "prod-AbbrevForwardStep"></a>[50]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AbbrevForwardStep">AbbrevForwardStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"@"? <a href=
              "#prod-NodeTest">NodeTest</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AbbrevReverseStep" name=
              "prod-AbbrevReverseStep"></a>[51]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AbbrevReverseStep">AbbrevReverseStep</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>".."</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ForwardAxis" name=
              "prod-ForwardAxis"></a>[52]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ForwardAxis">ForwardAxis</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"child" "::"&gt;<br />
              | &lt;"descendant" "::"&gt;<br />
              | &lt;"attribute" "::"&gt;<br />
              | &lt;"self" "::"&gt;<br />
              | &lt;"descendant-or-self" "::"&gt;<br />
              | &lt;"following-sibling" "::"&gt;<br />
              | &lt;"following" "::"&gt;<br />
              | &lt;"namespace" "::"&gt;</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ReverseAxis" name=
              "prod-ReverseAxis"></a>[53]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ReverseAxis">ReverseAxis</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"parent" "::"&gt;<br />
              | &lt;"ancestor" "::"&gt;<br />
              | &lt;"preceding-sibling" "::"&gt;<br />
              | &lt;"preceding" "::"&gt;<br />
              | &lt;"ancestor-or-self" "::"&gt;</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NodeTest" name=
              "prod-NodeTest"></a>[54]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-NodeTest">NodeTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-KindTest">KindTest</a> |
              <a href="#prod-NameTest">NameTest</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NameTest" name=
              "prod-NameTest"></a>[55]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-NameTest">NameTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a> | <a href=
              "#prod-Wildcard">Wildcard</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Wildcard" name=
              "prod-Wildcard"></a>[56]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-Wildcard">Wildcard</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"*"<br />
              | &lt;<a href="#prod-NCName">NCName</a> ":"
              "*"&gt;<br />
              | &lt;"*" ":" <a href=
              "#prod-NCName">NCName</a>&gt;</code></td>

              <td><i>/* <a href="#ws-explicit">ws: explicit</a>
              */</i></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-Literal" name=
              "prod-Literal"></a>[57]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-Literal">Literal</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-NumericLiteral">NumericLiteral</a> | <a href=
              "#prod-StringLiteral">StringLiteral</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NumericLiteral" name=
              "prod-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-NumericLiteral">NumericLiteral</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-IntegerLiteral">IntegerLiteral</a> | <a href=
              "#prod-DecimalLiteral">DecimalLiteral</a> | <a href=
              "#prod-DoubleLiteral">DoubleLiteral</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ParenthesizedExpr" name=
              "prod-ParenthesizedExpr"></a>[59]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ParenthesizedExpr">ParenthesizedExpr</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"(" <a href="#prod-Expr">Expr</a>?
              ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-FunctionCall" name=
              "prod-FunctionCall"></a>[60]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-FunctionCall">FunctionCall</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;<a href="#prod-QName">QName</a> "("&gt;
              (<a href="#prod-ExprSingle">ExprSingle</a> (","
              <a href="#prod-ExprSingle">ExprSingle</a>)*)?
              ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SingleType" name=
              "prod-SingleType"></a>[61]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SingleType">SingleType</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-AtomicType">AtomicType</a>
              "?"?</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SequenceType" name=
              "prod-SequenceType"></a>[62]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SequenceType">SequenceType</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>(<a href="#prod-ItemType">ItemType</a>
              <a href=
              "#prod-OccurrenceIndicator">OccurrenceIndicator</a>?)<br />

              | &lt;"empty" "(" ")"&gt;</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AtomicType" name=
              "prod-AtomicType"></a>[63]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AtomicType">AtomicType</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ItemType" name=
              "prod-ItemType"></a>[64]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ItemType">ItemType</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-AtomicType">AtomicType</a> |
              <a href="#prod-KindTest">KindTest</a> | &lt;"item"
              "(" ")"&gt;</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-KindTest" name=
              "prod-KindTest"></a>[65]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-KindTest">KindTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href=
              "#prod-DocumentTest">DocumentTest</a><br />
              | <a href="#prod-ElementTest">ElementTest</a><br />
              | <a href=
              "#prod-AttributeTest">AttributeTest</a><br />
              | <a href="#prod-PITest">PITest</a><br />
              | <a href="#prod-CommentTest">CommentTest</a><br />
              | <a href="#prod-TextTest">TextTest</a><br />
              | <a href=
              "#prod-AnyKindTest">AnyKindTest</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-ElementTest" name=
              "prod-ElementTest"></a>[66]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-ElementTest">ElementTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"element" "("&gt; ((<a href=
              "#prod-SchemaContextPath">SchemaContextPath</a>
              <a href="#prod-LocalName">LocalName</a>)<br />
              | (<a href="#prod-NodeName">NodeName</a> (","
              <a href="#prod-TypeName">TypeName</a>
              "nillable"?)?))? ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AttributeTest" name=
              "prod-AttributeTest"></a>[67]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AttributeTest">AttributeTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"attribute" "("&gt; ((<a href=
              "#prod-SchemaContextPath">SchemaContextPath</a> "@"
              <a href="#prod-LocalName">LocalName</a>)<br />
              | ("@" <a href="#prod-NodeName">NodeName</a> (","
              <a href="#prod-TypeName">TypeName</a>)?))?
              ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-PITest" name=
              "prod-PITest"></a>[68]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-PITest">PITest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"processing-instruction" "("&gt;
              (<a href="#prod-NCName">NCName</a> | <a href=
              "#prod-StringLiteral">StringLiteral</a>)?
              ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-DocumentTest" name=
              "prod-DocumentTest"></a>[69]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-DocumentTest">DocumentTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"document-node" "("&gt; <a href=
              "#prod-ElementTest">ElementTest</a>? ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-CommentTest" name=
              "prod-CommentTest"></a>[70]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-CommentTest">CommentTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"comment" "("&gt; ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-TextTest" name=
              "prod-TextTest"></a>[71]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-TextTest">TextTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"text" "("&gt; ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-AnyKindTest" name=
              "prod-AnyKindTest"></a>[72]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-AnyKindTest">AnyKindTest</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;"node" "("&gt; ")"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-SchemaContextPath" name=
              "prod-SchemaContextPath"></a>[73]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-SchemaContextPath">SchemaContextPath</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>&lt;<a href=
              "#prod-SchemaGlobalContext">SchemaGlobalContext</a>
              "/"&gt; &lt;<a href=
              "#prod-SchemaContextStep">SchemaContextStep</a>
              "/"&gt;*</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-LocalName" name=
              "prod-LocalName"></a>[74]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-LocalName">LocalName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a></code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-NodeName" name=
              "prod-NodeName"></a>[75]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-NodeName">NodeName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a> |
              "*"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-TypeName" name=
              "prod-TypeName"></a>[76]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-TypeName">TypeName</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code><a href="#prod-QName">QName</a> |
              "*"</code></td>
            </tr>
          </tbody>

          <tbody>
            <tr valign="baseline">
              <td><a id="prod-OccurrenceIndicator" name=
              "prod-OccurrenceIndicator"></a>[77]&#160;&#160;&#160;</td>

              <td><code><a href=
              "#doc-OccurrenceIndicator">OccurrenceIndicator</a></code></td>

              <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

              <td><code>"?" | "*" | "+"</code></td>
            </tr>
          </tbody>
        </table>

        <div class="div3">
          <h4><a id="notes-on-parsing" name=
          "notes-on-parsing"></a>A.1.1 Grammar Notes</h4>

          <p>This section contains general notes on the EBNF
          productions, which may be helpful in understanding how to
          create a parser based on this EBNF, how to read the EBNF,
          and generally call out issues with the syntax. The notes
          below are referenced from the right side of the
          production, with the notation: <em>/* gn: &lt;id&gt;
          */</em>.</p>

          <dl>
            <dt class="label"><a id="parse-note-parens" name=
            "parse-note-parens"></a>grammar-note: parens</dt>

            <dd>
              <p>A look-ahead of one character is required to
              distinguish function patterns from a QName followed
              by a comment. For example: <code>address (: this may
              be empty :)</code> may be mistaken for a call to a
              function named "address" unless this lookahead is
              employed.</p>
            </dd>

            <dt class="label"><a id="parse-note-lt" name=
            "parse-note-lt"></a>grammar-note: lt</dt>

            <dd>
              <p>Token disambiguation of the overloaded "&lt;"
              pattern is defined in terms of positional <a href=
              "#lexical-structure">lexical states</a>. The "&lt;"
              comparison operator can not occur in the same places
              as a "&lt;" tag open pattern. The "&lt;" comparison
              operator can only occur in the <a href=
              "#OPERATOR">OPERATOR</a> state and the "&lt;" tag
              open pattern can only occur in the <a href=
              "#DEFAULT">DEFAULT</a> <span class=
              "xpath"><span class="xpath">state.</span></span>
              (These states are only a specification tool, and do
              not mandate an implementation strategy for this same
              effect.)</p>
            </dd>

            <dt class="label"><a id="parse-note-validate" name=
            "parse-note-validate"></a>grammar-note: validate</dt>

            <dd>
              <p>The ValidateExpr in the exposition, which does not
              use the "&lt; ... &gt;" token grouping, presents the
              production in a much simplified, and understandable,
              form. The ValidateExpr presented in the appendix is
              technically correct, but structurally hard to
              understand, because of limitations of the "&lt; ...
              &gt;" token grouping.</p>
            </dd>

            <dt class="label"><a id="parse-note-leading-lone-slash"
            name="parse-note-leading-lone-slash"></a>grammar-note:
            leading-lone-slash</dt>

            <dd>
              <p>The "/" presents an issue because it occurs both
              in a leading position and an operator position in
              expressions. Thus, expressions such as "/ * 5" can
              easily be confused with the path expression "/*".
              Therefore, a stand-alone slash, in a leading
              position, that is followed by an operator, will need
              to be parenthesized in order to stand alone, as in
              "(/) * 5". "5 * /", on the other hand, is fine.</p>
            </dd>

            <dt class="label"><a id="parse-note-comments" name=
            "parse-note-comments"></a>grammar-note: comments</dt>

            <dd>
              <p>Expression comments are allowed inside expressions
              everywhere that ignorable white space is allowed.</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="div2">
        <h3><a id="lexical-structure" name=
        "lexical-structure"></a>A.2 Lexical structure</h3>

        <p>Legal characters are those allowed in the <a href=
        "#XML">[XML]</a> recommendation.</p>

        <p>When patterns are simple string matches, the strings are
        embedded directly into the EBNF. In other cases, named
        terminals are used.</p>

        <p>It is up to an implementation to decide on the exact
        tokenization strategy, which may be different depending on
        the parser construction. In the EBNF, the notation "&lt;
        ... &gt;" is used to indicate a grouping of terminals that
        together may help disambiguate the individual symbols.</p>

        <p>This document uses <b>lexical states</b> to assist with
        terminal symbol recognition. The states specify lexical
        constraints and transitions based on grammatical
        positioning. The rules for calculating these states are
        given in the <a href="#id-lexical-states"><b>A.2.2 Lexical
        Rules</b></a> section. The specification of these states in
        this document does not imply any tokenization strategy on
        the part of implementations.</p>

        <p>When tokenizing, the longest possible match that is
        valid in the current lexical state is preferred .</p>

        <p>All keywords are case sensitive.</p>

        <div class="div3">
          <h4><a id="whitespace-rules" name=
          "whitespace-rules"></a>A.2.1 White Space Rules</h4>

          <p>For readability, <span class="xpath"><span class=
          "xpath">white space</span></span> may be used in most
          expressions even though not explicitly notated in the
          EBNF. White space may be freely added between terminals,
          except a few cases where white space is needed to
          disambiguate the token. For instance, in XML, "-" is a
          valid character in an element or attribute name. When
          used as an operator after the characters of a name, it
          must be separated from the name, e.g. by using white
          space or parentheses.</p>

          <p>Special white space notation is specified with the
          EBNF productions, when it is different from the default
          rules, as follows.</p>

          <dl>
            <dt class="label"><a id="ws-explicit" name=
            "ws-explicit"></a>Whitespace: explicit</dt>

            <dd>
              <p>"ws: explicit" means that the EBNF notation must
              explicitly notate where white space is allowed,
              otherwise white space may not be freely used.</p>
            </dd>

            <dt class="label"><a id="ws-significant" name=
            "ws-significant"></a>Whitespace: significant</dt>

            <dd>
              <p>"ws: significant" means that white space is
              significant as value content.</p>
            </dd>
          </dl>
        </div>

        <div class="div3">
          <h4><a id="id-lexical-states" name=
          "id-lexical-states"></a>A.2.2 Lexical Rules</h4>

          <p>The lexical contexts and transitions between lexical
          contexts is described in terms of a series of states and
          transitions between those states.</p>

          <p>The tables below define the complete lexical rules for
          XPath. Each table corresponds to a lexical state and
          shows that the tokens listed are recognized when in that
          state. When a given token is recognized in the given
          state, the transition to the next state is given. In some
          cases, a transition will "push" the current state or a
          specific state onto an abstract stack, and will later
          restore that state by a "pop" when another lexical event
          occurs.</p>

          <p>The lexical states have, in many cases, close
          connection to the parser productions. However, just
          because a token is recognized in a certain lexical state,
          does not mean it will be legal in the current EBNF
          production.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>There is no requirement for a lexer/parser to be
            implemented in terms of lexical states... these are
            only a declarative way to specify the behavior. The
            only requirement is to produce results that are
            consistent with the results of these tables.</p>
          </div>

          <dl>
            <dt class="label"><a id="DEFAULT" name=
            "DEFAULT"></a>The DEFAULT State</dt>

            <dd>
              <p>This state is for patterns that occur at the
              beginning of an expression or subexpression.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-DecimalLiteral">DecimalLiteral</a>,
                    "..", ".", <a href=
                    "#prod-DoubleLiteral">DoubleLiteral</a>,
                    <a href=
                    "#prod-IntegerLiteral">IntegerLiteral</a>,
                    &lt;<a href="#prod-NCName">NCName</a> ":"
                    "*"&gt;, <a href="#prod-QName">QName</a>, "]",
                    ")", &lt;"*" ":" <a href=
                    "#prod-NCName">NCName</a>&gt;, "*", <a href=
                    "#prod-StringLiteral">StringLiteral</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OPERATOR</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"$", &lt;"for"
                    "$"&gt;, &lt;"some" "$"&gt;, &lt;"every"
                    "$"&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            VARNAME</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">&lt;"element"
                    "("&gt;, &lt;"attribute" "("&gt;, &lt;"comment"
                    "("&gt;, &lt;"text" "("&gt;, &lt;"node"
                    "("&gt;, &lt;"document-node" "("&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTEST</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState(OPERATOR)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">
                    &lt;"processing-instruction" "("&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTESTFORPI</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState(OPERATOR)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"(:"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            EXPR_COMMENT</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"@",
                    &lt;"ancestor-or-self" "::"&gt;, &lt;"ancestor"
                    "::"&gt;, &lt;"attribute" "::"&gt;, &lt;"child"
                    "::"&gt;, &lt;"descendant-or-self" "::"&gt;,
                    &lt;"descendant" "::"&gt;,
                    &lt;"following-sibling" "::"&gt;,
                    &lt;"following" "::"&gt;, &lt;"namespace"
                    "::"&gt;, &lt;"parent" "::"&gt;,
                    &lt;"preceding-sibling" "::"&gt;,
                    &lt;"preceding" "::"&gt;, &lt;"self" "::"&gt;,
                    ",", &lt;"if" "("&gt;, "[", "(", "-", "+",
                    &lt;<a href="#prod-QName">QName</a> "("&gt;,
                    "//", "/"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="OPERATOR" name=
            "OPERATOR"></a>The OPERATOR State</dt>

            <dd>
              <p>This state is for patterns that are defined for
              operators.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">"and", ",", "div",
                    "else", "=", "except", "eq", "ge", "gt", "le",
                    "lt", "ne", "&gt;=", "&gt;&gt;", "&gt;",
                    "idiv", "intersect", "in", "isnot", "is", "[",
                    "(", "&lt;=", "&lt;&lt;", "&lt;", "-", "mod",
                    "*", "!=", "or", "+", "return", "satisfies",
                    "//", "/", "then", "to", "union", "|",
                    SchemaModeForDeclareValidate</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            DEFAULT</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">&lt;"instance"
                    "of"&gt;, &lt;"castable" "as"&gt;, &lt;"cast"
                    "as"&gt;, &lt;"treat" "as"&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            ITEMTYPE</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"$", &lt;"for"
                    "$"&gt;, &lt;"some" "$"&gt;, &lt;"every"
                    "$"&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            VARNAME</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"(:"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            EXPR_COMMENT</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"]", <a href=
                    "#prod-IntegerLiteral">IntegerLiteral</a>,
                    <a href=
                    "#prod-DecimalLiteral">DecimalLiteral</a>,
                    <a href=
                    "#prod-DoubleLiteral">DoubleLiteral</a>, ")",
                    <a href=
                    "#prod-StringLiteral">StringLiteral</a>,
                    <a href="#prod-QName">QName</a>, &lt;<a href=
                    "#prod-NCName">NCName</a> ":" "*"&gt;, &lt;"*"
                    ":" <a href="#prod-NCName">NCName</a>&gt;, ".",
                    ".."</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="ITEMTYPE" name=
            "ITEMTYPE"></a>The ITEMTYPE State</dt>

            <dd>
              <p>This state distinguishes tokens that can occur
              only inside the ItemType production.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">"$"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            VARNAME</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">&lt;"empty" "("
                    ")"&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OPERATOR</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"(:"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            EXPR_COMMENT</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">&lt;"element"
                    "("&gt;, &lt;"attribute" "("&gt;, &lt;"comment"
                    "("&gt;, &lt;"text" "("&gt;, &lt;"node"
                    "("&gt;, &lt;"document-node" "("&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTEST</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState(OCCURRENCEINDICATOR)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">
                    &lt;"processing-instruction" "("&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTESTFORPI</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState(OPERATOR)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-QName">QName</a>, &lt;"item" "("
                    ")"&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OCCURRENCEINDICATOR</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="KINDTEST" name=
            "KINDTEST"></a>The KINDTEST State</dt>

            <dd>
              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">&lt;<a href=
                    "#prod-SchemaGlobalContext">SchemaGlobalContext</a>
                    "/"&gt;, <a href=
                    "#prod-SchemaGlobalTypeName">SchemaGlobalTypeName</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            SCHEMACONTEXTSTEP</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">")"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            popState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"*", <a href=
                    "#prod-QName">QName</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            CLOSEKINDTEST</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">&lt;"element"
                    "("&gt;</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTEST</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState(KINDTEST)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"@", <a href=
                    "#prod-StringLiteral">StringLiteral</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="KINDTESTFORPI" name=
            "KINDTESTFORPI"></a>The KINDTESTFORPI State</dt>

            <dd>
              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">")"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            popState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-NCName">NCName</a>, <a href=
                    "#prod-StringLiteral">StringLiteral</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="CLOSEKINDTEST" name=
            "CLOSEKINDTEST"></a>The CLOSEKINDTEST State</dt>

            <dd>
              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">")"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            popState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">","</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            KINDTEST</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"nillable"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="OCCURRENCEINDICATOR" name=
            "OCCURRENCEINDICATOR"></a>The OCCURRENCEINDICATOR
            State</dt>

            <dd>
              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">
                    NotOccurrenceIndicator</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OPERATOR</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            input_stream.backup(1)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"?", "*", "+"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OPERATOR</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="SCHEMACONTEXTSTEP" name=
            "SCHEMACONTEXTSTEP"></a>The SCHEMACONTEXTSTEP
            State</dt>

            <dd>
              <p>This state distinguishes the SchemaContextStep
              from the SchemaGlobalContext.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">&lt;<a href=
                    "#prod-SchemaContextStep">SchemaContextStep</a>
                    "/"&gt;, "@"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-QName">QName</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            CLOSEKINDTEST</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="VARNAME" name=
            "VARNAME"></a>The VARNAME State</dt>

            <dd>
              <p>This state differentiates variable names from
              qualified names. This allows only the pattern of a
              QName to be recognized when otherwise ambiguities
              could occur.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-VarName">VarName</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            OPERATOR</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"(:"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            EXPR_COMMENT</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>

            <dt class="label"><a id="EXPR_COMMENT" name=
            "EXPR_COMMENT"></a>The EXPR_COMMENT State</dt>

            <dd>
              <p>The "(:" token marks the beginning of an
              expression Comment, and the ":)" token marks the end.
              This allows no special interpretation of other
              characters in this state.</p>

              <table summary="Transition table" border="1">
                <thead>
                  <tr>
                    <th rowspan="1" colspan="1">Pattern</th>

                    <th rowspan="1" colspan="1">Transition To
                    State</th>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td rowspan="1" colspan="1">":)"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            popState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1">"(:"</td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">
                            EXPR_COMMENT</td>
                          </tr>

                          <tr>
                            <td rowspan="1" colspan="1">
                            pushState()</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                  <tr>
                    <td rowspan="1" colspan="1"><a href=
                    "#prod-ExprCommentContent">ExprCommentContent</a></td>

                    <td rowspan="1" colspan="1">
                      <table summary="Transition table">
                        <tbody>
                          <tr>
                            <td rowspan="1" colspan="1">(maintain
                            state)</td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table><br />
              <br />
            </dd>
          </dl>
        </div>
      </div>

      <div class="div2">
        <h3><a id="N12C92" name="N12C92"></a>A.3 Reserved Function
        Names</h3>

        <p>The following is a list of names that must not be used
        as user function names, in an unprefixed form, because
        these functions could be confused with expression
        syntax.</p>

        <ul>
          <li>
            <p><code>attribute</code></p>
          </li>

          <li>
            <p><code>comment</code></p>
          </li>

          <li>
            <p><code>document-node</code></p>
          </li>

          <li>
            <p><code>element</code></p>
          </li>

          <li>
            <p><code>empty</code></p>
          </li>

          <li>
            <p><code>if</code></p>
          </li>

          <li>
            <p><code>item</code></p>
          </li>

          <li>
            <p><code>node</code></p>
          </li>

          <li>
            <p><code>processing-instruction</code></p>
          </li>

          <li>
            <p><code>text</code></p>
          </li>

          <li>
            <p><code>type</code></p>
          </li>
        </ul>
      </div>

      <div class="div2">
        <h3><a id="id-precedence-order" name=
        "id-precedence-order"></a>A.4 Precedence Order</h3>

        <p>The grammar defines built-in precedence, which is
        summarised here. In the cases where a number of operators
        are a choice at the same production level, the expressions
        are always evaluated from left to right. The operators in
        order of increasing precedence are:</p>

        <table border="1">
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">1</td>

              <td rowspan="1" colspan="1">(comma)</td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">2</td>

              <td rowspan="1" colspan="1"><span class=
              "xpath"><span class="xpath"><a href=
              "#doc-ForExpr">ForExpr</a>,</span></span> <a href=
              "#doc-QuantifiedExpr">some, every</a>, <a href=
              "#doc-IfExpr">IfExpr</a>, <a href=
              "#doc-OrExpr">or</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">3</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-AndExpr">and</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">4</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-InstanceofExpr">instance of</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">5</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-TreatExpr">treat</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">6</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-CastableExpr">castable</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">7</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-CastExpr">cast</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">8</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-ValueComp">eq, ne, lt, le, gt, ge</a>, <a href=
              "#doc-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
              &gt;=</a>, <a href="#doc-NodeComp">is, isnot</a>,
              <a href="#doc-OrderComp">&lt;&lt;, &gt;&gt;</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">9</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-RangeExpr">to</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">10</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-AdditiveExpr">+, -</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">11</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-MultiplicativeExpr">*, div, idiv, mod</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">12</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-UnaryExpr">unary -, unary +</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">13</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-UnionExpr">union, |</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">14</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-IntersectExceptExpr">intersect, except</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">15</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-PathExpr">/, //</a></td>
            </tr>

            <tr>
              <td rowspan="1" colspan="1">16</td>

              <td rowspan="1" colspan="1"><a href=
              "#doc-Predicates">[ ]</a></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="div1">
      <h2><a id="N12D96" name="N12D96"></a>B Type Promotion and
      Operator Mapping</h2>

      <div class="div2">
        <h3><a id="promotion" name="promotion"></a>B.1 Type
        Promotion</h3>

        <p>Under certain circumstances, an atomic value can be
        promoted from one type to another. <b>Type promotion</b> is
        used in function calls (see <a href=
        "#id-function-calls"><b>3.1.5 Function Calls</b></a>) and
        in processing of operators that accept <b>numeric</b>
        operands (listed in the tables below). The following type
        promotions are permitted:</p>

        <ol class="enumar">
          <li>
            <p>A value of type <code>xs:float</code> (or any type
            derived by restriction from <code>xs:float</code>) can
            be promoted to the type <code>xs:double</code>. The
            result is the <code>xs:double</code> value that is the
            same as the original value. This kind of promotion may
            cause loss of precision.</p>
          </li>

          <li>
            <p>A value of type <code>xs:decimal</code> (or any type
            derived by restriction from <code>xs:decimal</code>)
            can be promoted to either of the types
            <code>xs:float</code> or <code>xs:double</code>. The
            result is the value of the target type that is closest
            to the original value.</p>
          </li>
        </ol>

        <p>Note that <b>promotion</b> is different from <b>subtype
        substitution</b>. For example:</p>

        <ul>
          <li>
            <p>A function that expects a parameter <code>$p</code>
            of type <code>xs:float</code> can be invoked with a
            value of type <code>xs:decimal</code>. This is an
            example of <b>promotion</b>. The value is actually
            converted to the expected type. Within the body of the
            function, <code>$p instance of xs:decimal</code>
            returns <code>false</code>.</p>
          </li>

          <li>
            <p>A function that expects a parameter <code>$p</code>
            of type <code>xs:decimal</code> can be invoked with a
            value of type <code>xs:integer</code>. This is an
            example of <b>subtype substitution</b>. The value
            retains its original type. Within the body of the
            function, <code>$p instance of xs:integer</code>
            returns <code>true</code>.</p>
          </li>
        </ul>
      </div>

      <div class="div2">
        <h3><a id="mapping" name="mapping"></a>B.2 Operator
        Mapping</h3>

        <p>The tables in this section list the combinations of
        types for which the various operators of XPath are defined.
        For each valid combination of types, the table indicates
        the function(s) that are used to implement the operator and
        the type of the result. Definitions of the functions can be
        found in <a href="#FunctionsAndOperators">[XQuery 1.0 and
        XPath 2.0 Functions and Operators]</a>. Note that in some
        cases the function does not implement the full semantics of
        the given operator. For a complete description of each
        operator (including its behavior for empty sequences or
        sequences of length greater than one), see the descriptive
        material in the main part of this document.</p>

        <p>Operators listed in the tables may be validly applied to
        operands whose types are derived by restriction from the
        listed operand types. For example, a table entry indicates
        that the <code>gt</code> operator may be applied to two
        <code>xs:date</code> operands, returning
        <code>xs:boolean</code>. Therefore, the <code>gt</code>
        operator may also be applied to two (possibly different)
        subtypes of <code>xs:date</code>, also returning
        <code>xs:boolean</code>.</p>

        <p>In the operator tables, the term <b>numeric</b> refers
        to the types <code>xs:integer</code>,
        <code>xs:decimal</code>, <code>xs:float</code>, and
        <code>xs:double</code>. An operator whose operands and
        result are designated as <b>numeric</b> might be thought of
        as representing four operators, one for each of the numeric
        types. For example, the numeric <code>+</code> operator
        might be thought of as representing the following four
        operators:</p>

        <table width="80%" border="1" summary="Operators">
          <tbody>
            <tr>
              <td align="center" rowspan="1" colspan="1">
              Operator</td>

              <td align="center" rowspan="1" colspan="1">First
              operand type</td>

              <td align="center" rowspan="1" colspan="1">Second
              operand type</td>

              <td align="center" rowspan="1" colspan="1">Result
              type</td>
            </tr>

            <tr>
              <td align="center" rowspan="1" colspan="1">
              <code>+</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:integer</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:integer</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:integer</code></td>
            </tr>

            <tr>
              <td align="center" rowspan="1" colspan="1">
              <code>+</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:decimal</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:decimal</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:decimal</code></td>
            </tr>

            <tr>
              <td align="center" rowspan="1" colspan="1">
              <code>+</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:float</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:float</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:float</code></td>
            </tr>

            <tr>
              <td align="center" rowspan="1" colspan="1">
              <code>+</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:double</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:double</code></td>

              <td align="center" rowspan="1" colspan="1">
              <code>xs:double</code></td>
            </tr>
          </tbody>
        </table>

        <p>A numeric operator accepts operands of the four numeric
        types and any type that is derived by restriction from one
        of the four numeric types. If the result type of an
        operator is listed as numeric, it means "the first numeric
        type, in promotion order, into which all operands can be
        converted by subtype substitution and promotion." As an
        example, suppose that the type <code>hatsize</code> is
        derived from <code>xs:integer</code> and the type
        <code>shoesize</code> is derived from
        <code>xs:float</code>. Then if the <code>+</code> operator
        is invoked with operands of type <code>hatsize</code> and
        <code>shoesize</code>, it returns a result of type
        <code>xs:float</code>. Similarly, if <code>+</code> is
        invoked with two operands of type <code>hatsize</code> it
        returns a result of type <code>xs:integer</code>.</p>

        <p>In the following tables, the term <b>Gregorian</b>
        refers to the types <code>xs:gYearMonth</code>,
        <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
        <code>xs:gDay</code>, and <code>xs:gMonth</code>. For
        binary operators that accept two Gregorian-type operands,
        both operands must have the same type (for example, if one
        operand is of type <code>xs:gDay</code>, the other operand
        must be of type <code>xs:gDay</code>.)</p>

        <div class="small">
          <table border="1" summary="Binary operators" class=
          "small">
            <caption>
              Binary Operators
            </caption>

            <tbody>
              <tr>
                <th rowspan="1" colspan="1">Operator</th>

                <th rowspan="1" colspan="1">Type(A)</th>

                <th rowspan="1" colspan="1">Type(B)</th>

                <th rowspan="1" colspan="1">Function</th>

                <th rowspan="1" colspan="1">Result type</th>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-add(A,
                B)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:add-yearMonthDuration-to-date(A, B)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                op:add-yearMonthDuration-to-date(B, A)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-date(A, B)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-date(B, A)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-time(A, B)</td>

                <td rowspan="1" colspan="1">xs:time</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-time(B, A)</td>

                <td rowspan="1" colspan="1">xs:time</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:add-yearMonthDuration-to-dateTime(A, B)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                op:add-yearMonthDuration-to-dateTime(B, A)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-dateTime(A, B)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDuration-to-dateTime(B, A)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:add-yearMonthDurations(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A + B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:add-dayTimeDurations(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-subtract(A,
                B)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">op:subtract-dates(A,
                B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-yearMonthDuration-from-date(A, B)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-dayTimeDuration-from-date(A, B)</td>

                <td rowspan="1" colspan="1">xs:date</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">op:subtract-times(A,
                B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-dayTimeDuration-from-time(A, B)</td>

                <td rowspan="1" colspan="1">xs:time</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                fn:subtract-dateTimes-yielding-dayTimeDuration(A,
                B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-yearMonthDuration-from-dateTime(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">xs:datetime</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-dayTimeDuration-from-dateTime(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-yearMonthDurations(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A - B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:subtract-dayTimeDurations(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A * B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-multiply(A,
                B)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A * B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                op:multiply-yearMonthDuration(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A * B</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:multiply-yearMonthDuration(B, A)</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A * B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                op:multiply-dayTimeDuration(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A * B</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:multiply-dayTimeDuration(B, A)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A idiv B</td>

                <td rowspan="1" colspan="1">xs:integer</td>

                <td rowspan="1" colspan="1">xs:integer</td>

                <td rowspan="1" colspan="1">op:integer-div(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:integer</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A div B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-divide(A,
                B)</td>

                <td rowspan="1" colspan="1">numeric; but xs:decimal
                if both operands are xs:integer</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A div B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                op:divide-yearMonthDuration(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A div B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">xs:decimal</td>

                <td rowspan="1" colspan="1">
                op:divide-dayTimeDuration(A, B)</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A mod B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-mod(A,
                B)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">op:boolean-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                op:numeric-equal(fn:compare(A, B), 1)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">op:date-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">op:time-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">op:datetime-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:yearMonthDuration-equal(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:dayTimeDuration-equal(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">Gregorian</td>

                <td rowspan="1" colspan="1">Gregorian</td>

                <td rowspan="1" colspan="1">op:gYear-equal(A, B)
                etc.</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:hexBinary</td>

                <td rowspan="1" colspan="1">xs:hexBinary</td>

                <td rowspan="1" colspan="1">op:hex-binary-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:base64Binary</td>

                <td rowspan="1" colspan="1">xs:base64Binary</td>

                <td rowspan="1" colspan="1">
                op:base64-binary-equal(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:anyURI</td>

                <td rowspan="1" colspan="1">xs:anyURI</td>

                <td rowspan="1" colspan="1">op:anyURI-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:QName</td>

                <td rowspan="1" colspan="1">xs:QName</td>

                <td rowspan="1" colspan="1">op:QName-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A eq B</td>

                <td rowspan="1" colspan="1">xs:NOTATION</td>

                <td rowspan="1" colspan="1">xs:NOTATION</td>

                <td rowspan="1" colspan="1">op:NOTATION-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                fn:not(op:numeric-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">
                fn:not(op:boolean-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                fn:not(op:numeric-equal(fn:compare(A, B), 1))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">fn:not(op:date-equal(A,
                B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">fn:not(op:time-equal(A,
                B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">
                fn:not(op:datetime-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:yearMonthDuration-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:dayTimeDuration-equal(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">Gregorian</td>

                <td rowspan="1" colspan="1">Gregorian</td>

                <td rowspan="1" colspan="1">
                fn:not(op:gYear-equal(A, B)) etc.</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:hexBinary</td>

                <td rowspan="1" colspan="1">xs:hexBinary</td>

                <td rowspan="1" colspan="1">
                fn:not(op:hex-binary-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:base64Binary</td>

                <td rowspan="1" colspan="1">xs:base64Binary</td>

                <td rowspan="1" colspan="1">
                fn:not(op:base64-binary-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:anyURI</td>

                <td rowspan="1" colspan="1">xs:anyURI</td>

                <td rowspan="1" colspan="1">
                fn:not(op:anyURI-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:QName</td>

                <td rowspan="1" colspan="1">xs:QName</td>

                <td rowspan="1" colspan="1">
                fn:not(op:QName-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ne B</td>

                <td rowspan="1" colspan="1">xs:NOTATION</td>

                <td rowspan="1" colspan="1">xs:NOTATION</td>

                <td rowspan="1" colspan="1">
                fn:not(op:NOTATION-equal(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                op:numeric-greater-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">
                op:boolean-greater-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                op:numeric-greater-than(fn:compare(A, B), 0)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">op:date-greater-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">op:time-greater-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">
                op:datetime-greater-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:yearMonthDuration-greater-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A gt B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:dayTimeDuration-greater-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">op:numeric-less-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">xs:boolean</td>

                <td rowspan="1" colspan="1">op:boolean-less-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                op:numeric-less-than(fn:compare(A, B), 0)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">op:date-less-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">op:time-less-than(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">
                op:datetime-less-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                op:yearMonthDuration-less-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A lt B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                op:dayTimeDuration-less-than(A, B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                fn:not(op:numeric-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                op:numeric-greater-than(fn:compare(A, B), -1)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                fn:not(op:date-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">
                fn:not(op:time-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">
                fn:not(op:datetime-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:yearMonthDuration-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A ge B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:dayTimeDuration-less-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                fn:not(op:numeric-greater-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">xs:string</td>

                <td rowspan="1" colspan="1">
                op:numeric-less-than(fn:compare(A, B), 1)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">xs:date</td>

                <td rowspan="1" colspan="1">
                fn:not(op:date-greater-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">xs:time</td>

                <td rowspan="1" colspan="1">
                fn:not(op:time-greater-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">xs:dateTime</td>

                <td rowspan="1" colspan="1">
                fn:not(op:datetime-greater-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                xdt:yearMonthDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:yearMonthDuration-greater-than(A,
                B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A le B</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                xdt:dayTimeDuration</td>

                <td rowspan="1" colspan="1">
                fn:not(op:dayTimeDuration-greater-than(A, B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A is B</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">op:node-equal(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A isnot B</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">fn:not(op:node-equal(A,
                B))</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A &lt;&lt; B</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">op:node-before(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A &gt;&gt; B</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">node</td>

                <td rowspan="1" colspan="1">op:node-after(A,
                B)</td>

                <td rowspan="1" colspan="1">xs:boolean</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A union B</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">op:union(A, B)</td>

                <td rowspan="1" colspan="1">node*</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A | B</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">op:union(A, B)</td>

                <td rowspan="1" colspan="1">node*</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A intersect B</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">op:intersect(A, B)</td>

                <td rowspan="1" colspan="1">node*</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A except B</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">node*</td>

                <td rowspan="1" colspan="1">op:except(A, B)</td>

                <td rowspan="1" colspan="1">node*</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A to B</td>

                <td rowspan="1" colspan="1">xs:integer</td>

                <td rowspan="1" colspan="1">xs:integer</td>

                <td rowspan="1" colspan="1">op:to(A, B)</td>

                <td rowspan="1" colspan="1">xs:integer+</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">A , B</td>

                <td rowspan="1" colspan="1">item*</td>

                <td rowspan="1" colspan="1">item*</td>

                <td rowspan="1" colspan="1">op:concatenate(A,
                B)</td>

                <td rowspan="1" colspan="1">item*</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="small">
          <table border="1" summary="Unary operators" class=
          "small">
            <caption>
              Unary Operators
            </caption>

            <tbody>
              <tr>
                <th rowspan="1" colspan="1">Operator</th>

                <th rowspan="1" colspan="1">Operand type</th>

                <th rowspan="1" colspan="1">Function</th>

                <th rowspan="1" colspan="1">Result type</th>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">+ A</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                op:numeric-unary-plus(A)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>

              <tr>
                <td rowspan="1" colspan="1">- A</td>

                <td rowspan="1" colspan="1">numeric</td>

                <td rowspan="1" colspan="1">
                op:numeric-unary-minus(A)</td>

                <td rowspan="1" colspan="1">numeric</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="xpath">
      <div class="div1">
        <h2><a id="id-xp-context-components" name=
        "id-xp-context-components"></a>C Context Components</h2>

        <p>The tables in this section describe the scope (range of
        applicability) of the various components in the static
        context and dynamic context.</p>

        <div class="div2">
          <h3><a id="id-xp-static-context-components" name=
          "id-xp-static-context-components"></a>C.1 Static Context
          Components</h3>

          <p>The following table describes the components of the
          <b>static context</b>. For each component, "global"
          indicates that the value of the component applies
          throughout an XPath expression, whereas "lexical"
          indicates that the value of the component applies only
          within the subexpression in which it is defined.</p>

          <div class="small">
            <table width="60%" border="1" summary="Static Context"
            class="small">
              <caption>
                Static Context Components
              </caption>

              <tbody>
                <tr>
                  <th rowspan="1" colspan="1">Component</th>

                  <th rowspan="1" colspan="1">Scope</th>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">XPath 1.0
                  Compatability Mode</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope
                  namespaces</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Default element/type
                  namespace</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Default function
                  namespace</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope type
                  definitions</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope element
                  declarations</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope attribute
                  declarations</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope
                  variables</td>

                  <td rowspan="1" colspan="1">lexical;
                  for-expression can bind new variables</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope
                  functions</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">In-scope
                  collations</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Default
                  collation</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Base URI</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Statically-known
                  documents</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Statically-known
                  collections</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="div2">
          <h3><a id="id-xp-evaluation-context-components" name=
          "id-xp-evaluation-context-components"></a>C.2 Dynamic
          Context Components</h3>

          <p>The following table describes how values are assigned
          to the various components of the <b>dynamic context</b>.
          For each component, "global" indicates that the component
          is initialized by the external environment and its value
          remains constant throughout the XPath expression, whereas
          "dynamic" indicates that the component is initialized by
          the external environment but its value can be modified by
          the evaluation of subexpressions.</p>

          <div class="small">
            <table width="60%" border="1" summary="Static Context"
            class="small">
              <caption>
                Dynamic Context Components
              </caption>

              <tbody>
                <tr>
                  <th rowspan="1" colspan="1">Component</th>

                  <th rowspan="1" colspan="1">Scope</th>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Context item</td>

                  <td rowspan="1" colspan="1">dynamic; changes
                  during evaluation of path expressions and
                  predicates</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Context position</td>

                  <td rowspan="1" colspan="1">dynamic; changes
                  during evaluation of path expressions and
                  predicates</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Context size</td>

                  <td rowspan="1" colspan="1">dynamic; changes
                  during evaluation of path expressions and
                  predicates</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Dynamic
                  variables</td>

                  <td rowspan="1" colspan="1">dynamic;
                  for-expression can bind new variables</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Current date and
                  time</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Implicit
                  timezone</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Accessible
                  documents</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>

                <tr>
                  <td rowspan="1" colspan="1">Accessible
                  collections</td>

                  <td rowspan="1" colspan="1">global</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a id="id-references" name="id-references"></a>D
      References</h2>

      <div class="div2">
        <h3><a id="id-normative-references" name=
        "id-normative-references"></a>D.1 Normative References</h3>

        <dl>
          <dt class="label"><a id="FunctionsAndOperators" name=
          "FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0
          Functions and Operators</dt>

          <dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath
          2.0 Functions and Operators</em> W3C Working Draft, 2 May
          2003. See <a href=
          "http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a></dd>

          <dt class="label"><a id="XQueryFormalSemantics" name=
          "XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0
          Formal Semantics</dt>

          <dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath
          2.0 Formal Semantics</em>. W3C Working Draft, 22 Aug.
          2003. See <a href=
          "http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>

          <dt class="label"><a id="XMLSchema" name=
          "XMLSchema"></a>XML Schema</dt>

          <dd>World Wide Web Consortium. <em>XML Schema, Parts 0,
          1, and 2</em>. W3C Recommendation, 2 May 2001. See
          <a href=
          "http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/</a>,
          <a href=
          "http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a>,
          and <a href=
          "http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>.</dd>

          <dt class="label"><a id="datamodel" name=
          "datamodel"></a>XQuery 1.0 and XPath 2.0 Data Model</dt>

          <dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath
          2.0 Data Model</em>. W3C Working Draft, 2 May 2003. See
          <a href=
          "http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>

          <dt class="label"><a id="serialization" name=
          "serialization"></a>XSLT 2.0 and XQuery 1.0
          Serialization</dt>

          <dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery
          1.0 Serialization</em>. W3C Working Draft, 2 May 2003.
          See <a href=
          "http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>

          <dt class="label"><a id="XML" name="XML"></a>XML</dt>

          <dd>World Wide Web Consortium. <em>Extensible Markup
          Language (XML) 1.0.</em> W3C Recommendation. See <a href=
          "http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/2000/REC-xml-20001006</a></dd>

          <dt class="label"><a id="XMLNAMES" name=
          "XMLNAMES"></a>XML Names</dt>

          <dd>World Wide Web Consortium. <em>Namespaces in
          XML.</em> W3C Recommendation. See <a href=
          "http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>

          <dt class="label"><a id="ISO10646" name=
          "ISO10646"></a>ISO/IEC 10646</dt>

          <dd>ISO (International Organization for Standardization).
          <em>ISO/IEC 10646-1993 (E). Information technology --
          Universal Multiple-Octet Coded Character Set (UCS) --
          Part 1: Architecture and Basic Multilingual Plane.</em>
          [Geneva]: International Organization for Standardization,
          1993 (plus amendments AM 1 through AM 7).</dd>

          <dt class="label"><a id="ISO10646-2000" name=
          "ISO10646-2000"></a>ISO/IEC 10646-2000</dt>

          <dd>ISO (International Organization for Standardization).
          <em>ISO/IEC 10646-1:2000. Information technology --
          Universal Multiple-Octet Coded Character Set (UCS) --
          Part 1: Architecture and Basic Multilingual Plane.</em>
          [Geneva]: International Organization for Standardization,
          2000.</dd>

          <dt class="label"><a id="Unicode" name=
          "Unicode"></a>Unicode</dt>

          <dd>The Unicode Consortium. <em>The Unicode Standard,
          Version 2.0.</em> Reading, Mass.: Addison-Wesley
          Developers Press, 1996.</dd>

          <dt class="label"><a id="Unicode3" name=
          "Unicode3"></a>Unicode3</dt>

          <dd>The Unicode Consortium. <em>The Unicode Standard,
          Version 3.0.</em> Reading, Mass.: Addison-Wesley
          Developers Press, 2000. ISBN 0-201-61633-5.</dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a id="id-non-normative-references" name=
        "id-non-normative-references"></a>D.2 Non-normative
        References</h3>

        <dl>
          <dt class="label"><span class="xpath"><a id=
          "XPath-Requirements" name="XPath-Requirements"></a>XPath
          2.0 Requirements</span></dt>

          <dd>
            <div class="xpath">
              World Wide Web Consortium. <em>XPath Requirements
              Version 2.0</em>. W3C Working Draft 22 August 2003.
              See <a href=
              "http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.
            </div>
          </dd>

          <dt class="label"><span class="xpath"><a id="xquery"
          name="xquery"></a>XQuery</span></dt>

          <dd>
            <div class="xpath">
              World Wide Web Consortium. <em>XQuery 1.0: An XML
              Query Language</em>. W3C Working Draft, 22 Aug. 2003.
              See <a href=
              "http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>
            </div>
          </dd>

          <dt class="label"><a id="XSLT" name="XSLT"></a>XSLT
          2.0</dt>

          <dd>World Wide Web Consortium. <em>XSL Transformations
          (XSLT) 2.0.</em> W3C Working Draft. See <a href=
          "http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>

          <dt class="label"><a id="ISO8601" name="ISO8601"></a>ISO
          8601</dt>

          <dd>International Organization for Standardization (ISO).
          <em>Representations of Dates and Times, 2000-08-03.</em>
          Available from <a href=
          "http://www.iso.ch/">http://www.iso.ch/</a></dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a id="id-background-references" name=
        "id-background-references"></a>D.3 Background
        References</h3>

        <dl>
          <dt class="label"><a id="XQL" name="XQL"></a>XQL</dt>

          <dd>J. Robie, J. Lapp, D. Schach. <em>XML Query Language
          (XQL)</em>. See <a href=
          "http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</dd>

          <dt class="label"><a id="XML-QL" name=
          "XML-QL"></a>XML-QL</dt>

          <dd>Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon
          Levy, and Dan Suciu. <em>A Query Language for XML</em>.
          See <a href=
          "http://www.research.att.com/~mff/files/final.html">http://www.research.att.com/~mff/files/final.html</a></dd>

          <dt class="label"><a id="SQL" name="SQL"></a>SQL</dt>

          <dd>International Organization for Standardization (ISO).
          <em>Information Technology-Database Language SQL</em>.
          Standard No. ISO/IEC 9075:1999. (Available from American
          National Standards Institute, New York, NY 10036, (212)
          642-4900.)</dd>

          <dt class="label"><a id="ODMG" name="ODMG"></a>ODMG</dt>

          <dd>Rick Cattell et al. <em>The Object Database Standard:
          ODMG-93, Release 1.2</em>. Morgan Kaufmann Publishers,
          San Francisco, 1996.</dd>

          <dt class="label"><a id="Lorel" name=
          "Lorel"></a>Lorel</dt>

          <dd>Serge Abiteboul, Dallan Quass, Jason McHugh, Jennifer
          Widom, and Janet L. Wiener. <em>The Lorel Query Language
          for Semistructured Data. International Journal on Digital
          Libraries</em>, 1(1):68-88, April 1997. See <a href=
          "http://www-db.stanford.edu/~widom/pubs.html">"http://www-db.stanford.edu/~widom/pubs.html</a></dd>

          <dt class="label"><a id="YATL" name="YATL"></a>YATL</dt>

          <dd>S. Cluet, S. Jacqmin, and J. Simeon. <em>The New
          YATL: Design and Specifications</em>. Technical Report,
          INRIA, 1999.</dd>

          <dt class="label"><a id="Quilt" name=
          "Quilt"></a>Quilt</dt>

          <dd>Don Chamberlin, Jonathan Robie, and Daniela Florescu.
          <em>Quilt: an XML Query Language for Heterogeneous Data
          Sources</em>. In <em>Lecture Notes in Computer
          Science</em>, Springer-Verlag, Dec. 2000. Also available
          at <a href=
          "http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</a>.
          See also <a href=
          "http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</a>.</dd>

          <dt class="label"><a id="XPath" name="XPath"></a>XPath
          1.0</dt>

          <dd>World Wide Web Consortium. <em>XML Path Language
          (XPath) Version 1.0</em>. W3C Recommendation, Nov. 16,
          1999. See <a href=
          "http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a id="id-informative-material" name=
        "id-informative-material"></a>D.4 Informative Material</h3>

        <dl>
          <dt class="label"><a id="RFC2396" name=
          "RFC2396"></a>RFC2396</dt>

          <dd>T. Berners-Lee, R. Fielding, and L. Masinter.
          <em>Uniform Resource Identifiers (URI): Generic
          Syntax</em>. IETF RFC 2396. See <a href=
          "http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>

          <dt class="label"><a id="CHARMOD" name=
          "CHARMOD"></a>Character Model</dt>

          <dd>World Wide Web Consortium. <em>Character Model for
          the World Wide Web.</em> W3C Working Draft. See <a href=
          "http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a></dd>

          <dt class="label"><a id="XINFO" name="XINFO"></a>XML
          Infoset</dt>

          <dd>World Wide Web Consortium. <em>XML Information
          Set.</em> W3C Recommendation 24 October 2001. See
          <a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>

          <dt class="label"><a id="XPTR" name=
          "XPTR"></a>XPointer</dt>

          <dd>World Wide Web Consortium. <em>XML Pointer Language
          (XPointer).</em> W3C Last Call Working Draft 8 January
          2001. See <a href=
          "http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>

          <dt class="label"><a id="XSLT1" name="XSLT1"></a>XSLT
          1.0</dt>

          <dd>World Wide Web Consortium. <em>XSL Transformations
          (XSLT) 1.0.</em> W3C Recommendation. See <a href=
          "http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
        </dl>
      </div>
    </div>

    <div class="div1">
      <h2><a id="id-glossary" name="id-glossary"></a>E
      Glossary</h2>

      <dl>
        <dt><a name="GLdt-accessible-collections" id=
        "GLdt-accessible-collections"></a>accessible
        collections</dt>

        <dd>
          <p><b>Accessible collections.</b> This is a mapping of
          strings onto sequences of nodes. The string represents
          the absolute URI of a resource. The sequence of nodes
          represents the result of the <code>fn:collection</code>
          function when that URI is supplied as the argument.</p>
        </dd>

        <dt><a name="GLdt-accessible-docs" id=
        "GLdt-accessible-docs"></a>accessible documents</dt>

        <dd>
          <p><b>Accessible documents.</b> This is a mapping of
          strings onto document nodes. The string represents the
          absolute URI of a resource. The document node is the
          representation of that resource as an instance of the
          data model, as returned by the <code>fn:doc</code>
          function when applied to that URI.</p>
        </dd>

        <dt><a name="GLdt-atomic-value" id=
        "GLdt-atomic-value"></a>atomic value</dt>

        <dd>
          <p>An <b>atomic value</b> is a value in the value space
          of an XML Schema <b>atomic type</b>, as defined in
          <a href="#XMLSchema">[XML Schema]</a> (that is, a simple
          type that is not a list type or a union type).</p>
        </dd>

        <dt><a name="GLdt-atomization" id=
        "GLdt-atomization"></a>atomization</dt>

        <dd>
          <p><b>Atomization</b> is applied to a value when the
          value is used in a context in which a sequence of atomic
          values is required. The result of atomization is either a
          sequence of atomic values or a <a title="type error"
          href="#dt-type-error">type error</a>. Atomization of a
          sequence is defined as the result of invoking the
          <code>fn:data</code> function on the sequence, as defined
          in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
          2.0 Functions and Operators]</a>.</p>
        </dd>

        <dt><a name="GLdt-attribute-test" id=
        "GLdt-attribute-test"></a>AttributeTest</dt>

        <dd>
          <p>An <b>AttributeTest</b> is used to match an attribute
          node by its name and/or type.</p>
        </dd>

        <dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base
        URI</dt>

        <dd>
          <p><b>Base URI.</b> This is an absolute URI, used when
          necessary in the resolution of relative URIs (for
          example, by the <code>fn:resolve-uri</code>
          function.)</p>
        </dd>

        <dt><a name="GLdt-context-item" id=
        "GLdt-context-item"></a>context item</dt>

        <dd>
          <p>The <b>context item</b> is the item currently being
          processed in a path expression. An item is either an
          atomic value or a node.</p>
        </dd>

        <dt><a name="GLdt-context-node" id=
        "GLdt-context-node"></a>context node</dt>

        <dd>
          <p>When the context item is a node, it can also be
          referred to as the <b>context node</b>.</p>
        </dd>

        <dt><a name="GLdt-context-position" id=
        "GLdt-context-position"></a>context position</dt>

        <dd>
          <p>The <b>context position</b> is the position of the
          context item within the sequence of items currently being
          processed in a path expression.</p>
        </dd>

        <dt><a name="GLdt-context-size" id=
        "GLdt-context-size"></a>context size</dt>

        <dd>
          <p>The <b>context size</b> is the number of items in the
          sequence of items currently being processed in a path
          expression.</p>
        </dd>

        <dt><a name="GLdt-date-time" id=
        "GLdt-date-time"></a>current date and time</dt>

        <dd>
          <p><b>Current date and time.</b> This information
          represents an implementation-dependent point in time
          during processing of a query or transformation. It can be
          retrieved by the <code>fn:current-date</code>,
          <code>fn:current-time</code>, and
          <code>fn:current-dateTime</code> functions. If invoked
          multiple times during the execution of a query or
          transformation, these functions always returns the same
          result.</p>
        </dd>

        <dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
        model</dt>

        <dd>
          <p>XPath operates on the abstract, logical structure of
          an XML document, rather than its surface syntax. This
          logical structure is known as the <b>data model</b>,
          which is defined in the <a href="#datamodel">[XQuery 1.0
          and XPath 2.0 Data Model]</a> document.</p>
        </dd>

        <dt><a name="GLdt-def-collation" id=
        "GLdt-def-collation"></a>default collation</dt>

        <dd>
          <p><b>Default collation.</b> This collation is used by
          string comparison functions when no explicit collation is
          specified.</p>
        </dd>

        <dt><a name="GLdt-def-elemtype-ns" id=
        "GLdt-def-elemtype-ns"></a>default element/type
        namespace</dt>

        <dd>
          <p><b>Default element/type namespace.</b> This is a
          namespace URI. This namespace is used for any unprefixed
          QName appearing in a position where an element or type
          name is expected.</p>
        </dd>

        <dt><a name="GLdt-def-fn-ns" id=
        "GLdt-def-fn-ns"></a>default function namespace</dt>

        <dd>
          <p><b>Default function namespace.</b> This is a namespace
          URI. This namespace URI is used for any unprefixed QName
          appearing as the function name in a function call. The
          initial default function namespace may be provided by the
          external environment.</p>
        </dd>

        <dt><a name="GLdt-docorder" id="GLdt-docorder"></a>document
        order</dt>

        <dd>
          <p><b>Document order</b> defines a total ordering among
          all the nodes seen by the language processor and is
          defined formally in the <a title="data model" href=
          "#dt-datamodel">data model</a>.</p>
        </dd>

        <dt><a name="GLdt-dynamic-context" id=
        "GLdt-dynamic-context"></a>dynamic context</dt>

        <dd>
          <p>The <b>dynamic context</b> of an expression is defined
          as information that is available at the time the
          expression is evaluated.</p>
        </dd>

        <dt><a name="GLdt-dynamic-error" id=
        "GLdt-dynamic-error"></a>dynamic error</dt>

        <dd>
          <p>A <b>dynamic error</b> is an error that must be
          detected during the evaluation phase and may be detected
          during the analysis phase. Numeric overflow is an example
          of a dynamic error.</p>
        </dd>

        <dt><a name="GLdt-dynamic-evaluation" id=
        "GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>

        <dd>
          <p>The <b>dynamic evaluation phase</b> is performed only
          after successful completion of the <a title=
          "static analysis phase" href="#dt-static-analysis">static
          analysis phase</a>. The dynamic evaluation phase depends
          on the <b>operation tree</b> of the expression being
          evaluated (step DQ1), on the input data (step DQ4), and
          on the <a title="dynamic context" href=
          "#dt-dynamic-context">dynamic context</a> (step DQ5),
          which in turn draws information from the external
          environment (step DQ3) and the <a title="static context"
          href="#dt-static-context">static context</a> (step
          DQ2).</p>
        </dd>

        <dt><a name="GLdt-dynamic-type" id=
        "GLdt-dynamic-type"></a>dynamic type</dt>

        <dd>
          <p>A <b>dynamic type</b> is associated with each value as
          it is computed. The dynamic type of a value may be either
          a structural type (such as "sequence of integers") or a
          named type. The dynamic type of a value may be more
          specific than the <a title="static type" href=
          "#dt-static-type">static type</a> of the expression that
          computed it (for example, the <a title="static type"
          href="#dt-static-type">static type</a> of an expression
          might be "zero or more integers or strings," but at
          evaluation time its value may have the dynamic type
          "integer.")</p>
        </dd>

        <dt><a name="GLdt-dyn-vars" id="GLdt-dyn-vars"></a>Dynamic
        variables</dt>

        <dd>
          <p><b>Dynamic variables</b>. This is a set of (QName,
          value) pairs. It contains the same QNames as the
          <a title="in-scope variables" href="#dt-is-vars">in-scope
          variables</a> in the <a title="static context" href=
          "#dt-static-context">static context</a> for the
          expression. The QName is the name of the variable and the
          value is the dynamic value of the variable.</p>
        </dd>

        <dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
        value</dt>

        <dd>
          <p>The <b>effective boolean value</b> of a value is
          defined as the result of applying the
          <code>fn:boolean</code> function to the value, as defined
          in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
          2.0 Functions and Operators]</a>.</p>
        </dd>

        <dt><a name="GLdt-element-test" id=
        "GLdt-element-test"></a>ElementTest</dt>

        <dd>
          <p>An <b>ElementTest</b> is used to match an element node
          by its name and/or type.</p>
        </dd>

        <dt><a name="GLdt-empty-sequence" id=
        "GLdt-empty-sequence"></a>empty sequence</dt>

        <dd>
          <p>A sequence containing zero items is called an <b>empty
          sequence</b>.</p>
        </dd>

        <dt><a name="GLdt-error-value" id=
        "GLdt-error-value"></a>error value</dt>

        <dd>
          <p>An <b>error value</b> is a single item or the empty
          sequence.</p>
        </dd>

        <dt><a name="GLdt-expression-context" id=
        "GLdt-expression-context"></a>expression context</dt>

        <dd>
          <p>The <b>expression context</b> for a given expression
          consists of all the information that can affect the
          result of the expression.</p>
        </dd>

        <dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>

        <dd>
          <p>The first three components of the <a title=
          "dynamic context" href="#dt-dynamic-context">dynamic
          context</a> (context item, context position, and context
          size) are called the <b>focus</b> of the expression.</p>
        </dd>

        <dt><a name="GLdt-functional-language" id=
        "GLdt-functional-language"></a>functional langauge</dt>

        <dd>
          <p>XPath is a <b>functional language</b> which means that
          expressions can be nested with full generality.</p>
        </dd>

        <dt><a name="GLdt-function-implementation" id=
        "GLdt-function-implementation"></a>function
        implementation</dt>

        <dd>
          <p>The <b>function implementation</b> enables the
          function to map instances of its parameter types into an
          instance of its result type.</p>
        </dd>

        <dt><a name="GLdt-function-signature" id=
        "GLdt-function-signature"></a>function signature</dt>

        <dd>
          <p>The <b>function signature</b> specifies the name of
          the function and the <a title="static type" href=
          "#dt-static-type">static types</a> of its parameters and
          its result.</p>
        </dd>

        <dt><a name="GLdt-implementation-defined" id=
        "GLdt-implementation-defined"></a>implementation
        defined</dt>

        <dd>
          <p><b>Implementation-defined</b> indicates an aspect that
          may differ between implementations, but must be specified
          by the implementor for each particular
          implementation.</p>
        </dd>

        <dt><a name="GLdt-implementation-dependent" id=
        "GLdt-implementation-dependent"></a>implementation
        dependent</dt>

        <dd>
          <p><b>Implementation-dependent</b> indicates an aspect
          that may differ between implementations, is not specified
          by this or any W3C specification, and is not required to
          be specified by the implementor for any particular
          implementation.</p>
        </dd>

        <dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
        timezone</dt>

        <dd>
          <p><b>Implicit timezone.</b> This is the timezone to be
          used when a date, time, or dateTime value that does not
          have a timezone is used in a comparison or in any other
          operation. This value is an instance of
          <code>xdt:dayTimeDuration</code> that is <a title=
          "implementation defined" href=
          "#dt-implementation-defined">implementation defined</a>.
          See <a href="#ISO8601">[ISO 8601]</a> for the range of
          legal values of a timezone.</p>
        </dd>

        <dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
        attribute declarations</dt>

        <dd>
          <p><b>In-scope attribute declarations.</b> Each attribute
          declaration is identified either by a QName (for a
          top-level attribute) or by an implementation-defined
          attribute identifier (for a local attribute).</p>
        </dd>

        <dt><a name="GLdt-is-collations" id=
        "GLdt-is-collations"></a>in-scope collations</dt>

        <dd>
          <p><b>In-scope collations.</b> This is a set of (URI,
          collation) pairs. It defines the names of the collations
          that are available for use in function calls that take a
          collation name as an argument.</p>
        </dd>

        <dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope
        element declarations</dt>

        <dd>
          <p><b>In-scope element declarations.</b> Each element
          declaration is identified either by a QName (for a
          top-level element) or by an implementation-defined
          element identifier (for a local element). An element
          declaration includes information about the
          <b>substitution groups</b> to which this element
          belongs.</p>
        </dd>

        <dt><a name="GLdt-is-funcs" id="GLdt-is-funcs"></a>in-scope
        functions</dt>

        <dd>
          <p><b>In-scope functions.</b> This component defines the
          set of functions that are available to be called from
          within an expression. Each function is uniquely
          identified by its expanded QName and its arity (number of
          parameters). Each function in <b>in-scope functions</b>
          has a <a title="function signature" href=
          "#dt-function-signature">function signature</a> and a
          <a title="function implementation" href=
          "#dt-function-implementation">function
          implementation.</a></p>
        </dd>

        <dt><a name="GLdt-is-namespaces" id=
        "GLdt-is-namespaces"></a>in-scope namespaces</dt>

        <dd>
          <p><b>In-scope namespaces.</b> This is a set of (prefix,
          URI) pairs. The in-scope namespaces are used for
          resolving prefixes used in QNames within the
          expression.</p>
        </dd>

        <dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
        definitions</dt>

        <dd>
          <p><b>In-scope schema definitions.</b> This is a generic
          term for all the element, attribute, and type definitions
          that are in scope during processing of an expression.</p>
        </dd>

        <dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope
        type definitions</dt>

        <dd>
          <p><b>In-scope type definitions.</b> The in-scope type
          definitions always include the predefined types listed in
          <a href="#id-predefined-types"><b>2.1.1.1 Predefined
          Types</b></a>. <span class="xpath"><span class=
          "xpath">Additional type definitions may be provided by
          the host language environment.</span></span></p>
        </dd>

        <dt><a name="GLdt-is-vars" id="GLdt-is-vars"></a>in-scope
        variables</dt>

        <dd>
          <p><b>In-scope variables.</b> This is a set of (QName,
          type) pairs. It defines the set of variables that are
          available for reference within an expression. The QName
          is the name of the variable, and the type is the
          <a title="static type" href="#dt-static-type">static
          type</a> of the variable.</p>
        </dd>

        <dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>

        <dd>
          <p>An <b>item</b> is either an <a title="atomic value"
          href="#dt-atomic-value">atomic value</a> or a <a title=
          "node" href="#dt-node">node</a>.</p>
        </dd>

        <dt><a name="GLdt-literal" id=
        "GLdt-literal"></a>literal</dt>

        <dd>
          <p>A <b>literal</b> is a direct syntactic representation
          of an atomic value.</p>
        </dd>

        <dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>

        <dd>
          <p>A <b>node</b> is an instance of one of the seven
          <b>node kinds</b> described in <a href=
          "#datamodel">[XQuery 1.0 and XPath 2.0 Data
          Model]</a>.</p>
        </dd>

        <dt><a name="GLdt-primary-expression" id=
        "GLdt-primary-expression"></a>primary expression</dt>

        <dd>
          <p><b>Primary expressions</b> are the basic primitives of
          the language. They include literals, variables, function
          calls, constructors, and the use of parentheses to
          control precedence of operators.</p>
        </dd>

        <dt><a name="GLdt-sequence" id=
        "GLdt-sequence"></a>sequence</dt>

        <dd>
          <p>A <b>sequence</b> is an ordered collection of zero or
          more <a title="item" href="#dt-item">items</a>.</p>
        </dd>

        <dt><a name="GLdt-sequence-type" id=
        "GLdt-sequence-type"></a>SequenceType</dt>

        <dd>
          <p>When it is necessary to refer to a type in an XPath
          expression, the syntax shown below is used. This syntax
          production is called <b>SequenceType</b>, since it
          describes the type of an XPath value, which is a
          sequence.</p>
        </dd>

        <dt><a name="GLdt-sequencetype-matching" id=
        "GLdt-sequencetype-matching"></a>SequenceType matching</dt>

        <dd>
          <p>During evaluation of an expression, it is sometimes
          necessary to determine whether a given value matches a
          type that was declared using the SequenceType syntax.
          This process is known as <b>SequenceType
          matching</b>.</p>
        </dd>

        <dt><a name="GLdt-serialization" id=
        "GLdt-serialization"></a>serialization</dt>

        <dd>
          <p><b>Serialization</b> is the process of converting an
          instance of the <a href="#datamodel">[XQuery 1.0 and
          XPath 2.0 Data Model]</a> into a sequence of octets (step
          DM4 in Figure 1.)</p>
        </dd>

        <dt><a name="GLdt-singleton-sequence" id=
        "GLdt-singleton-sequence"></a>singleton sequence</dt>

        <dd>
          <p>A sequence containing exactly one item is called a
          <b>singleton sequence</b>.</p>
        </dd>

        <dt><a name="GLdt-known-collections" id=
        "GLdt-known-collections"></a>statically-known
        collections</dt>

        <dd>
          <p><b>Statically-known collections.</b> This is a mapping
          from strings onto types. The string represents the
          absolute URI of a resource that is potentially accessible
          using the <code>fn:collection</code> function. The type
          is the type of the sequence of nodes that would result
          from calling the <code>fn:collection</code> function with
          this URI as its argument.</p>
        </dd>

        <dt><a name="GLdt-known-docs" id=
        "GLdt-known-docs"></a>statically-known documents</dt>

        <dd>
          <p><b>Statically-known documents.</b> This is a mapping
          from strings onto types. The string represents the
          absolute URI of a resource that is potentially accessible
          using the <code>fn:doc</code> function. The type is the
          type of the document node that would result from calling
          the <code>fn:doc</code> function with this URI as its
          argument.</p>
        </dd>

        <dt><a name="GLdt-static-analysis" id=
        "GLdt-static-analysis"></a>static analysis phase</dt>

        <dd>
          <p>The <b>static analysis phase</b> depends on the
          expression itself and on the <a title="static context"
          href="#dt-static-context">static context</a>. The static
          analysis phase does not depend on any input data.</p>
        </dd>

        <dt><a name="GLdt-static-context" id=
        "GLdt-static-context"></a>static context</dt>

        <dd>
          <p>The <b>static context</b> of an expression is the
          information that is available during static analysis of
          the expression, prior to its evaluation.</p>
        </dd>

        <dt><a name="GLdt-static-error" id=
        "GLdt-static-error"></a>static error</dt>

        <dd>
          <p>A <b>static error</b> is an error that must be
          detected during the analysis phase. A syntax error is an
          example of a <a title="static error" href=
          "#dt-static-error">static error</a>. The means by which
          <a title="static error" href="#dt-static-error">static
          errors</a> are reported during the analysis phase is
          <a title="implementation defined" href=
          "#dt-implementation-defined">implementation
          defined</a>.</p>
        </dd>

        <dt><a name="GLdt-static-type" id=
        "GLdt-static-type"></a>static type</dt>

        <dd>
          <p>The <b>static type</b> of an expression may be either
          a named type or a structural description--for example,
          <code>xs:boolean?</code> denotes an optional occurrence
          of the <code>xs:boolean</code> type. The rules for
          inferring the <a title="static type" href=
          "#dt-static-type">static type</a>s of various expressions
          are described in <a href="#XQueryFormalSemantics">[XQuery
          1.0 and XPath 2.0 Formal Semantics]</a>.</p>
        </dd>

        <dt><a name="GLdt-string-value" id=
        "GLdt-string-value"></a>string value</dt>

        <dd>
          <p>The <b>string value</b> of a node is a string and can
          be extracted by applying the the <code>fn:string</code>
          function to the node. The string value for each kind of
          node is defined by the <code>dm:string-value</code>
          accessor in <a href="#datamodel">[XQuery 1.0 and XPath
          2.0 Data Model]</a>.</p>
        </dd>

        <dt><a name="GLdt-strongly-typed" id=
        "GLdt-strongly-typed"></a>strongly typed</dt>

        <dd>
          <p>XPath is also a <b>strongly-typed language</b> in
          which the operands of various expressions, operators, and
          functions must conform to the expected types.</p>
        </dd>

        <dt><a name="GLdt-type-annotation" id=
        "GLdt-type-annotation"></a>type annotation</dt>

        <dd>
          <p>Element and attribute nodes have a <b>type
          annotation</b>, which represents (in an
          implementation-dependent way) the <a title="dynamic type"
          href="#dt-dynamic-type">dynamic (run-time) type</a> of
          the node.</p>
        </dd>

        <dt><a name="GLdt-typed-value" id=
        "GLdt-typed-value"></a>typed value</dt>

        <dd>
          <p>The <b>typed value</b> of a node is a sequence of
          atomic values and can be extracted by applying the
          <code>fn:data</code> function to the node. The typed
          value for each kind of node is defined by the
          <code>dm:typed-value</code> accessor in <a href=
          "#datamodel">[XQuery 1.0 and XPath 2.0 Data
          Model]</a>.</p>
        </dd>

        <dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
        error</dt>

        <dd>
          <p>A <b>type error</b> may be raised during the analysis
          or evaluation phase. During the analysis phase, a
          <a title="type error" href="#dt-type-error">type
          error</a> occurs when the <a title="static type" href=
          "#dt-static-type">static type</a> of an expression does
          not match the expected type of the context in which the
          expression occurs. During the evaluation phase, a
          <a title="type error" href="#dt-type-error">type
          error</a> occurs when the dynamic type of a value does
          not match the expected type of the context in which the
          value occurs.</p>
        </dd>

        <dt><a name="GLdt-xpath-compat-mode" id=
        "GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility
        mode</dt>

        <dd>
          <p><b>XPath 1.0 compatibility mode.</b> <span class=
          "xpath"><span class="xpath">This value is
          <code>true</code> if rules for backward compatibility
          with XPath Version 1.0 are in effect; otherwise it is
          <code>false</code>.</span></span></p>
        </dd>
      </dl>
    </div>

    <div class="div1">
      <h2><a id="id-errors" name="id-errors"></a>F Summary of Error
      Conditions</h2>

      <dl>
        <dt><a name="ERRXP0001" id="ERRXP0001"></a>err:XP0001</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if analysis of an
          expression relies on some component of the <a title=
          "static context" href="#dt-static-context">static
          context</a> that has not been assigned a value.</p>
        </dd>

        <dt><a name="ERRXP0002" id="ERRXP0002"></a>err:XP0002</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if evaluation of an
          expression relies on some part of the <a title=
          "dynamic context" href="#dt-dynamic-context">dynamic
          context</a> that has not been assigned a value.</p>
        </dd>

        <dt><a name="ERRXP0003" id="ERRXP0003"></a>err:XP0003</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an expression is
          not a valid instance of the grammar defined in <a href=
          "#id-grammar"><b>A.1 EBNF</b></a>.</p>
        </dd>

        <dt><a name="ERRXQ0004" id="ERRXQ0004"></a>err:XQ0004</dt>

        <dd>
          <p>During the analysis phase, it is a <a title=
          "type error" href="#dt-type-error">type error</a> if the
          static typing feature is in effect and an expression is
          found to have a static type that is not appropriate for
          the context in which the expression occurs.</p>
        </dd>

        <dt><a name="ERRXQ0005" id="ERRXQ0005"></a>err:XQ0005</dt>

        <dd>
          <p>During the analysis phase, it is a <a title=
          "type error" href="#dt-type-error">type error</a> if the
          static typing feature is in effect and the static type
          assigned to an expression other than the expression
          <code>()</code> is the empty type.</p>
        </dd>

        <dt><a name="ERRXP0006" id="ERRXP0006"></a>err:XP0006</dt>

        <dd>
          <p>During the evaluation phase, it is a <a title=
          "type error" href="#dt-type-error">type error</a> if a
          value does not match a required type as specified by the
          matching rules in <a href=
          "#id-sequencetype-matching"><b>2.4.1.1 SequenceType
          Matching</b></a>.</p>
        </dd>

        <dt><a name="ERRXP0007" id="ERRXP0007"></a>err:XP0007</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the
          <code>fn:data</code> function is applied to a node whose
          type annotation denotes a complex type with non-mixed
          complex content.</p>
        </dd>

        <dt><a name="ERRXP0008" id="ERRXP0008"></a>err:XP0008</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an expression
          refers to a type name, function name, namespace prefix,
          or variable name that is not defined in the <a title=
          "static context" href="#dt-static-context">static
          context</a>.</p>
        </dd>

        <dt><a name="ERRXQ0009" id="ERRXQ0009"></a>err:XQ0009</dt>

        <dd>
          <p>An implementation that does not support the Schema
          Import Feature may raise a <a title="static error" href=
          "#dt-static-error">static error</a> if a query prolog
          contains a schema import statement.</p>
        </dd>

        <dt><a name="ERRXQ0010" id="ERRXQ0010"></a>err:XQ0010</dt>

        <dd>
          <p>An implementation that does not support the Full Axis
          Feature may raise a <a title="static error" href=
          "#dt-static-error">static error</a> if a path expression
          references an unsupported axis (ancestor,
          ancestor-or-self, following, following-sibling,
          preceding, or preceding-sibling).</p>
        </dd>

        <dt><a name="ERRXQ0012" id="ERRXQ0012"></a>err:XQ0012</dt>

        <dd>
          <p>If the Schema Import Feature is in effect, it is a
          <a title="static error" href="#dt-static-error">static
          error</a> if the set of definitions contained in all
          imported schemas do not satisfy the conditions for schema
          validity specified in Sections 3 and 5 of <a href=
          "#XMLSchema">[XML Schema]</a> Part 1. In particular, the
          definitions must be valid, they must be complete, and
          they must be unique -- that is, the pool of definitions
          must not contain two or more schema components with the
          same name and target namespace.</p>
        </dd>

        <dt><a name="ERRXQ0013" id="ERRXQ0013"></a>err:XQ0013</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an implementation
          supports a pragma and the implementation determines that
          the <a href="#">PragmaContents</a> are invalid.</p>
        </dd>

        <dt><a name="ERRXQ0014" id="ERRXQ0014"></a>err:XQ0014</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an implementation
          does not support a must-understand extension or an
          implementation does support a must-understand extension
          and the implementation determines that the <a href=
          "#">ExtensionContents</a> are invalid.</p>
        </dd>

        <dt><a name="ERRXQ0015" id="ERRXQ0015"></a>err:XQ0015</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the XQuery Flagger
          is enabled and the query contains a must-understand
          extension.</p>
        </dd>

        <dt><a name="ERRXP0016" id="ERRXP0016"></a>err:XP0016</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> to reference a
          variable that is not in scope.</p>
        </dd>

        <dt><a name="ERRXP0017" id="ERRXP0017"></a>err:XP0017</dt>

        <dd>
          <p>It is <span class="xpath"><span class="xpath">It is an
          error (the host language environment may define this
          error as either a static or a <a title="dynamic error"
          href="#dt-dynamic-error">dynamic error</a>)</span></span>
          if the expanded QName and number of arguments in a
          function call do not match the name and arity of an
          <a title="in-scope functions" href=
          "#dt-is-funcs">in-scope function</a> in the <a title=
          "static context" href="#dt-static-context">static
          context</a>.</p>
        </dd>

        <dt><a name="ERRXP0018" id="ERRXP0018"></a>err:XP0018</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> for an expression to
          depend on the focus when the focus is undefined.</p>
        </dd>

        <dt><a name="ERRXP0019" id="ERRXP0019"></a>err:XP0019</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the result of a step
          expression (StepExpr) is not a sequence of nodes.</p>
        </dd>

        <dt><a name="ERRXP0020" id="ERRXP0020"></a>err:XP0020</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if in an axis expression,
          the context item is not a node.</p>
        </dd>

        <dt><a name="ERRXP0021" id="ERRXP0021"></a>err:XP0021</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if a value in a
          cast expression cannot be cast to the required type.</p>
        </dd>

        <dt><a name="ERRXQ0022" id="ERRXQ0022"></a>err:XQ0022</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of a
          namespace declaration attribute is not a literal
          string.</p>
        </dd>

        <dt><a name="ERRXQ0023" id="ERRXQ0023"></a>err:XQ0023</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the content sequence
          in an element constructor contains a document node.</p>
        </dd>

        <dt><a name="ERRXQ0024" id="ERRXQ0024"></a>err:XQ0024</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the content sequence
          in an element constructor contains an attribute node
          following a node that is not an attribute node or a
          namespace node.</p>
        </dd>

        <dt><a name="ERRXQ0025" id="ERRXQ0025"></a>err:XQ0025</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if two or more
          attribute values in the content sequence of an element
          constructor have the same name.</p>
        </dd>

        <dt><a name="ERRXQ0026" id="ERRXQ0026"></a>err:XQ0026</dt>

        <dd>
          <p>In an element-constructor expression, it is a
          <a title="dynamic error" href="#dt-dynamic-error">dynamic
          error</a> if the validation mode is <code>strict</code>
          and the <a title="in-scope element declarations" href=
          "#dt-is-elems">in-scope element declarations</a> do not
          contain an element declaration whose unique name matches
          the name of the constructed element.</p>
        </dd>

        <dt><a name="ERRXQ0027" id="ERRXQ0027"></a>err:XQ0027</dt>

        <dd>
          <p>In an element-constructor or validate expression, it
          is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if validation
          fails.</p>
        </dd>

        <dt><a name="ERRXQ0028" id="ERRXQ0028"></a>err:XQ0028</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the content sequence
          in a document constructor contains a document, attribute,
          or namespace node.</p>
        </dd>

        <dt><a name="ERRXP0029" id="ERRXP0029"></a>err:XP0029</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> in a cast
          expression if the input value does not satisfy the facets
          of the target type.</p>
        </dd>

        <dt><a name="ERRXQ0030" id="ERRXQ0030"></a>err:XQ0030</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the argument of a
          <code>validate</code> expression does not evaluate to
          exactly one document or element node.</p>
        </dd>

        <dt><a name="ERRXQ0031" id="ERRXQ0031"></a>err:XQ0031</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the version number
          specified in a version declaration is not supported by
          the implementation.</p>
        </dd>

        <dt><a name="ERRXQ0032" id="ERRXQ0032"></a>err:XQ0032</dt>

        <dd>
          <p>A <a title="static error" href=
          "#dt-static-error">static error</a> is raised if the
          query prolog contains multiple declarations for the base
          URI.</p>
        </dd>

        <dt><a name="ERRXQ0033" id="ERRXQ0033"></a>err:XQ0033</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the query prolog
          contains multiple declarations for the same namespace
          prefix.</p>
        </dd>

        <dt><a name="ERRXQ0034" id="ERRXQ0034"></a>err:XQ0034</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if more than one
          function declared or imported by a module has the same
          expanded QName.</p>
        </dd>

        <dt><a name="ERRXQ0035" id="ERRXQ0035"></a>err:XQ0035</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> to import two schemas
          that both define the same name in the same symbol space
          and in the same scope.</p>
        </dd>

        <dt><a name="ERRXQ0036" id="ERRXQ0036"></a>err:XQ0036</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> to import a module if the
          importing module's <a title="in-scope type definitions"
          href="#dt-is-types">in-scope type definitions</a> do not
          include definitions for the type names that appear in
          variable declarations, function parameters, or function
          returns found in the imported module.</p>
        </dd>

        <dt><a name="ERRXQ0037" id="ERRXQ0037"></a>err:XQ0037</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> to import a module
          that contains function declarations or variable
          declarations whose names are already declared in the
          <a title="static context" href=
          "#dt-static-context">static context</a> of the importing
          module.</p>
        </dd>

        <dt><a name="ERRXQ0038" id="ERRXQ0038"></a>err:XQ0038</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a query prolog
          specifies more than one default collation, or value
          specified does not identify a collation known to the
          implementation.</p>
        </dd>

        <dt><a name="ERRXQ0039" id="ERRXQ0039"></a>err:XQ0039</dt>

        <dd>
          <p>It is an <a title="static error" href=
          "#dt-static-error">static error</a> for a function
          declaration to have more than one parameter with the same
          name.</p>
        </dd>

        <dt><a name="ERRXQ0040" id="ERRXQ0040"></a>err:XQ0040</dt>

        <dd>
          <p>It is a <a title="type error" href=
          "#dt-type-error">type error</a> if the content sequence
          in an element constructor contains a namespace node node
          following a node that is not a namespace node.</p>
        </dd>

        <dt><a name="ERRXQ0041" id="ERRXQ0041"></a>err:XQ0041</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if the name
          expression in a computed processing instruction or
          computed namespace constructor returns a QName whose URI
          part is not empty.</p>
        </dd>

        <dt><a name="ERRXQ0042" id="ERRXQ0042"></a>err:XQ0042</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the enclosing
          expression of a computed namespace constructor is not a
          computed element constructor.</p>
        </dd>

        <dt><a name="ERRXQ0043" id="ERRXQ0043"></a>err:XQ0043</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if two or more
          computed namespace constructors within the same computed
          element constructor attempt to bind the same namespace
          prefix.</p>
        </dd>

        <dt><a name="ERRXQ0044" id="ERRXQ0044"></a>err:XQ0044</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if the name
          expression of a computed attribute constructor returns a
          string that begins with the characters
          <code>xmlns</code>.</p>
        </dd>

        <dt><a name="ERRXQ0045" id="ERRXQ0045"></a>err:XQ0045</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the declared
          function name in a function declaration has no namespace
          prefix or has one of the predefined namespace prefixes
          other than <code>local</code>.</p>
        </dd>

        <dt><a name="ERRXQ0046" id="ERRXQ0046"></a>err:XQ0046</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the URI in a
          namespace declaration or default namespace declaration is
          not a valid URI. In addition, the URI in a (non-default)
          namespace declaration may not be a zero-length
          string.</p>
        </dd>

        <dt><a name="ERRXQ0047" id="ERRXQ0047"></a>err:XQ0047</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the target URI
          (and location hint, if present) in a module import do not
          identify an accessible module.</p>
        </dd>

        <dt><a name="ERRXQ0048" id="ERRXQ0048"></a>err:XQ0048</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a function or
          variable declared in a library module is not in the
          target namespace of the library module.</p>
        </dd>

        <dt><a name="ERRXQ0049" id="ERRXQ0049"></a>err:XQ0049</dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if more than one
          variable declared or imported by a module has the same
          expanded QName.</p>
        </dd>

        <dt><a name="ERRXP0050" id="ERRXP0050"></a>err:XP0050</dt>

        <dd>
          <p>It is a <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> if dynamic type of
          the operand of a <code>treat</code> expression does not
          match the type specified by the <code>treat</code>
          expression.</p>
        </dd>
      </dl>
    </div>

    <div class="xpath">
      <div class="div1">
        <h2><a id="N13D90" name="N13D90"></a>G Conformance</h2>

        <p>XPath is intended primarily as a component that can be
        used by other specifications. Therefore, XPath relies on
        specifications that use it (such as <a href=
        "#XPTR">[XPointer]</a> and <a href="#XSLT">[XSLT 2.0]</a>)
        to specify conformance criteria for XPath in their
        respective environments. Specifications that set
        conformance criteria for their use of XPath must not change
        the syntactic or semantic definitions of XPath as given in
        this specification, except by subsetting and/or compatible
        extensions.</p>
      </div>
    </div>

    <div class="xpath">
      <div class="div1">
        <h2><a id="id-backwards-compatibility" name=
        "id-backwards-compatibility"></a>H Backwards Compatibility
        with XPath 1.0 (Non-Normative)</h2>

        <p>This section provides a summary of the main areas of
        incompatibility between XPath 2.0 and <a href=
        "#XPath">[XPath 1.0]</a>.</p>

        <p>Three separate cases are considered:</p>

        <ol class="enumar">
          <li>
            <p>Incompatibilities that exist when source documents
            have no schema, and when running with XPath 1.0
            compatibility mode set to true. This specification has
            been designed to reduce the number of incompatibilities
            in this situation to an absolute minumum, but some
            differences remain and are listed individually.</p>
          </li>

          <li>
            <p>Incompatibilities that arise when XPath 1.0
            compatibility mode is set to false. In this case, the
            number of expressions where compatibility is lost is
            rather greater.</p>
          </li>

          <li>
            <p>Incompatibilities that arise when the source
            document is processed using a schema (whether or not
            XPath 1.0 compatibility mode is set to true).
            Processing the document with a schema changes the way
            that the values of nodes are interpreted, and this can
            cause an XPath expression to return different
            results.</p>
          </li>
        </ol>

        <div class="div2">
          <h3><a id="N13DB2" name="N13DB2"></a>H.1
          Incompatibilities when Compatibility Mode is true</h3>

          <p>The list below contains all known areas, within the
          scope of this specification, where an XPath 2.0 processor
          running with compatibility mode set to true will produce
          different results from an XPath 1.0 processor evaluating
          the same expression, assuming that the expression was
          valid in XPath 1.0, and that the nodes in the source
          document have no type annotations other than
          <code>xs:anyType</code> and
          <code>xs:anySimpleType</code>.</p>

          <p>Incompatibilities in the behavior of individual
          functions are not listed here, but are included in an
          appendix of <a href="#">[FANDO]</a>.</p>

          <p>In the description below, the terms <em>node-set</em>
          and <em>number</em> are used with their XPath 1.0
          meanings, that is, to describe expressions which
          according to the rules of XPath 1.0 would have generated
          a node-set or a number respecively.</p>

          <ol class="enumar">
            <li>
              <p>The rules for comparing a node-set to a boolean
              have changed. In XPath 1.0, an expression such as
              <code>$nodeset=true()</code> was evaluated by
              converting the node-set to a boolean and then
              performing a boolean comparison: so this expression
              would return <code>true</code> if
              <code>$nodeset</code> was non-empty. In XPath 2.0,
              this expression is handled in the same way as other
              comparisons between a sequence and a singleton: it is
              <code>true</code> if <code>$nodeset</code> contains
              at least one node whose value, after casting to a
              boolean, is <code>true</code>.</p>

              <p>This means that if <code>$nodeset</code> is empty,
              the result under XPath 2.0 will be <code>false</code>
              regardless of the value of the boolean operand, and
              regardless of which operator is used. If
              <code>$nodeset</code> is non-empty, then in most
              cases the cast to a boolean is likely to fail, giving
              a dynamic error. But if a node has the value "0",
              "1", "true", or "false", evaluation of the expression
              may succeed.</p>
            </li>

            <li>
              <p>The rules for comparing an integer to a boolean
              have changed. In XPath 1.0, the expression <code>(4 =
              true())</code> is evaluated by converting the number
              4 to boolean (yielding <code>true</code>). The
              expression returns <code>true</code>. In XPath 2.0,
              running in compatibility mode, the same expression is
              evaluated by converting both operands to double
              (yielding <code>4e0 = 1e0</code>). The expression
              returns <code>false</code>.</p>
            </li>

            <li>
              <p>The rules for comparing a string to a boolean have
              changed. In XPath 1.0, the expression <code>("x" =
              true())</code> is evaluated by converting the string
              to a boolean, and performing a boolean comparison. In
              XPath 2.0 a comparison between a boolean and a string
              raises a type error, even when compatibility mode is
              true.</p>
            </li>

            <li>
              <p>Additional numeric types have been introduced,
              with the effect that arithmetic may now be done as an
              integer, decimal, or single- or double-precision
              floating point calculation where previously it was
              always performed as double-precision floating point.
              The result of the <code>div</code> operator when
              dividing two integers is now a value of type decimal
              rather than double. The expression <code>10 div
              0</code> raises an error rather than returning
              positive infinity.</p>
            </li>

            <li>
              <p>The rules for converting numbers to strings have
              changed. These will affect the way numbers are
              displayed in the output of a stylesheet. The output
              format depends on the data type of the result:
              floating point values, for example, will be displayed
              using scientific notation. The result of a decimal
              calculation such as <code>1.5 + 3.5</code> will be
              displayed as <code>5.0</code>, not <code>5</code> as
              previously. The general rule is that the numbers are
              converted to strings using the rules for casting to
              the type <code>xs:string</code>.</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>The rules for converting floating point numbers
                to strings are currently under review.</p>
              </div>
            </li>

            <li>
              <p>The rules for converting strings to numbers have
              changed. The representation of special values such as
              Infinity has been aligned with XML Schema. Strings
              containing a leading plus sign, or numbers in
              scientific notation, may now be converted to ordinary
              numeric values, whereas in XPath 1.0 they were
              converted to <code>NaN</code>.</p>
            </li>

            <li>
              <p>Many operations in XPath 2.0 produce an empty
              sequence as their result when one of the arguments or
              operands is an empty sequence. With XPath 1.0, the
              result of such an operation was typically a
              zero-length string or the numeric value
              <code>NaN</code>. Examples include the arithmetic
              operators and certain functions such as
              <code>substring</code>. Many functions also produce
              an empty sequence when applied to an argument for
              which no other value is defined. However, for
              functions in the core such as <code>name</code>, the
              XPath 1.0 behavior has been retained; for example,
              applying the <code>name</code> function to a text
              node produces a zero-length string, as it did in
              XPath 1.0.</p>

              <p>An example of an expression whose value will
              change as a result of this rule is <code>string(@a+0)
              = "NaN"</code>, in the case where <code>@a</code>
              returns an empty node-set. With XPath 1.0, this would
              produce the value <code>true</code>. With XPath 2.0,
              it produces the value <code>false</code>.</p>
            </li>

            <li>
              <p>In XPath 1.0, the <code>&lt;</code> and
              <code>&gt;</code> operators, when applied to two
              strings, attempted to convert both the strings to
              numbers and then made a numeric comparison between
              the results. In XPath 2.0, these operators perform a
              string comparison using the default collating
              sequence. (If either value is numeric, however, the
              results are compatible with XPath 1.0)</p>
            </li>

            <li>
              <p>In XPath 1.0, functions and operators that
              compared strings (for example, the <code>=</code>
              operator and the <code>contains</code> function)
              worked on the basis of character-by-character
              equality of Unicode codepoints, allowing Unicode
              normalization at the discretion of the implementor.
              In XPath 2.0, these comparisons are done using the
              default collating sequence. The host language from
              which XPath is invoked may define mechanisms allowing
              codepoint comparison to be selected as the default
              collating sequence, but there is no such mechanism
              defined in XPath itself.</p>
            </li>

            <li>
              <p>In XPath 1.0, it was defined that with an
              expression of the form <code>A and B</code>, B would
              not be evaluated if A was false. Similarly in the
              case of <code>A or B</code>, B would not be evaluated
              if A was true. This is no longer guaranteed with
              XPath 2.0: the implementation is free to evaluate the
              two operands in either order or in parallel. This
              change has been made to give more scope for
              optimization in situations where XPath expressions
              are evaluated against large data collections
              supported by indexes. Implementations may choose to
              retain backwards compatibility in this area, but they
              are not obliged to do so.</p>
            </li>

            <li>
              <p>Consecutive comparison operators such as <code>A
              &lt; B &lt; C</code> were supported in XPath 1.0, but
              are not permitted by the XPath 2.0 grammar. Such
              comparisons in XPath 1.0 did not have the intuitive
              meaning, so it is unlikely that they have been widely
              used in practice.</p>
            </li>

            <li>
              <p>The namespace axis is deprecated in XPath 2.0.
              Implementations may support the namespace axis for
              backward compatibility with XPath 1.0, but they are
              not required to do so.</p>
            </li>
          </ol>
        </div>

        <div class="div2">
          <h3><a id="N13E65" name="N13E65"></a>H.2
          Incompatibilities when Compatibility Mode is false</h3>

          <p>Even when the setting of the XPath 1.0 compatibility
          mode is false, many XPath expressions will still produce
          the same results under XPath 2.0 as under XPath 1.0.
          However, there are exceptions.</p>

          <p>The main additional incompatibilities are as
          follows:</p>

          <ol class="enumar">
            <li>
              <p>When a node-set containing more than one node is
              supplied as an argument to a function or operator
              that expects a single node or value, the rule that
              all nodes after the first are discarded no longer
              applies. Instead, a type error occurs if there is
              more than one node. The XPath 1.0 behavior can always
              be restored by using the predicate <code>[1]</code>
              to explicitly select the first node in the
              node-set.</p>
            </li>

            <li>
              <p>When an empty node-set is supplied as an argument
              to a function or operator that expects a string or
              number, the value is no longer converted implicitly
              to a zero-length string or NaN. The XPath 1.0
              behavior can always be restored by using the
              <code>string</code> or <code>number</code> function
              to perform an explicit conversion.</p>
            </li>

            <li>
              <p>More generally, the supplied arguments to a
              function or operator are no longer implicitly
              converted to the required type, except in the case
              where the supplied argument is of type
              <code>xdt:untypedAtomic</code> (which will commonly
              be the case when a node in a schema-less document is
              supplied as the argument). For example, the function
              call <code>concat("chapter", $nr)</code> raises a
              type error if the variable <code>$nr</code> is
              numeric, because the arguments to the
              <code>concat</code> function must be strings rather
              than numbers. The XPath 1.0 behavior can be restored
              by performing an explicit conversion to the required
              type using a constructor function or cast.</p>
            </li>
          </ol>

          <p>It is <em>not</em> the case that these differences
          will always result in XPath 2.0 raising an error. In some
          cases, XPath 2.0 will return different results for the
          same expression. For example, consider the expression
          <code>string-length(@x) = 0</code>, in the case where
          <code>@x</code> returns an empty node-set. In XPath 1.0,
          and in XPath 2.0 in compatibility mode, the empty
          node-set is converted to a zero-length string, so the
          result of the expression is <code>true</code>. In XPath
          2.0, with compatibility mode set to false, the
          <code>string-length</code> function returns an empty
          sequence, and the comparison of an empty sequence to the
          number <code>0</code> returns <code>false</code>.</p>
        </div>

        <div class="div2">
          <h3><a id="N13EA2" name="N13EA2"></a>H.3
          Incompatibilities when using a Schema</h3>

          <p>An XPath expression applied to a document that has
          been processed against a schema will not always give the
          same results as the same expression applied to the same
          document in the absence of a schema. Since schema
          processing had no effect on the result of an XPath 1.0
          expression, this may give rise to further
          incompatibilities.</p>

          <p>Suppose that the context node is an element node
          derived from the following markup: <code>&lt;background
          color="red green blue"/&gt;</code>. In XPath 1.0, the
          predicate <code>[@color="blue"]</code> would return
          <code>false</code>. In XPath 2.0, if the
          <code>color</code> attribute is defined in a schema to be
          of type <code>xs:string*</code>, the same predicate will
          return <code>true</code>.</p>

          <p>Similarly, consider the expression <code>@birth &lt;
          @death</code> applied to the element <code>&lt;person
          birth="1901-06-06" death="1991-05-09"/&gt;</code>. With
          XPath 1.0, this expression would return false, because
          both attributes are converted to numbers, which returns
          <code>NaN</code> in each case. With XPath 2.0, in the
          presence of a schema that annotates these attributes as
          dates, the expression returns <code>true</code>.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a id="id-issues" name="id-issues"></a>I XPath 2.0 and
      XQuery 1.0 Issues (Non-Normative)</h2>

      <p>Values for <b>Status</b> has the following meaning:</p>

      <p><b>resolved</b>: a decision has been finalized and the
      document updated to reflect the decision.</p>

      <p><b>decided</b>: recommendations and decision(s) has been
      made by one or more of the following: a task-force, XPath WG,
      or XQuery WG.</p>

      <p><b>draft</b>: a proposal has been developed for possible
      future inclusion in a published document.</p>

      <p><b>active</b>: issue is actively being discussed.</p>

      <p><b>unassigned</b>: discussion of issue deferred.</p>

      <p><b>subsumed</b>: issue has been subsumed by another
      issue.</p>

      <p>(parameters used: kwSort: cluster, kwFull: brief, kwDate:
      00000000).</p>
      <hr />

      <table>
        <tr>
          <th style="text-align:left; width:5%">Num</th>

          <th style="text-align:left">Cl</th>

          <th style="text-align:left">Pr</th>

          <th style="text-align:left">Cluster</th>

          <th style="text-align:left">Status</th>

          <th style="text-align:left">Locus</th>

          <th style="text-align:left">Description</th>

          <th style="text-align:left">Responsible</th>
        </tr>

        <tr>
          <td><a href="#cdata-charref-semantics">293</a></td>

          <td></td>

          <td>1</td>

          <td></td>

          <td>decided</td>

          <td>xquery</td>

          <td>Cdata and CharRef Semantics</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0101">444</a></td>

          <td></td>

          <td>1</td>

          <td></td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Support for mixed content in the type system</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#xquery-normalized-equality">96</a></td>

          <td></td>

          <td>o-1</td>

          <td>(in)equality-operators</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Normalized Equality</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-xpath-axes">114</a></td>

          <td></td>

          <td>o-1</td>

          <td>axes</td>

          <td>decided</td>

          <td>xquery</td>

          <td>XPath Axes</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#cdata-section">328</a></td>

          <td></td>

          <td>1</td>

          <td>cdata section</td>

          <td>decided</td>

          <td>xquery</td>

          <td>What does CDATA section constructor construct?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#collection-always-return-same">257</a></td>

          <td>D</td>

          <td>1</td>

          <td>collections</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Does collection() always return same result?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#normativity-external-internal-mapping">561</a></td>

          <td></td>

          <td>1</td>

          <td>conformance</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Normativity of External Mappings</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#conformance-levels">546</a></td>

          <td></td>

          <td>1</td>

          <td>conformance-levels</td>

          <td>active</td>

          <td>xpath</td>

          <td>Are there more processing model options that could
          make sense as consistent features and thus as conformance
          levels?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#element-construction-vs-streaming">286</a></td>

          <td></td>

          <td>1</td>

          <td>constructor-expr</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Element Construction vs Streaming</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#element-attribute-constructor-name-type">290</a></td>

          <td></td>

          <td>1</td>

          <td>constructor-expr</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Element Attribute Constructor Name Type</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#node-identity-modeling">529</a></td>

          <td></td>

          <td>1</td>

          <td>constructor-expr</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Node identity in the formal semantics</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#duplicate-attribute-constructors">329</a></td>

          <td></td>

          <td>1</td>

          <td>constructors</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Duplicate attribute constructors</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#document-nodes-identity">258</a></td>

          <td>D</td>

          <td>2</td>

          <td>documents</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Identity of Document Nodes</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#what-is-normative">554</a></td>

          <td></td>

          <td>1</td>

          <td>editorial</td>

          <td>active</td>

          <td>xpath</td>

          <td>What is the really normative text?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#element-attribute-construction-order">339</a></td>

          <td></td>

          <td>2</td>

          <td>errors</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Error type for attributes constructed too late</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#errors-unique-identification">340</a></td>

          <td></td>

          <td>1</td>

          <td>errors</td>

          <td>decided</td>

          <td>xpath</td>

          <td>How to identify errors?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#dynamic-errors-reported-statically">553</a></td>

          <td></td>

          <td>1</td>

          <td>errors</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Rules for reporting dynamic errors statically</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#static-error-evaluate-dynamically">563</a></td>

          <td></td>

          <td>1</td>

          <td>errors</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Is dynamic evaluation performed if error in static
          analysis?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#extension-mechanism">317</a></td>

          <td></td>

          <td>1</td>

          <td>extensions</td>

          <td>decided</td>

          <td>xquery</td>

          <td>XQuery Extension Mechanisms</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#keyword-extensions">538</a></td>

          <td></td>

          <td>1</td>

          <td>extensions</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Can (and should) keyword extensions be allowed in
          XQuery by equipping them with a namespace prefix?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#external-functions">272</a></td>

          <td></td>

          <td>1</td>

          <td>external-functions</td>

          <td>decided</td>

          <td>xpath</td>

          <td>External Functions</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#external-objests">273</a></td>

          <td></td>

          <td>1</td>

          <td>external-objects</td>

          <td>decided</td>

          <td>xpath</td>

          <td>External Objects</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#module-import-fs">555</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Formal Semantics of Module Import</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#variable-definitions-fs">556</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Formal Semantics of Variable Definitions</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#validation-declaration-fs">557</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Formal semantics of Validation Declaration</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-support-new-sequence-type">559</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>New Sequence Type needs to be fully implemented in
          Formal Semantics</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-allow-PIs-comments">558</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>The content of element types should always allow PI's
          and comment node types</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#exactness-type-inference">560</a></td>

          <td></td>

          <td>1</td>

          <td>formal semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Exactness of Type Inference</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#semantics-interfering-with-optimization">335</a></td>

          <td></td>

          <td>1</td>

          <td>formal-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>XPath/XQuery's current semantics greatly interferes
          with optimization</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#lang-inheritance">265</a></td>

          <td></td>

          <td>2</td>

          <td>FTTF-xml:lang</td>

          <td>decided</td>

          <td>xpath-fulltext</td>

          <td>How do we determine the xml:lang for a node if it
          inherits xml:lang from a higher-level node?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#lang-sublanguage-support">266</a></td>

          <td></td>

          <td>2</td>

          <td>FTTF-xml:lang</td>

          <td>decided</td>

          <td>xpath-fulltext</td>

          <td>Do we support the sublanguage portion of
          xml:lang?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-external-functions">124</a></td>

          <td></td>

          <td>o-1</td>

          <td>functions</td>

          <td>decided</td>

          <td>xquery</td>

          <td>External Functions</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#xquery-function-library">157</a></td>

          <td></td>

          <td>o-1</td>

          <td>functions</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Function Libraries</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#functions-parameter-evaluation">327</a></td>

          <td></td>

          <td>1</td>

          <td>functions</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Evaluate unused function parameters?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#external-function-definition">223</a></td>

          <td></td>

          <td>o-1</td>

          <td>functions external</td>

          <td>decided</td>

          <td>xquery</td>

          <td>We need a way to declare external functions</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0115">458</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>What is in the default context?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0116">459</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Serialization</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0149">492</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Derivation by extension in XQuery</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0150">493</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>May the content of a text node be the empty
          string?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0156">499</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Casting and validation</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0167">510</a></td>

          <td></td>

          <td>1</td>

          <td>Language</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Is validate working on sequences?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#lexical-representation-of-atomic-values">295</a></td>

          <td></td>

          <td>1</td>

          <td>lexical-representation</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Lexical Representation of Atomic Values</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#imported-schemas-used-function-signatures">537</a></td>

          <td></td>

          <td>1</td>

          <td>modules</td>

          <td>decided</td>

          <td>xquery</td>

          <td>What happens to imported schemas that are used in
          function signatures?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-module-syntax">74</a></td>

          <td></td>

          <td>o-1</td>

          <td>module-semantics</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Module syntax</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#xquery-import">75</a></td>

          <td></td>

          <td>o-1</td>

          <td>module-semantics</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Importing Modules</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-encoding">79</a></td>

          <td></td>

          <td>o-1</td>

          <td>module-syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Encoding</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#default-namespace-functions">228</a></td>

          <td></td>

          <td>o-2</td>

          <td>namespace functions</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Should we keep the default function namespace, and
          the xf: namespace?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#namespace-default-affecting">247</a></td>

          <td></td>

          <td>2</td>

          <td>namespaces</td>

          <td>decided</td>

          <td>xpath</td>

          <td>What does default namespace(s) affect?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#namespace-definitions-and-validate">319</a></td>

          <td></td>

          <td>1</td>

          <td>namespaces</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Namespace definitions and in-scope namespaces</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#namespaces-functions">343</a></td>

          <td></td>

          <td>1</td>

          <td>namespaces</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Do functions in the null namespace clash with
          functions in the default namespace?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#namespace-constructor">549</a></td>

          <td></td>

          <td>1</td>

          <td>namespaces</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Computed namespace-constructor</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#schema-import-multiple-times">564</a></td>

          <td></td>

          <td>1</td>

          <td>schema-import</td>

          <td>active</td>

          <td>xquery</td>

          <td>Loading same schema-component twice</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#text-constructor-empty-sequence">528</a></td>

          <td></td>

          <td>1</td>

          <td>semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Semantics of text constructor on empty sequence</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0138">481</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Semantics of Schema Context</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0153">496</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Support for lax and strict wildcards</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0094">437</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static type errors and warnings</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0098">441</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Implementation of and conformance levels for static
          type checking</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0107">450</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of data()</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0109">452</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of order by</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0110">453</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of element and attribute constructors</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0114">457</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Dynamic context for current date and time</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0118">461</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Data model syntax and literal values</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0130">473</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>When to process the query prolog</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0135">478</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of special functions</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0136">479</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Non-determinism in the semantics</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0139">482</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Type equivalence rules</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0141">484</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Treatment of nillability and xsi:nil</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0144">487</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Representation of text nodes in formal values</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0148">491</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Validation of an empty string against a string
          list</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0160">503</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Collations in the static environment</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0165">508</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Namespaces in element constructors</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0171">514</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Raising errors</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0177">520</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Coercion between untyped and atomic values</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0178">521</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of XPath 1.0 compatibility</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0180">525</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static context accessible from the dynamic
          context</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0100">443</a></td>

          <td></td>

          <td>1</td>

          <td>Semantics?</td>

          <td>active</td>

          <td>formal-semantics</td>

          <td>Namespace resolution</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#cdata-serialization">244</a></td>

          <td></td>

          <td>2</td>

          <td>serialization</td>

          <td>decided</td>

          <td>xquery</td>

          <td>CDATA sections and serialization</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#xquery-phantom-sortby">155</a></td>

          <td></td>

          <td>o-1</td>

          <td>sort</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Sorting by Non-exposed Data</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#sort-disappearing">243</a></td>

          <td></td>

          <td>3</td>

          <td>sort</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Provide an example of sorting "disappearing"</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#sort-by">251</a></td>

          <td></td>

          <td>2</td>

          <td>sort</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Sorting "input to loop", not the result</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#sort-in-FLWR">318</a></td>

          <td></td>

          <td>1</td>

          <td>sort</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Add 'order by' clause to FLWR?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#static-typing-fn-root">562</a></td>

          <td></td>

          <td>1</td>

          <td>static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>What static typing for fn:root?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0112">455</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Typing for the typeswitch default clause</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0129">472</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static typing of union</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0132">475</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Typing for descendant</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0145">488</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static typing of path expressions in the presence of
          derivation by extension</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0166">509</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static typing for validate</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0170">513</a></td>

          <td></td>

          <td>1</td>

          <td>Static typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Imprecise static type of constructed elements</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#xquery-escaping-quotes-and-apostrophes">144</a></td>

          <td></td>

          <td>o-1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Escaping Quotes and Apostrophes</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#nested-comments">246</a></td>

          <td></td>

          <td>2</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Nested XQuery comments allowed?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#SequenceType-problems">341</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Problems with SequenceType</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#sequence-type-path-alignment">532</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Alignment between path expressions and sequence
          types</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#lexical-state-tables">535</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Lexical state tables</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#grammar-declare">547</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Use "declare" for declarations</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#lexical-rules">548</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Lexical Rules: states normative?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#comments-location">550</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Location of Comments</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#processing-instruction-quotes">552</a></td>

          <td></td>

          <td>1</td>

          <td>syntax</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Should the quotes in processing-instruction("...") be
          optional?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#schema-types-from-input-documents">307</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>active</td>

          <td>xpath</td>

          <td>Schema Types from input documents?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#xpath-datatype-support">206</a></td>

          <td>T</td>

          <td>2</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Typing support in XPath</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#function-return-datatype">224</a></td>

          <td>T</td>

          <td>2</td>

          <td>types</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Why do we want to allow optional returns and
          DataType?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#binding">297</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Should XPath have "type binding" in variable?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#PSVI-Data-Model-mapping-normative">306</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>PSVI to Data Model mapping part of normative
          text?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#type-soundness">308</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Type Soundness</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#type-annotations-child-of-element">310</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Are the children of a newly constructed element
          typed?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#cardinality-typed-comparison">316</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Is anySimpleType = anySimpleType*?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#types-conformancelevels-same-results">320</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Should different conformance levels give the same
          result for the same query and data?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#element-def-not-in-in-scope">325</a></td>

          <td>T</td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Refering to element that is not in the in-scope
          schema def.</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#static-semantics-anySimpleType-untypedAtomic">526</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Semantics for anySimpleType and untypedAtomic</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#static-typing-index-expressions">527</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Static typing of XPath index expressions</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#cast-untypedAtomic-backward-compatibility-mode">539</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of fs:cast-untypedAtomic in backward
          compatibility mode</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#static-semantics-input-unions">540</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>How does the static semantics works in the case where
          the input types are unions?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#constructor-functions-user-types">551</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Constructor functions for unprefixed user defined
          types</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#treat-as-up-down-type-hierarchy">566</a></td>

          <td></td>

          <td>1</td>

          <td>types</td>

          <td>decided</td>

          <td>xpath</td>

          <td>"treat" should work up and down type hierarchy</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#schema-plural-data-types">524</a></td>

          <td></td>

          <td>1</td>

          <td>type semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Plural datatypes different from Singular *?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-define-schema-variants">43</a></td>

          <td>T</td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Defining Behavior for Well Formed, DTD, and Schema
          Documents</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#xquery-subtype-substitutability">47</a></td>

          <td>T</td>

          <td>2</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Subtype Substitutability</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#xquery-typeswitch-case-not-subtype">48</a></td>

          <td>T</td>

          <td>3</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>algebra</td>

          <td>CASE not a subtype</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xpath-lightweight-cast">279</a></td>

          <td>T</td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>Should there be a lightweight cast?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-failed-validation">334</a></td>

          <td>T</td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>How are documents for which validation has failed
          processed?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#input-and-schema-validation">523</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>input(), collection(), document(); validation
          semantics</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#type-copied-subelement">531</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Should discard the type of copied subelement</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#automatic-coersion-strict-or-not">533</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Strict static typing for automatic coercion of
          untyped atomic to atomic values</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#function-calls-and-expected-type">534</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Semantics of function calls and notion of "expected
          type"</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#static-type-empty-error">541</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Should it be a static error if an expression other
          than () has type empty?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#type-of-well-formed">542</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>What should be the type of an attribute or element
          that is well-formed but not validated, or is validated in
          skip mode?</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#xpath-matching-substitution-groups">543</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>How can a path expression match elements in the
          substitution group of a given element?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xpath-matching-types">544</a></td>

          <td></td>

          <td>1</td>

          <td>type-semantics</td>

          <td>decided</td>

          <td>xpath</td>

          <td>How can a path expression match nodes of a given
          type?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-type-syntax">56</a></td>

          <td>T</td>

          <td>3</td>

          <td>type-syntax</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Human-Readable Syntax for Types</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0103">446</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Complexity of interleaving</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0106">449</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Constraint on attribute and element content
          models</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0143">486</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Support for PI, comment and namespace nodes</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#FS-Issue-0158">501</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Support for XML Schema groups</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0173">516</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Typeswitch and type substitutability</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#FS-Issue-0176">519</a></td>

          <td></td>

          <td>1</td>

          <td>Typing</td>

          <td>decided</td>

          <td>formal-semantics</td>

          <td>Type of document node</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#validate-lax-strict">321</a></td>

          <td></td>

          <td>1</td>

          <td>validate</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Is validate strict or lax?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#validate-lax-strict-override">322</a></td>

          <td></td>

          <td>1</td>

          <td>validate</td>

          <td>decided</td>

          <td>xquery</td>

          <td>"validate" strict/lax override?</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#default-validation-mode">530</a></td>

          <td></td>

          <td>1</td>

          <td>validation</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Default default validation mode</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href="#declaring-variables-in-prolog">250</a></td>

          <td></td>

          <td>2</td>

          <td>variables</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Declaring Variables in Prolog</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#whitespace-in-element-constructors">191</a></td>

          <td></td>

          <td>o-1</td>

          <td>whitespace</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Whitespace handling in element constructors</td>

          <td></td>
        </tr>

        <tr>
          <td><a href=
          "#whitespace-attribute-constructors">311</a></td>

          <td></td>

          <td>1</td>

          <td>whitespace</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Whitespace and Attribute Constructors</td>

          <td></td>
        </tr>

        <tr style="background-color:#FFA">
          <td><a href=
          "#whitespace-character-reference">338</a></td>

          <td></td>

          <td>1</td>

          <td>whitespace</td>

          <td>decided</td>

          <td>xquery</td>

          <td>Handling of whitespace and character references</td>

          <td></td>
        </tr>

        <tr>
          <td><a href="#xquery-abql">152</a></td>

          <td></td>

          <td>o-1</td>

          <td>xqueryx</td>

          <td>active</td>

          <td>xqueryx</td>

          <td>XML-based Syntax</td>

          <td></td>
        </tr>
      </table>
      <hr />

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>293. <a name="cdata-charref-semantics" id=
        "cdata-charref-semantics"><u>cdata-charref-semantics</u>:
        Cdata and CharRef Semantics</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: Priority: <b>1</b>
          Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Cdata and CharRef
          Semantics

          <h3><a name="id-issue-N52409" id=
          "id-issue-N52409"></a>Description</h3>

          <div>
            <p>The data model cannot represent CDATA or CharRef,
            since the Information Set looses this information.</p>
          </div>

          <h3><a name="id-issue-N5240C" id=
          "id-issue-N5240C"></a>Proposed Resolution</h3>

          <div>
            <p>The XQuery document should make it clear that:</p>

            <p>1. CDATA sections and CharRefs inside XQueries that
            are not embedded inside XML (which is what the XQuery
            document only talks about), are syntactic helps to
            write queries that otherwise would need entitization
            (in the case if CDATA sections) or a unicode input
            device (CharRefs).</p>

            <p>2. Implementations can chose to use this information
            as serialization hints to preserve the CDATA and
            entitization.</p>
          </div>

          <h3><a name="id-issue-N52414" id=
          "id-issue-N52414"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to close, with document changes as described
            by Mike Kay in <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
            including editorial comments.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>444. <a name="FS-Issue-0101" id=
        "FS-Issue-0101"><u>FS-Issue-0101</u>: Support for mixed
        content in the type system</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: Priority:
          <b>1</b> Status: <b>decided</b><br />
          Originator: <b>FS Editors</b></small>Support for mixed
          content in the type system

          <h3><a name="id-issue-N5350A" id=
          "id-issue-N5350A"></a>Description</h3>

          <div>
            <p>Support for mixed content in the type system is an
            open issue. This reopens issue [resolved issue
            #FS-Issue-0016]. Dealing with mixed content with
            interleaving raises complexity issue. See also <a href=
            "#FS-Issue-0103">#FS-Issue-0103</a>.</p>
          </div>

          <h3><a name="id-issue-N53513" id=
          "id-issue-N53513"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>The formal semantics is a specification of the
            behavior of an XQuery processor, not a recipe for
            implementation. The uses of interleaving in the
            specification are sufficiently restricted that a
            practical implementation can be written.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>96. <a name="xquery-normalized-equality" id=
        "xquery-normalized-equality"><u>xquery-normalized-equality</u>:
        Normalized Equality</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster:
          <b>(in)equality-operators</b> Priority: <b>o-1</b>
          Status: <b>decided</b><br />
          Originator: <b>Mary Fernandez</b></small>Normalized
          Equality

          <h3><a name="id-issue-N50ADE" id=
          "id-issue-N50ADE"></a>Description</h3>

          <div>
            <p>When elements are compared, are comments and PIs
            considered in the comparison? How is whitespace
            handled? Do we need to allow more than one way to
            handle these in comparisons?</p>
          </div>

          <h3><a name="id-issue-N50AE1" id=
          "id-issue-N50AE1"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0078.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0078.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-03
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0025.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0025.html
            (W3C-members only)</a>)</small>The XSL WG is not
            agreeable to blessing this.</p>

            <p>"When elements are compared, are comments and PIs
            considered in the comparison?": NO</p>

            <p>"How is whitespace handled?": This depends on the
            whitespace in the instance as per the data model.</p>

            <p>"Do we need to allow more than one way to handle
            these in comparisons?": NO, not in XPath 2.0/XQuery
            1.0.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>114. <a name="xquery-xpath-axes" id=
        "xquery-xpath-axes"><u>xquery-xpath-axes</u>: XPath
        Axes</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>axes</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>XPath Axes

          <h3><a name="id-issue-N50D3A" id=
          "id-issue-N50D3A"></a>Description</h3>

          <div>
            <p>XPath supports 13 axes. The current Working Draft
            says that XQuery will support a subset of these axes,
            including at least those axes required by the
            abbreviated syntax. The definitive set of axes to be
            supported by XQuery has not yet been determined. In the
            current Working Draft, the examples use abbreviated
            syntax, but the grammar supports unabbreviated
            syntax.</p>

            <p>For the axes required by the abbreviated syntax,
            should XQuery allow both the unabbreviated and
            abbreviated syntax? If we decide not to support
            additional axes, no new functionality would be added by
            supporting the unabbreviated syntax. Opinions vary as
            to whether the unabbreviated syntax is clearer.</p>
          </div>

          <h3><a name="id-issue-N50D3F" id=
          "id-issue-N50D3F"></a>Proposed Resolution</h3>

          <div>
            <p>Text is in Working Draft 2001-11-28 sec 2.3.</p>
          </div>

          <h3><a name="id-issue-N50D43" id=
          "id-issue-N50D43"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2002-01-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Jan/0067.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Jan/0067.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-01-23
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Jan/0345.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Jan/0345.html
            (W3C-members only)</a>)</small></p>

            <p>Acceptance of text in December 2001 published
            Working Draft.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-07-17
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Jul/0329.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Jul/0329.html
            (W3C-members only)</a>)</small> Decided: additional
            axes will not be included in XQuery Version 1.</p>

            <p>The XML Query WG has decided not to support the full
            set of XPath axes in Version 1. We are trying to keep
            XQuery small, and that means we want to avoid providing
            the same functionality in multiple ways unless there is
            a compelling reason to do so. We also felt that we
            could easily add the full set of axes in future
            versions if users clearly demand it.</p>

            <p>Experienced XPath users leverage the full set of
            axes to express complex queries. In examining many
            XPath expressions, we have found that they can be
            expressed in XQuery using other features, often using
            FLWR expressions. The two different approaches use
            different idioms, and are based on different
            programming models. We decided not to try to support
            both models, because it increases the learning required
            to master the entire language, and increases the
            probability that distinct user communities will evolve,
            and they will have difficulty reading each other's
            queries.</p>

            <p>Another reason for not supporting the axes in
            Version 1 is that they have a lot of semantics, and
            these can be a burden for an optimizer. An
            implementation may well be able to do precedes or
            follows efficiently without an efficient way to perform
            all the enumerations required by the axes. For
            instance, an implementation may be able to efficiently
            determine whether one node is before another node
            (which means it supports 'precedes' efficiently), yet
            still have no efficient way of listing all nodes that
            precede a given node in reverse order (which is
            required to support the 'preceding' axis). And these
            axes come in pairs, so an implementation must be able
            to enumerate the nodes in either document order or
            reverse document order. Interactions between forward
            and reverse axes can also be tricky for query
            optimizers.</p>

            <p>We also note that it is easy to write a function
            library that mimics the axes.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-06-25
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0031.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0031.html
            (W3C-members only)</a>)</small></p>

            <p>Consensus of the XQuery group to make all of the
            axes (minus namespace) optional as a set (all or
            nothing).</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>328. <a name="cdata-section" id=
        "cdata-section"><u>cdata-section</u>: What does CDATA
        section constructor construct?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>cdata section</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>What does CDATA
          section constructor construct?

          <h3><a name="id-issue-N528EB" id=
          "id-issue-N528EB"></a>Description</h3>

          <div>
            <p>Section 3.7.5 describes CDATA section constructor,
            but these cannot be represented in the data model.</p>
          </div>

          <h3><a name="id-issue-N528EE" id=
          "id-issue-N528EE"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to close, with document changes as described
            by Mike Kay in <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
            including editorial comments.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>257. <a name="collection-always-return-same" id=
        "collection-always-return-same"><u>collection-always-return-same</u>:
        Does collection() always return same result?</a></h2>

        <div>
          <small>Issue Class: <b>D</b> Locus: <b>xpath</b> Cluster:
          <b>collections</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Does collection()
          always return same result?

          <h3><a name="id-issue-N51EFF" id=
          "id-issue-N51EFF"></a>Description</h3>

          <div>
            <p>Does collection() always return same result for the
            same URI? The same within the scope of a
            query/transformation? Are the nodes in the sequence
            identical?</p>
          </div>

          <h3><a name="id-issue-N51F02" id=
          "id-issue-N51F02"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-10-23
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0467.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0467.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-31
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html
            (W3C-members only)</a>)</small></p>

            <p>It should return the same answer every time. Applies
            also to input(). We should use the same language as we
            use for document() and for current-dateTime().</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>561. <a name="normativity-external-internal-mapping"
        id="normativity-external-internal-mapping"><u>normativity-external-internal-mapping</u>:
        Normativity of External Mappings</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>conformance</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Normativity of
          External Mappings

          <h3><a name="id-issue-N54328" id=
          "id-issue-N54328"></a>Description</h3>

          <div>
            <p>Our specifications describe three mappings between
            the Query Processing environment and the External
            Processing environment: (1) the Data Model provides
            optional mappings from a PSVI or Infoset to a Data
            Model Instance; (2) the Serialization specification
            provides optional mappings from a Data Model Instance
            to serialized XML; (3) the Formal Semantics provides
            optional mappings from an XML Schema to the In-Scope
            Schema Definitions.</p>

            <p>How normative are these mappings?</p>

            <p>The following alternatives seem plausible:</p>

            <p>1. The mappings are purely informative.</p>

            <p>2. Implementations may choose whether to conform to
            one or more of these mappings, which will be identified
            by name.</p>

            <p>3. As an aid to conformance testing, implementations
            are required to support a mode in which these mappings
            are available as specified.</p>

            <p>Are there other alternatives we should consider?
            What are the relative advantages of these
            approaches?</p>
          </div>

          <h3><a name="id-issue-N54337" id=
          "id-issue-N54337"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-07-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0092.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0092.html
            (W3C-members only)</a>)</small></p>

            <p>The mappings are non-normative.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>546. <a name="conformance-levels" id=
        "conformance-levels"><u>conformance-levels</u>: Are there
        more processing model options that could make sense as
        consistent features and thus as conformance
        levels?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster:
          <b>conformance-levels</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>Processing Model TF</b></small>Are there
          more processing model options that could make sense as
          consistent features and thus as conformance levels?

          <h3><a name="id-issue-N5411E" id=
          "id-issue-N5411E"></a>Description</h3>

          <div>
            <p>Are there more processing model options that could
            make sense as consistent features and thus as
            conformance levels? What types can these "predefine" in
            the static context? Do these options have the
            desired/expected interoperability characteristics?</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>286. <a name="element-construction-vs-streaming" id=
        "element-construction-vs-streaming"><u>element-construction-vs-streaming</u>:
        Element Construction vs Streaming</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>constructor-expr</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Element
          Construction vs Streaming

          <h3><a name="id-issue-N5230B" id=
          "id-issue-N5230B"></a>Description</h3>

          <div>
            <p>The element construction rules in 2.8 make efficient
            streaming of element construction difficult/impossible.
            For example, we execute the following expression on a
            stream and serialize the result in a streaming
            processing (such as XSLT like applications):</p>

            <p>&lt;foo&gt;{"foo", "bar", if (expr) then "baz" else
            &lt;baz/&gt;}&lt;/foo&gt;</p>

            <p>If expr is true, then this is serialized:</p>

            <p>&lt;foo&gt;foo bar baz&lt;/foo&gt;</p>

            <p>If expr is false, then this is serialized:
            &lt;foo&gt;foobar&lt;baz/&gt;&lt;/foo&gt;</p>

            <p>The implementation must cache up the "foo" and "bar"
            strings, just in case a sub-element node is
            constructed. If not, then I must insert a space between
            "foo" and "bar". This seems to contradict one of our
            explicit use scenarios in the XML Query Requirements
            (section 2.5).</p>
          </div>

          <h3><a name="id-issue-N52318" id=
          "id-issue-N52318"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N5231D" id=
          "id-issue-N5231D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0078.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0078.html
            (W3C-members only)</a>)</small></p>

            <p>This issue has been addressed by the recent changes
            to the element constructor.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>290. <a name="element-attribute-constructor-name-type"
        id=
        "element-attribute-constructor-name-type"><u>element-attribute-constructor-name-type</u>:
        Element Attribute Constructor Name Type</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>constructor-expr</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Element Attribute
          Constructor Name Type

          <h3><a name="id-issue-N523A2" id=
          "id-issue-N523A2"></a>Description</h3>

          <div>
            <p>Does the name expression on dynamically computed
            names in element/attribute constructors be of type
            QName without implicit cast from string, QName with
            implicit cast from string, or string?</p>
          </div>

          <h3><a name="id-issue-N523A5" id=
          "id-issue-N523A5"></a>Proposed Resolution</h3>

          <div>
            <p>If the name is constructed by an expression, the
            expected type is xs:QName. Xs:string is in general
            implicitly cast to xs:QName (and xs:anyURI).</p>
          </div>

          <h3><a name="id-issue-N523A9" id=
          "id-issue-N523A9"></a>Proposed Resolution</h3>

          <div>
            <p>(1) In Section 3.7.1 ("Direct Element
            Constructors"), modify the paragraph below the first
            example as follows:</p>

            <p>"Unqualified element names used in a direct element
            constructor are implicitly qualified by the default
            namespace for element names. In a direct element
            constructor, the name used in the end tag must exactly
            match the name used in the corresponding start tag
            (including its prefix or absence of a prefix)."</p>

            <p>(2) In Section 3.7.2.1 ("Computed Element
            Constructors"), add a new first paragraph as
            follows:</p>

            <p>"The name expression of a computed element
            constructor is processed as follows:</p>

            <p>1. If the name expression returns a QName, that
            QName is used as the name of the constructed element.
            If the QName returned by the name expression is
            unqualified, the name of the constructed element is in
            default namespace for element names.</p>

            <p>2. If the name expression returns a string, that
            string is implicitly cast to a QName by using the
            fn:QName-in-context function with its $use-default
            parameter set to True. The resulting QName is used as
            the name of the constructed element.</p>

            <p>3. If the name expression does not return a QName or
            a string, a dynamic error is raised."</p>

            <p>(3) In Section 3.7.2.2 ("Computed Attribute
            Constructors"), add a new first paragraph as
            follows:</p>

            <p>"The name expression of a computed attribute
            constructor is processed as follows:</p>

            <p>1. If the name expression returns a QName, that
            QName is used as the name of the constructed attribute.
            If the QName returned by the name expression is
            unqualified, the name of the constructed attribute is
            in no namespace.</p>

            <p>2. If the name expression returns a string, that
            string is implicitly cast to a QName by using the
            fn:QName-in-context function with its $use-default
            parameter set to True. The resulting QName is used as
            the name of the constructed attribute.</p>

            <p>3. If the name expression does not return a QName or
            a string, a dynamic error is raised."</p>
          </div>

          <h3><a name="id-issue-N523C3" id=
          "id-issue-N523C3"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>x-editors</b> on 2003-02-05
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0010.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0010.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Recommend Don's proposal as the closure of this
            issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>529. <a name="node-identity-modeling" id=
        "node-identity-modeling"><u>node-identity-modeling</u>:
        Node identity in the formal semantics</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>constructor-expr</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>Node identity in
          the formal semantics

          <h3><a name="id-issue-N53ED6" id=
          "id-issue-N53ED6"></a>Description</h3>

          <div>
            <p>The fs currently does not model node identity. The
            position of the formal semantics editors is that a
            formal semantics need not model everything. So it is
            not absolutely required that we model node identity,
            though it would be desirable for us to do so, not least
            because a clear description of node identity may help
            clarify the semantics of update. The formal semantics
            should include a mode of node identity if time
            permits.</p>
          </div>

          <h3><a name="id-issue-N53ED9" id=
          "id-issue-N53ED9"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Decided to define node identity in the Formal
            Semantics. Required some editorial work to be done.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>329. <a name="duplicate-attribute-constructors" id=
        "duplicate-attribute-constructors"><u>duplicate-attribute-constructors</u>:
        Duplicate attribute constructors</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>constructors</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>Duplicate attribute
          constructors

          <h3><a name="id-issue-N52904" id=
          "id-issue-N52904"></a>Description</h3>

          <div>
            <p>If there are multiple constructors for the same
            attribute on an element; which one is taken or is it an
            error?</p>
          </div>

          <h3><a name="id-issue-N52907" id=
          "id-issue-N52907"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to make it an error for an element
            constructor to specify two attributes with the same
            name. Error to be documented in XQuery Section
            3.7.4.1.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>258. <a name="document-nodes-identity" id=
        "document-nodes-identity"><u>document-nodes-identity</u>:
        Identity of Document Nodes</a></h2>

        <div>
          <small>Issue Class: <b>D</b> Locus: <b>xpath</b> Cluster:
          <b>documents</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Identity of
          Document Nodes

          <h3><a name="id-issue-N51F1E" id=
          "id-issue-N51F1E"></a>Description</h3>

          <div>
            <p>Consider the following query:</p>

            <div class="exampleInner">
              <pre>
        if (document("foo.com") == document("foo.com"))
                then &lt;yep/&gt;
                else &lt;nope/&gt;
</pre>
            </div>

            <p>I would like the following output:</p>

            <div class="exampleInner">
              <pre>
        &lt;yep/&gt;
</pre>
            </div>

            <p>I think we can achieve this if we say that the URI
            of a resource is used as its identity. However, one
            resource can be identified by more than one URI.
            Suppose that "foo.com/here/there/hi.xml" and
            "file://c:/temp/limerick-tei.xml" refer to the same
            resource. What does the following return?</p>

            <div class="exampleInner">
              <pre>
if (document("foo.com/here/there/hi.xml") ==
document("file://c:/temp/limerick-tei.xml"))
        then &lt;yep/&gt;
        else &lt;nope/&gt;
</pre>
            </div>

            <p>Should we simply use the URI of the parameter to
            establish identity and say that the two do not match?
            Should we make the result implementation-dependent?</p>
          </div>

          <h3><a name="id-issue-N51F2D" id=
          "id-issue-N51F2D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-10-23
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0467.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0467.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-31
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html
            (W3C-members only)</a>)</small></p>

            <p>This is already covered by the existing spec, but we
            may want to review the language as part of the actions
            for issue 257.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>554. <a name="what-is-normative" id=
        "what-is-normative"><u>what-is-normative</u>: What is the
        really normative text?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>editorial</b>
          Priority: <b>1</b> Status: <b>active</b><br />
          Originator: <b>XPath TF</b></small>What is the really
          normative text?

          <h3><a name="id-issue-N54274" id=
          "id-issue-N54274"></a>Description</h3>

          <div>
            <p>Some normative material in XPath/XQuery
            specifications occurs in more than one location. The
            specifications need to be clear which of the replicated
            material is the unique normative definition to ensure
            ease of implementation and avoid conflicts.</p>
          </div>

          <h3><a name="id-issue-N54277" id=
          "id-issue-N54277"></a>Proposed Resolution</h3>

          <div>
            <p>The language book(s) and the Formal Semantics book
            define together what the semantics of the XQuery 1.0
            and XPath 2.0 languages is.</p>

            <p>However, there is often duplication (the language
            book(s) using English while the FS book uses formal
            notations), and often one document is more specific
            than the other (for instance the static typing optional
            feature is mostly described in the FS document). In
            addition, despite all our hard work some
            inconsistencies are probably still lurking. Finally, we
            need to deal with the question about which part of the
            documents is going to be normative.</p>

            <p>Here is a small proposal, laying out a plan to deal
            with those issues. This plan was discussed at last
            week's FS editors call, people liked it, and that I was
            actioned to write it down.</p>

            <p>The proposal</p>

            <p>(1) For all expressions in the language, the
            language book should clearly specify in English prose
            the dynamic semantics of the expression. This English
            text will serve as the normative version for the
            dynamic semantics.</p>

            <p>(2) For all expressions, the formal semantics book
            should have dynamic rules which align with (1)
            above.</p>

            <p>(3) For all expressions in the language, the
            corresponding section in the language book should point
            to the corresponding FS section which contain the
            formal rules.</p>

            <p>(4) For all expressions, the formal semantics book
            should have static rules which specify the static
            semantics of the language. Those formal rules will
            serve as the normative version for the static
            semantics.</p>

            <p>This plan will obviously require some significant
            work on our documents, but we believed this would solve
            all of our alignment/normative problems and improve the
            quality of our specifications.</p>
          </div>

          <h3><a name="id-issue-N5428B" id=
          "id-issue-N5428B"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Accepting this general approach and the details with
            respect to the Formal Semantics. Similar to be worked
            out for the</p>

            <p>"language books" and Datamodel</p>

            <p>"language books" and Functions and Operators</p>

            <p>Functions and Operators and Formal Semantics</p>

            <p>The links that we will put into the documents need
            to be bi-directional.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>339. <a name="element-attribute-construction-order" id=
        "element-attribute-construction-order"><u>element-attribute-construction-order</u>:
        Error type for attributes constructed too late</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>errors</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Error type for
          attributes constructed too late

          <h3><a name="id-issue-N52A2E" id=
          "id-issue-N52A2E"></a>Description</h3>

          <div>
            <p>What kind of error should be raised by an element
            constructor in which an attribute is encountered after
            other element content?</p>
          </div>

          <h3><a name="id-issue-N52A31" id=
          "id-issue-N52A31"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>This a type error. Type error to be documented in
            XQuery Section 3.7.2.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>340. <a name="errors-unique-identification" id=
        "errors-unique-identification"><u>errors-unique-identification</u>:
        How to identify errors?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>errors</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>How to identify
          errors?

          <h3><a name="id-issue-N52A44" id=
          "id-issue-N52A44"></a>Description</h3>

          <div>
            <p>How should we allocate codes or identifiers to
            errors defined in the spec? We should not use
            "explanatory sentences" as these are not appropriate
            for I18N reasons.</p>
          </div>

          <h3><a name="id-issue-N52A47" id=
          "id-issue-N52A47"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xsl</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>(not really an issue); Ashok and Norm will
            investigate whether we can editorially markup errors
            consistently.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-01-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0101.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0101.html
            (W3C-members only)</a>)</small></p>

            <p>Issue should remain open pending proposal on: ACTION
            XPATH-091-11 Mary adds herself to XPATH-091-11.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-04-08
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0075.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0075.html
            (W3C-members only)</a>)</small></p>

            <p>1. All occurrences of static and dynamic errors
            should be identified in the F&amp;O, DM, language, and
            FS specs using distinguished error markup.</p>

            <p>2. Error markup should include unique alpha-numeric
            identifier for each error which permits the source to
            refer to unique error definitions and to include
            reverse indices on errors.</p>

            <p>3. In first cut, alpha-numeric error codes will not
            be revealed in printed documents, but we can reveal
            them at a later time if we decide to make error codes
            part of conformance requirements.</p>

            <p>4. Until we consider an API for conveying errors to
            the evaluation environment, we recommend *not*
            requiring implementations to return specific error
            codes (and possibly additional context info such as
            location of error in query body or name of built-in
            function, etc.)</p>

            <p><small>Decision by: <b>xquery</b> on 2003-04-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0247.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0247.html
            (W3C-members only)</a>)</small> with amendment: instead
            of tying the codes to conformance, we are suggesting to
            publish these in a non-normative appendix so
            implementers can use them if see fit</p>

            <p><small>Decision by: <b>xquery</b> on 2003-04-30
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0007.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0007.html
            (W3C-members only)</a>)</small></p>

            <p>The XML Query WG has agreed that errors be
            identified with a code and and some English text as
            recommended by the I18N folks. The XSL WG has not
            discussed this yet.</p>

            <p>The markup suggested for errors:</p>

            <div class="exampleInner">
              <pre>
        &lt;error id="code&gt; English text &lt;/error&gt;
</pre>
            </div>

            <p>seems fine, but we need to decide how to assign the
            codes.</p>

            <p>Jim Melton suggessted 5 or 6 digit fixed length
            codes partitioned in some manner to indicate the type
            of error:
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0259.html</p>

            <p>Liam Quin suggested words separated by hyphens:
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0267.html</p>

            <p>Mike Kay would like them to be QNames: unprefixed in
            the case of codes defined by W3C, namespace-prefixed in
            the case of implementation-defined or user-defined
            codes. See
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0284.html</p>

            <p>SUGGESTION ON HOW TO MOVE FORWARD Since the error
            codes will encompass the language documents, the
            F&amp;O and possibly the formal semantics we need folks
            representing all these constituencies to decide on the
            structure of the error codes and how to partition them.
            I suggest a small task force to address this. This
            taskforce would also address the issue of the
            non-normative appendix and where it should reside.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>553. <a name="dynamic-errors-reported-statically" id=
        "dynamic-errors-reported-statically"><u>dynamic-errors-reported-statically</u>:
        Rules for reporting dynamic errors statically</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>errors</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL WG</b></small>Rules for reporting
          dynamic errors statically

          <h3><a name="id-issue-N54240" id=
          "id-issue-N54240"></a>Description</h3>

          <div>
            <p>Under what circumstances can a dynamic error
            detected early be reported statically, for example if
            it occurs in code that might not be executed. A host
            language may determine this, e.g. an &lt;xsl:if&gt;
            construct.</p>
          </div>

          <h3><a name="id-issue-N54243" id=
          "id-issue-N54243"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N54246" id=
          "id-issue-N54246"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>As just a minor addition to the doc is needed and
            the other addition is the raise of the following other
            error: a constructor function with a constant argument
            that is not in the lexical space it was decided to
            close this issue.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-07-08
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0032.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0032.html
            (W3C-members only)</a>)</small></p>

            <p>Adopted the actual text in <a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jun/0087.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jun/0087.html</a>.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Wording reviewed and accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>563. <a name="static-error-evaluate-dynamically" id=
        "static-error-evaluate-dynamically"><u>static-error-evaluate-dynamically</u>:
        Is dynamic evaluation performed if error in static
        analysis?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>errors</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Is dynamic
          evaluation performed if error in static analysis?

          <h3><a name="id-issue-N54385" id=
          "id-issue-N54385"></a>Description</h3>

          <div>
            <p>Is the dynamic evaluation phase performed only after
            successful completion of the static analysis phase or
            whether it can continue even after a static type
            error.</p>
          </div>

          <h3><a name="id-issue-N54388" id=
          "id-issue-N54388"></a>Proposed Resolution</h3>

          <div>
            <p>Proposed Resolution: allowing to continue after
            static type error can be considered a dynamic typing
            implementation with a static typing compiler flag (like
            C's lint). Reason: You would still need to perform
            dynamic typing. Such an implementation should be
            possible but not required or even described by the
            spec.</p>
          </div>

          <h3><a name="id-issue-N5438C" id=
          "id-issue-N5438C"></a>Proposed Resolution</h3>

          <div>
            <p>Proposed resolution:</p>

            <p>In 2.2.3.2 Dynamic Evaluation Phase, change current
            text:</p>

            <p>&lt;current_text&gt; The dynamic evaluation phase is
            performed only after successful completion of the
            static analysis phase. &lt;/current_text&gt;</p>

            <p>to:</p>

            <p>&lt;new_text&gt; The dynamic evaluation phase occurs
            after the static analysis phase only if the static
            analysis phase does not raise any non-type static
            errors. &lt;xquery_only&gt; If the Static Typing
            Feature is in effect, dynamic evaluation occurs only if
            the static analysis phase does not raise any static
            (non-type and type) errors. &lt;/new_text&gt;</p>

            <p>Rationale: In the absence of static typing, all type
            errors must be detected dynamically. Thus, even if a
            type error is detected statically, it should not
            prevent dynamic evaluation. However, when static typing
            is in effect, *all* type errors are static errors, thus
            any static error should prevent dynamic evaluation.</p>

            <p>This resolution requires that static typing behave
            as it does in other high-level languages. If an
            implementor wants to provide a "lint-like" feature,
            they can do so by optionally reporting type errors
            during static analysis.</p>
          </div>

          <h3><a name="id-issue-N5439C" id=
          "id-issue-N5439C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small></p>

            <p>Mary's text adopted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>317. <a name="extension-mechanism" id=
        "extension-mechanism"><u>extension-mechanism</u>: XQuery
        Extension Mechanisms</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>extensions</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Andrew Eisenberg</b></small>XQuery
          Extension Mechanisms

          <h3><a name="id-issue-N5273D" id=
          "id-issue-N5273D"></a>Description</h3>

          <div>
            <p>Issue: XQuery has not determined what extension
            mechanisms might be supported. XQuery may support the
            following:</p>

            <ul>
              <li>implementation-defined extensions to the XQuery
              grammar</li>

              <li>an XQuery-flagger that identifies extensions to
              XQuery 1.0</li>

              <li>implementation-defined extensions to the
              functions that are available to</li>

              <li>an XQuery author. The author would be required to
              explicitly declare the</li>

              <li>namespaces of any extension functions that are
              used</li>
            </ul>
          </div>

          <h3><a name="id-issue-N5274B" id=
          "id-issue-N5274B"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N52752" id=
          "id-issue-N52752"></a>Proposed Resolution</h3>

          <div>
            <div class="exampleInner">
              <pre>
This proposal adds the following to the XQuery language document (in
section 2.5 Errors and Conformance):


2.5.5 Extensions

Conforming XQuery implementations are permitted to make two different kinds
of extensions to the specifications: grammar extensions and semantic
extensions. There are two types of grammar extensions: pragmas and
must-understand extensions. While an XQuery implementation may support some
or all of these types of extensions, this does not negate the requirement
to support the XQuery functionality defined in this specification.


2.5.5.1 Pragmas

A pragma may be used to provide additional information to an XQuery
implementation.

[x1]  Pragma            ::=   "(::" "pragma" PragmaQName PragmaContents
"::)"

[x2]  PragmaQName       ::=   ExplicitQName

[x3]  ExplicitQName     ::=   QName

[x4]  PragmaContents    ::=   .*

An ExplicitQName requires that QName contain a Prefix. Pragmas may be used
anywhere that ignorable whitespace is allowed, and within element content.
See A.1 Lexical structure for the exact lexical states where pragmas are
recognized. A pragma is identified by its PragmaQName.

If an implementation does not support a pragma, then that pragma shall be
ignored. If an implementation does support a pragma and the implementation
determines that the PragmaContents are invalid, then a static error is
raised. Otherwise, the effect of the pragma on the result of the Query is
implementation-defined.

The following example shows how a pragma might be used:

   declare namespace exq = "http://example.org/XQueryImplementation"

   (:: pragma exq:timeout 1000 ::)

   count(input()//author)

An implementation that supports the exq:timeout pragma might raise a
dynamic  error if it is unable to count the authors within 1000 seconds. An
implementation that did not support this pragma would execute as long as
necessary to count the authors.


2.5.5.2 Must-Understand Extensions

An implementation may extend the XQuery grammar by supporting
must-understand extensions.

[y1]  MustUnderstandExtension ::=
            "(::" "extension" ExtensionQName ExtensionContents "::)"

[y2]  ExtensionQName          ::=   ExplicitQName

[y3]  ExtensionContents ::=   .*

A MustUnderstandExtension may be used anywhere that ignorable whitespace is
allowed, and within element content. See A.1 Lexical structure for the
exact lexical states where pragmas are recognized. A must-understand
extension is identified by its ExtensionQName.

If an implementation does not support a must-understand extension, then a
static error is raised. If an implementation does support an
must-understand extension and the implementation determines that the
ExtensionContents are invalid, then a static error is raised. Otherwise,
the effect of the must-understand extension on the result of the Query
being executed is implementation-defined.

The following example shows how a must-understand extension might be used:

   declare namespace exq = "http://example.org/XQueryImplementation"

   for $e in doc("employees.xml")//employee
   order by $e/lastname (:: extension exq:RightToLeft ::)
   return $e

An implementation that supports the exq:RightToLeft must-understand
extension might order the last names by examining characters from right to
left instead of left to right. An implementation that did not support this
must-understand extension would raise a static error.


2.5.5.3 Semantic Extensions

An implementation may extend XQuery by supporting semantic extensions. A
semantic extension allows a conforming Query to be processed in a
non-conforming way. The way in which such semantic extensions are enabled
is implementation-defined.

The effect of a semantic extension on the result of a Query is
implementation-defined.

The following example shows how a command line might be used to enable a
semantic extension:

   xquery q12.xquery
   98

   xquery q12.xquery -EmptyIdentity=on
   100

The execution of the query contained in q12.xquery might treat an empty
sequence as 0 when it is being used in addition and subtraction and treat
it as 1 when it is being used in multiplication and division.


2.5.5.4 XQuery Flagger

An XQuery Flagger is a facility that is provided by an implementation that
is able to identify queries that contain extensions other than pragmas. If
an implementation supports extensions other than pragmas, then an XQuery
Flagger must be provided. The XQuery Flagger is disabled by default; the
mechanism by which the XQuery Flagger is enabled is implementation-defined.
When enabled, the XQuery Flagger will raise a static error for an otherwise
valid Query that contains either must-understand extensions or semantic
extensions.

An XQuery Flagger is provided to assist programmers in producing queries
that are portable among multiple conforming XQuery implementations.

The following examples show how an XQuery Flagger might be used:

   xquery q10.xquery
   &lt;employee&gt; ... &lt;/employee&gt;

   xquery q10.xquery -Flagger=on
   [static error] A must-understand extension is being used:
   exq:RightToLeft

   xquery q12.xquery -EmptyIdentity=on
   100

   xquery q12.xquery -EmptyIdentity=on -Flagger=on
   [static error] A semantic extension is being used: EmptyIdentity
</pre>
            </div>

            <p>Updates to proposal:</p>

            <p>- Usage of (:: ::) syntax.</p>

            <p>- must-understand extension.</p>
          </div>

          <h3><a name="id-issue-N5275C" id=
          "id-issue-N5275C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-03-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html
            (W3C-members only)</a>)</small></p>

            <p>#1 PRAGMAS: Adopted Unanimously.</p>

            <p>#2 MUST-UNDERSTAND EXTENSIONS: Adopted.</p>

            <p>#3 SEMANTIC EXTENSIONS: Rejected.</p>

            <p>#4 FLAGGER: Adopted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>538. <a name="keyword-extensions" id=
        "keyword-extensions"><u>keyword-extensions</u>: Can (and
        should) keyword extensions be allowed in XQuery by
        equipping them with a namespace prefix?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>extensions</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Peter Fankhauser</b></small>Can (and
          should) keyword extensions be allowed in XQuery by
          equipping them with a namespace prefix?

          <h3><a name="id-issue-N53FF9" id=
          "id-issue-N53FF9"></a>Description</h3>

          <div>
            <p>Can (and should) keyword extensions be allowed in
            XQuery by equipping them with a namespace prefix?</p>

            <p>Example:</p>

            <div class="exampleInner">
              <pre>
declare namespace my = http://example.com/myextensions

for $e in document ("employees.xml")//employee
order by $e/lastname my:fastorder
return $e
</pre>
            </div>

            <p>The advantage of this is that namespaces are a
            well-established concept for extending vocabularies,
            and different prefixes may be used for multiple
            extensions (my:fastorder vs. real:fastorder). The
            possible disadvantage may be that namespaces are
            regarded as too clumsy for this purpose.</p>

            <p>Note that using namespaces for keyword extensions
            does not appear to provide a generic mechanism to make
            the XQuery grammar extensible (one cannot simply allow
            a sequence of Qnames at arbitrary places without
            running into ambiguities). An implementation providing
            some extensions still needs to modify the XQuery
            grammar accordingly. However this also holds for the
            other two options, unless "x-" is added to the reserved
            keywords.</p>
          </div>

          <h3><a name="id-issue-N54004" id=
          "id-issue-N54004"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N54009" id=
          "id-issue-N54009"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-03-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html
            (W3C-members only)</a>)</small></p>

            <p>The decision for <a href=
            "#extension-mechanism">#extension-mechanism</a> also
            covers this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>272. <a name="external-functions" id=
        "external-functions"><u>external-functions</u>: External
        Functions</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster:
          <b>external-functions</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>External Functions

          <h3><a name="id-issue-N52143" id=
          "id-issue-N52143"></a>Description</h3>

          <div>
            <p>The ability to call external functions is an
            established feature of XSLT 1.0, and is retained in
            XSLT 2.0. The facility is widely used, and some
            significant libraries of external functions have been
            developed by third parties. We made an attempt to
            standardize language bindings for external functions in
            the XSLT 1.1 working draft, but this proved highly
            controversial and has been dropped. The facility
            remains, however, even though the binding mechanisms
            remain implementation-defined.</p>

            <p>The XPath 2.0 specification continues to tolerate
            external functions, though it doesn't really
            acknowledge their existence properly. All we say is
            that the repertoire of functions that can be called is
            part of the context.</p>

            <p>The issue is: should the function
            function-available() function be transferred from XSLT
            to XPath?</p>

            <p>This function tests whether a named function is
            available, and returns true if it is, and false if it
            isn't. A typical call is:</p>

            <div class="exampleInner">
              <pre>
if  (function-available('my:debug')) then my:debug('Hi!') else ()
</pre>
            </div>

            <p>This has two implications:</p>

            <p>(a) a call on my:debug must not be a static error if
            the function is not available</p>

            <p>(b) the names of functions (and the in-scope
            namespaces needed to resolve their QNames) must be
            available at run-time.</p>

            <p>Logically the function-available() function has no
            dependencies on XSLT so it should be transferred to
            XPath.</p>
          </div>

          <h3><a name="id-issue-N52156" id=
          "id-issue-N52156"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-12-10
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0164.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0164.html
            (W3C-members only)</a>)</small></p>

            <p>Proposed to resolve by stating that the XPath
            specification to state that at the discretion of the
            host language, a call to a function that is not in the
            static context may generate a dynamic error rather than
            a static error.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>This issue is also impacted by the following
            decision:</p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>273. <a name="external-objests" id=
        "external-objests"><u>external-objests</u>: External
        Objects</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster:
          <b>external-objects</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>External Objects

          <h3><a name="id-issue-N52174" id=
          "id-issue-N52174"></a>Description</h3>

          <div>
            <p>Part of the strength of external functions is that
            they can return objects that are outside the scope of
            the XPath type system. For example, a function library
            for performing SQL database access may have a function
            sql:connect() that returns an object representing a
            database connection. This object may be passed as an
            argument to calls on other functions in the SQL
            function library.</p>

            <p>The way this is handled in XPath 1.0 is that the
            XPath specification defines four data-types, and
            explicitly leaves the host language free to define
            additional data types. We could probably live with a
            similar solution for XPath 2.0, but it's a fudge, and I
            think we ought to try and do better.</p>

            <p>Note that the only things you can do with an
            external object (under the XSLT 1.0 rules) are to
            assign it to a variable, or pass it as the argument to
            another function. In practice I think implementations
            also allow external objects to have additional
            behavior, for example they might allow conversion to a
            string when used in a context where a string is
            required. I think we should leave such behavior
            implementation-defined rather than saying that it is
            always an error.</p>

            <p>The question arises as to where external objects
            should fit into the type hierarchy. Should they be a
            top-level thing at the same level as "sequence", or
            should they be one level down, along with "node" and
            "atomic value"? I think it makes most sense to preserve
            the principle "everything is a sequence", which means
            that there are now three kinds of item: nodes, atomic
            values, and external objects.</p>

            <p>Handling this rigorously sounds like quite a
            pervasive change to the spec, but I don't think it's as
            bad as it seems. I don't think we should add any
            language features to support external objects, with the
            possible exception of a keyword "external" in the type
            syntax so that one can test for it using "instance of".
            Functions and operators that work on any sequence (for
            example, count) should treat an external object like
            any other item in the sequence. Operations that expect
            nodes will fail if presented with an external object;
            operations that expect atomic values will also fail,
            except that implementations may define fallback
            conversions from external objects to atomic values.</p>
          </div>

          <h3><a name="id-issue-N5217F" id=
          "id-issue-N5217F"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N52184" id=
          "id-issue-N52184"></a>Proposed Resolution</h3>

          <div>
            <p>Technically, I believe we could close the issue with
            no change to the documents, on the basis that the
            definition for the static context (in both XPath and
            XQuery) states: "Additional type definitions may be
            added to the in-scope type definitions by the language
            environment." I think an implementation could take this
            as sufficient authority to extend the type hierarchy
            with additional types, including types needed to
            represent objects returned by extension functions (such
            as "an SQL database connection").</p>

            <p>Editorially, I think it would be a good idea if we
            state this explicitly in a Note, as follows:</p>

            <p>NOTE: an implementation may allow function calls in
            a Query/Expression to bind to functions written in
            languages that use a different type system (these are
            known as "extension functions" in XSLT, "external
            functions" in XQuery). In this case, the way in which
            the arguments and results of such functions are mapped
            between the two type systems is implementation-defined.
            An implementation may define new types anywhere within
            the type hierarchy of the [Data Model] that are
            designed to facilitate interworking with other
            languages, for example a type that encapsulates an
            object returned by an external function; or it may
            provide mechanisms for the user to define such
            types.</p>
          </div>

          <h3><a name="id-issue-N5218C" id=
          "id-issue-N5218C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0206.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0206.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0344.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0344.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>555. <a name="module-import-fs" id=
        "module-import-fs"><u>module-import-fs</u>: Formal
        Semantics of Module Import</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>fs editors</b></small>Formal Semantics of
          Module Import

          <h3><a name="id-issue-N542B0" id=
          "id-issue-N542B0"></a>Description</h3>

          <div>
            <p>The semantics of Module Import is not formally
            specified.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>556. <a name="variable-definitions-fs" id=
        "variable-definitions-fs"><u>variable-definitions-fs</u>:
        Formal Semantics of Variable Definitions</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>fs editors</b></small>Formal Semantics of
          Variable Definitions

          <h3><a name="id-issue-N542BE" id=
          "id-issue-N542BE"></a>Description</h3>

          <div>
            <p>The semantics of Variables Definitions in the XQuery
            prolog is not formally specified.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>557. <a name="validation-declaration-fs" id=
        "validation-declaration-fs"><u>validation-declaration-fs</u>:
        Formal semantics of Validation Declaration</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>fs editors</b></small>Formal semantics of
          Validation Declaration

          <h3><a name="id-issue-N542CC" id=
          "id-issue-N542CC"></a>Description</h3>

          <div>
            <p>The semantics of Validation Declaration in the
            XQuery prolog is not formally specified.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>559. <a name="FS-support-new-sequence-type" id=
        "FS-support-new-sequence-type"><u>FS-support-new-sequence-type</u>:
        New Sequence Type needs to be fully implemented in Formal
        Semantics</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>Michael Rys</b></small>New Sequence Type
          needs to be fully implemented in Formal Semantics

          <h3><a name="id-issue-N542F4" id=
          "id-issue-N542F4"></a>Description</h3>

          <div>
            <p>The formal semantics of the new form of sequence
            types is incomplete and is still under work.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>558. <a name="FS-allow-PIs-comments" id=
        "FS-allow-PIs-comments"><u>FS-allow-PIs-comments</u>: The
        content of element types should always allow PI's and
        comment node types</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>The content of
          element types should always allow PI's and comment node
          types

          <h3><a name="id-issue-N542DA" id=
          "id-issue-N542DA"></a>Description</h3>

          <div>
            <p>The content of element types should always allow
            PI's and comment node types. This is not currently
            taken into account in the FS document. The best way to
            deal with that problem is still an open issue. Two
            possible options are to add PI and comment types during
            XML Schema import into the XQuery type system (Section
            8). Another option is to add PI and comment types
            during type expansion (judgment expands_to in 7.2.7
            Type expansion).</p>
          </div>

          <h3><a name="id-issue-N542DD" id=
          "id-issue-N542DD"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-05-01
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html
            (W3C-members only)</a>)</small></p>

            <p>Fix is in [Section 7.2.6 Type adjustment] which now
            adds pi and comment types when accessing an element
            type.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>560. <a name="exactness-type-inference" id=
        "exactness-type-inference"><u>exactness-type-inference</u>:
        Exactness of Type Inference</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>formal
          semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Micheal Rys</b></small>Exactness of Type
          Inference

          <h3><a name="id-issue-N54302" id=
          "id-issue-N54302"></a>Description</h3>

          <div>
            <p>We currently have a couple of static type inference
            rules (child, descendent) that preserve the more
            complex type consisting of interleaf, union and
            sequence. The question is whether this complexity is
            really needed.</p>

            <p>In many cases (such as the FLWR expression used to
            define /) we just change the inferred type into prime x
            quantifier.</p>

            <p>If we could just infer prime x quantifier, often our
            inference rules could be simplified.</p>

            <p>So the question becomes: Do we really need the more
            complex and precise types for performing static type
            checking?</p>
          </div>

          <h3><a name="id-issue-N5430B" id=
          "id-issue-N5430B"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Decided to accept the "Simplified typing" proposal
            in <a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Jul/0023.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Jul/0023.html</a>,
            which solves this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>335. <a name="semantics-interfering-with-optimization"
        id=
        "semantics-interfering-with-optimization"><u>semantics-interfering-with-optimization</u>:
        XPath/XQuery's current semantics greatly interferes with
        optimization</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster:
          <b>formal-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>XPath/XQuery's
          current semantics greatly interferes with optimization

          <h3><a name="id-issue-N529C6" id=
          "id-issue-N529C6"></a>Description</h3>

          <div>
            <p>Current semantics basically defines the semantics by
            mapping FLWRs and path expression to go top-down.
            Errors are normative. Problem is that we can not apply
            many optimizations. Simple query rewrites such as
            pushing or pulling filters, etc. Like to be able to
            push predicates down and evaluate them. Potentially the
            predicate might raise an error you would not have
            gotten if you processed top down. Want to allow
            implementations to do bottom up evaluations.</p>

            <p>Suggested resolution:</p>

            <p>The formal semantics defines dynamic evaluation in
            terms of a naive, top-down reduction of a core
            expression to a data-model value. Implementations may
            choose alternative evaluation strategies, which, for
            example, may reduce a core expression bottom-up. If an
            evaluation of a core expression yields a value (i.e.,
            it does not raise an error), the value must be the same
            value as would be produced by the dynamic semantics
            defined in this document. The evaluation of a core
            expression may raise an error that may not be raised by
            the dynamic semantics as defined in this document.</p>
          </div>

          <h3><a name="id-issue-N529CD" id=
          "id-issue-N529CD"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-10-29
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0449.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0449.html
            (W3C-members only)</a>)</small>as part of Agendum
            1.</p>

            <p>Expressions, with the exception of "if", may be
            reordered and thus some errors may be raised that using
            another evaluation strategy may not have occurred.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-10-30
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0511.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0511.html
            (W3C-members only)</a>)</small>accepting text for next
            publication, but keep issue active.</p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-31
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html
            (W3C-members only)</a>)</small>accepting text for next
            publication, but keep issue active.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0232.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0232.html
            (W3C-members only)</a>)</small></p>

            <p>No adverse public comments received. Close issue
            with no change.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>265. <a name="lang-inheritance" id=
        "lang-inheritance"><u>lang-inheritance</u>: How do we
        determine the xml:lang for a node if it inherits xml:lang
        from a higher-level node?</a></h2>

        <div>
          <small>Locus: <b>xpath-fulltext</b> Cluster:
          <b>FTTF-xml:lang</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>FTTF</b></small>How do we determine the
          xml:lang for a node if it inherits xml:lang from a
          higher-level node?

          <h3><a name="id-issue-N5206D" id=
          "id-issue-N5206D"></a>Description</h3>

          <div>
            <p>How do we determine the xml:lang for a node if it
            inherits xml:lang from a higher-level node?</p>
          </div>

          <h3><a name="id-issue-N52070" id=
          "id-issue-N52070"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to close issue with no change to documents,
            since user-written expressions or functions can
            determine the value of xml:lang that a node
            inherits.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>266. <a name="lang-sublanguage-support" id=
        "lang-sublanguage-support"><u>lang-sublanguage-support</u>:
        Do we support the sublanguage portion of xml:lang?</a></h2>

        <div>
          <small>Locus: <b>xpath-fulltext</b> Cluster:
          <b>FTTF-xml:lang</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>FTTF</b></small>Do we support the
          sublanguage portion of xml:lang?

          <h3><a name="id-issue-N52083" id=
          "id-issue-N52083"></a>Description</h3>

          <div>
            <p>Do we support the sublanguage portion of xml:lang?
            If so, how?</p>
          </div>

          <h3><a name="id-issue-N52086" id=
          "id-issue-N52086"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>A user-written expression of function has to
            determine the value of xml:lang and then do the
            appropriate analysis of the value. No change to
            document.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>124. <a name="xquery-external-functions" id=
        "xquery-external-functions"><u>xquery-external-functions</u>:
        External Functions</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>functions</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>External
          Functions

          <h3><a name="id-issue-N50E4C" id=
          "id-issue-N50E4C"></a>Description</h3>

          <div>
            <p>An extensibility mechanism needs to be defined that
            permits XQuery to access a library of functions written
            in some other programming language such as Java.</p>

            <p>Some sources of information: the definition of
            external functions in SQL, the implementation of
            external functions in Kweelt.</p>
          </div>

          <h3><a name="id-issue-N50E51" id=
          "id-issue-N50E51"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>157. <a name="xquery-function-library" id=
        "xquery-function-library"><u>xquery-function-library</u>:
        Function Libraries</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>functions</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>Function
          Libraries

          <h3><a name="id-issue-N51249" id=
          "id-issue-N51249"></a>Description</h3>

          <div>
            <p>XQuery needs a mechanism to allow function
            definitions to be shared by multiple queries. The
            XQuery grammar allows function definitions to occur
            without a query expression.</p>

            <p>We must provide a way for queries to access
            functions in libraries. For instance, we might add an
            IMPORT statement to XQuery, with the URI of the
            functions to be imported. It must be possible to
            specify either that (1) local definitions replace the
            imported definitions, or (2) imported definitions
            replace the local ones.</p>
          </div>

          <h3><a name="id-issue-N5124E" id=
          "id-issue-N5124E"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>327. <a name="functions-parameter-evaluation" id=
        "functions-parameter-evaluation"><u>functions-parameter-evaluation</u>:
        Evaluate unused function parameters?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>functions</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL/XQuery joint</b></small>Evaluate
          unused function parameters?

          <h3><a name="id-issue-N528C4" id=
          "id-issue-N528C4"></a>Description</h3>

          <div>
            <p>Is an implementation obligated to evaluate all its
            parameters (and raise any errors doing so) even when
            they're not needed in the function body?</p>
          </div>

          <h3><a name="id-issue-N528C7" id=
          "id-issue-N528C7"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-10-29
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0449.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0449.html
            (W3C-members only)</a>)</small>as part of Agendum
            1.</p>

            <p>There is no need to evaluate "non needed"
            expressions.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-10-30
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0511.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Oct/0511.html
            (W3C-members only)</a>)</small>accepting text for next
            publication, but keep issue active.</p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-31
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0004.html
            (W3C-members only)</a>)</small>accepting text for next
            publication, but keep issue active.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0232.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0232.html
            (W3C-members only)</a>)</small></p>

            <p>No adverse public comments received. Close issue
            with no change.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>223. <a name="external-function-definition" id=
        "external-function-definition"><u>external-function-definition</u>:
        We need a way to declare external functions</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>functions
          external</b> Priority: <b>o-1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>We need a way to
          declare external functions

          <h3><a name="id-issue-N51A9B" id=
          "id-issue-N51A9B"></a>Description</h3>

          <div>
            <p>Should we allow external functions to be defined
            using a syntax like this?</p>

            <div class="exampleInner">
              <pre>
       [71a] ExternalFnDef ::= {"define" S "external" S "function"}
            QName "(" ParamList? ")" ("returns" Datatype)?
  
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N51AA0" id=
          "id-issue-N51AA0"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N51AA3" id=
          "id-issue-N51AA3"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>458. <a name="FS-Issue-0115" id=
        "FS-Issue-0115"><u>FS-Issue-0115</u>: What is in the
        default context?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>What is in the default
          context?

          <h3><a name="id-issue-N536D9" id=
          "id-issue-N536D9"></a>Description</h3>

          <div>
            <p>What do the default namespace and type environments
            contain? I believe at least the default namespace
            environment should contain the "xs", "fn" and "op"
            prefixes, as well as the default namespaces bound to
            the empty namespace. Should the default type
            environment contain wildcard types?</p>
          </div>

          <h3><a name="id-issue-N536E5" id=
          "id-issue-N536E5"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Decided to accept the "Processing Model" Proposal
            which addresses this issue.</p>

            <p>The "spreadsheet" contains a list of the items.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>459. <a name="FS-Issue-0116" id=
        "FS-Issue-0116"><u>FS-Issue-0116</u>:
        Serialization</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Serialization

          <h3><a name="id-issue-N53700" id=
          "id-issue-N53700"></a>Description</h3>

          <div>
            <p>Serialization of data model instances, and XQuery
            results is still an open issue.</p>
          </div>

          <h3><a name="id-issue-N53703" id=
          "id-issue-N53703"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Serialization is implemented in the data model.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>492. <a name="FS-Issue-0149" id=
        "FS-Issue-0149"><u>FS-Issue-0149</u>: Derivation by
        extension in XQuery</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>Derivation by
          extension in XQuery

          <h3><a name="id-issue-N53A9F" id=
          "id-issue-N53A9F"></a>Description</h3>

          <div>
            <p>If type u is derived from type t by extension, then
            the formal semantics document specifies that type u may
            appear wherever type t is expected. It is not clear
            what the XQuery document says on this point.</p>
          </div>

          <h3><a name="id-issue-N53AA2" id=
          "id-issue-N53AA2"></a>Proposed Resolution</h3>

          <div>
            <p>The relevant text in the XQuery document can be
            found in Section 2.4.2.1, "SequenceType Matching",
            under the description of "ElemOrAttrType", Rules 1 and
            2.</p>

            <p>Rule 1 describes matching by type-name. It says "The
            match is successful only if the given element or
            attribute has a type annotation that is the same as the
            required type or ... derived from the required
            type."</p>

            <p>Rule 2 describes matching by element-name. It says
            "The match is successful only if the name of the given
            element or attribute is equal to the required name or
            ... derived from the required name, and if the element
            or attribute has been validated."</p>

            <p>Rules 1 and 2 do not distinguish between derivation
            by extension or by restriction, so by implication they
            apply to both kinds of derivation. I do not believe
            that Rules 1 and 2 were intended to apply to derivation
            by list or union. I believe this should be clarified by
            changing "derived" to "derived by restriction or
            extension" in Rules 1 and 2.</p>

            <p>I believe that this change will close Issue 492.</p>
          </div>

          <h3><a name="id-issue-N53AAE" id=
          "id-issue-N53AAE"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-29
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to accept proposal and thus resolving
            issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>493. <a name="FS-Issue-0150" id=
        "FS-Issue-0150"><u>FS-Issue-0150</u>: May the content of a
        text node be the empty string?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>May the content of
          a text node be the empty string?

          <h3><a name="id-issue-N53AC1" id=
          "id-issue-N53AC1"></a>Description</h3>

          <div>
            <p>May the content of a text node be the empty string?
            None of the formal semantics, the datamodel, or the
            XQuery document addresses this point.</p>
          </div>

          <h3><a name="id-issue-N53AC4" id=
          "id-issue-N53AC4"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Add a constraint that a text node must consist of at
            least one character information items to the Data
            Model.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>499. <a name="FS-Issue-0156" id=
        "FS-Issue-0156"><u>FS-Issue-0156</u>: Casting and
        validation</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Casting and
          validation

          <h3><a name="id-issue-N53B44" id=
          "id-issue-N53B44"></a>Description</h3>

          <div>
            <p>Validation from text to simple type performs an
            operation similar to casting. Should validation of
            simple type values and 'cast as' in [XPath/XQuery] be
            aligned?</p>
          </div>

          <h3><a name="id-issue-N53B47" id=
          "id-issue-N53B47"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small></p>

            <p>Close issue since Functions and Operators answers
            this question.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>510. <a name="FS-Issue-0167" id=
        "FS-Issue-0167"><u>FS-Issue-0167</u>: Is validate working
        on sequences?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Language</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Is validate
          working on sequences?

          <h3><a name="id-issue-N53C95" id=
          "id-issue-N53C95"></a>Description</h3>

          <div>
            <p>We have not yet reached consensus on the semantics
            of validate for all sequences. In particular:</p>

            <p>1. Can validate be applied to a sequence, or only to
            a single item?</p>

            <p>2. Can validate be applied to any item? Some believe
            that it should apply only to elements and document
            nodes - the two kinds of nodes for which it is well
            defined - and raise an error if other items are
            encountered. Others believe that validate should
            validate elements and document nodes, returning other
            items without change. Should an attribute node be
            validated? Note that XML Schema does not define
            stand-alone validation for attribute nodes.</p>

            <p>We need to carefully consider the usage scenarios in
            which validation might be applied to sequences or items
            that are not elements or document nodes to determine
            which behavior is most desirable.</p>

            <p>Should validate work on sequences of nodes, or only
            on a single node?</p>
          </div>

          <h3><a name="id-issue-N53CA0" id=
          "id-issue-N53CA0"></a>Proposed Resolution</h3>

          <div>
            <p>At today's Query telcon, we discussed the semantics
            of the validate expression. We need to decide whether
            it applies to a sequence, or only to a single node. We
            also need to define its semantics for various kinds of
            nodes (and for atomic values, if they occur in a
            validated sequence).</p>

            <p>Most people agreed that the validate operator,
            applied to an attribute node, should raise an error.
            This is because we rely on the XML Schema specification
            for the semantics of validation, and XML Schema does
            not specify how to validate a stand-alone attribute
            node.</p>

            <p>For text, comment, and PI nodes and atomic values,
            some people believe that validate should raise an
            error, and others believe that validate should simply
            return the original node or value unchanged. We did not
            reach a consensus on this.</p>

            <p>If validate is defined to operate on a sequence, the
            sequence may contain some items for which validate is
            well-defined and others for which it is not
            well-defined. In order for users to invoke validate on
            a sequence, they will first need to filter the sequence
            to keep only items for which validate is well-defined.
            If users need to do this work anyway, they might as
            well invoke validate expressions only on the individual
            items for which validation is well-defined. This was
            considered a strong argument for not allowing sequences
            to be passed to a validate expression.</p>

            <p>At the end of the discussion, a consensus seemed to
            be emerging around the following points:</p>

            <p>(1) The operand of validate must be a single element
            node or a single document node (anything else raises a
            type error).</p>

            <p>(2) The semantics of validate on an element node are
            as defined in Section 3.13 ("Validate Expressions") of
            the current language document.</p>

            <p>(3) The semantics of validate on a document node are
            as defined in Karun's proposal,
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0015.html,
            approved by the Query working group on 2/12/03.</p>
          </div>

          <h3><a name="id-issue-N53CB2" id=
          "id-issue-N53CB2"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted. It was rejected to aloow
            validation of attribute nodes, even though Schema
            defines the semantics.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>295. <a name="lexical-representation-of-atomic-values"
        id=
        "lexical-representation-of-atomic-values"><u>lexical-representation-of-atomic-values</u>:
        Lexical Representation of Atomic Values</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>lexical-representation</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>xquery/xsl f2f</b></small>Lexical
          Representation of Atomic Values

          <h3><a name="id-issue-N52448" id=
          "id-issue-N52448"></a>Description</h3>

          <div>
            <p>The wording in section 2.8.3 needs to be aligned
            with Data model and F&amp;O; 'lexical representation'
            needs to be defined differently and be consistent in
            XQuery, Datamodel, F&amp;O. It probably needs to be
            string value (canonical value of integer in W3C Schema
            has a "." so not appropriate [or we need to have our
            own definition of the canonical value...]).</p>
          </div>

          <h3><a name="id-issue-N5244B" id=
          "id-issue-N5244B"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>3.7.2.4 "text node constructors", that's the one
            that should be aligned to "string-value".</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>537. <a name=
        "imported-schemas-used-function-signatures" id=
        "imported-schemas-used-function-signatures"><u>imported-schemas-used-function-signatures</u>:
        What happens to imported schemas that are used in function
        signatures?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>modules</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>What happens to
          imported schemas that are used in function signatures?

          <h3><a name="id-issue-N53FD7" id=
          "id-issue-N53FD7"></a>Description</h3>

          <div>
            <p>If a function module imports a schema and uses it in
            the function signature, is the import of the function
            module implicitly importing the schema components
            needed by the function signatures?</p>

            <p>Example:</p>

            <p>The module says:</p>

            <div class="exampleInner">
              <pre>
import schema namespace foo = "abc"
namespace f = "xyz"
define function f:foo($x as foo:bar) as xs:int { ... }
</pre>
            </div>

            <p>Does</p>

            <div class="exampleInner">
              <pre>
import module namespace f = "xyz"
</pre>
            </div>

            <p>import the schema and one only needs to bind a
            prefix to the schema namespace or does the schema have
            to be explicitly imported?</p>
          </div>

          <h3><a name="id-issue-N53FE6" id=
          "id-issue-N53FE6"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small></p>

            <p>The adopted module proposal implicitly resolves this
            issue. An example showing this clearly needs to be
            added.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>74. <a name="xquery-module-syntax" id=
        "xquery-module-syntax"><u>xquery-module-syntax</u>: Module
        syntax</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>module-semantics</b> Priority: <b>o-1</b> Status:
          <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>Module syntax

          <h3><a name="id-issue-N5085E" id=
          "id-issue-N5085E"></a>Description</h3>

          <div>
            <p>The definition and syntax of a query module are
            still under discussion in the working group. The
            specifications in this section are pending approval by
            the working group.</p>

            <p>Future versions of the language may support other
            forms of query modules, such as update statements and
            view definitions.</p>
          </div>

          <h3><a name="id-issue-N50863" id=
          "id-issue-N50863"></a>Proposed Resolution</h3>

          <div>
            <p>Paulist Modules Proposal</p>

            <div class="exampleInner">
              <pre>
This proposal adds modules, external variables, external functions,
and global variables to XQuery. It addresses the following open
issues:

   74 Module syntax
   75 Importing Modules
124 External Functions
157 Function Libraries
223 We need a way to declare external functions
250 Declaring Variables in Prolog

This proposal is called the Paulist Modules Proposal, because it is
based on a simplification Paul Cotton made to earlier module
proposals, which can be found here:

  Subject: Paul's Proposal (was: Unified proposal on modules, global
           and external variables, and external functions)
  From: Jonathan Robie (jonathan.robie@datadirect-technologies.com)
  Date: Thu, Dec 19 2002
  http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0391.html

Many other people have contributed to this proposal in various
iterations, including Mary Fernandez, Jerome Simeon, Don Chamberlin,
Michael Rys, Phil Wadler, and Michael Kay.


1. Modules and Module Declarations

    An XQuery module is a resource that contains a Query. A module may
    declare a target namespace using a ModuleDecl. The syntax of Query
    and ModuleDecl is as follows:

      Query ::= ModuleDecl? QueryProlog ExprSequence?
      ModuleDecl ::= "module" ModuleURI

    If a module contains a ModuleDecl, its functions may be imported by
    other modules. A module that does not have a ModuleDecl can not be
    imported. A ModuleURI may be relative - if so, it is combined with
    the Base URI to create an absolute URI.

    In a module that is imported by another module, the optional
    ExprSequence must be absent, or a static error is raised.

2. Module Imports

    A query may import modules in the QueryProlog using
    ModuleImports. The syntax of QueryProlog and ModuleImport is as
    follows:

      QueryProlog ::=  (NamespaceDecl
                       | DefaultNamespaceDecl
                       | SchemaImport
                       | ModuleImport
                       | VarDn)*
                       FunctionDn*

      ModuleImport ::= "import" "module" ModuleURI ("at" ImplURI)?

    Functions and global variables defined in a module may be used in
    any module that imports the defining module. Importing a module
    does not provide access to the imported schemas or namespaces of
    that module. Importing a module does not provide access to the
    functions imported by that module.

    An implementation may locate a module in any convenient manner,
    provided the ModuleURI of the module it locates matches the
    ModuleURI of the ModuleImport. The optional ImplURI specifies the
    resource containing the implemenation of the module. It is treated
    like a schema location hint in XML Schema - an implementation may
    ignore it completely.

    Two modules may import each other. For instance, if module A
    imports module B, then module B may import module A.

3. Variable declarations and definitions

    A variable may be declared or defined using a VarDn in the
    QueryProlog. The syntax of VarDn is as follows:

      VarDn ::=  "define" "global"? "external"? "variable" "$" VarName
                    ("as" SequenceType)? (":=" Expr)?

    A variable may have no forward references to functions or
    variables. Functions and variables imported into a module are
    considered prior to a global variable if they are imported before
    the global variable is defined. A variable may not be used before
    it is defined.

    If the "global" keyword is present, then the variable will be
    imported whenever the module that contains it is imported.

    If the "external" keyword is present, the variable is [external];
    if it is absent, the variable is [internal].

    An [external] variable definition must include only the variable's
    name and optional sequence type, or a static error is raised.
    During dynamic evaluation, an [external] variable must be bound to
    a value in the dynamic context, or an error is raised.

    An [internal] variable definition must include the variable's name,
    optional sequence type, and a required expression, or a static
    error is raised.

    It is a type error, if the value of a variable does not match the
    declared sequence type of the variable.


4. External functions

    An external function definition allows XQuery to call functions
    written in other languages. The syntax of a FunctionDefn is as
    follows:

     FunctionDefn ::= &lt;"define" "function"&gt; "external"? &lt;QName "("&gt;
     ParamList? (")" | (&lt;")" "as"&gt; SequenceType)) EnclosedExpr

    If the "external" keyword is present, the function is [external];
    if it is absent, the function is [internal].

    If a function is [internal], its implementation is given as an
    XQuery expression in the module's implementation. If a function is
    [external], its implementation is given by the query environment.
    XQuery does not specify how external functions are implemented or
    accessed, how actual arguments are passed to external functions, or
    how return values are passed to the query environment - all that is
    implementation defined.
</pre>
            </div>

            <p>Questions in proposal that need resolution:</p>

            <div class="exampleInner">
              <pre>
In today's telcon, we identified three central questions that need to
be resolved for the modules proposal. Once we resolve these questions,
it will be easy to rewrite the Paulist module accordingly.

Question 1: What is the relationship between the ModuleURI and the
namespace of the functions it contains?

Possible answers:

1.A. There is no relationship. A module is identified by a URI, and
may contain functions in any namespace.

1.B. The module URI is the namespace of functions and global variables
defined in that module. It serves as a default namespace for both
functions and global variables, but the prolog can change these
defaults.

1.C. The module URI is the namespace of functions and global variables
exported by the module. A module may contain functions and global
variables defined in other namespaces or in no namespace, but they are
not exported when the module is imported into another module.


2. Should there an optional LocationURI?

2.A. A module has an optional LocationURI, which provides the location
of a resource. This allows the name of a resource to be decoupled from
its location, while allowing relative or absolute locations to be
specified explicitly.

2.B. A module is identified only by the ModuleURI, which may be
relative or absolute. Catalogs or other similar devices are used to
map the ModuleURI onto a location.

There are two variations on 2.B:

2.B.i: The ModuleURI may be relative.
2.B.ii: The ModuleURI must be absolute.

Relative ModuleURIs are not useful if we choose 2.A.

Jonathan

Note: Michael Kay suggested Option A and Option B. They are defined as:

Option A: (C3, L1)
Option B: (C1, L2)
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N5086D" id=
          "id-issue-N5086D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>75. <a name="xquery-import" id=
        "xquery-import"><u>xquery-import</u>: Importing
        Modules</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>module-semantics</b> Priority: <b>o-1</b> Status:
          <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>Importing
          Modules

          <h3><a name="id-issue-N50880" id=
          "id-issue-N50880"></a>Description</h3>

          <div>
            <p>The means by which a query module gains access to
            the functions defined an an external function library
            remains to be defined.</p>

            <p>Should xmlns only be respected for construction,
            Xquery expressions but not functions, or also
            functions?</p>
          </div>

          <h3><a name="id-issue-N50885" id=
          "id-issue-N50885"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>79. <a name="xquery-encoding" id=
        "xquery-encoding"><u>xquery-encoding</u>: Encoding</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>module-syntax</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Encoding

          <h3><a name="id-issue-N508E5" id=
          "id-issue-N508E5"></a>Description</h3>

          <div>
            <p>Does XQuery need a way to specify the encoding of a
            query? For instance, should the prolog allow statements
            like the following?</p>

            <div class="exampleInner">
              <pre>
ENCODING utf-16
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N508EA" id=
          "id-issue-N508EA"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-29
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html
            (W3C-members only)</a>)</small></p>

            <p>The text of a query is in Unicode. Serialization is
            done in Unicode, but APIs can set other encodings for
            serialization.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>228. <a name="default-namespace-functions" id=
        "default-namespace-functions"><u>default-namespace-functions</u>:
        Should we keep the default function namespace, and the xf:
        namespace?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>namespace
          functions</b> Priority: <b>o-2</b> Status:
          <b>decided</b><br />
          Originator: <b>Scott Boag</b></small>Should we keep the
          default function namespace, and the xf: namespace?

          <h3><a name="id-issue-N51B3F" id=
          "id-issue-N51B3F"></a>Description</h3>

          <div>
            <p>The question was raised of whether the Query WG and
            F&amp;O TF have 1) a good rationale for putting
            built-in functions in a namespace, and 2) a consistent
            story about how this will relate to default namespace
            declarations and user-defined functions.</p>

            <p>It would seem odd to have to have all user defined
            functions put in the FandO namespace if a namespace is
            not declared for it. If you do not do that, then user
            defined functions that don't require a prefix will not
            match the QName.</p>

            <p>And, if there is not a good rational that provides
            user benifits, then it seems like we are going through
            a lot of additional complexity for little or no
            benefit.</p>
          </div>

          <h3><a name="id-issue-N51B46" id=
          "id-issue-N51B46"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Kristoffer
            Rose:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
            </div>
          </div>

          <h3><a name="id-issue-N51B4C" id=
          "id-issue-N51B4C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html
            (W3C-members only)</a>)</small>Unqualified,
            user-defined functions are placed in the default
            namespace for the scope of the query *only*.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-01-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0046.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0046.html
            (W3C-members only)</a>)</small></p>

            <p>This issue is identical to XSLT issue 155.
            Decision:</p>

            <p>- no controls on default function namespace</p>

            <p>- XSLT functions are in F&amp;O namespace</p>

            <p>- User defined function must be in a namespace</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html
            (W3C-members only)</a>)</small></p>

            <p>1. Propose to require (in XQuery) that all
            user-defined functions be defined in a namespace.</p>

            <p>2. Provide built-in namespace prefix (local, xql,
            ...) so that user is not required to define function
            namespace in every query.</p>

            <p>E.g., define function local:test () { }</p>

            <p>Benefits</p>

            <p>* Simplifies rules for resolving unprefixed function
            and type names ALOT!</p>

            <p>* Aligns with XSLT, which requires all functions be
            defined in some namespace.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F, accepting
            XPath TF proposal</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F, accepting
            XPath TF proposal</p>

            <p>Summary of things needed:</p>

            <p>No necessary change to the grammar.</p>

            <p>But other change is that if somebody chooses the fn
            namespace as default, other implementation-defined
            functions have to be prefixed.</p>

            <p>We have to add the constraints on where you can put
            your functions (which URIs you can add them to).</p>

            <p>We have to define "local" (have a mapping in the
            language document between chosen prefix and
            corresponding URI)</p>

            <p>And, we have to change the Use Cases
            accordingly.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>247. <a name="namespace-default-affecting" id=
        "namespace-default-affecting"><u>namespace-default-affecting</u>:
        What does default namespace(s) affect?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>namespaces</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>What does default
          namespace(s) affect?

          <h3><a name="id-issue-N51DC8" id=
          "id-issue-N51DC8"></a>Description</h3>

          <div>
            <p>What is effect of default namespace declarations on
            unprefixed QNames that may occur in element
            constructors, attribute constructors, and name tests
            (or anywhere else).</p>

            <p>In XPath 1.0, in-scope namespace decls effect
            prefixed QNames, but default namespace decl does not
            effect unprefixed names in a name test. In XSLT 2.0, we
            introduced multiple default namespace decls :one for
            constructed elements, one for names in xpath
            expressions.</p>
          </div>

          <h3><a name="id-issue-N51DCD" id=
          "id-issue-N51DCD"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to accept status quo:</p>

            <p>- default element namespace defines a namespace URI
            that is associated with unprefixed names of elements
            and types.</p>

            <p>- default function namespace defines a namespace URI
            that is associated with unprefixed names of
            functions.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>319. <a name="namespace-definitions-and-validate" id=
        "namespace-definitions-and-validate"><u>namespace-definitions-and-validate</u>:
        Namespace definitions and in-scope namespaces</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>namespaces</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Namespace definitions
          and in-scope namespaces

          <h3><a name="id-issue-N527B4" id=
          "id-issue-N527B4"></a>Description</h3>

          <div>
            <p>Addition of namespaces in the query prolog to the
            in-scope namespaces; how is this information carried
            through to provide input to validation?</p>

            <p>Additional aspecs are:</p>

            <p>(a) the whole question of how the namesapce context
            is affected by namespace declarations in element
            constructors</p>

            <p>(b) the general notion (in XQuery, specifically),
            that the static context can vary for different parts of
            a query</p>

            <p>(c) what information gets through to act as input to
            validation</p>
          </div>

          <h3><a name="id-issue-N527BF" id=
          "id-issue-N527BF"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Decided to accept the "Processing Model" Proposal
            which addresses this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>343. <a name="namespaces-functions" id=
        "namespaces-functions"><u>namespaces-functions</u>: Do
        functions in the null namespace clash with functions in the
        default namespace?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>namespaces</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Do functions in the
          null namespace clash with functions in the default
          namespace?

          <h3><a name="id-issue-N52AD0" id=
          "id-issue-N52AD0"></a>Description</h3>

          <div>
            <p>If you define the DFN (default function namespace)
            to be the null namespace, which you must do if you are
            going to call functions in this namespace, can you
            still use unprefixed names to refer to functions in the
            built-in namespace?</p>
          </div>

          <h3><a name="id-issue-N52AD3" id=
          "id-issue-N52AD3"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N52AD6" id=
          "id-issue-N52AD6"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html
            (W3C-members only)</a>)</small>A static error is raised
            when there is a clash between a user-defined function
            in the default namespace and any other function of the
            same name in the default namespace.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Given the decision on issue <a href=
            "#default-namespace-functions">#default-namespace-functions</a>
            it is a (statically detectable) error to define
            functions in the null namespace.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>549. <a name="namespace-constructor" id=
        "namespace-constructor"><u>namespace-constructor</u>:
        Computed namespace-constructor</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>namespaces</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XQuery WG</b></small>Computed
          namespace-constructor

          <h3><a name="id-issue-N54186" id=
          "id-issue-N54186"></a>Description</h3>

          <div>
            <p>Is the following construction is a valid XQuery
            expression or not:</p>

            <div class="exampleInner">
              <pre>
element foo:bar {
  attribute a1 {"foo"},
  attribute xmlns:foo {"urn1"},
  element e1 {"goo"}
}
</pre>
            </div>

            <p>The XML Query WG has decided to forbid the above
            construct by defining an explicit constructor for
            namespaces in computed constructor syntax, and to
            disallow the use of computed attribute constructors for
            declaring namespaces. The WG also believes that there
            should be a constructor for comments.</p>

            <p>The WG also agreed that the namesapce constructor
            should have a syntax parallel to that of attribute
            constructors, be restricted to constant namespace
            prefixes and URLs, and should appear first in the
            children of an element constructor, as in the following
            example:</p>

            <div class="exampleInner">
              <pre>
element foo:bar {
     namespace test { "urn1" },
     attribute a1 {"foo"},
     element e1 {"goo"}
}
</pre>
            </div>

            <p>The above example is precisely equivalent to:</p>

            <div class="exampleInner">
              <pre>
&lt;foo:bar xmlns:test="urn1"&gt;{
      attribute a1 {"foo"},
      element e1 {"goo"}
}&lt;/foo:bar&gt;
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N54195" id=
          "id-issue-N54195"></a>Proposed Resolution</h3>

          <div>
            <p>The proposal itself is quite simple:</p>

            <p>Syntax:</p>

            <div class="exampleInner">
              <pre>
ComputedElementConstructor    ::=    (&lt;"element" QName "{"&gt;
      |  (&lt;"element" "{"&gt; Expr "}" "{")) NamespaceCList? ExprSequence?
"}"

NamespaceCList ::= ComputedNamespaceConstructor (","
ComputedNamespaceConstructor)* ","

ComputedNamespaceConstructor ::= (&lt;"namespace" NCName "{"&gt; StringLiteral
"}"
</pre>
            </div>

            <p>A NamespaceCList may appear as the first expressions
            in the ExprSequence of an element constructor, using
            either computed or XML element constructor syntax. It
            is syntactically impossible for
            ComputedNamespaceConstructors to appear in any other
            context.</p>

            <p>Semantics:</p>

            <p>If two ComputedNamespaceConstructors in the same
            element declare the same prefix, a type error is
            raised. A namespace declared using a
            ComputedNamespaceconstructor is in scope within the
            constructed element, including the name of the element
            itself.</p>

            <p>If the name of an attribute in a computed attribute
            constructor begins with the string "xmlns", a type
            error is raised.</p>

            <p>In an ElementConstructor, if an attribute in an
            AttributeList begins with the string "xmlns", then it
            is treated as a namespace declaration, and is
            equivalent to a computed namespace constructor that
            declares the same prefix and URI.</p>
          </div>

          <h3><a name="id-issue-N541A7" id=
          "id-issue-N541A7"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-03-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0232.html
            (W3C-members only)</a>)</small></p>

            <p>Adoption of the proposal.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>564. <a name="schema-import-multiple-times" id=
        "schema-import-multiple-times"><u>schema-import-multiple-times</u>:
        Loading same schema-component twice</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>schema-import</b>
          Priority: <b>1</b> Status: <b>active</b><br />
          Originator: <b>Michael Rys</b></small>Loading same
          schema-component twice

          <h3><a name="id-issue-N543AF" id=
          "id-issue-N543AF"></a>Description</h3>

          <div>
            <p>We currently allow a schema component to be only
            loaded once into the in-scope schema definitions. If a
            type, element or attribute having an expanded name as
            an already loaded type, element or attribute
            respectively, we have to error regardless of the actual
            type definition.</p>

            <p>Since we now require explicit schema import of the
            XSD schema but already have predefined the XSD types,
            we introduced a special case for having to avoid the
            error. However, this still does not solve the following
            two problems:</p>

            <p>1. Schema import transitively import other imported
            schemata. Thus if a transitively imported schema is
            imported more than once, we would have to raise an
            error</p>

            <p>2. In order to provide interoperable queries, one
            should be able to explicitly import schemata that may
            be implicitly imported by the XQuery implementation.
            Again, today that would lead to an error.</p>
          </div>

          <h3><a name="id-issue-N543B8" id=
          "id-issue-N543B8"></a>Proposed Resolution</h3>

          <div>
            <p>If a type, element or attribute has already been
            loaded, then loading a type, element or attribute
            respectively with the same expanded name does not lead
            to an error if it can be determined that they are
            describing the same type, element or attribute. Note
            that the inscope schema definition will only contain
            one entry...</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>528. <a name="text-constructor-empty-sequence" id=
        "text-constructor-empty-sequence"><u>text-constructor-empty-sequence</u>:
        Semantics of text constructor on empty sequence</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>semantics</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Semantics of text
          constructor on empty sequence

          <h3><a name="id-issue-N53EC0" id=
          "id-issue-N53EC0"></a>Description</h3>

          <div>
            <p>Semantics of text constructor on empty sequence:
            should it return empty sequence or raise an error?</p>
          </div>

          <h3><a name="id-issue-N53EC3" id=
          "id-issue-N53EC3"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Change the language document, adding that a text
            node constructor on empty sequence returns the empty
            sequence.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>481. <a name="FS-Issue-0138" id=
        "FS-Issue-0138"><u>FS-Issue-0138</u>: Semantics of Schema
        Context</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>Jerome Simeon</b></small>Semantics of
          Schema Context

          <h3><a name="id-issue-N53978" id=
          "id-issue-N53978"></a>Description</h3>

          <div>
            <p>The semantics of Schema Context types in the
            SequenceType production is still an open issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>496. <a name="FS-Issue-0153" id=
        "FS-Issue-0153"><u>FS-Issue-0153</u>: Support for lax and
        strict wildcards</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>FS Editors</b></small>Support for lax and
          strict wildcards

          <h3><a name="id-issue-N53B03" id=
          "id-issue-N53B03"></a>Description</h3>

          <div>
            <p>The Formal Semantics does not currently model lax
            and strict wildcards. The mapping in Section 7, only
            describes how XML Schema wilcards with the 'skip
            validation' semantics are imported into the XQuery Type
            System.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>437. <a name="FS-Issue-0094" id=
        "FS-Issue-0094"><u>FS-Issue-0094</u>: Static type errors
        and warnings</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Static type
          errors and warnings

          <h3><a name="id-issue-N5346F" id=
          "id-issue-N5346F"></a>Description</h3>

          <div>
            <p>Static type errors and warnings are not specified.
            We need to enumerate in both the [XPath/XQuery] and
            formal semantics documents what kinds of static type
            errors and warnings are produced by the type system.
            See also [resolved issue #FS-Issue-0090].</p>
          </div>

          <h3><a name="id-issue-N53477" id=
          "id-issue-N53477"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft describes the semantics of
            errors.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>441. <a name="FS-Issue-0098" id=
        "FS-Issue-0098"><u>FS-Issue-0098</u>: Implementation of and
        conformance levels for static type checking</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Implementation
          of and conformance levels for static type checking

          <h3><a name="id-issue-N534CE" id=
          "id-issue-N534CE"></a>Description</h3>

          <div>
            <p>This issue is related to [resolved issue
            #FS-Issue-0059] Static type checking may be difficult
            and/or expensive to implement. Some discussion of
            algorithmic issues of type checking are needed. In
            addition, we may want to define "conformance levels"
            for [XPath/XQuery], in which some processors (or some
            processing modes) are more permissive about types. This
            would allow [XPath/XQuery] implementations that do not
            understand all of Schema, and it would allow customers
            some control over the cost/benefit tradeoff of type
            checking.</p>
          </div>

          <h3><a name="id-issue-N534D4" id=
          "id-issue-N534D4"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Close issue 441 with no further work.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>450. <a name="FS-Issue-0107" id=
        "FS-Issue-0107"><u>FS-Issue-0107</u>: Semantics of
        data()</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>FS Editors</b></small>Semantics of data()

          <h3><a name="id-issue-N535D2" id=
          "id-issue-N535D2"></a>Description</h3>

          <div>
            <p>What is the semantics of data() applied to anything
            else than an element or attribute node ?</p>
          </div>

          <h3><a name="id-issue-N535D5" id=
          "id-issue-N535D5"></a>Proposed Resolution</h3>

          <div>
            <div class="exampleInner">
              <pre>
XQuery 1.0 and XPath 2.0 Data Model
W3C Working Draft 17 January 2003
http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0251.html

4.1.5 string-value Accessor
----------------------------

1. REPLACE entire section WITH:

    Every node has a string value; the way in which the string value
    is computed is different for each kind of node and is specified in
    the sections on nodes below.

4.1.6 typed-value Accessor
--------------------------

1. REPLACE:
      Otherwise, xs:anyType for elements or xs:anySimpleType for
attributes.

   WITH:
      Otherwise, xs:anyType for elements or xdt:untypedAtomic for
attributes.

2. REPLACE :

    * If the item is an element node with type xs:anyType, then its
      typed value is equal to its string value, as an instance of
      xdt:untypedAtomic.

  WITH:

    * If the node is an element node with type xs:anyType, then its
      typed value is equal to its string value, as an instance of
      xdt:untypedAtomic.

3. REPLACE :

    * The typed value of an element node with a simple type is derived
      from its string value and type in a way that is consistent with
      XML Schema validation.

  WITH:

    * If the node is an element node with a simple type or with a
      complex type of simple content, then its typed value is
      derived from its string value and type in a way that is
      consistent with XML Schema validation.

4. ADD:

    * If the item is an element node with complex type of empty
      content, then its typed value is the empty sequence.

    * If the node is an element node with a complex type of mixed
      content, then its typed value is its string value as an instance
      of xdt:untypedAtomic.

5. REPLACE:

    * If the item is an element node with complex content,
      dm:typed-value returns the empty sequence.

  WITH:

    * If the item is an element node with complex type of complex
      content, then its typed value is the empty sequence.

*************************************************
XQuery 1.0 and XPath 2.0 Functions and Operators
W3C Working Draft 10 December 2002
http://lists.w3.org/Archives/Member/w3c-archive/2002Dec/att-0035/02-xquery-operators.html

2.4 fn:data
-----------

1. REWRITE entire section as described in:
   http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0391.html

This text incorporates changes for nodes with complex type of mixed
content:

  fn:data($srcval as item*) as atomic value*

  The fn:data function takes a sequence of items and returns a
  sequence of atomic values.

  The result of fn:data is the sequence of atomic values produced by
  applying the following rules to each item in $srcval:

    If the item is an atomic value, it is returned.

    If the item is a node, fn:data returns the typed value of the
    node, as defined by the accessor function dm:typed-value defined
    for that kind of node in [XQuery 1.0 and XPath 2.0 Data Model].

    If the item is a comment, document, namespace,
    processing-instruction, or text node, then its typed value is
    equal to its string value, as an instance of xdt:untypedAtomic.

    If the item is an attribute node with type annotation
    xs:anySimpleType, then its typed value is equal to its string
    value, as an instance of xdt:untypedAtomic. The typed value of any
    other attribute node is derived from its string value and type
    annotation in a way that is consistent with XML Schema validation,
    as described in [XQuery 1.0 and XPath 2.0 Data Model].

    If the item is an element node whose type annotation
    denotes a complex type of empty content, then its typed value
    is equal to the empty sequence.

    If the item is an element node whose type annotation is xs:anyType
    or denotes a complex type of mixed content, then its typed value
    is equal to its string value, as an instance of xs:untypedAtomic.

    If the item is an element node whose type annotation denotes a
    simple type or a complex type of simple content, then its typed
    value is derived from its string value and type in a way that is
    consistent with XML Schema validation, as described in [XQuery 1.0
    and XPath 2.0 Data Model].

    If the item is an element node whose type annotation denotes a
    complex type with complex content (i.e., a type that permits
    subelements), fn:data raises a type error.

    [ Ed note: The typed-value accessor returns an empty sequence when
      applied to an element node with complex type of comple content,
      whereas fn:data() raises a type error, because type errors are a
      characteristic of the language, not the data model. ]

************************************************************************
XQuery 1.0: An XML Query Language
W3C Working Draft 15 November 2002
http://www.w3.org/TR/xquery/

and

XPath 2.0
W3C Working Draft 15 November 2002
http://www.w3.org/TR/xpath20/

2.3.2 Typed Value and String Value
----------------------------------

1. ADD definition of fn:data() as given above following:

  The typed value and string value for each kind of node are defined
  by the dm:typed-value and dm:string-value accessors in [XQuery 1.0
  and XPath 2.0 Data Model].

  The normative definitions are in the [XQuery 1.0 and XPath 2.0 Data
  Model] and is repeated here for convenience:

*****************************************************************************
XQuery 1.0 and XPath 2.0 Formal Semantics
W3C Working Draft 15 December 2002
http://lists.w3.org/Archives/Member/w3c-archive/2003Jan/0033.html

7.2.5 The fn:data function
--------------------------

1. This section is entirely rewritten to align with new semantics.

Introduction

  The fn:data function converts a sequence of items to a sequence of
  atomic values.

Notation

  Infering the type for the fn:data function is done by applying the
  fn:data function as a Filter, using the same approach as for the
  XPath steps.

    statEnv |- fn:data on Type1 : Type2

Static Type Analysis
--------------------

  The general rule for the function fn:data is to apply the filter
  [fn:data on] to the prime type of its argument type, then apply the
  quantifier to the result:

                 statEnv |- Expr : Type
          statEnv |- [fn:data on] prime(Type) : Type1
  ----------------------------------------------------
  statEnv |- fn:data(Expr) :  Type1 o quantifier(Type)


  The rules for the [fn:data on] filter always take a prime type
  (i.e., a union of item types) as an argument.

  When applied to none, [fn:data on] yields none.

    ---------------------------------
    statEnv |- [fn:data on] none : none


  When applied to the union of two types, [fn:data on] is applied to
each
  of the two types.  The resulting types are combined into a factored
  type.  This rule is necessary because [fn:data on] may return a
sequence
  of atomic types.


             statEnv |- [fn:data on] Type1 : Type3
             statEnv |- [fn:data on] Type2 : Type4
    ------------------------------------------------
    statEnv |- [fn:data on] Type1 | Type2 :
      prime(Type3 | Type4) o quantifier(Type3 | Type4)

  When applied to an atomic type, the [fn:data on] filter simply
  returns the atomic type:

                   Type &lt;: xdt:anyAtomicType
               ---------------------------------
               statEnv |- [fn:data on] Type : Type

  When applied to comment, processing instruction, text, and document
  node types, the [fn:data on] filter returns xdt:untypedAtomic.

   Type &lt;: comment | processing-instruction | text | document
  -----------------------------------------------------------
       statEnv |- [fn:data on] Type : xdt:untypedAtomic

  When applied to attribute node types with type annotation
  xs:anySimpleType or element node types with type annotation
  xs:anyType, the [fn:data on] filter returns xdt:untypedAtomic.

  statEnv |- AttributeType static lookup (of type xs:anySimpleType)
  -----------------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : xdt:untypedAtomic

  statEnv |- ElementType static lookup (of type xs:anyType)
  -----------------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : xdt:untypedAtomic

  When applied to an attribute type with any type annotation other
  than xs:anySimpleType, the [fn:data on] filter returns the attribute's
  simple type.

  statEnv |- AttributeType static lookup (of type TypeName)
             not(TypeName = xs:anySimpleType)
  statEnv |- (of type TypeName) expands to Type
  ----------------------------------------------------------
     statEnv |- [fn:data on] AttributeType : Type

  When applied to an element type whose type annotation denotes a
  simple type or a complex type of simple content or a complex type of
  empty content, the [fn:data on] filter returns the element's simple
  type.

     statEnv |- ElementType static lookup TypeReference
     statEnv |- TypeReference expands to Type
                 Type &lt;: (Type1, Type2)
                 Type1 &lt;: AttributeType*
                Type2 &lt;: xs:anySimpleType
  ----------------------------------------------------------
          statEnv |- [fn:data on] ElementType : Type2

  When applied to an element type whose type annotation denotes a
  complex type of mixed content, the [fn:data on] filter returns
  xdt:untypedAtomic.

     statEnv |- ElementType static lookup (of type TypeName)
statEnv.typeDefn(TypeName) =&gt; define type TypeName Derivation? Mixed {
Type1? }
-------------------------------------------------------------------------------
        statEnv |- [fn:data on] ElementType : xdt:untypedAtomic

  The [fn:data on] filter is not defined on any element type whose
  type annotation denotes a complex type of complex content and
  therefore raises a static error.

Dynamic Evaluation
------------------

The dynamic semantics of fn:data() are specified in [2.4 fn:data] of
[XQuery 1.0 and XPath 2.0 Functions and Operators].
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N535D9" id=
          "id-issue-N535D9"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-02-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Feb/0121.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Feb/0121.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-02-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>452. <a name="FS-Issue-0109" id=
        "FS-Issue-0109"><u>FS-Issue-0109</u>: Semantics of order
        by</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Semantics of order by

          <h3><a name="id-issue-N5360C" id=
          "id-issue-N5360C"></a>Description</h3>

          <div>
            <p>The precise semantics of order by is still open
            issue.</p>
          </div>

          <h3><a name="id-issue-N5360F" id=
          "id-issue-N5360F"></a>Proposed Resolution</h3>

          <div>
            <p>1) The dynamic semantics of order by will not be
            formally specified. Instead the following text will be
            added to the appropriate FS section:</p>

            <div class="exampleInner">
              <pre>
The dynamic semantics of order by is not formally specified. Formally
specifying order by may be done with the addition of tuples in the data
model and of operations on tuples. We believe this addition would add
much complexity to little benefit. The XQuery 1.0 document contains
enough information about the semantics of order by that can be used for
implementation purposes.
</pre>
            </div>

            <p>2) The satic semantics of order by will be
            specified. Here is how:</p>

            <p>* Normalization:</p>

            <p>The order by is normalized as an order by close in
            the single inner-most for or let clause. For
            instance:</p>

            <div class="exampleInner">
              <pre>
for $x in //a,
    $y in //b
order by $x+$y
return
  $x
</pre>
            </div>

            <p>is normalized to</p>

            <div class="exampleInner">
              <pre>
for $x in //a return
 for $y in //b
   order by $x+$y
     return $x
</pre>
            </div>

            <p>* Static typing:</p>

            <p>The order by clause in a single for loop is
            statically typed as follows:</p>

            <div class="exampleInner">
              <pre>
statEnv |- Expr1 : Type1
statEnv.varType($x : Type1) |- Expr2 : Type2
Type2 &lt;: anySimpleType
statEnv.varType($x : Type1) |- Expr3 : Type3
--------------------------------------------
for $x in Expr1 order by Expr2 return Expr3
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N53627" id=
          "id-issue-N53627"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>453. <a name="FS-Issue-0110" id=
        "FS-Issue-0110"><u>FS-Issue-0110</u>: Semantics of element
        and attribute constructors</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Semantics of element and
          attribute constructors

          <h3><a name="id-issue-N5363A" id=
          "id-issue-N5363A"></a>Description</h3>

          <div>
            <p>The precise semantics of element constructors is
            still an open issue.</p>
          </div>

          <h3><a name="id-issue-N5363D" id=
          "id-issue-N5363D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Closed following the semantics of element
            constructors agreed at the December f2f meeting.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>457. <a name="FS-Issue-0114" id=
        "FS-Issue-0114"><u>FS-Issue-0114</u>: Dynamic context for
        current date and time</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Dynamic context for
          current date and time

          <h3><a name="id-issue-N536BB" id=
          "id-issue-N536BB"></a>Description</h3>

          <div>
            <p>The following components dynamic contexts have no
            formal representation yet: current date and time.</p>

            <p>Related question: where are these context components
            used?</p>
          </div>

          <h3><a name="id-issue-N536C0" id=
          "id-issue-N536C0"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Add current date and time in the Dynamic
            Environment.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>461. <a name="FS-Issue-0118" id=
        "FS-Issue-0118"><u>FS-Issue-0118</u>: Data model syntax and
        literal values</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>Data model syntax
          and literal values

          <h3><a name="id-issue-N53735" id=
          "id-issue-N53735"></a>Description</h3>

          <div>
            <p>Phil suggests the data model should support
            primitive literals in their lexical form, in which case
            no explicit dynamic semantic rule would be
            necessary.</p>

            <p>More generally, should the data model support a
            constructor syntax?</p>
          </div>

          <h3><a name="id-issue-N5373A" id=
          "id-issue-N5373A"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>The corresponding syntax is going to be implemented
            in the formal semantics.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>473. <a name="FS-Issue-0130" id=
        "FS-Issue-0130"><u>FS-Issue-0130</u>: When to process the
        query prolog</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>When to process the
          query prolog

          <h3><a name="id-issue-N53893" id=
          "id-issue-N53893"></a>Description</h3>

          <div>
            <p>The query prolog needs to be processed before the
            normalization phase. This is not reflected yet in the
            processing model.</p>
          </div>

          <h3><a name="id-issue-N53896" id=
          "id-issue-N53896"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Decided to accept the "Processing Model" Proposal
            which addresses this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>478. <a name="FS-Issue-0135" id=
        "FS-Issue-0135"><u>FS-Issue-0135</u>: Semantics of special
        functions</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>Semantics of
          special functions

          <h3><a name="id-issue-N53925" id=
          "id-issue-N53925"></a>Description</h3>

          <div>
            <p>The current semantics does not completely cover
            built-in functions. Some functions used in the Formal
            semantics, or some functions from the XQuery 1.0 and
            XPath 2.0 Functions and Operators document need
            additional semantics specification.</p>
          </div>

          <h3><a name="id-issue-N53928" id=
          "id-issue-N53928"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Ashok has posted a list of functions for which we
            need special typing rules:
            http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0027.html</p>

            <p>It is now editorial just to implement those typing
            rules in the formal semantics document.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>479. <a name="FS-Issue-0136" id=
        "FS-Issue-0136"><u>FS-Issue-0136</u>: Non-determinism in
        the semantics</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Mary Fernandez</b></small>Non-determinism
          in the semantics

          <h3><a name="id-issue-N53943" id=
          "id-issue-N53943"></a>Description</h3>

          <div>
            <p>Some operations, such as logical operations and
            quantified operations are not deterministics
            ("early-out" semantics allowing not to evaluate all of
            the expressions). The formal semantics cannot capture
            the non-determinism in those operations.</p>
          </div>

          <h3><a name="id-issue-N53946" id=
          "id-issue-N53946"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft describes non deterministic
            semantics.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>482. <a name="FS-Issue-0139" id=
        "FS-Issue-0139"><u>FS-Issue-0139</u>: Type equivalence
        rules</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Type equivalence
          rules

          <h3><a name="id-issue-N53986" id=
          "id-issue-N53986"></a>Description</h3>

          <div>
            <p>Should we add back equivalence rules for types
            (e.g., <code>T1** == T1*</code> or <code>(T1 | T1) ==
            T1</code>). They are useful in practical
            implementations (e.g., to print an infered type or
            reduce complexity of infered types), and could be added
            in an appendix.</p>
          </div>

          <h3><a name="id-issue-N5398F" id=
          "id-issue-N5398F"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to add back equivalence rules.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>484. <a name="FS-Issue-0141" id=
        "FS-Issue-0141"><u>FS-Issue-0141</u>: Treatment of
        nillability and xsi:nil</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Treatment of
          nillability and xsi:nil

          <h3><a name="id-issue-N539B7" id=
          "id-issue-N539B7"></a>Description</h3>

          <div>
            <p>Nillability on an element declaration indicates that
            content of the corresponding element can be empty. The
            current data model preserves the xsi:nil attribute and
            this is used in the semantics at the type level. An
            alternative design would be to remove the xsi:nil
            attribute and add a 'nillable' marker in the schema
            component in the data model. This might be helping when
            we perform updates.</p>
          </div>

          <h3><a name="id-issue-N539BA" id=
          "id-issue-N539BA"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0259.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0259.html
            (W3C-members only)</a>)</small></p>

            <p>Guided by Jerome the following was decided:</p>

            <p>Assume: an element of type T may be nillable.
            Another element of type T may not be nillable.</p>

            <p>There is a Bug in language book re. type matching.
            Element with nil='true' does not have content according
            to the given type.</p>

            <p>Question 1 - Yes 10 Abstain 1, Recorded No from
            Vassilis</p>

            <p>Question 4 - Yes (unanimous) Do not know Vasillis
            votes.</p>

            <p>Question 3 - nil marker in datamodel and keep
            xsi:nil (both) Votes:1, 0, 8 MRys abstains as he wants
            update case clarified.</p>

            <p>Question 2 - Not relevant due to Yes answer to
            4.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xsl</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Decided to accept Jerome's proposal in <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0352.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0352.html</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>487. <a name="FS-Issue-0144" id=
        "FS-Issue-0144"><u>FS-Issue-0144</u>: Representation of
        text nodes in formal values</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Representation
          of text nodes in formal values

          <h3><a name="id-issue-N53A1F" id=
          "id-issue-N53A1F"></a>Description</h3>

          <div>
            <p>Formal Values described in section <a href=
            "http://www.w3.org/TR/xquery-semantics/#sec_values">http://www.w3.org/TR/xquery-semantics/#sec_values</a>
            represents either text nodes for well-formed documents
            or values for validated documents. Do we need to
            support a dual representation with both text nodes and
            values in the formal semantics?</p>
          </div>

          <h3><a name="id-issue-N53A25" id=
          "id-issue-N53A25"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>The formal semantics will keep the current formalism
            for values which uses either atomic values or text, but
            not both. The current version is easier to read and
            understand.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>491. <a name="FS-Issue-0148" id=
        "FS-Issue-0148"><u>FS-Issue-0148</u>: Validation of an
        empty string against a string list</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Validation of an
          empty string against a string list

          <h3><a name="id-issue-N53A83" id=
          "id-issue-N53A83"></a>Description</h3>

          <div>
            <p>The formal semantics assumes that the result of
            validating an element with empty content or with an
            empty text node against a list of strings is the empty
            sequence, not the empty string. Is that consistent with
            XML Schema?</p>
          </div>

          <h3><a name="id-issue-N53A86" id=
          "id-issue-N53A86"></a>Proposed Resolution</h3>

          <div>
            <p>I think XML Schema is clear that validating and
            empty element validated against a list type yields an
            empty element in the PSVI and therefore an empty
            element in the data model. In the formal semantics that
            corresponds to validating the content of the element to
            result in an empty sequence.</p>

            <p>I think this issue should be closed and that the
            current Formal Semantics documents is correct here.</p>
          </div>

          <h3><a name="id-issue-N53A8C" id=
          "id-issue-N53A8C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>JS's proposal ACCEPTED. No changes to the
            document.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>503. <a name="FS-Issue-0160" id=
        "FS-Issue-0160"><u>FS-Issue-0160</u>: Collations in the
        static environment</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Collations in the
          static environment

          <h3><a name="id-issue-N53BB5" id=
          "id-issue-N53BB5"></a>Description</h3>

          <div>
            <p>The Formal Semantics does not represent collations
            in the static environment. Should it?</p>
          </div>

          <h3><a name="id-issue-N53BB8" id=
          "id-issue-N53BB8"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Add collations in the Dynamic Environment.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>508. <a name="FS-Issue-0165" id=
        "FS-Issue-0165"><u>FS-Issue-0165</u>: Namespaces in element
        constructors</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Denise Draper</b></small>Namespaces in
          element constructors

          <h3><a name="id-issue-N53C25" id=
          "id-issue-N53C25"></a>Description</h3>

          <div>
            <p>We do not supply either namespaces or
            schema-components to the constructor. We cannot do
            these things because of the bottom-up nature of element
            construction: we do not, in general, know either the
            namespaces in scope or the validation-associated schema
            type until this element has been "seated" in some
            containing element (and so on recursively).</p>
          </div>

          <h3><a name="id-issue-N53C28" id=
          "id-issue-N53C28"></a>Proposed Resolution</h3>

          <div>
            <p>"A namespace node is created corresponding to the
            namespace used in the name of the element and in the
            name of each of its attributes."</p>

            <p>And add the following note:</p>

            <p>"Note: The set of namespace nodes does not need to
            be minimal, in that an implementation may choose to
            provide different prefixes for the same namespace URI
            on the same element (see example N1)."</p>

            <p>The reason is that this gives implementation more
            freedom to generate the namespace declarations
            efficiently while not really changing the information
            content. Note that it does not say that you can loose
            the prefix of the active namespace node, only, that you
            may be able to add more.</p>

            <p>The example N1 would be:</p>

            <div class="exampleInner">
              <pre>
Let $in be bound to
&lt;a:b xmlns:a="foo"/&gt;
</pre>
            </div>

            <p>Consider the query (assuming that we copy all
            namespace nodes):</p>

            <div class="exampleInner">
              <pre>
&lt;r:a xmlns:r="foo"&gt;{$in}&lt;/r:a&gt;
</pre>
            </div>

            <p>The data model at a minimum should have the
            following namespace nodes:</p>

            <p>{foo}a has xmlns:r="foo" and the xml namespace</p>

            <p>{foo}b has xmlns:r="foo" and the xml namespace as a
            minimum, but an implementation may chose to also
            provide xmlns:NS="foo" and serialize the result as</p>

            <div class="exampleInner">
              <pre>
&lt;r:a xmlns:r="foo"&gt;&lt;NS:b xmlns:r="foo" xmlns:NS="foo"/&gt;&lt;/r:a&gt;
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N53C42" id=
          "id-issue-N53C42"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-06-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jun/0039.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jun/0039.html
            (W3C-members only)</a>)</small></p>

            <p>The copy case will be decided separately later.</p>

            <p>Proposal adopted subject to following changes:</p>

            <p>1. Delete: unless there is already a namespace node
            for this namespace URI.</p>

            <p>2. Add: The namespace node need not be created if
            there is already a namespace node for this namespace
            URI on the given element.</p>

            <p>The editors may also choose to change the placement
            of the namespace node in the example:</p>

            <div class="exampleInner">
              <pre>
&lt;r:a xmlns:r="foo" xmlns:NS="foo"&gt;&lt;NS:b xmlns:r="foo" /&gt;&lt;/r:a&gt;
</pre>
            </div>

            <p>The editors may also choose whether to include a
            negative example along these lines:</p>

            <div class="exampleInner">
              <pre>
&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;
</pre>
            </div>

            <p>The resulting p element will have three namespace
            nodes:</p>

            <div class="exampleInner">
              <pre>
xmlns:NS0="&lt;http://www.w3.org/2001/XMLSchema-instance&gt;http://www.w3.org/2001/XMLSchema-instance"
xmlns:xml="&lt;http://www.w3.org/XML/1998/namespace&gt;http://www.w3.org/XML/1998/namespace"
</pre>
            </div>

            <p>And then point out that validation will obviously
            fail. This example is important for people to
            understand that the statically active/passive
            namespaces are dealt with before validation occurs.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small></p>

            <p>Decision for the "copy case".</p>

            <p>It was decided to stay with status quo; always copy
            all in-scope namespaces when constructing elements.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>514. <a name="FS-Issue-0171" id=
        "FS-Issue-0171"><u>FS-Issue-0171</u>: Raising
        errors</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Mary Fernandez</b></small>Raising errors

          <h3><a name="id-issue-N53D27" id=
          "id-issue-N53D27"></a>Description</h3>

          <div>
            <p>The semantics of raising errors in [XPath/XQuery] is
            not formally specified.</p>
          </div>

          <h3><a name="id-issue-N53D2A" id=
          "id-issue-N53D2A"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft describes the semantics of
            errors.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>520. <a name="FS-Issue-0177" id=
        "FS-Issue-0177"><u>FS-Issue-0177</u>: Coercion between
        untyped and atomic values</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Coercion between
          untyped and atomic values

          <h3><a name="id-issue-N53DC8" id=
          "id-issue-N53DC8"></a>Description</h3>

          <div>
            <p>Function calls, arithmetics expressions, etc. should
            cast untyped data to values. This is not currently
            formally specified.</p>
          </div>

          <h3><a name="id-issue-N53DCB" id=
          "id-issue-N53DCB"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft describes coercion between
            untyped and atomic values in function calls.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>521. <a name="FS-Issue-0178" id=
        "FS-Issue-0178"><u>FS-Issue-0178</u>: Semantics of XPath
        1.0 compatibility</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Semantics of
          XPath 1.0 compatibility

          <h3><a name="id-issue-N53DDE" id=
          "id-issue-N53DDE"></a>Description</h3>

          <div>
            <p>The semantics is not specified in the case the XPath
            1.0 compatibility flag is on.</p>
          </div>

          <h3><a name="id-issue-N53DE1" id=
          "id-issue-N53DE1"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft describes xpath 1.0 backward
            compatibility semantics.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>525. <a name="FS-Issue-0180" id=
        "FS-Issue-0180"><u>FS-Issue-0180</u>: Static context
        accessible from the dynamic context</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Static context
          accessible from the dynamic context

          <h3><a name="id-issue-N53E57" id=
          "id-issue-N53E57"></a>Description</h3>

          <div>
            <p>The formal semantics states that the static context
            is available from the dynamic context at run time. This
            should only be the case for part of the static context.
            Moreover certain parts of the dynamic context must be
            updated appropriately from during the dynamic
            evaluation (e.g., namespaces).</p>
          </div>

          <h3><a name="id-issue-N53E5A" id=
          "id-issue-N53E5A"></a>Proposed Resolution</h3>

          <div>
            <p>My recollection is that Mary implemented some
            changes in the internal FS document. I think we never
            reported that change to the working group.</p>

            <p>I'm not sure how to deal with this one. Maybe Mary
            can explain the change and the issue be closed?</p>
          </div>

          <h3><a name="id-issue-N53E60" id=
          "id-issue-N53E60"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-04-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0059.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0059.html
            (W3C-members only)</a>)</small></p>

            <p>The new FS working draft specifies that the whole of
            the static context is available from the dynamic
            context.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>443. <a name="FS-Issue-0100" id=
        "FS-Issue-0100"><u>FS-Issue-0100</u>: Namespace
        resolution</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Semantics?</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>FS Editors</b></small>Namespace resolution

          <h3><a name="id-issue-N534FC" id=
          "id-issue-N534FC"></a>Description</h3>

          <div>
            <p>The way (when? where?) namespace prefixes are
            resolved is still an open issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>244. <a name="cdata-serialization" id=
        "cdata-serialization"><u>cdata-serialization</u>: CDATA
        sections and serialization</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>serialization</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>CDATA sections and
          serialization

          <h3><a name="id-issue-N51D75" id=
          "id-issue-N51D75"></a>Description</h3>

          <div>
            <p>What are the semantics of CDATA sections in XQuery?
            Are they preserved in the data model for
            serialization?</p>
          </div>

          <h3><a name="id-issue-N51D78" id=
          "id-issue-N51D78"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to close, with document changes as described
            by Mike Kay in <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0095.html</a>,
            including editorial comments.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>155. <a name="xquery-phantom-sortby" id=
        "xquery-phantom-sortby"><u>xquery-phantom-sortby</u>:
        Sorting by Non-exposed Data</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Sorting by
          Non-exposed Data

          <h3><a name="id-issue-N51203" id=
          "id-issue-N51203"></a>Description</h3>

          <div>
            <p>Should we make it easier to sort by data that is not
            exposed in the result? Although the current language
            allows this, it is difficult to define complex sort
            orders in which some items are not exposed in the
            result and others are computed in the expression that
            is sorted. Is there a more convenient syntax for this
            that would be useful in XQuery?</p>
          </div>

          <h3><a name="id-issue-N51206" id=
          "id-issue-N51206"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N51209" id=
          "id-issue-N51209"></a>Proposed Resolution</h3>

          <div>
            <div class="exampleInner">
              <pre>
Here is an example:

FOR $e IN //employee
WHERE ...
RETURN
  &lt;newe&gt;$e/name&lt;/newe&gt;
SORTBY
  -- Now I would like to sort by salary but cannot.

Instead, the query would have to be written as

FOR $e IN (FOR $x IN //employee RETURN $x SORTBY employee/salary/data())
WHERE ...
RETURN
  &lt;newe&gt;$e/name&lt;/newe&gt;

Which seems awkward.

The question is of course how we can integrate the SORTBY in an other
way.

For example, could we say

FOR $e IN //employee
WHERE ...
SORTBY $e/salary/data()
RETURN
   &lt;newe&gt;$e/name&lt;/newe&gt;

?

Best regards
Michael
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N5120D" id=
          "id-issue-N5120D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0236.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0236.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-10
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html
            (W3C-members only)</a>)</small>Confirming that there
            are no concerns for the resolution of this XQuery only
            issue.</p>

            <p>Resolved by the adoption of the proposal to add
            "orderby" to the FLWR expression and to drop the
            previous "sortby" syntax/</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>243. <a name="sort-disappearing" id=
        "sort-disappearing"><u>sort-disappearing</u>: Provide an
        example of sorting "disappearing"</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>sort</b> Priority:
          <b>3</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Provide an example
          of sorting "disappearing"

          <h3><a name="id-issue-N51D59" id=
          "id-issue-N51D59"></a>Description</h3>

          <div>
            <p>Provide an example of</p>

            <div class="exampleInner">
              <pre>
   (employee sortby data(salary))/name
  
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N51D5E" id=
          "id-issue-N51D5E"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-10
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to leave this to editorial discretion.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>251. <a name="sort-by" id="sort-by"><u>sort-by</u>:
        Sorting "input to loop", not the result</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>Sorting "input to
          loop", not the result

          <h3><a name="id-issue-N51E2C" id=
          "id-issue-N51E2C"></a>Description</h3>

          <div>
            <p>Consider this query:</p>

            <div class="exampleInner">
              <pre>
   for $x in /books/book, $y in /reviews/review
   where $x/isbn = $y/isbn
   return &lt;newbook&gt;{ $x/title, $x/author, $y/reviewer }&lt;/newbook&gt;
   sortby isbn
</pre>
            </div>

            <p>This is an error, since isbn doesn't appear in
            newbook. (The static type system would catch this
            error.) What you have to write is</p>

            <div class="exampleInner">
              <pre>
   for $z in
     for $x in book, $y in review
     where $x/isbn = $y/isbn
     return &lt;dummy&gt;{ $x/title, $x/author, $y/reviewer, $x/isbn }&lt;/dummy&gt;
     sortby isbn
   return &lt;newbook&gt;{ $z/title, $z/author, $z/reviewer }&lt;/newbook&gt;
</pre>
            </div>

            <p>This is painful.</p>

            <p>I think that XQuery should support this syntax, or
            something similar:</p>

            <div class="exampleInner">
              <pre>
   for $x in book, $y in review
   where $x/isbn = $y/isbn
   sortby $x/isbn
   return &lt;newbook&gt;{ $x/title, $x/author, $y/reviewer }&lt;/newbook&gt;
</pre>
            </div>

            <p>Our plate is full with more important matters just
            now, but I hope we could fix this before we finalize
            XQuery.</p>
          </div>

          <h3><a name="id-issue-N51E3D" id=
          "id-issue-N51E3D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0236.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0236.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-10
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html
            (W3C-members only)</a>)</small>Confirming that there
            are no concerns for the resolution of this XQuery only
            issue.</p>

            <p>Resolved by the adoption of the proposal to add
            "orderby" to the FLWR expression and to drop the
            previous "sortby" syntax.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>318. <a name="sort-in-FLWR" id=
        "sort-in-FLWR"><u>sort-in-FLWR</u>: Add 'order by' clause
        to FLWR?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>sort</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Add 'order by'
          clause to FLWR?

          <h3><a name="id-issue-N52775" id=
          "id-issue-N52775"></a>Description</h3>

          <div>
            <p>Four issues were raised in a proposal to restructure
            sorting in XQuery [1]:</p>

            <p>1. Should we add an 'order by' clause to FLWR?</p>

            <p>The following syntax has been proposed:</p>

            <div class="exampleInner">
              <pre>
FLWRExpr ::= (ForClause |  LetClause)+ SortClause? WhereClause?
"return"  Expr
OrderClause ::=  "order by" stable? SortSpecList
SortSpecList ::= Expr SortModifier ("," SortSpecList)?
SortModifier ::= ("ascending" |  "descending")? ("empty" "greatest"
|  "empty" "least")?
</pre>
            </div>

            <p>The OrderClause sorts the tuple stream based on the
            conditions specified in the SortSpecList.</p>

            <p>In the status quo, 'sortby' is a standalone postfix
            expression. FLWR is used to iterate, and 'sortby' is
            used to sort. This causes certain difficulties, because
            iteration and sorting are not distinct, unrelated
            operations - in general, the order in which the output
            sequence is ordered determines the best order to choose
            when iterating over the input.</p>

            <p>When sorting data created with element constructors,
            it can sometimes be quite tricky to determine the
            original source of data in a constructed element. The
            more complex the expressions that construct the
            element, the more tricky this becomes. It is also
            tricky to iterate in an order determined by data that
            is not returned in a generated sequence.</p>

            <p>If we add this clause, should a FLWOR expression
            that contains an OrderClause but no ForClause result in
            a semantic error, since there is no tuple stream to
            sort?</p>

            <p>2. If we add an 'order by' clause, should we keep
            the sortby() expression, or remove it from our
            language?</p>

            <p>Keeping it is convenient for some expressions.
            Removing it leaves us with a simpler language, and does
            not require us to explain to our users why we have two
            ways of doing the same thing.</p>

            <p>3. How should we formalize 'order by' - or should we
            formalize it in Version 1.0?</p>

            <p>The most straightforward way to formalize 'order by'
            is to use tuples, which do not exist in our Data Model,
            and these would cause significant change to our Formal
            Semantics. However, the semantics of 'order by' are
            straightforward.</p>

            <p>Our options seem to be:</p>

            <p>3.a. Ensure that we know how it would be formalized
            using tuples, but postpone including this in the Formal
            Semantics until after Version 1.</p>

            <p>3.b. Refuse to add the feature unless it can be
            formalized with our current Data Model.</p>

            <p>3.c. Restrict the feature to functionality easily
            formalized with our current Data Model.</p>

            <p>I believe there was significant enthusiasm for 3.a.
            in today's telcon.</p>

            <p>4. Is the 'order by' clause part of the XPath spec,
            or is it only in XQuery?</p>

            <p>Jonathan</p>

            <p>[1]
            http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Jul/0177.html</p>
          </div>

          <h3><a name="id-issue-N5279E" id=
          "id-issue-N5279E"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N527A1" id=
          "id-issue-N527A1"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-10-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Oct/0278.html
            (W3C-members only)</a>)</small></p>

            <p>'order by' has been added.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>562. <a name="static-typing-fn-root" id=
        "static-typing-fn-root"><u>static-typing-fn-root</u>: What
        static typing for fn:root?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>What static typing
          for fn:root?

          <h3><a name="id-issue-N5434A" id=
          "id-issue-N5434A"></a>Description</h3>

          <div>
            <p>A: '/' is an important operation in XPath and XQuery
            and it should have a precise type. This is normalized
            to 'fn:root(self::node()). This means we need to have a
            special typing rule for fn:root.</p>

            <p>B: Should fn:root($x) be a type error or a dynamic
            error, if the root node of $x is not a document
            node?</p>

            <p>Some arguments in favor: If the root node is not a
            document but-let's say-an element node with name a,
            then it is non-obvious and confusing that /a does not
            select this element. Erroring would allow us to
            investigate this issue further and provide a solution
            at a later date. The current semantics does not. Also,
            in XPath 1.0, the root node always was a document
            node.</p>

            <p>Possible argument against: You cannot use an
            absolute path expression starting with / on a data
            model instance that has no document node as a root
            node.</p>
          </div>

          <h3><a name="id-issue-N54353" id=
          "id-issue-N54353"></a>Proposed Resolution</h3>

          <div>
            <p>B: Suggested resolution: The arguments in favor
            outweigh the arguments against and thus my proposal is
            to raise the error.</p>
          </div>

          <h3><a name="id-issue-N54357" id=
          "id-issue-N54357"></a>Proposed Resolution</h3>

          <div>
            <p>#1 fn:root statically the same.</p>

            <p>#2 implementations can extend the static
            semantics.</p>

            <p>#3 fn:root dynamic semantics stay the same.</p>
          </div>

          <h3><a name="id-issue-N5435F" id=
          "id-issue-N5435F"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-06-25
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0031.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0031.html
            (W3C-members only)</a>)</small></p>

            <p>#1,2 Adopted.</p>

            <p>No decision on item #3 pending comment from Michael
            Rys</p>

            <p><small>Decision by: <b>xquery</b> on 2003-07-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Decision to decouple fn:root and "/". "/" is an
            error if there is no document node. Formally:</p>

            <div class="exampleInner">
              <pre>
Expr[/] =
    fs:doc-root(self::node)

Expr[/Expr] =
Expr[fs:doc-root(self::node)/Expr]

define function fs:doc-root($n as node) as document
{
    fn:root($n) treat as document
}
</pre>
            </div>

            <p>Note that XSL WG will still need to review the
            proposal before deciding.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jul/0063.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jul/0063.html
            (W3C-members only)</a>)</small></p>

            <p>Accepting decisions on #1 and #2.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>455. <a name="FS-Issue-0112" id=
        "FS-Issue-0112"><u>FS-Issue-0112</u>: Typing for the
        "typeswitch" default clause</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Typing for the
          "typeswitch" default clause

          <h3><a name="id-issue-N53670" id=
          "id-issue-N53670"></a>Description</h3>

          <div>
            <p>There is an asymetry in the typing for the default
            clause in typeswitch vs. the other case clauses. This
            results in a less precise type when the default clause
            can be applied.</p>

            <p>It would be nicer to be able to have the type be
            more precise, like for the other case clauses.</p>

            <p>The technical problem is the need for some form of
            negation. I think one could define a
            "non-common-primes" function that would do the trick,
            but I leave that as open for now until further review
            of the new typeswitch section is made.</p>
          </div>

          <h3><a name="id-issue-N53677" id=
          "id-issue-N53677"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-02-13
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-02-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html
            (W3C-members only)</a>)</small></p>

            <p>Accepting proposal in <a href=
            "#FS-Issue-0173">#FS-Issue-0173</a> resolves this
            issue.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Reaffirming decision.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>472. <a name="FS-Issue-0129" id=
        "FS-Issue-0129"><u>FS-Issue-0129</u>: Static typing of
        union</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Static typing of
          union

          <h3><a name="id-issue-N53863" id=
          "id-issue-N53863"></a>Description</h3>

          <div>
            <p>What should be the semantics of arithmetics
            expressions over unions. Right now, it would raise a
            dynamic error. Do we want to raise a static error?</p>

            <p>Should operators and functions consistenly with
            respect to typing?</p>

            <p>With the current semantics in Section 4.5 expr1 +
            expr2 raises a static type error if (e.g.) expr1 has
            type string and expr2 has type integer. It raises only
            a dynamic error, if expr1 has type (string | integer)
            and expr2 has type integer, and expr1 actually
            evaluates to a string. An alternative would be that
            this raises also a static error, because it cannot be
            guarantueed to succeed on all instances.</p>
          </div>

          <h3><a name="id-issue-N5386A" id=
          "id-issue-N5386A"></a>Proposed Resolution</h3>

          <div>
            <p>For user-defined functions there is no issue and the
            current static typing rules work fine.</p>

            <p>There is an issue about static typing for built-in
            overloaded functions (arithmetic and comparison
            operators). In that case, the following algorithm is
            proposed:</p>

            <p>If one or both of the types of the operands are a
            union, static typing is performed for each par of item
            types in the union. If any of the cases raises a static
            type error, the whole static typing raises a static
            type error. Otherwise each resulting static type is
            unioned to form the final result type.</p>

            <p>Here are examples for the expression (E1 + E2) in
            the case of various input types:</p>

            <div class="exampleInner">
              <pre>
     E1 : int and E2 : int
then E1 + E2 : int

     E1 : float and E2 : int
then E1 + E2 : float
</pre>
            </div>

            <p>those cases did not change. In case there is a
            union:</p>

            <div class="exampleInner">
              <pre>
     E1 : (float | int) and E2 : int
then E1 + E2 : (float | int)
</pre>
            </div>

            <p>since both cases (int + int) and (float | int) could
            occur.</p>

            <div class="exampleInner">
              <pre>
E1 : (float | int) and E2 : (int | string)
</pre>
            </div>

            <p>raises a static error since (int + string) raises a
            static error.</p>
          </div>

          <h3><a name="id-issue-N53880" id=
          "id-issue-N53880"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>475. <a name="FS-Issue-0132" id=
        "FS-Issue-0132"><u>FS-Issue-0132</u>: Typing for
        descendant</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Peter Fankhauser</b></small>Typing for
          descendant

          <h3><a name="id-issue-N538C7" id=
          "id-issue-N538C7"></a>Description</h3>

          <div>
            <p>The current static typing for descendant is still
            under review and the inferences rules in that version
            are probably containing bugs.</p>
          </div>

          <h3><a name="id-issue-N538CA" id=
          "id-issue-N538CA"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Decided to accept the "Simplified typing" proposal
            in <a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Jul/0023.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Jul/0023.html</a>,
            which solves this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>488. <a name="FS-Issue-0145" id=
        "FS-Issue-0145"><u>FS-Issue-0145</u>: Static typing of path
        expressions in the presence of derivation by
        extension</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Static typing of
          path expressions in the presence of derivation by
          extension

          <h3><a name="id-issue-N53A3E" id=
          "id-issue-N53A3E"></a>Description</h3>

          <div>
            <p>The current static type analysis rules for Step
            expressions is broken in the presence of derivation by
            extension. This bug is impacting section <a href=
            "http://www.w3.org/TR/xquery-semantics/#sec_steps">http://www.w3.org/TR/xquery-semantics/#sec_steps</a>.</p>
          </div>

          <h3><a name="id-issue-N53A44" id=
          "id-issue-N53A44"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-01-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jan/0097.html
            (W3C-members only)</a>)</small></p>

            <p>Dec. FS working draft fixes the static semantics of
            path expressions in the presence of derivation by
            extension.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>509. <a name="FS-Issue-0166" id=
        "FS-Issue-0166"><u>FS-Issue-0166</u>: Static typing for
        validate</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Static typing for
          validate

          <h3><a name="id-issue-N53C71" id=
          "id-issue-N53C71"></a>Description</h3>

          <div>
            <p>Although validate should always return a typed
            value, there is no way to do static analysis for it,
            since the type against which it is validated cannot be
            known at static type (it depends on the result of
            evaluation for the input expression).</p>
          </div>

          <h3><a name="id-issue-N53C74" id=
          "id-issue-N53C74"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Ignore content's type. Assign static type using
            element name and validation context.</p>

            <p>May raise type error if element content will NEVER
            validate successfully.</p>

            <div class="exampleInner">
              <pre>
&lt;fixbrain&gt;{ validate { input()/fixsink/person } }&lt;/fixbrain&gt;
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>513. <a name="FS-Issue-0170" id=
        "FS-Issue-0170"><u>FS-Issue-0170</u>: Imprecise static type
        of constructed elements</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster: <b>Static
          typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Mary Fernandez</b></small>Imprecise static
          type of constructed elements

          <h3><a name="id-issue-N53CFF" id=
          "id-issue-N53CFF"></a>Description</h3>

          <div>
            <p>Implementation of Alternative 1 means that the
            static type for constructed elements and attributes is
            very imprecise. E.g., the type of {(1,2,3)} is element
            a { xs: anyType }. See remark by Denise in section on
            element constructors for possible fix.</p>
          </div>

          <h3><a name="id-issue-N53D02" id=
          "id-issue-N53D02"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Applies to literal element constructor and computed
            element constructor with literal name</p>

            <p>Raise type error if element content will NEVER
            validate successfully.</p>

            <p>If static typing is enabled, it is a static type
            error if the type of the content of the element is NOT
            a subtype of type declared for the element. Untyped
            content treated "liberally".</p>

            <p>Parallels semantics of static typing rules for
            function calls.</p>

            <div class="exampleInner">
              <pre>
type plumber { element name of type xs:string }
type surgeon { element name of type xs:string }
element fixsink { element person of type plumber }
element fixbrain { element person of type surgeon }

&lt;fixbrain&gt;{ input()/fixsink/person }&lt;/fixbrain&gt;
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>144. <a name="xquery-escaping-quotes-and-apostrophes"
        id=
        "xquery-escaping-quotes-and-apostrophes"><u>xquery-escaping-quotes-and-apostrophes</u>:
        Escaping Quotes and Apostrophes</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>XML Query</b></small>Escaping Quotes and
          Apostrophes

          <h3><a name="id-issue-N510DA" id=
          "id-issue-N510DA"></a>Description</h3>

          <div>
            <p>In attribute constructors and string constructors,
            XQuery uses quotes or apostrophes as delimiters. How
            are these characters escaped when they occur within
            strings that are created by one of these
            constructors?</p>
          </div>

          <h3><a name="id-issue-N510DD" id=
          "id-issue-N510DD"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Michael Rys:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
              <div class="exampleInner">
                <pre>
I asked a member of my team to check for a resolution that he can live
with. He said he has not found it and currently works on constructing
examples that shows the open issue.
</pre>
              </div>
            </div>
          </div>

          <h3><a name="id-issue-N510E3" id=
          "id-issue-N510E3"></a>Proposed Resolution</h3>

          <div>
            <p>I propose that we use double-delimiters within a
            string literal, e.g. 'I don''t', and unlike most of my
            syntactic ideas, this proposal seemed to recieve
            general support.</p>
          </div>

          <h3><a name="id-issue-N510E7" id=
          "id-issue-N510E7"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-04-30
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Apr/0204.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Apr/0204.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-05-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002May/0241.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002May/0241.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-06-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2002Jun/0037.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2002Jun/0037.html
            (W3C-members only)</a>)</small></p>

            <p>Syntax in current draft has this, but explanatory
            text need to be added.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>246. <a name="nested-comments" id=
        "nested-comments"><u>nested-comments</u>: Nested XQuery
        comments allowed?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Nested XQuery
          comments allowed?

          <h3><a name="id-issue-N51DAC" id=
          "id-issue-N51DAC"></a>Description</h3>

          <div>
            <p>Nested XQuery comments allowed?</p>
          </div>

          <h3><a name="id-issue-N51DAF" id=
          "id-issue-N51DAF"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Permit nested comments. Use "(:" and ":)"
            syntax.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>341. <a name="SequenceType-problems" id=
        "SequenceType-problems"><u>SequenceType-problems</u>:
        Problems with SequenceType</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>Problems with
          SequenceType

          <h3><a name="id-issue-N52A8F" id=
          "id-issue-N52A8F"></a>Description</h3>

          <div>
            <p>Using the "instance of SequenceType" construct
            within a predicate of a path expression, or in an XSLT
            match pattern, is very unwieldy: the verbose
            English-like syntax of a SequenceType does not go well
            with the terse syntax of path expressions, leading to
            inelegant constructs like</p>

            <div class="exampleInner">
              <pre>
select="//*[.instance of element of type address]"
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N52A94" id=
          "id-issue-N52A94"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Michael Kay:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
            </div>
          </div>

          <h3><a name="id-issue-N52A98" id=
          "id-issue-N52A98"></a>Proposed Resolution</h3>

          <div>
            <div class="exampleInner">
              <pre>
1. Motivation

Many people have asked for the ability to test for elements of a given
type in path expressions, and to be able to write path expressions
that would retrieve nodes with types that match the declared types of
function parameters. For instance, consider the following query in the
syntax of our current Working Draft:

       define function name($e as element person)
         returns element name
       {
            $e/name
       }

       for $p in input()//person
       return name($p)

This query can fail at runtime, because the path expression matches
any element named person, and the function parameter requires a valid
element conforming to a globally declared element named person.

This proposal adds ElementType and AttributeType nodetests to path
expressions, and aligns the syntax of SequenceType with the syntax of
type tests done in path expressions. For instance, in the following
syntax, the KindTest "element(person)" matches only person elements
that are valid instances of the globally declared person element, and
the same test is used for the function's parameter type:

       define function name($e as element(person))
         returns element name
       {
            $e/name
       }

       for $p in input()//element(person)
       return name($p)

Using the same syntax and semantics for these tests in both path
expressions and SequenceType ensures that they are well aligned, and
reduces the number of expressions users of the language must learn. In
addition, it allows us to fix some problems with SequenceType that
have made the grammar complex to maintain.

ElementType and AttributeType nodetests also allow the names of types
to be used to select nodes, eg:

       define function name($e as element(person, surgeon))
         returns element name
       {
            $e/name
       }


       for $p in input()//element(person, surgeon)
       return name($p)

Or:

      for $date in input()//element(*, xs:date)
      return &lt;date&gt;{ $date }&lt;/date&gt;

Note that the above queries provide enough type information to be
statically valid without 'treat as'. If a NameTest were used instead
of the ElementType nodetest, the above query would not be statically
valid, and the query writer would need to use treat as to make it so.

Using this proposal, the most convenient way to match locally declared
types in a path expression is to use the globally declared types in
which they are contained to establish a type context; eg, the
following query from use case STRONG is statically valid as modified
below:


define function names-match(
    $s as element(ipo:purchaseOrder/ipo:shipTo),
    $b as element(ipo:purchaseOrder/ipo:billTo)
    as xs:boolean
{
        $s/ipo:name = $b/ipo:name
}

for $p in document("ipo.xml")//element(ipo:purchaseOrder)
where not( names-match( $p/ipo:shipTo, $p/ipo:billTo ) )
return $p


ElementType and AttributeType nodetests can also be used in match
patterns on XSLT stylesheets, eg:

     &lt;xsl:template match="element(person)"&gt;

     &lt;xsl:template match="attribute(*,xs:date)"&gt;

For more examples of ElementType and AttributeType nodetests in match
patterns, see [1].

This proposal steals liberally from proposals by Phil Wadler, Jeni
Tennison, Michael Rys, and Mike Kay. Don Chamberlin gave detailed
review and pointed out important problems and their solutions.  Scott
Boag tested the grammar.


========================================================================
2. Examples of ElementTypeTest and AttributeTypeTest

Informally, the principles for matching an ElementTypeTest or
AttributeTypeTest are as follows:

- element() matches elements, attribute() matches attributes.

- names in ElementTypeTest and AttributeTypeTest test the name of a
   node. If the name of an element identifies a Corresponding Element
   Declaration which is the head of a substitution group, the name of
   an ElementTypeTest also matches other names in the substitution
   group.

- types in ElementTypeTest and AttributeTypeTest match type
   annotations.  If no type is supplied, there must be a Corresponding
   Element Declaration or a Corresponding Attribute Declaration, which
   is used to nominate a type.

The following examples illustrate these semantics by stating what
nodes an ElementTypeTest would match.

  element()
  element(*)
  element(*,*)

    Matches any element. These three forms are equivalent.

  element( person )

    Matches any element named 'person' with the type corresponding to
    the globally declared 'person' element; if this element is
    nillable, also matches any empty element named person containing an
    xsi:nil attribute with the value 'true'. If the globally declared
    'person' element is the head of a substitution group, also matches
    element names from the substitution group. If there is no globally
    declared 'person' element, a type error is raised.

  element( person, * )

    Matches any element named person or any element whose name is in
    the substitution group of the globally declared element person, if
    one exists. This is equivalent to the earlier ~person syntax, which
    we feel is no longer needed.

  element( person, personType nillable )

    Matches any element named 'person' with the type 'personType',
    including any empty element named person containing an xsi:nil
    attribute with the value 'true'. If the globally declared 'person'
    element is the head of a substitution group, also matches element
    names from the substitution group.

  element( *, xs:integer nillable )

   Matches any element of type xs:integer, including any such element
   with xs:nil="true" and no content.

  element( foo/bar/person )

    Matches any element named 'person' with the type of the
    corresponding element declaration.

  element( foo/bar/person, personType )

    Syntax Error.

  attribute()

    Matches any attribute.

  attribute( foo/bar/person/@id )

    Matches any attribute named 'id' with the type of the corresponding
    attribute declaration.

  element( @*, xs:integer )

   Matches any attribute of type xs:integer.

  attribute( @price, xs:integer )

   Matches any attribute named price of type xs:integer.


========================================================================
3. Syntax


Tokens

Scott currently has the following as tokens, and is working on making
them productions:

[22]    SchemaGlobalContext    ::=    QName |  ("type" "(" QName ")")
[23]    SchemaContextStep    ::=    QName

Productions

[112]    SequenceType    ::=    (SequenceSingleType OccurrenceIndicator?)
                              |  &lt;"empty" "(" ")"&gt;
[113]    SequenceSingleType    ::=    AtomicType |  ItemType
[114]    AtomicType    ::=    QName
[115]    ItemType    ::=   KindTest |  &lt;"item" "(" ")"&gt;
[116]    KindTest    ::=   DocumentTest
                         |  ElementTypeTest
                         |  AttributeTypeTest
                         |  ProcessingInstructionTest
                         |  CommentTest
                         |  TextTest
                         |  AnyKindTest


[117]    DocumentTest    ::=    &lt;"document" "(" ")"&gt;
[118]    ElementTypeTest ::=    &lt;"element" "("&gt; ((SchemaContextPath LocalName)
                             |  (NodeName ("," TypeName "nillable"?)?))? ")"
[119]    AttributeTypeTest ::=  &lt;"attribute" "("&gt; ((SchemaContextPath "@"
LocalName)
                             |  ("@" NodeName ("," TypeName)?))? ")"
[120]    SchemaContextPath ::=  &lt;SchemaGlobalContext "/"&gt;
&lt;SchemaContextStep "/"&gt;*
[122]    LocalName    ::=    QName
[123]    NodeName    ::=    QName |  "*"
[124]    TypeName    ::=    QName |  "*"
[125]    OccurrenceIndicator    ::=    "*" |  "+" |  "?"


========================================================================
4. Semantics

A ContextName identifies a valid path from a globally declared element
declaration or type definition in the in-scope schema definitions. For
instance, the following indicates a shipTo element on a purchaseOrder:

   purchaseOrder/shipTo

If a ContextName begins with type(t), then the path starts with a
global named type in the in-scope schema definitions. For instance,
the following indicates a shipTo element in a complex type called
purchaseOrderType:

   type(purchaseOrderType)/shipTo

The rules for matching an ElementTypeTest depend on the Corresponding
Element Declaration, which is determined as follows:

   An ElementName is the first argument of an ElementTypeTest.

   If the ElementName has the form NodeName, and it matches the name of
   a globally declared element declaration in the in-scope schema
   definitions, it is the "Corresponding Element Declaration". If the
   ElementName has the form SchemaContextPath LocalName, then the
   element declaration which would correspond to an element named
   LocalName in the given context is the "Corresponding Element
   Declaration".

The rules for matching an AttributeTypeTest depend on the
Corresponding Attribute Declaration,

   An AttributeName is the first argument of an AttributeTypeTest.

   If the AttributeName has the form NodeName, and it matches the name
   of a globally declared element declaration in the in-scope schema
   definitions, it is the "Corresponding Element Declaration". If the
   AttributeName has the form SchemaContextPath LocalName, then the
   element declaration which would correspond to an element named
   LocalName in the given context is the "Corresponding Attribute
   Declaration".

An ElementTypeTest matches a node if the node is an element, the
element's name matches the ElementName of the ElementTypeTest, and the
element's type matches the type and nillability of the
ElementTypeTest.

An ElementName is matched as follows:

   If the ElementName is absent or "*", it matches an
   element of any name.

   If the ElementName has the form NodeName, it matches an element if
   the expanded-QNames of the element and the ElementName match. If the
   ElementName has the form SchemaContextPath LocalName, it matches an
   element if the expanded-QNames of the element and the LocalName
   match.

   If the Corresponding Element Declaration is the head of a
   substitution group, then the ElementName also matches an element if
   the expanded-QNames of the element and any element in the
   substitution group match.

   Otherwise, the ElementName does not match the element's name.

An element's TypeName is matched as follows:

   If the TypeName is "*", it matches an element of any type.

   If the TypeName is absent, then the default TypeName is selected,
   which is the type of the Corresponding Element Declaration. The
   default nillability is also selected, which is the nillability of
   the Corresponding Element Declaration.

   If the expanded-QName of the TypeName matches the element's type or
   any of its subtypes, then the TypeName matches the element's type if
   the type nillability is also satisfied.

   If the element's type name is an anonymous local type, the TypeName
   must be a default type chosen from the Corresponding Element
   Declaration, and they match if the element's type is the same as or
   derived by restriction or extension from the type of the TypeName,
   provided the type nillability is also satisfied.

   An element's type nillability is not satisified when the type is not
   nillable, and the element's dm:nil property is 'true'; otherwise, it
   is satisfied.

The semantics of AttributeTypeTest are parallel, substituting the word
'attribute' for 'element' in the above description and eliminating
substitution groups and nillable, which do not apply to attributes. An
AttributeTypeTest matches a node if the node is an attribute, the
attribute's name matches the AttributeName of the AttributeTypeTest, and
the attribute's type matches the type and nillability of the
AttributeTypeTest.


An AttributeName is matched as follows:

   If the AttributeName is absent or "*", it matches any attribute.

   If the AttributeName has the form NodeName, it matches an element if
   the expanded-QNames of the element and the AttributeName match. If
   the AttributeName has the form SchemaContextPath LocalName, it
   matches an element if the expanded-QNames of the element and the
   LocalName match.

   Otherwise, the AttributeName does not match the attribute's name.

An attribute's TypeName is matched as follows:

   If the TypeName is "*", it matches an attribute of any type.

   If the TypeName is absent, then the default TypeName is selected,
   which is the type of the corresponding attribute declaration.

   If the expanded-QName of the TypeName matches the attribute's type
   or any of its subtypes, then the TypeName matches the attribute.

   If the attribute's type name is an anonymous local type, the
   TypeName must be a default type chosen from the Corresponding
   Attribute Declaration, and they match if the attribute's type is the
   same as or derived by restriction or extension from the type of the
   TypeName.


========================================================================
6. attribute() and default axes

To allow attribute() to be used in path expressions, abbreviated steps
need to be modified as follows:

Current text:


   &gt;     The most important abbreviation is that child:: can be omitted
   &gt;     from a step. In effect, child is the default axis. For example,
   &gt;     a path expression section/para is short for
   &gt;     child::section/child::para.


Proposed text:


   &gt;     The most important abbreviation is that child:: can be omitted
   &gt;     from a step, or attribute:: can be omitted from a step that
   &gt;     contains an AttributeTypeTest. In most cases, child is the
   &gt;     default axis. For example, a path expression section/para is
   &gt;     short for child::section/child::para. However, if the step
   &gt;     contains an AttributeType, the default axis is attribute::. For
   &gt;     example, child::section/attribute( id ) is short for
   &gt;     child::section/attribute::attribute( id ).



========================================================================
7. Static Semantics

    To be supplied.


========================================================================
8. Issues

Issue:

     Should a WildCard be allowed for the names of attributes and
     elements? For instance, one might imagine wanting to select only
     HTML elements of type xs:string:

         element(html:*, xs:string)
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N52A9C" id=
          "id-issue-N52A9C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Proposal accepted resolving issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>532. <a name="sequence-type-path-alignment" id=
        "sequence-type-path-alignment"><u>sequence-type-path-alignment</u>:
        Alignment between path expressions and sequence
        types</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>Alignment between
          path expressions and sequence types

          <h3><a name="id-issue-N53F2E" id=
          "id-issue-N53F2E"></a>Description</h3>

          <div>
            <p>Should there be better alignment between path
            expressions and sequence types?</p>
          </div>

          <h3><a name="id-issue-N53F31" id=
          "id-issue-N53F31"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Proposal in issue <a href=
            "#SequenceType-problems">#SequenceType-problems</a>
            accepted resolving issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>535. <a name="lexical-state-tables" id=
        "lexical-state-tables"><u>lexical-state-tables</u>: Lexical
        state tables</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Scott Boag</b></small>Lexical state tables

          <h3><a name="id-issue-N53F97" id=
          "id-issue-N53F97"></a>Description</h3>

          <div>
            <p>Should the state tables be removed or made non
            normative?</p>
          </div>

          <h3><a name="id-issue-N53F9A" id=
          "id-issue-N53F9A"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Decided to keep them normative.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>547. <a name="grammar-declare" id=
        "grammar-declare"><u>grammar-declare</u>: Use "declare" for
        declarations</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Use "declare" for
          declarations

          <h3><a name="id-issue-N5412C" id=
          "id-issue-N5412C"></a>Description</h3>

          <div>
            <p>G3. Section 4.3 Validation Declaration</p>

            <div class="exampleInner">
              <pre>
[118]     ValidationDecl

   ::=     &lt;"validation" "lax"&gt; |  &lt;"validation" "strict"&gt; |
&lt;"validation" "skip"&gt;
</pre>
            </div>

            <p>Add declare keyword in order to align with general
            declaration syntax</p>

            <p>Proposal:</p>

            <div class="exampleInner">
              <pre>
&lt;"declare" "validation" ("lax" |  "strict" |  "skip")&gt;
</pre>
            </div>

            <p>G4. Section 4.4 Xmlspace Declaration</p>

            <div class="exampleInner">
              <pre>
[104]     XMLSpaceDecl

   ::=     &lt;"declare" "xmlspace"&gt; "=" ("preserve" |  "strip")
</pre>
            </div>

            <p>drop "=" in order to align with general declaration
            syntax (this is an option and not a value like in
            namespace declarations)</p>

            <p>Proposal:</p>

            <div class="exampleInner">
              <pre>
&lt;"declare" "xmlspace"&gt; ("preserve" |  "strip")
</pre>
            </div>

            <p>G5. Section 4.5 Default Collation</p>

            <div class="exampleInner">
              <pre>
[105]     DefaultCollationDecl

   ::=     &lt;"default" "collation" "="&gt; StringLiteral
</pre>
            </div>

            <p>drop "=" and add "declare" in order to align with
            general declaration syntax.</p>

            <p>Proposal:</p>

            <div class="exampleInner">
              <pre>
&lt;"declare" "default" "collation"&gt; StringLiteral
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N5414B" id=
          "id-issue-N5414B"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>(1) use of a declare keyword accepted without
            objection</p>

            <p>(2) remove "=" in 3 places</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>548. <a name="lexical-rules" id=
        "lexical-rules"><u>lexical-rules</u>: Lexical Rules: states
        normative?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Lexical Rules:
          states normative?

          <h3><a name="id-issue-N54166" id=
          "id-issue-N54166"></a>Description</h3>

          <div>
            <p>G6. Section A.1.2 Lexical Rules</p>

            <p>Current wording: "The lexical contexts and
            transitions between lexical contexts is described in
            terms of a series of states and transitions between
            those states."</p>

            <p>Make all states non-normative except those that are
            needed for XML construction, string literal and XQuery
            context.</p>
          </div>

          <h3><a name="id-issue-N5416D" id=
          "id-issue-N5416D"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>They are normative. They define things not defined
            elsewhere. An implementation doesn't need to work in
            terms of lexical states; they are a declarative way to
            specify the results.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>550. <a name="comments-location" id=
        "comments-location"><u>comments-location</u>: Location of
        Comments</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Location of
          Comments

          <h3><a name="id-issue-N541BA" id=
          "id-issue-N541BA"></a>Description</h3>

          <div>
            <p>XQuery 1.0 states "Comments may be used anywhere
            that ignorable whitespace is allowed, and within
            element content." I am trying to understand what that
            means and whether it is still true.</p>

            <p>What does this mean?</p>

            <div class="exampleInner">
              <pre>
&lt;a&gt;A (:big:) cat&lt;/a&gt;
</pre>
            </div>

            <p>Does (:big:) get recognized as a comment and removed
            from the element content, and then the two surrounding
            pieces of text get coalesced into a single text node
            with the content "A cat"?</p>

            <p>Or does the tag get a text node containing the
            string "A (:big:) cat"? If this is not the case, then
            how would I construct an element that actually has this
            content?</p>

            <p>Have we thought carefully about whether we want
            comments to be recognized inside tag content? In most
            other ways, element-content is treated much like a
            string. I believe that comments are not recognized
            inside strings, right? Is this a strong argument for
            not recognizing comments inside element content? Is
            there any argument for recognizing them?</p>
          </div>

          <h3><a name="id-issue-N541C7" id=
          "id-issue-N541C7"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Comments to be allowed everywhere ignorable
            whitespace can occur in an XQuery expression.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>552. <a name="processing-instruction-quotes" id=
        "processing-instruction-quotes"><u>processing-instruction-quotes</u>:
        Should the quotes in processing-instruction("...") be
        optional?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>syntax</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL WG</b></small>Should the quotes in
          processing-instruction("...") be optional?

          <h3><a name="id-issue-N5420E" id=
          "id-issue-N5420E"></a>Description</h3>

          <div>
            <p>Do we want to make the quotes in
            processing-instruction() optional? It is always a
            string literal and we have introduced element() and
            attribute() that already do not look like
            functions...</p>
          </div>

          <h3><a name="id-issue-N54211" id=
          "id-issue-N54211"></a>Proposed Resolution</h3>

          <div>
            <p>Here are the changes that would be needed to
            implement this change in the current Working Draft of
            XQuery:</p>

            <p>1. Change the ProcessingInstruction Test production
            to:</p>

            <div class="exampleInner">
              <pre>
[123] ProcessingInstructionTest ::= &lt;"processing-instruction" "("&gt; NCName ")"
        |   &lt;"processing-instruction" "("&gt; StringLiteral? ")"
</pre>
            </div>

            <p>2. Replace the following text:</p>

            <div class="exampleInner">
              <pre>
 &gt;    4. processing-instruction(N ) matches any processing instruction
 &gt;       node whose name (called its "PITarget" in XML) is equal to N,
 &gt;       where N is a StringLiteral. Example:
 &gt;       processing-instruction("browser") matches any processing
 &gt;       instruction directed to the application named browser.
</pre>
            </div>

            <p>Here is the replacement text:</p>

            <div class="exampleInner">
              <pre>
4. processing-instruction(N) matches any processing instruction
   node whose name (called its "PITarget" in XML) is equal to N,
   where N is an NCName. Example: processing-instruction(browser)
   matches any processing instruction directed to the application
   named browser.

   Note:

    For backwards compatibility with XPath 1.0, the argument to a
    processing instruction may also be a string literal,
    surrounded by quotes,
    e.g. processing-instruction("browser"). This string literal
    must be an NCName, or a static error is raised.
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N54221" id=
          "id-issue-N54221"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>307. <a name="schema-types-from-input-documents" id=
        "schema-types-from-input-documents"><u>schema-types-from-input-documents</u>:
        Schema Types from input documents?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>active</b><br />
          Originator: <b>Don Chamberlin</b></small>Schema Types
          from input documents?

          <h3><a name="id-issue-N525B0" id=
          "id-issue-N525B0"></a>Description</h3>

          <div>
            <p>During the analysis phase, in-scope schema
            definitions are derived from schemas named in Schema
            Import clauses.</p>

            <p>Should there be additional in-scope schema
            definitions that are part of the static context? Should
            there be another set of in-scope schema definitions
            that are part of the dynamic context? What would that
            do to static typing? Would this interfere with
            interoperability?</p>

            <p>In particular:</p>

            <p>1. Should an environment be allowed to statically
            predefine schema definitions for a query? This would
            allow queries on fixed collections or known message
            types to provide strong type information without
            forcing users to explicitly import the corresponding
            schemas.</p>

            <p>2. How does type information found dynamically in
            queried documents affect the query environment?</p>

            <p>Does data() dynamically use the type information
            found in the instances that are queried, even when the
            types have not been declared in imported schemas? Note
            that Basic XQuery does not work properly if this is not
            true, since it must be able to discover the types of
            elements without importing their definition.</p>

            <p>May an instance contain types that have not been
            imported into the static environment? If we say it may
            not, then schema imports are needed to query any
            document that contains types that are not predefined in
            XQuery.</p>

            <p>May documents that are queried have different
            definitions for the same names? Note that solutions
            that dynamically load type information from a document
            into the in-scope schema definitions may try to
            introduce all such definitions into the static
            environment, which should cause an error according to
            our current rules.</p>
          </div>

          <h3><a name="id-issue-N525C2" id=
          "id-issue-N525C2"></a>Proposed Resolution</h3>

          <div>
            <p>If we want Basic XQuery to be able to query
            documents that have types that are not predefined, then
            data() must be able to use type information from
            instances. But if we want to be able to query validated
            documents that have different schemas this information
            must not be added to the static environment (or else we
            must find a way to add more than one schema definition
            for a given name to the static environment, or say that
            the static environment is dynamic, or....).</p>

            <p>My tentative conclusions:</p>

            <p>1. The in-scope schema definitions should be
            determined statically.</p>

            <p>2. data() and many operators must be able to utilize
            the type information found in a document.</p>

            <p>3. As a matter of convenience, it should be possible
            to import the schemas associated with a single document
            or with all documents in a collection. For instance, a
            syntax like the following may be useful:</p>

            <div class="exampleInner">
              <pre>
import schema from collection
"jdbc:datadirect:sqlserver://localhost:1433;database='airports'"
</pre>
            </div>

            <p>or</p>

            <div class="exampleInner">
              <pre>
import schema from document
"file:///C:/projects/query/requirements/xml-spec.xsd"
</pre>
            </div>

            <p>4. Implementations should be allowed to implicitly
            import schemas into the environment before executing a
            query, using any of the approved ways above.</p>
          </div>

          <h3><a name="id-issue-N525D6" id=
          "id-issue-N525D6"></a>Proposed Resolution</h3>

          <div>
            <p>Proposal (3): Types in Queries, Types in
            Documents</p>

            <p>This proposal distinguishes the relationship between
            types known statically in the query and types that are
            discovered dynamically in documents during query
            processing. This version of the proposal follows the
            results of a telcon on the subject, as recorded in:</p>

            <p>Re: Issue 307 Telcon: Friday, 15 Nov, 12:00 EST
            From: Jonathan Robie
            (jonathan.robie@datadirect-technologies.com) Date: Fri,
            Nov 15 2002
            http://lists.w3.org/Archives/Member/w3c-query-editors/2002Nov/0148.html</p>

            <p>This proposal addresses the following issue:</p>

            <p>Issue 307 schema-types-from-input-documents: Schema
            Types from input documents?</p>

            <p>And here is the proposal itself:</p>

            <p>1. Static Types in Queries</p>

            <p>Implementations are allowed to implicitly import
            schemas into the environment before executing a query.
            The in-scope schema definitions are determined
            statically, containing the built-in type definitions,
            any schemas imported explicitly into the query, and any
            schemas imported implicitly from the query
            environment.</p>

            <p>In a query, it is a static error to use a name in a
            SequenceType production if the name is not found in the
            in-scope schema definitions.</p>

            <p>2. Types in Input Documents</p>

            <p>An input document may be accessed via an input
            function or via an externally defined variable that is
            bound to the input document by the query environment.
            An input document may refer to type names that have not
            been imported into the in-scope schema definitions, but
            it must not contain types that have the same names as
            types in the static environment, but conflicting
            definitions. Input functions and the query environment
            must promote unknown type names to the nearest type
            name in the in-scope schema definitions that is known
            to be substitutable for the unknown type name. If the
            unknown type name is derived from a known type by
            extension, list, or union, then the type name is
            changed to xs:anySimpleType if it is a simple type, or
            to xs:anyType if it is a complex type. This loses type
            information, but ensures that all type names in input
            documents are also in the in-scope schema
            definitions.</p>

            <p>Note: This approach guarantees that the built-in
            types and the static in-scope-schema definitions are
            the only types found in an input document. As a result,
            there is no need to extend the known types when a new
            document is read.</p>

            <p>Note: One ramification of this approach is that
            types derived by extension are not substitutable for
            their base types unless the schemas defining these
            types are imported into the query. We consider this a
            fair tradeoff for type safety. If people want to
            exploit the full type hierarchy, they need to import
            the schema that defines it.</p>

            <p>Note: Mapping all the types when an input function
            is called is obviously an inefficient implementation
            strategy. Many implementations will take a different
            approach, but this is a simple way to specify the
            desired behavior.</p>
          </div>

          <h3><a name="id-issue-N525F4" id=
          "id-issue-N525F4"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html
            (W3C-members only)</a>)</small> Proposal (3)
            accepted.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-25
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0326.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0326.html
            (W3C-members only)</a>)</small> Revoke resolution of
            Issue 307. Type annotations are not "dumbed down".</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>206. <a name="xpath-datatype-support" id=
        "xpath-datatype-support"><u>xpath-datatype-support</u>:
        Typing support in XPath</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>Mike Kay</b></small>Typing support in
          XPath

          <h3><a name="id-issue-N51879" id=
          "id-issue-N51879"></a>Description</h3>

          <div>
            <p>Which of these type productions (CAST, TREAT,
            ASSERT, TYPESWITCH...) belong in XPath? (ie common to
            XQuery and XPath)</p>

            <p>The list is now (2002-10): CAST, TREAT, VALIDATE,
            INSTANCE OF, types on variable bindings,
            TYPESWITCH.</p>
          </div>

          <h3><a name="id-issue-N5187E" id=
          "id-issue-N5187E"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-04-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Apr/0034.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Apr/0034.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-04-09
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0175.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0175.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to remove "validate" from XPath.
            ("typeswitch" was removed already)</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>224. <a name="function-return-datatype" id=
        "function-return-datatype"><u>function-return-datatype</u>:
        Why do we want to allow optional returns and
        DataType?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>types</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Why do we want to
          allow optional returns and DataType?

          <h3><a name="id-issue-N51ABA" id=
          "id-issue-N51ABA"></a>Description</h3>

          <div>
            <p>Would we prefer a syntax that requires explicit
            declaration of a general type when a function is to be
            loosely typed, rather than use the current syntax in
            which the type is omitted when the function is
            untyped.</p>
          </div>

          <h3><a name="id-issue-N51ABD" id=
          "id-issue-N51ABD"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Decided that the default is item*.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>297. <a name="binding" id="binding"><u>binding</u>:
        Should XPath have "type binding" in variable?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>Should XPath
          have "type binding" in variable?

          <h3><a name="id-issue-N5248A" id=
          "id-issue-N5248A"></a>Description</h3>

          <div>
            <p>The 2002-06-24 grammar introduces the "binding"
            production. "assert" is removed from both XQuery and
            XPath. "binding" currently requires reserved words.
            Should "binding" be in XPath?</p>

            <p>Several reasons NOT to include it in XPath:</p>

            <p>- grammar</p>

            <p>- semantics don't match function call semantics</p>

            <p>- rarely useful</p>

            <p>- reads oddly for range variables if (some integer
            $x in (1,2,"fred") satisfies $x=1)</p>

            <p>- biggest of all, users are asking us to simplify.
            We will get a very adverse reaction if we make "for"
            expressions more complicated.</p>

            <p>But it is worrying to have such a big split between
            XPath and XQuery.</p>
          </div>

          <h3><a name="id-issue-N5249B" id=
          "id-issue-N5249B"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-11-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0187.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0187.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-11-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0044.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0044.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-01-09
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0011.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0011.html
            (W3C-members only)</a>)</small></p>

            <p>Closed based on the XSLT recommendation to not
            include type declarations in XPath.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>306. <a name="PSVI-Data-Model-mapping-normative" id=
        "PSVI-Data-Model-mapping-normative"><u>PSVI-Data-Model-mapping-normative</u>:
        PSVI to Data Model mapping part of normative text?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>PSVI to Data
          Model mapping part of normative text?

          <h3><a name="id-issue-N52599" id=
          "id-issue-N52599"></a>Description</h3>

          <div>
            <p>Should the mapping from PSVI to Query Data Model be
            part of the normative language specification? (The
            mapping is affected by the presence or absence of the
            Schema Import Feature).</p>
          </div>

          <h3><a name="id-issue-N5259C" id=
          "id-issue-N5259C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Close issue: mapping already exists and is
            Normative).</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>308. <a name="type-soundness" id=
        "type-soundness"><u>type-soundness</u>: Type
        Soundness</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Type Soundness

          <h3><a name="id-issue-N5260C" id=
          "id-issue-N5260C"></a>Description</h3>

          <div>
            <p>The Static Typing Feature is claimed to have a
            property called "type soundness." However, Dana says
            she has counterexamples to the claim of type soundness
            as described in this section (Section 2.4.2.3). (At
            least sequence type matching breaks TYPE SOUNDNESS so
            what else breaks it?) We need to examine the claim and
            make sure it is stated correctly.</p>
          </div>

          <h3><a name="id-issue-N5260F" id=
          "id-issue-N5260F"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-11-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0187.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Nov/0187.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-11-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0044.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Nov/0044.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-01-09
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0011.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Jan/0011.html
            (W3C-members only)</a>)</small></p>

            <p>Closed due to the definition of type errors in
            language and FS books.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>310. <a name="type-annotations-child-of-element" id=
        "type-annotations-child-of-element"><u>type-annotations-child-of-element</u>:
        Are the children of a newly constructed element
        typed?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Dana F</b></small>Are the children of a
          newly constructed element typed?

          <h3><a name="id-issue-N52646" id=
          "id-issue-N52646"></a>Description</h3>

          <div>
            <p>What happens with the type annotation of the
            children of a newly constructed element? Type
            annotation kept or given xs:anyType.</p>
          </div>

          <h3><a name="id-issue-N52649" id=
          "id-issue-N52649"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small></p>

            <p>Decision to accept the propsal of Phil Wadler in
            <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-01-29
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0502.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to reopen the issue.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small></p>

            <p>Decided NOT to reopen the issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>316. <a name="cardinality-typed-comparison" id=
        "cardinality-typed-comparison"><u>cardinality-typed-comparison</u>:
        Is anySimpleType = anySimpleType*?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Is anySimpleType =
          anySimpleType*?

          <h3><a name="id-issue-N526FD" id=
          "id-issue-N526FD"></a>Description</h3>

          <div>
            <p>Given the following function:</p>

            <div class="exampleInner">
              <pre>
define function foo(xs:anySimpleType $x) returns xs:anySimpleType {$x}
</pre>
            </div>

            <p>and the untyped data</p>

            <div class="exampleInner">
              <pre>
&lt;a a="1"/&gt;&lt;a a="2"/&gt;&lt;a a="3"/&gt;
</pre>
            </div>

            <p>should the following be a (static or dyamic) type
            error or should it work?</p>

            <div class="exampleInner">
              <pre>
foo(/a/@a)
</pre>
            </div>

            <p>If it should work, what should the following query
            return?</p>

            <div class="exampleInner">
              <pre>
count(data(&lt;e&gt;1 2&lt;/e&gt;))
count(data(&lt;a b="1 2"/&gt;/@b))
</pre>
            </div>

            <p>Should it be 1 or 2?</p>
          </div>

          <h3><a name="id-issue-N52710" id=
          "id-issue-N52710"></a>Proposed Resolution</h3>

          <div>
            <p>anySimpleType is the base type of all the
            *primitive* XML Schema datatypes.</p>

            <p>List and union types are *generated* (my word,
            Schema uses the word *derived*) from primitive types
            and thus, not included in anySimpleType. See the
            extract from the XML Schema datatypes spec below.</p>

            <p>"[Definition:] There exists a conceptual datatype,
            whose name is anySimpleType, that is the simple version
            of the ur-type definition from [XML Schema Part 1:
            Structures]. anySimpleType can be considered as the
            *base type* of all *primitive* types. The *value space*
            of anySimpleType can be considered to be the *union* of
            the *value space*s of all *primitive* datatypes."</p>

            <p>Thus, the function call above should result in a
            (static or dynamic, depending on typing conformance)
            type error.</p>

            <p>The count expressions would always return 1.</p>
          </div>

          <h3><a name="id-issue-N5271C" id=
          "id-issue-N5271C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html
            (W3C-members only)</a>)</small></p>

            <p>Decided that anySimpleType is a list one. This needs
            to be carried out clearly in the documents.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>To solve issues 316 and 524 we need to do eliminate
            three constructor functions from F&amp;O, and
            integrating with the changes described in the message:
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0021.html.</p>

            <p>This was agreed.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>320. <a name="types-conformancelevels-same-results" id=
        "types-conformancelevels-same-results"><u>types-conformancelevels-same-results</u>:
        Should different conformance levels give the same result
        for the same query and data?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Anders Berglund</b></small>Should
          different conformance levels give the same result for the
          same query and data?

          <h3><a name="id-issue-N527D9" id=
          "id-issue-N527D9"></a>Description</h3>

          <div>
            <p>Are different conformance levels going to give the
            same results? Is it possible to get different results
            for the same query? The principle should be that you
            either get the same result or a failure. Currently this
            isn't the case.</p>
          </div>

          <h3><a name="id-issue-N527DC" id=
          "id-issue-N527DC"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Anders
            Berglund:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
            </div>

            <p>[link to member only information] Kristoffer
            Rose:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
            </div>
          </div>

          <h3><a name="id-issue-N527E7" id=
          "id-issue-N527E7"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>proc-mod-tf</b> on 2003-02-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Feb/0110.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Feb/0110.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html
            (W3C-members only)</a>)</small></p>

            <p>Given that types add semantics, there is no way to
            achieve the proposed principle between basic XQuery and
            schema import without adding additional specification
            in the query.</p>

            <p>It is decided not to add any such functionality and
            close this issue without action.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>325. <a name="element-def-not-in-in-scope" id=
        "element-def-not-in-in-scope"><u>element-def-not-in-in-scope</u>:
        Refering to element that is not in the in-scope schema
        def.</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>XQuery</b></small>Refering to element that
          is not in the in-scope schema def.

          <h3><a name="id-issue-N52869" id=
          "id-issue-N52869"></a>Description</h3>

          <div>
            <p>In recent discussions on the type system and when
            reviewing the documents I noticed that many people
            interpret</p>

            <div class="exampleInner">
              <pre>
element foo
</pre>
            </div>

            <p>differently than the spec indicates it needs to be
            interpreted. This seems to indicate that we have a
            problem.</p>

            <p>The semantics that people expect seems to be:</p>

            <p>element foo is the same as element foo of type
            xs:anyType and matches all elements with the given name
            (regardless where or whether the element was declared
            in the schema).</p>

            <p>attribute foo is the same as attribute foo of type
            xs:anySimpleType and matches all attributes with the
            given name regardless where or whether it was declared
            in the schema).</p>

            <p>However our spec [1] says:</p>

            <p>Another form of ElemOrAttrType is simply a QName,
            which is interpreted as the required name of the
            element or attribute. The QName must be an element or
            attribute name that is found in the in-scope schema
            definitions. The match is successful only if the given
            element or attribute has the required name and also
            conforms to the schema definition for the required
            name. This can be verified in either of the following
            ways:</p>

            <p>If the schema definition for the required name has a
            named type, the given element or attribute must have a
            type annotation that is the same as that named type or
            is known (in the in-scope schema definitions) to be
            derived from that named type. For example, suppose that
            a schema declares the element named location to have
            the type State. Then the SequenceType element location
            will match a given element only if its name is location
            and its type annotation is State or some named type
            that is derived from State.</p>

            <p>If the schema definition for the required name has
            an anonymous (unnamed) type definition, the actual
            content of the given element or attribute must
            structurally comply with this type definition. For
            example, suppose that a schema declares the element
            named shippingAddress to have an anonymous complex type
            consisting of a street element followed by a city
            element. Then the SequenceType element shippingAddress
            will match a given element only if its name is
            shippingAddress and its content is a street element
            followed by a city element.</p>

            <p>The constraint that an element must have a required
            name is considered to be satisfied if the element has
            been validated and found to be a member of a
            substitution group whose head element has the required
            name. Substitution groups are described in [XML
            Schema].</p>

            <p>which seems to indicate that this is not the
            case.</p>

            <p>I would like to open an issue on this. I think even
            if people do not want to use schema types, they may
            still want to restrict the argument type of a function
            to an element with a given name.</p>

            <p>In addition, many people are surprised to see the
            SchemaContext in the SequenceType production for other
            usages than for validate in ...</p>

            <p>While there is a use case, I wonder whether this
            needs to be a required feature for XQuery V1 given the
            leap in complexity. Maybe it would be useful to solve
            the above problem by saying that you have to use</p>

            <div class="exampleInner">
              <pre>
element foo in /
</pre>
            </div>

            <p>to force the name to be in the in-scope schema
            definition? This would mean that / becomes allowed in
            the SchemaGlobalContext production.</p>
          </div>

          <h3><a name="id-issue-N5288C" id=
          "id-issue-N5288C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2002-12-17
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002Dec/0252.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xsl</b> on 2002-12-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>In sequence type it is an error, it is valid in a
            path expression.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>526. <a name=
        "static-semantics-anySimpleType-untypedAtomic" id=
        "static-semantics-anySimpleType-untypedAtomic"><u>static-semantics-anySimpleType-untypedAtomic</u>:
        Semantics for anySimpleType and untypedAtomic</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>types</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Semantics for
          anySimpleType and untypedAtomic

          <h3><a name="id-issue-N53E73" id=
          "id-issue-N53E73"></a>Description</h3>

          <div>
            <p>1. If you statically infer xs:anySimpleType, can you
            error if the expected type is a subtype or do you
            handle it as xdt:untypedAtomic at runtime?</p>

            <p>2. If you statically infer xdt:untypedAtomic, can
            you recast into expected type statically?</p>
          </div>

          <h3><a name="id-issue-N53E78" id=
          "id-issue-N53E78"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-04-09
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0175.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Apr/0175.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html
            (W3C-members only)</a>)</small></p>

            <p>The two questions are answered in the current draft
            of the formal semantics.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003May/0063.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003May/0063.html
            (W3C-members only)</a>)</small></p>

            <p>It was also noted that the Datamodel needs some
            changes due to this.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>527. <a name="static-typing-index-expressions" id=
        "static-typing-index-expressions"><u>static-typing-index-expressions</u>:
        Static typing of XPath index expressions</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Algebra Editors</b></small>Static typing
          of XPath index expressions

          <h3><a name="id-issue-N53E9F" id=
          "id-issue-N53E9F"></a>Description</h3>

          <div>
            <p>Typing for XPath predicate expressions of the form
            E1[Integer] is not precise (often of the form ItemType*
            instead of ItemType or ItemType?). Should we have
            specific typing rules for XPath predicate expressions
            of the form E1[Integer], or is the use of 'type relief'
            functions, as described in: <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Nov/0161.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Nov/0161.html</a>
            sufficient?</p>
          </div>

          <h3><a name="id-issue-N53EA5" id=
          "id-issue-N53EA5"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0435.html
            (W3C-members only)</a>)</small></p>

            <p>The general static type of the general
            expression:</p>

            <div class="exampleInner">
              <pre>
Expr1[Expr2]
</pre>
            </div>

            <p>Is (assuming normalization has taken place)</p>

            <div class="exampleInner">
              <pre>
TYPE{Expr1[Expr2]} == IF TYPE{Expr2} &lt;: numeric THEN TYPE{Expr1}
</pre>
            </div>

            <p>Decided that if Expr2 is a literal number, then do
            cardinality reduction, otherwise don't.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>539. <a name=
        "cast-untypedAtomic-backward-compatibility-mode" id=
        "cast-untypedAtomic-backward-compatibility-mode"><u>cast-untypedAtomic-backward-compatibility-mode</u>:
        Semantics of fs:cast-untypedAtomic in backward
        compatibility mode</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Semantics of
          fs:cast-untypedAtomic in backward compatibility mode

          <h3><a name="id-issue-N5401F" id=
          "id-issue-N5401F"></a>Description</h3>

          <div>
            <p>What should be the semantics of
            fs:cast-untypedAtomic in the XPath 1.0 backward
            compatibility mode?</p>
          </div>

          <h3><a name="id-issue-N54022" id=
          "id-issue-N54022"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-05-01
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html
            (W3C-members only)</a>)</small></p>

            <p>Resolved by the addition of the following section:
            [Section 6.1.4 The fs:convert-simple-operand function]
            which deals with XPath 1.0 backward compatibility.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>540. <a name="static-semantics-input-unions" id=
        "static-semantics-input-unions"><u>static-semantics-input-unions</u>:
        How does the static semantics works in the case where the
        input types are unions?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>types</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>How does the
          static semantics works in the case where the input types
          are unions?

          <h3><a name="id-issue-N54039" id=
          "id-issue-N54039"></a>Description</h3>

          <div>
            <p>How does the static semantics works in the case
            where the input types are unions? (union propagation)
            For instance, what is the static type obtained for an
            input (untypedAtomic | int) + (float) [the expected
            result is (double | float)].</p>
          </div>

          <h3><a name="id-issue-N5403C" id=
          "id-issue-N5403C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-05-01
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html
            (W3C-members only)</a>)</small></p>

            <p>Resolved by the current text in [Section 4.1.4
            Function Calls].</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>551. <a name="constructor-functions-user-types" id=
        "constructor-functions-user-types"><u>constructor-functions-user-types</u>:
        Constructor functions for unprefixed user defined
        types</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>types</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL WG</b></small>Constructor functions
          for unprefixed user defined types

          <h3><a name="id-issue-N541E0" id=
          "id-issue-N541E0"></a>Description</h3>

          <div>
            <p>We state that there is (implicitly) a constuctor
            function in the static context for each user defined
            type. How do you refer to such a constructor function
            for a non-prefixed type?</p>
          </div>

          <h3><a name="id-issue-N541E3" id=
          "id-issue-N541E3"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>No technical change to documents.</p>

            <p>Add note (in Functions and Operators) indicating
            that to construct types defined in null namespace, use
            "cast as" expression.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Wording reviewed and accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>566. <a name="treat-as-up-down-type-hierarchy" id=
        "treat-as-up-down-type-hierarchy"><u>treat-as-up-down-type-hierarchy</u>:
        "treat" should work up and down type hierarchy</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>types</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>"treat" should work
          up and down type hierarchy

          <h3><a name="id-issue-N543DD" id=
          "id-issue-N543DD"></a>Description</h3>

          <div>
            <p>Section 3.13.6 Treat</p>

            <p>Current wording: "The semantics of treat as type1
            (expr2) are as follows:</p>

            <p>During static analysis (if the Static Typing Feature
            is implemented):</p>

            <p>type1 must be derived by restriction from the static
            type of expr2--otherwise, a type error is raised. The
            static type of the treat expression is type1. This
            enables the expression to be used as an argument of a
            function that requires a parameter of type1."</p>

            <p>We propose to allow treat to work up and down the
            type hierarchy.</p>

            <p>Reason: Since a supertype always can substitute for
            a subtype, you get implicit "treat as" from sub to
            supertypes. Instead of forcing people to write let $x
            as supertype := subtypevalue, we should also statically
            allow treat as supertype (subtypevalue).</p>
          </div>

          <h3><a name="id-issue-N543EA" id=
          "id-issue-N543EA"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-07-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Decided that the user can tell you exactly what the
            target type is. If the user is wrong there will be a
            dynamic error. Thus no (static) restrictions on "treat
            as" (as you can do everything in two steps
            anyway...).</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>524. <a name="schema-plural-data-types" id=
        "schema-plural-data-types"><u>schema-plural-data-types</u>:
        Plural datatypes different from Singular *?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>type semantics</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>Plural datatypes
          different from Singular *?

          <h3><a name="id-issue-N53E39" id=
          "id-issue-N53E39"></a>Description</h3>

          <div>
            <p>Is there any semantic difference between eg NMTOKEN*
            and NMTOKENS? Statically? Dynamically?</p>
          </div>

          <h3><a name="id-issue-N53E3C" id=
          "id-issue-N53E3C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>To solve issues 316 and 524 we need to do eliminate
            three constructor functions from F&amp;O, and
            integrating with the changes described in the message:
            http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0021.html.</p>

            <p>This was agreed.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>43. <a name="xquery-define-schema-variants" id=
        "xquery-define-schema-variants"><u>xquery-define-schema-variants</u>:
        Defining Behavior for Well Formed, DTD, and Schema
        Documents</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Don Chamberlin</b></small>Defining
          Behavior for Well Formed, DTD, and Schema Documents

          <h3><a name="id-issue-N504A1" id=
          "id-issue-N504A1"></a>Description</h3>

          <div>
            <p>We should specify the behavior of XQuery for well
            formed XML, XML validated by a schema, and XML
            validated by a DTD.</p>
          </div>

          <h3><a name="id-issue-N504A4" id=
          "id-issue-N504A4"></a>Proposed Resolution</h3>

          <div>
            <p>The mapping of a DTD validated or well formed
            document still needs to be defined in the Data
            Model.</p>
          </div>

          <h3><a name="id-issue-N504A8" id=
          "id-issue-N504A8"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Closing of the directly related issues: [resolved
            issue #xquery-abstract-syntax] and [resolved issue
            #xpath-issue-complex-type-value] is sufficient to close
            this issue.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>On recommendation of the Processing Model Taskforce
            the disposition is reaffirmed.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>47. <a name="xquery-subtype-substitutability" id=
        "xquery-subtype-substitutability"><u>xquery-subtype-substitutability</u>:
        Subtype Substitutability</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>type-semantics</b> Priority: <b>2</b> Status:
          <b>decided</b><br />
          Originator: <b>XQuery Editors</b></small>Subtype
          Substitutability

          <h3><a name="id-issue-N50540" id=
          "id-issue-N50540"></a>Description</h3>

          <div>
            <p>Should XQuery 1.0 support subtype substitutability
            for function parameters?</p>

            <p>If subtype substitutability is not supported in
            XQuery Version 1, the motivation for TYPESWITCH is
            weakened and the decision to support TYPESWITCH should
            be revisited.</p>
          </div>

          <h3><a name="id-issue-N50545" id=
          "id-issue-N50545"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Michael Rys:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
              <div class="exampleInner">
                <pre>
I think this is still an open issue given some semantic issues that we
found between named subtype substitutability and derivation by
extension. I will send mail on this issue this week,
</pre>
              </div>
            </div>
          </div>

          <h3><a name="id-issue-N5054B" id=
          "id-issue-N5054B"></a>Actual Resolution</h3>

          <div>
            <p>Addressed by the "Named Typing" proposal.</p>

            <p><small>Decision by: <b>xpath-tf</b> on 2002-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2002May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2002May/0037.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2002-05-22
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002May/0241.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002May/0241.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-06-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2002Jun/0037.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2002Jun/0037.html
            (W3C-members only)</a>)</small></p>

            <p>Accepting text in 2002-04-30 public draft.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>48. <a name="xquery-typeswitch-case-not-subtype" id=
        "xquery-typeswitch-case-not-subtype"><u>xquery-typeswitch-case-not-subtype</u>:
        CASE not a subtype</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>algebra</b>
          Cluster: <b>type-semantics</b> Priority: <b>3</b> Status:
          <b>decided</b><br />
          Originator: <b>XML Query</b></small>CASE not a subtype

          <h3><a name="id-issue-N50569" id=
          "id-issue-N50569"></a>Description</h3>

          <div>
            <p>If the types in the CASE branches are not subtypes
            of the TYPESWITCH, is this an error, or are these
            branches simply never executed? If the latter, should
            we require a warning?</p>
          </div>

          <h3><a name="id-issue-N5056C" id=
          "id-issue-N5056C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-12
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0242.html
            (W3C-members only)</a>)</small></p>

            <p>Issue 48 closed without changes to the document (no
            static errors will be raised, implementations can but
            are not required to raise warnings).</p>

            <p><small>Decision by: <b>fs-editors</b> on 2003-02-13
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-02-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html
            (W3C-members only)</a>)</small></p>

            <p>Accepting proposal in <a href=
            "#FS-Issue-0173">#FS-Issue-0173</a> closes this issue
            in a consistent way.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>279. <a name="xpath-lightweight-cast" id=
        "xpath-lightweight-cast"><u>xpath-lightweight-cast</u>:
        Should there be a lightweight cast?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Should there be
          a lightweight cast?

          <h3><a name="id-issue-N52233" id=
          "id-issue-N52233"></a>Description</h3>

          <div>
            <p>Should there be any provision for a lightweight cast
            that does not observe facets? Phil Wadler has suggested
            that 'validate' be used whenever full schema validation
            is desired, and 'cast' be used as a lightweight
            validation, which can be used for either simple or
            complex types, but which does not supply defaults,
            enforce facets, or check integrity constraints. It may
            be easier to optimize through cast than through
            validate, but supporting both constructs may confuse
            users due to their similarity. He suggests the
            following syntax for these expressions:</p>

            <div class="exampleInner">
              <pre>
('cast'|'validate') as SequenceType ()
('cast'|'validate') 'in' ContextExpr { Expr }
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N52238" id=
          "id-issue-N52238"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2002-10-10
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0121.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to reject this proposal. Cast checks all
            facets.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>334. <a name="xquery-failed-validation" id=
        "xquery-failed-validation"><u>xquery-failed-validation</u>:
        How are documents for which validation has failed
        processed?</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xpath</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>How are
          documents for which validation has failed processed?

          <h3><a name="id-issue-N529A1" id=
          "id-issue-N529A1"></a>Description</h3>

          <div>
            <p>What is the result of a failed validation? Can you
            inspect the result to detect this? Do you just get
            anySimpleType and anyType?</p>
          </div>

          <h3><a name="id-issue-N529A4" id=
          "id-issue-N529A4"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N529A9" id=
          "id-issue-N529A9"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Access to documents that fail validation is not
            supported.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>523. <a name="input-and-schema-validation" id=
        "input-and-schema-validation"><u>input-and-schema-validation</u>:
        input(), collection(), document(); validation
        semantics</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>type-semantics</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XPath TF</b></small>input(), collection(),
          document(); validation semantics

          <h3><a name="id-issue-N53E10" id=
          "id-issue-N53E10"></a>Description</h3>

          <div>
            <p>What are the semantics of the functions input(),
            collection(), document(), and the implicit context that
            binds variables to documents with respect to schema
            validation.</p>
          </div>

          <h3><a name="id-issue-N53E13" id=
          "id-issue-N53E13"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N53E18" id=
          "id-issue-N53E18"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-07-08
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0032.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Jul/0032.html
            (W3C-members only)</a>)</small></p>

            <p>Closed by the addition of the "Statically known
            documents/collections" and "Accessible
            documents/collections" to the static and dynamic
            contexts and the addition of the constraints in Section
            2.2.5. of the current document.</p>

            <p>ACTION XPATH-124-01 to verify the semantics of
            fn:document() and fn:doc() w.r.t. failed
            validation.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-07-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0122.html
            (W3C-members only)</a>)</small>Joint meeting.</p>

            <p>Decision accepted, with a change of "Accessible" to
            "Available" in order to avoid confusion with "WAI".</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>531. <a name="type-copied-subelement" id=
        "type-copied-subelement"><u>type-copied-subelement</u>:
        Should discard the type of copied subelement</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Michael Rys</b></small>Should discard the
          type of copied subelement

          <h3><a name="id-issue-N53F0E" id=
          "id-issue-N53F0E"></a>Description</h3>

          <div>
            <p>Currently element construction untypes all simple
            content (untypedAtomic) but preserves the type of
            subnodes.</p>

            <p>This is seen as inconsistent by some and thus an
            issue.</p>

            <p>The proposed resolution would be to erase the type
            for any node under the new element (make it
            element/attribute of type xs:anyType/xdt:untypedAtomic
            or potentially (and preferably) untypedComplex for
            elements).</p>
          </div>

          <h3><a name="id-issue-N53F15" id=
          "id-issue-N53F15"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Element construction should behave like skip
            validation and erase the type of all subnodes.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>533. <a name="automatic-coersion-strict-or-not" id=
        "automatic-coersion-strict-or-not"><u>automatic-coersion-strict-or-not</u>:
        Strict static typing for automatic coercion of untyped
        atomic to atomic values</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Mary Fernandez</b></small>Strict static
          typing for automatic coercion of untyped atomic to atomic
          values

          <h3><a name="id-issue-N53F51" id=
          "id-issue-N53F51"></a>Description</h3>

          <div>
            <p>Should static typing for automatic coercion of
            untyped atomic to atomic values be strict or not? For
            instance:</p>

            <p>Should the following function call:</p>

            <div class="exampleInner">
              <pre>
define function f($x as xs:integer)  ....

let $x := &lt;a&gt;1&lt;/a&gt; return f($x/node())
</pre>
            </div>

            <p>be allowed or not?</p>
          </div>

          <h3><a name="id-issue-N53F5A" id=
          "id-issue-N53F5A"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>In principle, xdt:untypedAtomic is typed liberally
            rather than conservatively. That is, it is made
            statically well-typed whenever possible.</p>

            <p>Thus, addition of xdt:untypedAtomic to xs:integer is
            well-typed and has type xs:double. Comparing
            xdt:untypedAtomic to any other type is well-typed.</p>

            <p>This resolution applies only to the general
            comparison (=, &lt;), not to value comparison (eq, lt),
            so that the latter retains transitivity.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>534. <a name="function-calls-and-expected-type" id=
        "function-calls-and-expected-type"><u>function-calls-and-expected-type</u>:
        Semantics of function calls and notion of "expected
        type"</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Kristoffer Rose</b></small>Semantics of
          function calls and notion of "expected type"

          <h3><a name="id-issue-N53F7B" id=
          "id-issue-N53F7B"></a>Description</h3>

          <div>
            <p>While the "expected type" is well defined for user
            and non-overloaded standard functions, it is not so for
            the overloaded built-in functions. For general
            [XQuery/XPath] use (without XPath 1.0 compatibility
            flag) we must ensure that each overloaded argument is
            either always atomic or non-atomic so it is unambiguous
            for every function argment which of the two
            normalization choices to pick. With XPath 1.0
            compatibility flag some other solution must be found as
            several functions are now overloaded with, e.g.,
            numeric and non-numeric types allowed for the same
            argument.</p>
          </div>

          <h3><a name="id-issue-N53F7E" id=
          "id-issue-N53F7E"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-05-01
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003May/0007.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0024.html
            (W3C-members only)</a>)</small></p>

            <p>Clarification to be added in FS document:</p>

            <p>Furthermore notice that the normalization is only
            well-defined when it is guaranteed that overloading is
            restricted to atomic types with the same
            quantifier.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>541. <a name="static-type-empty-error" id=
        "static-type-empty-error"><u>static-type-empty-error</u>:
        Should it be a static error if an expression other than ()
        has type empty?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>static typing task force</b></small>Should
          it be a static error if an expression other than () has
          type empty?

          <h3><a name="id-issue-N54053" id=
          "id-issue-N54053"></a>Description</h3>

          <div>
            <p>Motivation: This catches common errors such as $x/e
            when there is no e element.</p>
          </div>

          <h3><a name="id-issue-N54056" id=
          "id-issue-N54056"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N54059" id=
          "id-issue-N54059"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Yes this should be a static error.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>542. <a name="type-of-well-formed" id=
        "type-of-well-formed"><u>type-of-well-formed</u>: What
        should be the type of an attribute or element that is
        well-formed but not validated, or is validated in skip
        mode?</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>type-semantics</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Phil Wadler</b></small>What should be the
          type of an attribute or element that is well-formed but
          not validated, or is validated in skip mode?

          <h3><a name="id-issue-N54076" id=
          "id-issue-N54076"></a>Description</h3>

          <div>
            <p>Currently, attributes are given type
            xs:anySimpleType and elements are given type
            xs:anyType. In order to do a better job of static
            typing for well-formed data, it might be better to give
            attributes type xdt:untypedAtomic and to give elements
            type xdt:anyUntyped (where the latter is a newly minted
            type).</p>
          </div>

          <h3><a name="id-issue-N54079" id=
          "id-issue-N54079"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-14
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0037.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Unvalidated elements from well-formed docs and
            skip-validated elements labeled with
            [xdt:untypedAny].</p>

            <p>Relationships with other types:</p>

            <p>xdt:untypedAny &lt;: xs:anyType</p>

            <p>xdt:untypedAtomic &lt;: xdt:anyAtomicType &lt;:
            xs:anySimpleType</p>

            <p>Benefits</p>

            <p>* Can distinguish unvalidated/skip-validated
            elements from validated elements</p>

            <p>* Aligns with type annotations for
            unvalidated/skip-validated attributes
            (xdt:untypedAtomic).</p>

            <p>NB: xdt:untypedAny is lousy name.</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-28
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0177.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0177.html
            (W3C-members only)</a>)</small></p>

            <p>&gt; Status: Michael Rys believes we need to
            consider what data() does in this case. Skipped at F2F
            meeting.</p>

            <p>Proposal:</p>

            <p>Two corrections below: First data will never return
            a list type, but an atomic typename with an occurance
            indicator. Second, the atomization of
            element(xs:anyType) needs to raise a type error now
            since it could be a complex element with non-mixed
            complex content (note: this cannot occur with dynamic
            typing, since no instance will be of type
            element(xs:anyType) anymore).</p>

            <p>So the new rules should be</p>

            <div class="exampleInner">
              <pre>
   data(attribute(xs:anySimpleType))   has type  xdt:anyAtomicType*
   data(element(xs:anySimpleType))     "         xdt:anyAtomicType*
   data(element(xs:anyType))           raises a type error

   data(attribute(xdt:untypedAtomic))  has type  xdt:untypedAtomic
   data(element(xdt:untypedAtomic))    "         xdt:untypedAtomic
   data(element(xdt:untypedAny))       "         xdt:untypedAtomic
</pre>
            </div>

            <p>Also we need to add the following definition:</p>

            <p>1.3.x xdt:untypedAny</p>

            <p>The abstract datatype xdt:untypedAny is a child of
            xs:anyType and serves as a special type annotation to
            indicate the type of element nodes that have not been
            validated by a XML Schema or have received an instance
            type annotation of xs:anyType in the PSVI. This
            datatype cannot be used in [XML Schema Part 1:
            Structures] type declarations; nor can it be used as a
            base for user-defined atomic types. It can be used in
            the [XQuery 1.0: An XML Query Language] SequenceType
            production to define a required type (for example in a
            function signature) to indicate that only an element
            with untyped content is acceptable. This datatype
            resides in the namespace
            http://www.w3.org/2003/05/xpath-datatypes and is
            considered to be non-atomic.</p>

            <p>Agreed: as written.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>543. <a name="xpath-matching-substitution-groups" id=
        "xpath-matching-substitution-groups"><u>xpath-matching-substitution-groups</u>:
        How can a path expression match elements in the
        substitution group of a given element?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>type-semantics</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>How can a path
          expression match elements in the substitution group of a
          given element?

          <h3><a name="id-issue-N540BA" id=
          "id-issue-N540BA"></a>Description</h3>

          <div>
            <p>How can a path expression match elements in the
            substitution group of a given element?</p>
          </div>

          <h3><a name="id-issue-N540BD" id=
          "id-issue-N540BD"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Proposal in issue <a href=
            "#SequenceType-problems">#SequenceType-problems</a>
            accepted resolving issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>544. <a name="xpath-matching-types" id=
        "xpath-matching-types"><u>xpath-matching-types</u>: How can
        a path expression match nodes of a given type?</a></h2>

        <div>
          <small>Locus: <b>xpath</b> Cluster: <b>type-semantics</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>How can a path
          expression match nodes of a given type?

          <h3><a name="id-issue-N540DD" id=
          "id-issue-N540DD"></a>Description</h3>

          <div>
            <p>How can a path expression match nodes of a given
            type?</p>
          </div>

          <h3><a name="id-issue-N540E0" id=
          "id-issue-N540E0"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Proposal in issue <a href=
            "#SequenceType-problems">#SequenceType-problems</a>
            accepted resolving issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>56. <a name="xquery-type-syntax" id=
        "xquery-type-syntax"><u>xquery-type-syntax</u>:
        Human-Readable Syntax for Types</a></h2>

        <div>
          <small>Issue Class: <b>T</b> Locus: <b>xquery</b>
          Cluster: <b>type-syntax</b> Priority: <b>3</b> Status:
          <b>decided</b><br />
          Originator: <b>Algebra Editors</b></small>Human-Readable
          Syntax for Types

          <h3><a name="id-issue-N5066C" id=
          "id-issue-N5066C"></a>Description</h3>

          <div>
            <p>The Algebra has a syntax for declaring types. Up to
            now, XQuery uses XML Schema for declaring types. Is
            this sufficient? Some important questions:</p>

            <ol class="enumar">
              <li>Are type names sufficient, or does XQuery really
              need its own syntax for declaring types?</li>

              <li>Would Normalized Universal Names (derived from
              MSL) be sufficient for type names?</li>

              <li>How will type names be bound to definitions?</li>
            </ol>
          </div>

          <h3><a name="id-issue-N50676" id=
          "id-issue-N50676"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-01-15
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0215.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0215.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Decided:</p>

            <p>Are type names sufficient - YES</p>

            <p>Would NUNS be sufficient for type name - not
            needed</p>

            <p>How will type names be bound to definitions - with
            imported schemas and namespaces</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>446. <a name="FS-Issue-0103" id=
        "FS-Issue-0103"><u>FS-Issue-0103</u>: Complexity of
        interleaving</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>FS Editors</b></small>Complexity of
          interleaving

          <h3><a name="id-issue-N53544" id=
          "id-issue-N53544"></a>Description</h3>

          <div>
            <p>The current type system allows interleaving is
            allowed on arbitrary types. Interleaving is an
            expensive operation and it is not clear how to define
            subtyping for it. Should we restrict use of
            interleaving on (optional) atomic types ? Should this
            restriction reflects the one in XML schema ? Related to
            [resolved issue #FS-Issue-0077].</p>
          </div>

          <h3><a name="id-issue-N5354A" id=
          "id-issue-N5354A"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>The formal semantics is a specification of the
            behavior of an XQuery processor, not a recipe for
            implementation. The uses of interleaving in the
            specification are sufficiently restricted that a
            practical implementation can be written.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>449. <a name="FS-Issue-0106" id=
        "FS-Issue-0106"><u>FS-Issue-0106</u>: Constraint on
        attribute and element content models</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome</b></small>Constraint on attribute
          and element content models

          <h3><a name="id-issue-N535AF" id=
          "id-issue-N535AF"></a>Description</h3>

          <div>
            <p>The [XPath/XQuery] type system allows more content
            model than what XML Schema allows. For instance, the
            current type grammar allows the following types:</p>

            <div class="exampleInner">
              <pre>
   element d { (attribute a | element b, attribute c)* }
   attribute a { element b }
</pre>
            </div>

            <p>Section <a href=
            "http://www.w3.org/TR/xquery-semantics/#sec_types">http://www.w3.org/TR/xquery-semantics/#sec_types</a>
            indicates corresponding constraints on the
            [XPath/XQuery] type system to avoid that problem. The
            status of these constraints is unclear. When are they
            enforced and checked?</p>
          </div>

          <h3><a name="id-issue-N535B9" id=
          "id-issue-N535B9"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>Closed following the semantics of element
            constructors agreed at the December f2f meeting.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>486. <a name="FS-Issue-0143" id=
        "FS-Issue-0143"><u>FS-Issue-0143</u>: Support for PI,
        comment and namespace nodes</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>FS Editors</b></small>Support for PI,
          comment and namespace nodes

          <h3><a name="id-issue-N539FD" id=
          "id-issue-N539FD"></a>Description</h3>

          <div>
            <p>The [XPath/XQuery] type system does not currently
            support PI nodes, comment nodes and namespace
            nodes.</p>
          </div>

          <h3><a name="id-issue-N53A00" id=
          "id-issue-N53A00"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-05-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003May/0018.html
            (W3C-members only)</a>)</small></p>

            <p>Close by adding "namespace node type" to type system
            for XPath 2.0 only (not to XQuery 1.0). Action Jerome
            to determine how to add such a type for XPath only.</p>

            <p><small>Decision by: <b>xsl</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p><small>Decision by: <b>xquery</b> on 2003-05-16
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003May/0176.html
            (W3C-members only)</a>)</small>Joint F2F</p>

            <p>Proposal accepted. It was also decided not to add it
            to "SequenceType".</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>501. <a name="FS-Issue-0158" id=
        "FS-Issue-0158"><u>FS-Issue-0158</u>: Support for XML
        Schema groups</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Support for XML
          Schema groups

          <h3><a name="id-issue-N53B76" id=
          "id-issue-N53B76"></a>Description</h3>

          <div>
            <p>How to support XML Schema groups during the schema
            import phase is not clear. If the mapping is based on
            the XML Schema syntax, then it should be handled durin
            the mapping phase. Should we have support for XML
            Schema groups in the XQuery type system?</p>
          </div>

          <h3><a name="id-issue-N53B79" id=
          "id-issue-N53B79"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xsl</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-07
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>XML Schema groups are mapped in the type system.
            There is no need for a syntax for schema group in the
            type system.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>516. <a name="FS-Issue-0173" id=
        "FS-Issue-0173"><u>FS-Issue-0173</u>: Typeswitch and type
        substitutability</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>XSL Working Group</b></small>Typeswitch
          and type substitutability

          <h3><a name="id-issue-N53D5A" id=
          "id-issue-N53D5A"></a>Description</h3>

          <div>
            <p>It seems that some examples of typeswitch with
            xs:anySimpleType might break type substitutability.</p>
          </div>

          <h3><a name="id-issue-N53D5D" id=
          "id-issue-N53D5D"></a>Proposed Resolution</h3>

          <div>
            <div class="exampleInner">
              <pre>
The required changes include the new (simpler!) normalization and typing
rules below, plus:

  1. A new formal-semantics function fs:cast-untypedAtomic, which
     takes two arguments and :

     a. If the first argument is the empty sequence, returns the empty
        sequence.

     b. If first argument is untypedAtomic, and

        b1. If the second argument is untypedAtomic, returns the first
            argument cast to string;

        b2. Else if the second argument is numeric, returns the first
            argument cast to double;

        b3. Otherwise, returns the first argument cast to the type of
            the *second* argument.

     c. Otherwise, returns the first argument, unchanged.

     Thus fs:cast-untypedAtomic encapsulates the implicit coercion
     semantics of the arithmetic and general comparision operators.

     The "generic" signature of fs:cast-untypedAtomic is:

       fs:cast-untypedAtomic ($v1 as xdt:anyAtomicType?, $v2 as
       xdt:anyAtomicType?) as xdt:anyAtomicType?

     The specific type rules for fs:cast-untypedAtomic are below.

  2. New signatures for the overloaded (op:numeric-OP) operators such
     that they are all defined on the empty sequence.  If either
     argument is the empty sequence, these operators return the
     empty sequence.

     E.g., here's the new signature for op:numeric-add (similar
     signatures for the other op:numeric-op functions):

     op:numeric-add($operand1 as numeric?, $operand2 as numeric?) as
numeric?

New normalization rules:
~~~~~~~~~~~~~~~~~~~~~~~
Given the changes above, here are the normalization rules for the plus
and the general less-than operators.  (The general rules for any
arithmetic or general comparison operator are similar -- it's just
easier to explain by example).

Plus:

  [Expr1 + Expr2]_Expr   ==
    let $e1 := fn:data ( [Expr1]_Expr ) return
    let $e2 := fn:data ( [Expr2]_Expr ) return
    let $v1 := fs:cast-untypedAtomic ($e1, 1.0e0) return
    let $v2 := fs:cast-untypedAtomic ($e2, 1.0e0) return
      op:numeric-add($v1, $v2)

Note that arithmetic operators always cast an untypedAtomic argument
to a double -- the call to fs:cast-untypedAtomic above performs this
cast.

Less-than:

  [Expr1 &lt; Expr2]_Expr   ==
    some $v1 in fn:data( [Expr1]_Expr ) satisfies
    some $v2 in fn:data( [Expr2]_Expr ) satisfies
      let $v1' := fs:cast-untypedAtomic($v1, $v2) return
      let $v2' := fs:cast-untypedAtomic($v2, $v1) return
        op:less-than($v1', $v2')

Note that general comparison operators always cast an untypedAtomic
argument to the type of the other argument -- the call to
fs:cast-untypedAtomic performs this cast.

Static type rules for fs:cast-untypedAtomic:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rule (a) above:

              statEnv |- Expr1 : ()
  ----------------------------------------------------
  statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : ()

Rule (b1) above:

  statEnv |- Expr1 : Type1   statEnv |- Type1 &lt;: xdt:untypedAtomic
  statEnv |- Expr2 : Type2   statEnv |- Type2 &lt;: xdt:untypedAtomic
  -----------------------------------------------------------------
  statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : xs:string

Rule (b2) above:

  statEnv |- Expr1 : Type1   statEnv |- Type1 &lt;: xdt:untypedAtomic
statEnv |- Expr2 : Type2   statEnv |- Type2 &lt;: (xs:decimal | xs:float |
xs:double)
----------------------------------------------------------------------------------
     statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : xs:double

Rule (b3) above:

      statEnv |- Expr1 : Type1   Type1 &lt;: xdt:untypedAtomic
                 statEnv |- Expr2 : Type2
statEnv |-  not(Type2 &lt;: xdt:untypedAtomic | xs:decimal | xs:float |
xs:double)
--------------------------------------------------------------------------------
          statEnv |- fs:cast-untypedAtomic(Expr1, Expr2) : Type2

Rule (c) above:

             statEnv |- Expr1 : Type1
           not(Type1 &lt;: xdt:untypedAtomic)
   ---------------------------------------------
   fs:cast-untyped-atomic(Expr1, Expr2) : Type1

Static type rules for typeswitch:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The static rules for typeswitch are now very simple. We type each case
expression and take the union of these types:

     statEnv |- Expr0 : Type0
     statEnv |- Type0 [case] case Variable1 as SequenceType1 return
Expr1 : Type1
        ...
     statEnv |- Type0 [case] case Variablen as SequenceTypen return
Exprn : Typen
     statEnv |- Type0 [case] default Variablen+1 return Exprn+1 :
Typen+1

--------------------------------------------------------------------------------
     statEnv |-
       (typeswitch (Expr0)
        case Variable1 as SequenceType1 return Expr1
        ...
        case Variablen as SequenceTypen return Exprn
        default Variablen+1 return Exprn+1)
     : Type1 | ... | Typen+1


The type of the case clauses is inferred based on the CaseType, independently
of the typeswitch expression type.

             CaseType = [ SequenceType ]_sequencetype
        statEnv + varType(Variable : CaseType) |- Expr : Type1
-------------------------------------------------------------------------
statEnv |- Type0 [case] case Variable as SequenceType return Expr : Type1


The type of the default branch is inferred based on the typeswitch expression
type.

        statEnv + varType(Variable : Type0) |- Expr : Type1
      ------------------------------------------------------------
      statEnv |- Type0 [case] default Variable return Expr : Type1
</pre>
            </div>
          </div>

          <h3><a name="id-issue-N53D61" id=
          "id-issue-N53D61"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>fs-editors</b> on 2003-02-13
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html">http://lists.w3.org/Archives/Member/w3c-query-editors/2003Feb/0075.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xquery</b> on 2003-02-19
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0404.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-02-27
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2003Feb/0143.html
            (W3C-members only)</a>)</small></p>

            <p>Proposal accepted resolving this issue.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>519. <a name="FS-Issue-0176" id=
        "FS-Issue-0176"><u>FS-Issue-0176</u>: Type of document
        node</a></h2>

        <div>
          <small>Locus: <b>formal-semantics</b> Cluster:
          <b>Typing</b> Priority: <b>1</b> Status:
          <b>decided</b><br />
          Originator: <b>Jerome Simeon</b></small>Type of document
          node

          <h3><a name="id-issue-N53DA6" id=
          "id-issue-N53DA6"></a>Description</h3>

          <div>
            <p>What should the type of a document node be? Should a
            document node be described by a type name?</p>
          </div>

          <h3><a name="id-issue-N53DA9" id=
          "id-issue-N53DA9"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xpath-tf</b> on 2003-03-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html">http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Mar/0060.html
            (W3C-members only)</a>)</small></p>

            <p><small>Decision by: <b>xsl</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small>Joint meeting</p>

            <p>SequenceType extended to include
            document-node(ElementTypeTest)</p>

            <p>Formal types extended to include document { Type
            }</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>321. <a name="validate-lax-strict" id=
        "validate-lax-strict"><u>validate-lax-strict</u>: Is
        validate strict or lax?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>validate</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL/XQuery joint</b></small>Is validate
          strict or lax?

          <h3><a name="id-issue-N52800" id=
          "id-issue-N52800"></a>Description</h3>

          <div>
            <p>Does "validate" do strict or lax validation?</p>
          </div>

          <h3><a name="id-issue-N52803" id=
          "id-issue-N52803"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small></p>

            <p>Decision to accept the propsal of Phil Wadler in
            <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>322. <a name="validate-lax-strict-override" id=
        "validate-lax-strict-override"><u>validate-lax-strict-override</u>:
        "validate" strict/lax override?</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>validate</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>XSL/XQuery joint</b></small>"validate"
          strict/lax override?

          <h3><a name="id-issue-N52819" id=
          "id-issue-N52819"></a>Description</h3>

          <div>
            <p>Should the user should be able to override which
            type (strict/lax) of validation "validate" does?</p>
          </div>

          <h3><a name="id-issue-N5281C" id=
          "id-issue-N5281C"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-18
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jan/0167.html
            (W3C-members only)</a>)</small></p>

            <p>Decision to accept the propsal of Phil Wadler in
            <a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0378.html</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>530. <a name="default-validation-mode" id=
        "default-validation-mode"><u>default-validation-mode</u>:
        Default default validation mode</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>validation</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Jim Melton</b></small>Default default
          validation mode

          <h3><a name="id-issue-N53EF2" id=
          "id-issue-N53EF2"></a>Description</h3>

          <div>
            <p>The adoption of implicit validation of element
            constructors specified that syntax be provided to allow
            query authors to specify the validation mode (skip,
            lax, or strict) for a given constructor, as well as
            syntax to allow query authors to specify in the query
            prolog the default validation for all constructors in
            the query. If neither syntax is used, there must be a
            "default default" mode. That mode can be specified by
            the XQuery specification itself, or it can be made
            implementation-defined to account for varying
            implementation requirements. Specifying the default
            mode in the XQuery specification would seem to improve
            interoperability, but there are strong user
            requirements that are best satisfied by allowing the
            XQuery implementation determine the default mode based
            on customer needs and other factors. In order to
            improve interoperability, XQuery authors can specify
            their default mode in their XQuery prologs.</p>
          </div>

          <h3><a name="id-issue-N53EF5" id=
          "id-issue-N53EF5"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-03-06
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Mar/0269.html
            (W3C-members only)</a>)</small></p>

            <p>This issue is an example of a more generic issue:
            how should the default value be determined for the
            parts of the static context and evaluation context that
            are not explicitly assigned values in the query prolog?
            I believe that this generic issue should be addressed
            by a well-defined and uniform policy that is documented
            in the language books. I propose the following
            resolution:</p>

            <p>(1) Section 2.1.1, "Static Context": Add the
            following sentence just before the bullet-list of
            context items (XQuery only): "Any part of the Static
            Context that is not assigned a value in the Query
            Prolog may be assigned a default value by the XQuery
            implementation."</p>

            <p>(2) Section 2.1.2, "Evaluation Context": Add the
            following sentence just before the bullet-list of
            context items: "Any part of the Evaluation Context may
            be assigned an initial value by the XPath/XQuery
            implementation."</p>

            <p>Proposal accepted.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>250. <a name="declaring-variables-in-prolog" id=
        "declaring-variables-in-prolog"><u>declaring-variables-in-prolog</u>:
        Declaring Variables in Prolog</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>variables</b>
          Priority: <b>2</b> Status: <b>decided</b><br />
          Originator: <b>Jonathan Robie</b></small>Declaring
          Variables in Prolog

          <h3><a name="id-issue-N51E0B" id=
          "id-issue-N51E0B"></a>Description</h3>

          <div>
            <p>Functions in a function library often need to access
            the same variables. For instance, a function library
            that manipulates a grammar may need to use the
            following variables in many functions:</p>

            <div class="exampleInner">
              <pre>
$grammar := document("xpath-grammar.xml")/g:grammar
$target := "xquery"
</pre>
            </div>

            <p>One possible syntax for this is:</p>

            <div class="exampleInner">
              <pre>
'define' ''variable' varname ':=' expr
</pre>
            </div>

            <p>The above production would occur only in the
            prolog.</p>
          </div>

          <h3><a name="id-issue-N51E16" id=
          "id-issue-N51E16"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2003-02-26
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Feb/0459.html
            (W3C-members only)</a>)</small></p>

            <p>Decided to adopt 1B and 2A in proposal for issue
            <a href=
            "#xquery-module-syntax">#xquery-module-syntax</a>.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>191. <a name="whitespace-in-element-constructors" id=
        "whitespace-in-element-constructors"><u>whitespace-in-element-constructors</u>:
        Whitespace handling in element constructors</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
          Priority: <b>o-1</b> Status: <b>decided</b><br />
          Originator: <b>XPath Editors</b></small>Whitespace
          handling in element constructors

          <h3><a name="id-issue-N5167C" id=
          "id-issue-N5167C"></a>Description</h3>

          <div>
            <p>How is whitespace handled in element
            constructors?</p>

            <p>Issue is for material in sec 2.8. in Working Draft
            2001-11-28.</p>
          </div>

          <h3><a name="id-issue-N51681" id=
          "id-issue-N51681"></a>Interactions and Input</h3>

          <div>
            <p>[link to member only information] Michael Kay:</p>

            <div style="margin-left: 2em; margin-right: 2em;">
              <div class="exampleInner">
                <pre>
The XQuery WG requested information from XSL WG
as to how we currently deal with whitespace, in the hope that we can provide
an off-the-shelf solution to the problem.

In response to the action, here's a description of what XSLT does.

The stylesheet is an XML document. In constructing its infoset, all
processing instructions, comments, and whitespace-only text nodes are
discarded. (To be absolutely precise, PIs and comments are discarded; then
adjacent text nodes are merged; then whitespace-only text nodes are removed
from the tree). Whitespace text nodes are retained however, in two
circumstances: (a) if the whitespace text node is a child of an &lt;xsl:text&gt;
element, and (b) if an ancestor element specifies xml:space="preserve".

Certain elements in the stylesheet (for example, xsl:element) contain a
"content constructor". A content constructor is a sequence of XSLT
instructions, literal result elements, and literal text nodes. In evaluating
a content constructor, XSLT instructions do whatever the semantics of the
particular instruction say, while literal result elements and literal text
nodes are copied to the result tree.

The effect of this is that a whitespace-only text node in the stylesheet is
copied to the result tree only if either (a) it appears immediately inside
&lt;xsl:text&gt;, or (b) it is within the scope of an xml:space="preserve"
attribute.

Whitespace that is adjacent to non-white text in a literal text node is
copied to the result tree.

The effect of these rules is as follows:

=======================================
&lt;a&gt;  &lt;/a&gt;
generates an empty element:
&lt;a/&gt;
=======================================
&lt;a xml-space="preserve"&gt;  &lt;/a&gt;
generates:
&lt;a xml-space="preserve"&gt;  &lt;/a&gt;
=======================================
&lt;a&gt;&lt;xsl:text&gt;  &lt;/xsl:text&gt;&lt;/a&gt;
generates:
&lt;a&gt;  &lt;/a&gt;
=======================================
&lt;a&gt;
  &lt;b/&gt;
&lt;a&gt;
generates:
&lt;a&gt;&lt;b/&gt;&lt;/a&gt;
=======================================
&lt;a&gt;Some text
  &lt;b/&gt;
&lt;/a&gt;
generates:
&lt;a&gt;Some text
  &lt;b/&gt;&lt;/a&gt;
=======================================

There are other complications with whitespace. Whitespace in the result tree
can come from the source document as well as from the stylesheet; XSLT
provides control over whether whitespace-only text nodes in the source
document are significant or not. Whitespace can also be generated in the
output during serialization, if the xsl:output option indent="yes" is
specified.

Also of course the XSLT rules apply in addition to the XML rules. XML for
example normalizes line endings and normalizes whitespace (but not 

character references) in attribute values. This happens outside XSLT's
control. Whitespace character references such as   are treated
differently from literal whitespace by the XML processor, but are treated
identically to literal whitespace by the XSLT processor.

It's fair to say that these rules create a fair bit of confusion. It usually
doesn't matter for generating HTML, because whitespace in HTML is rarely
significant. For generating text files, it can be quite tricky. However, the
rules are well-defined and a user who understands the rules can always get
the required output.

What should XQuery do? I'd suggest mimicking these rules as closely as
possible, if only because users then only have to learn one set of confusing
rules rather than two. I can't think of any obvious improvements that would
make the system less confusing. Where the user wants to explicitly output
whitespace, of course, &lt;a&gt;{'  '}&lt;/a&gt; provides a suitable alternative to
XSLT's &lt;xsl:text&gt; instruction.

This analogy would suggest that &lt;a&gt;  {'x'}  &lt;/a&gt; should output &lt;a&gt;x&lt;/a&gt;,
while &lt;a&gt;z {'x'} y&lt;/a&gt; should output &lt;a&gt;z x y&lt;/a&gt;: that is, the characters
between &lt;a&gt; and "{" are ignored if they consist entirely of whitespace, but
are all significant if any of them is non-whitespace. &lt;a&gt; &lt;/a&gt; should output
&lt;a/&gt;, as should &lt;a&gt; &lt;/a&gt;. This is only a suggestion, of course, the
decision is entirely for XQuery to make.

Mike Kay
</pre>
              </div>
            </div>
          </div>

          <h3><a name="id-issue-N51687" id=
          "id-issue-N51687"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-09-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Sep/0180.html
            (W3C-members only)</a>)</small></p>

            <p>Decided: Resolve this by adopting the whitespace
            proposal.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>311. <a name="whitespace-attribute-constructors" id=
        "whitespace-attribute-constructors"><u>whitespace-attribute-constructors</u>:
        Whitespace and Attribute Constructors</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator:</small>Whitespace and Attribute Constructors

          <h3><a name="id-issue-N5266B" id=
          "id-issue-N5266B"></a>Description</h3>

          <div>
            <p>Whitespace in an XSLT attribute value template is
            significant insofar as it survives the XML rules for
            normalization of attributes. This means that CRLF
            combinations and tabs are normalized to x20 spaces,
            unless they are written as XML character references. I
            think it's an open question whether XQuery wants to
            emulate the XML attribute normalization rules.</p>

            <p>In XSLT,</p>

            <div class="exampleInner">
              <pre>
&lt;foo bar="
   {'x'}
"/&gt;
</pre>
            </div>

            <p>will produce the result &lt;foo bar=" x "/&gt;</p>

            <p>while &lt;foo bar="&#13;"/&gt; produces an element
            containing an attribute whose value is a single CR
            character.</p>

            <p>If XQuery wants to reproduce this behavior exactly,
            then it's going to have to reproduce the XML treatment
            of whitespace as well as the XSLT treatment.</p>

            <p>But whether it does so or not, I think Mary is right
            that</p>

            <div class="exampleInner">
              <pre>
&lt;foo bar=" {'x'} "/&gt;
</pre>
            </div>

            <p>should produce lt;foo bar=" x "/&gt; and not &lt;foo
            bar="x"/&gt;. There is a difference between element and
            attribute constructors: attributes have quotes around
            them, and this sets a different expectation.</p>
          </div>

          <h3><a name="id-issue-N5267E" id=
          "id-issue-N5267E"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html
            (W3C-members only)</a>)</small></p>

            <p>Confirmed that Mary's proposal for whitespace, that
            was accepted 2002-11-27, closes this issue.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Resolved by the recent adoption of the revised text
            on attribute constructors.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: green; background-color: white">
        <h2>338. <a name="whitespace-character-reference" id=
        "whitespace-character-reference"><u>whitespace-character-reference</u>:
        Handling of whitespace and character references</a></h2>

        <div>
          <small>Locus: <b>xquery</b> Cluster: <b>whitespace</b>
          Priority: <b>1</b> Status: <b>decided</b><br />
          Originator: <b>Michael Kay</b></small>Handling of
          whitespace and character references

          <h3><a name="id-issue-N52A0D" id=
          "id-issue-N52A0D"></a>Description</h3>

          <div>
            <p>The effect of CharRef in Element or Attribute
            content is underspecified. For example, if the value of
            the CharRef is whitespace, does it behave like
            whitespace in Element or Attribute content, or does it
            behave like ordinary characters? Either way, it is hard
            to make it behave exactly like the XML construct that
            it mimics: in XML, a character reference such as
            suppresses certain effects such as whitespace
            normalization. It is not clear whether such
            normalization happens in XQuery.</p>
          </div>

          <h3><a name="id-issue-N52A10" id=
          "id-issue-N52A10"></a>Interactions and Input</h3>

          <h3><a name="id-issue-N52A15" id=
          "id-issue-N52A15"></a>Actual Resolution</h3>

          <div>
            <p><small>Decision by: <b>xquery</b> on 2002-12-04
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0167.html
            (W3C-members only)</a>)</small></p>

            <p>Confirmed that Mary's proposal for whitespace, that
            was accepted 2002-11-27, closes this issue.</p>

            <p><small>Decision by: <b>xquery</b> on 2002-12-11
            (<a href=
            "http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html">http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2002Dec/0317.html
            (W3C-members only)</a>)</small></p>

            <p>Resolved by the recent adoption of the revised text
            on attribute constructors.</p>
          </div>
        </div>
      </div>

      <div class="issue" style=
      "color: red; background-color: white">
        <h2>152. <a name="xquery-abql" id=
        "xquery-abql"><u>xquery-abql</u>: XML-based Syntax</a></h2>

        <div>
          <small>Locus: <b>xqueryx</b> Cluster: <b>xqueryx</b>
          Priority: <b>o-1</b> Status: <b>active</b><br />
          Originator: <b>XML Query WG</b></small>XML-based Syntax

          <h3><a name="id-issue-N511BF" id=
          "id-issue-N511BF"></a>Description</h3>

          <div>
            <p>XQuery needs an XML representation that reflects the
            structure of an XQuery query. Drafts of such a
            representation have been prepared, but it is not yet
            ready for publication.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a id="id-revisions-log" name="id-revisions-log"></a>J
      Revision Log (Non-Normative)</h2>

      <div class="div2">
        <h3><a id="N13EDA" name="N13EDA"></a>J.1 22 August
        2003</h3>

        <ul>
          <li>
            <p>Section 2 has been reorganized and a new subsection
            ("Processing Model") has been introduced, together with
            a new Appendix ("Context Components") that summarizes
            how the static and dynamic context are initialized.</p>
          </li>

          <li>
            <p>Specific error codes have been introduced and
            summarized in a new Appendix ("Summary of Error
            Conditions").</p>
          </li>

          <li>
            <p>Many terms throughout the document have been
            explicitly defined and summarized in a new Appendix
            ("Glossary").</p>
          </li>

          <li>
            <p>The section on Optional Features has been rewritten.
            The term Basic XPath is no longer used.</p>
          </li>

          <li>
            <p>Minor changes have been made to the definition of
            leading <code>/</code> and <code>//</code> in a path
            expression (now raises an error if the root node above
            the context node is not a document node).</p>
          </li>

          <li>
            <p>Changes have been made to the rules for static type
            checking of a <code>treat</code> expression.</p>
          </li>

          <li>
            <p>Comments, pragmas, and extensions are now allowed
            only in places where insignificant whitespace is
            allowed. For example, they are not allowed in element
            content.</p>
          </li>

          <li>
            <p>The <code>input()</code> function has been
            deleted.</p>
          </li>

          <li>
            <p>A Context Item Expression (".") is now classified as
            a Primary Expression rather than as an Abbreviated
            Forward Step.</p>
          </li>
        </ul>
      </div>
    </div>
  </div>
</body>
</html>
