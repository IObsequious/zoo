<html>
<head>
<title> Types, Values, and Variables</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="lexical.html">Prev</a> | <a href="conversions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="44329"></a>
<p><strong>
CHAPTER
 4 </strong></p>
<a name="48440"></a>
<h1>Types, Values, and Variables</h1>
<hr><p>
<a name="97679"></a>
The Java programming language is a <em>strongly typed</em> language, which means that every variable and every expression has a type that is known at compile time. Types limit the values that a variable <a href="typesValues.html#18470">(&#167;4.12)</a> can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations. Strong typing helps detect errors at compile time.<p>
<a name="50743"></a>
The types of the Java programming language are divided into two categories: primitive types and reference types. The primitive types <a href="typesValues.html#85587">(&#167;4.2)</a> are the <code>boolean</code> type and the numeric types. The numeric types are the integral types <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>char</code>, and the floating-point types <code>float</code> and <code>double</code>. The reference types <a href="typesValues.html#9317">(&#167;4.3)</a> are class types, interface types, and array types. There is also a special null type. An object <a href="typesValues.html#12028">(&#167;4.3.1)</a> is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class <code>Object</code> <a href="typesValues.html#11055">(&#167;4.3.2)</a>. String literals are represented by <code>String</code> objects <a href="typesValues.html#26992">(&#167;4.3.3)</a>.<p>
<a name="50838"></a>
 <p>
<a name="50800"></a>
Types exist at compile-time. Some types correspond to classes and interfaces, which exist at run-time. The correspondence between types and classes or interfaces is incomplete for two reasons:<p>
<ol>
<a name="111011"></a>
<li>At run-time, classes and interfaces are loaded by the Java virtual machine using class loaders. Each class loader defines its own set of classes and interfaces. As a result, it is possible for two loaders to load an identical class or interface definition but produce distinct classes or interfaces at run-time.
<a name="111030"></a>
<li>Type arguments and type variables <a href="typesValues.html#108850">(&#167;4.4)</a> are not reified at run-time. As a result, different parameterized types <a href="typesValues.html#112898">(&#167;4.5)</a> are implemented by the same class or interface at run time. Indeed, all invocations of a given generic type declaration (<a href="classes.html#299360">&#167;8.1.2</a>, <a href="interfaces.html#78598">&#167;9.1.2</a> )share a single run-time implementation. 
</ol>
<a name="111013"></a>
A consequence of (<a href="typesValues.html#111011">1</a>) is that code that compiled correctly may fail at link time if the class loaders that load it are inconsistent. See the paper <em>Dynamic Class Loading in the Java Virtual Machine</em>, by Sheng Liang and Gilad Bracha, in <em>Proceedings of OOPSLA '98</em>, published as <em>ACM SIGPLAN Notices</em>, Volume 33, Number 10, October 1998, pages 36-44, and <em>The Java Virtual Machine Specification, Second Edition</em> for more details.<p>
<a name="111047"></a>
A consequence of (<a href="typesValues.html#111030">2</a>) is the possibility of heap pollution <a href="typesValues.html#111088">(&#167;4.12.2.1)</a>. Under certain conditions, it is possible that a variable of a parameterized type refers to an object that is not of that parameterized type. The variable will always refer to an object that is an instance of a class that implements the parameterized type. See <a href="typesValues.html#28345">(&#167;4.12.2)</a> for further discussion.<p>
<a name="111059"></a>
<a name="4.1"></a>
<h2>4.1    The Kinds of Types and Values</h2>
<a name="107970"></a>
There are two kinds of <em>types</em> in the Java programming language: primitive types <a href="typesValues.html#85587">(&#167;4.2)</a> and reference types <a href="typesValues.html#9317">(&#167;4.3)</a>. There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values <a href="typesValues.html#85587">(&#167;4.2)</a> and reference values <a href="typesValues.html#9317">(&#167;4.3)</a>.<p>
<blockquote><pre>
<i>
Type:
        PrimitiveType
        ReferenceType
        </i>
</pre></blockquote><a name="23953"></a>
There is also a special <em>null type</em>, the type of the expression <code>null</code>, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the programmer can ignore the null type and just pretend that <code>null</code> is merely a special literal that can be of any reference type.<p>
<a name="85587"></a>
<a name="4.2"></a>
<h2>4.2    Primitive Types and Values</h2>
<a name="9122"></a>
A <em>primitive type</em> is predefined by the Java programming language and named by its reserved keyword <a href="lexical.html#229308">(&#167;3.9)</a>:<p>
<blockquote><pre>
<i>
PrimitiveType:
        NumericType</i>
        boolean<i>

NumericType:
        IntegralType
        FloatingPointType

IntegralType: one of</i>
        byte short int long char<i>

FloatingPointType: one of</i>
        float double
</pre></blockquote><a name="50919"></a>
Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that same type. The value of a variable of primitive type can be changed only by assignment operations on that variable (including increment (<a href="expressions.html#292383">&#167;15.14.2</a>, <a href="expressions.html#39547">&#167;15.15.1</a>) and decrement (<a href="expressions.html#4987">&#167;15.14.3</a>, <a href="expressions.html#239136">&#167;15.15.2</a>) operators).<p>
<a name="9137"></a>
The <em>numeric types</em> are the integral types and the floating-point types. <p>
<a name="88061"></a>
The <em>integral types</em> are <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and <code>char</code>, whose values are 16-bit unsigned integers representing UTF-16 code units <a href="lexical.html#95413">(&#167;3.1)</a>.<p>
<a name="88062"></a>
The <em>floating-point types</em> are <code>float</code>, whose values include the 32-bit IEEE 754 floating-point numbers, and <code>double</code>, whose values include the 64-bit IEEE 754 floating-point numbers.<p>
<a name="50913"></a>
The <code>boolean</code> type has exactly two values: <code>true</code> and <code>false.</code><p>
<a name="9151"></a>
<a name="4.2.1"></a>
<h3>4.2.1    Integral Types and Values</h3>
<a name="50950"></a>
The values of the integral types are integers in the following ranges:<p>
<ul><a name="9163"></a>
<li>For <code>byte</code>, from -128 to 127, inclusive
<a name="9164"></a>
<li>For <code>short</code>, from -32768 to 32767, inclusive
<a name="9165"></a>
<li>For <code>int</code>, from -2147483648 to 2147483647, inclusive
<a name="9166"></a>
<li>For <code>long</code>, from -9223372036854775808 to 9223372036854775807, inclusive
<a name="51034"></a>
<li>For <code>char</code>, from <code>'\u0000'</code> to <code>'\uffff'</code> inclusive, that is, from 0 to 65535
</ul><a name="51035"></a>
<a name="4.2.2"></a>
<h3>4.2.2    Integer Operations</h3>
<a name="29775"></a>
The Java programming language provides a number of operators that act on integral values:<p>
<ul><a name="10358"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="9181"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.html#153654">(&#167;15.20.1)</a>
<a name="17601"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="10365"></a>
<li>The numerical operators, which result in a value of type <code>int</code> or <code>long</code>:
<ul>
<a name="18334"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.html#24924">&#167;15.15.3</a>, <a href="expressions.html#236345">&#167;15.15.4</a>)
<a name="17539"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.html#239829">(&#167;15.17)</a>
<a name="19482"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.html#15746">(&#167;15.18)</a>
<a name="24026"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.html#292383">(&#167;15.14.2)</a>
<a name="24036"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.html#4987">(&#167;15.14.3)</a>
<a name="19496"></a>
<li>The signed and unsigned shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> <a href="expressions.html#5121">(&#167;15.19)</a>
<a name="51061"></a>
<li>The bitwise complement operator <code>~</code> <a href="expressions.html#5017">(&#167;15.15.5)</a>
<a name="17770"></a>
<li>The integer bitwise operators <code>&amp;</code>, <code>|</code>, and <code>^</code> <a href="expressions.html#5233">(&#167;15.22.1)</a>
</ul>
<a name="19469"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.html#290293">(&#167;15.25)</a>
<a name="18373"></a>
<li>The cast operator, which can convert from an integral value to a value of any specified numeric type (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>)
<a name="17774"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and an integral operand, will convert the integral operand to a <code>String</code> representing its value in decimal form, and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="51025"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, and <code>Character</code>.<p>
<a name="28057"></a>
If an integer operator other than a shift operator has at least one operand of type <code>long</code>, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type <code>long</code>. If the other operand is not <code>long</code>, it is first widened <a href="conversions.html#190646">(&#167;5.1.5)</a> to type <code>long</code> by numeric promotion <a href="conversions.html#26917">(&#167;5.6)</a>. Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type <code>int</code>. If either operand is not an <code>int</code>, it is first widened to type <code>int</code> by numeric promotion.<p>
<a name="9194"></a>
The built-in integer operators do not indicate overflow or underflow in any way. Integer operators can throw a <code>NullPointerException</code> if unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> of a null reference is required. Other than that, the only integer operators that can throw an exception <a href="exceptions.html#44043">(&#167;11)</a> are the integer divide operator <code>/</code> <a href="expressions.html#5047">(&#167;15.17.2)</a> and the integer remainder operator <code>%</code> <a href="expressions.html#24956">(&#167;15.17.3)</a>, which throw an <code>ArithmeticException</code> if the right-hand operand is zero, and the increment and decrement operators <code>++</code>(<a href="expressions.html#39547">&#167;15.15.1</a>, <a href="expressions.html#239136">&#167;15.15.2</a>) and <code>--</code>(<a href="expressions.html#4987">&#167;15.14.3</a>, <a href="expressions.html#292383">&#167;15.14.2</a>), which can throw an <code>OutOfMemoryError</code> if boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> is required and there is not sufficient memory available to perform the conversion.<p>
<a name="86654"></a>
<p>The example:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int i = 1000000;
                System.out.println(i * i);
                long l = i;
                System.out.println(l * l);
                System.out.println(20296 / (l - i));
        }
}
</pre></blockquote><a name="51131"></a>
produces the output:<p>
<blockquote><pre>-727379968
1000000000000
</pre></blockquote><a name="51199"></a>
and then encounters an <code>ArithmeticException</code> in the division by <code>l</code> <code>-</code> <code>i</code>, because <code>l</code> <code>-</code> <code>i</code> is zero. The first multiplication is performed in 32-bit precision, whereas the second multiplication is a <code>long</code> multiplication. The value <code>-727379968</code> is the decimal value of the low 32 bits of the mathematical result, <code>1000000000000</code>, which is a value too large for type <code>int</code>.<p>
<a name="51203"></a>
Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type <code>boolean</code>.<p>
<a name="9208"></a>
<a name="4.2.3"></a>
<h3>4.2.3    Floating-Point Types, Formats, and Values</h3>
<a name="87606"></a>
The floating-point types are <code>float</code> and <code>double</code>, which are conceptually associated with the single-precision 32-bit and double-precision 64-bit format IEEE 754 values and operations as specified in <em>IEEE Standard for Binary Floating-Point Arithmetic</em>, ANSI/IEEE Standard 754-1985 (IEEE, New York).<p>
<a name="88071"></a>
The IEEE 754 standard includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative <em>infinities</em>, and special <em>Not-a-Number </em>values (hereafter abbreviated NaN). A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero. NaN constants of both <code>float</code> and <code>double</code> type are predefined as <code>Float.NaN</code> and <code>Double.NaN</code>.<p>
<a name="96776"></a>
Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the <em>float value set</em> and the <em>double value set</em>. In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point value sets, called the<em> float-extended-exponent value set</em> and the<em> double-extended-exponent value set</em>. These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of expressions of type <code>float</code> or <code>double</code> (<a href="conversions.html#184225">&#167;5.1.13</a>, <a href="expressions.html#249198">&#167;15.4</a>).<p>
<a name="96777"></a>
The finite nonzero values of any floating-point value set can all be expressed in the form <i>s &#183; m &#183; </i>2<i><font size="-1"><sup></i>(<i>e-N</i>+1)</sup></font></i>, where <em>s</em> is +1 or -1, <em>m</em> is a positive integer less than 2<font size="-1"><sup><i>N</i></sup></font>, and <em>e</em> is an integer between <i>E<font size="-1"><sub>min</sub></font></i> = -(2<font size="-1"><sup><i>K</i>-1</sup></font>-2) and <i>E<font size="-1"><sub>max</sub></font></i> = 2<font size="-1"><sup><i>K</i>-1</sup></font>-1, inclusive, and where <em>N</em> and <em>K</em> are parameters that depend on the value set. Some values can be represented in this form in more than one way; for example, supposing that a value <em>v</em> in a value set might be represented in this form using certain values for <em>s</em>, <em>m</em>, and <em>e</em>, then if it happened that <em>m</em> were even and <em>e</em> were less than 2<font size="-1"><sup><i>K</i>-1</sup></font>, one could halve <em>m</em> and increase <em>e</em> by 1 to produce a second representation for the same value <em>v</em>. A representation in this form is called <em>normalized</em> if <i>m</i> <img src="chars/gtequal.gif"> 2<font size="-1"><sup>(<i>N</i>-1)</sup></font>; otherwise the representation is said to be <em>denormalized</em>. If a value in a value set cannot be represented in such a way that <i>m</i> <img src="chars/gtequal.gif"> 2<font size="-1"><sup>(<i>N</i>-1)</sup></font>, then the value is said to be a <em>denormalized value</em>, because it has no normalized representation.<p>
<a name="96680"></a>
The constraints on the parameters <em>N</em> and <em>K</em> (and on the derived parameters <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>) for the two required and two optional floating-point value sets are summarized in <a href="typesValues.html#96802">Table 4.1</a>. 
<p>
<Table Border="1" cellpadding="2">
<tr><th><a name="96683"></a>
<a name=""</a>
<b>Parameter</b>
<th><a name="96685"></a>
<a name=""</a>
<b> <strong>float</strong></b>
<th><a name="96687"></a>
<a name=""</a>
<b> <strong>float-extended-exponent</strong></b>
<th><a name="96689"></a>
<a name=""</a>
<b> double</b>
<th><a name="96691"></a>
<a name=""</a>
<b> double-extended-exponent</b>

<tr><td><a name="96693"></a>
 N<p>
<td><a name="96695"></a>
 24<p>
<td><a name="96697"></a>
 24<p>
<td><a name="96699"></a>
 53<p>
<td><a name="96701"></a>
 53<p>

<tr><td><a name="96703"></a>
 K<p>
<td><a name="96705"></a>
 8<p>
<td><a name="96707"></a>
 <img src="chars/gtequal.gif"> 11<p>
<td><a name="96709"></a>
 11<p>
<td><a name="96711"></a>
 <img src="chars/gtequal.gif"> 15<p>

<tr><td><a name="96713"></a>
 E<sub><i>max</i></sub><p>
<td><a name="96715"></a>
 +127<p>
<td><a name="96717"></a>
 <img src="chars/gtequal.gif"> +1023<p>
<td><a name="96719"></a>
 +1023<p>
<td><a name="96721"></a>
 <img src="chars/gtequal.gif"> +16383<p>

<tr><td><a name="96723"></a>
 E<sub><i>min</i></sub><p>
<td><a name="96725"></a>
 -126<p>
<td><a name="96727"></a>
<img src="chars/lt_equal.gif"> -1022<p>
<td><a name="96729"></a>
 -1022<p>
<td><a name="96731"></a>
<img src="chars/lt_equal.gif"> -16382<p>


</Table>

<Table>
<tr><td>
</Table>
<p>
<a name="106189"></a>
Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant <em>K</em>, whose value is constrained by <a href="typesValues.html#96802">Table 4.1</a>; this value <em>K</em> in turn dictates the values for <em>E</em><sub><i>min</i></sub> and <em>E</em><sub><i>max</i></sub>.<p>
<a name="96735"></a>
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.<p>
<a name="96736"></a>
Note that the constraints in <a href="typesValues.html#96802">Table 4.1</a> are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set. Likewise, each element of the double value set is necessarily also an element of the double-extended-exponent value set. Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.<p>
<a name="96737"></a>
The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard. The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard. Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do <em>not</em> correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.<p>
<a name="96744"></a>
The float, float-extended-exponent, double, and double-extended-exponent value sets are not types. It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value of type <code>float</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the float-extended-exponent value set instead. Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type <code>double</code>; however, it may be permissible in certain regions of code for an implementation to use an element of the double-extended-exponent value set instead.<p>
<a name="106159"></a>
Except for NaN, floating-point values are <em>ordered</em>; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.<p>
<a name="106160"></a>
IEEE 754 allows multiple distinct NaN values for each of its single and double floating-point formats. While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information. <p>
<a name="106258"></a>
For the most part, the Java platform treats NaN values of a given type as though collapsed into a single canonical value (and hence this specification normally refers to an arbitrary NaN as though to a canonical value). However, version 1.3 the Java platform introduced methods enabling the programmer to distinguish between NaN values: the <code>Float.floatToRawIntBits</code> and <code>Double.doubleToRawLongBits</code> methods. The interested reader is referred to the specifications for the <code>Float</code> and <code>Double</code> classes for more information.<p>
<a name="86666"></a>
Positive zero and negative zero compare equal; thus the result of the expression <code>0.0==-0.0</code> is <code>true</code> and the result of <code>0.0&gt;-0.0</code> is <code>false</code>. But other operations can distinguish positive and negative zero; for example, <code>1.0/0.0</code> has the value positive infinity, while the value of <code>1.0/-0.0</code> is negative infinity.<p>
<a name="16083"></a>
NaN is <em>unordered</em>, so the numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> return <code>false</code> if either or both operands are NaN <a href="expressions.html#153654">(&#167;15.20.1)</a>. The equality operator <code>==</code> returns <code>false</code> if either operand is NaN, and the inequality operator <code>!=</code> returns <code>true</code> if either operand is NaN <a href="expressions.html#5198">(&#167;15.21.1)</a>. In particular, <code>x!=x</code> is <code>true</code> if and only if <code>x</code> is NaN, and <code>(x&lt;y)</code> <code>==</code> <code>!(x&gt;=y)</code> will be <code>false</code> if <code>x</code> or <code>y</code> is NaN.<p>
<a name="16093"></a>
Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type <code>boolean</code>.<p>
<a name="9249"></a>
<a name="4.2.4"></a>
<h3>4.2.4    Floating-Point Operations</h3>
<a name="9981"></a>
The Java programming language provides a number of operators that act on floating-point values:<p>
<ul><a name="52058"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="52062"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="expressions.html#153654">(&#167;15.20.1)</a>
<a name="52066"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="expressions.html#5198">(&#167;15.21.1)</a>
</ul>
<a name="52069"></a>
<li>The numerical operators, which result in a value of type <code>float</code> or <code>double</code>:
<ul>
<a name="52076"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="expressions.html#24924">&#167;15.15.3</a>, <a href="expressions.html#236345">&#167;15.15.4</a>)
<a name="24115"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="expressions.html#239829">(&#167;15.17)</a>
<a name="24119"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="expressions.html#13510">(&#167;15.18.2)</a>
<a name="24126"></a>
<li>The increment operator <code>++</code>, both prefix <a href="expressions.html#39547">(&#167;15.15.1)</a> and postfix <a href="expressions.html#292383">(&#167;15.14.2)</a>
<a name="24107"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="expressions.html#239136">(&#167;15.15.2)</a> and postfix <a href="expressions.html#4987">(&#167;15.14.3)</a>
</ul>
<a name="19446"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.html#290293">(&#167;15.25)</a>
<a name="11998"></a>
<li>The cast operator, which can convert from a floating-point value to a value of any specified numeric type (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>)
<a name="21842"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a floating-point operand, will convert the floating-point operand to a <code>String</code> representing its value in decimal form (without information loss), and then produce a newly created <code>String</code> by concatenating the two strings
</ul><a name="12009"></a>
Other useful constructors, methods, and constants are predefined in the classes <code>Float</code>, <code>Double</code>, and <code>Math</code>.<p>
<a name="12005"></a>
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.<p>
<a name="51262"></a>
If at least one of the operands to a numerical operator is of type <code>double</code>, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>double</code>. (If the other operand is not a <code>double</code>, it is first widened to type <code>double</code> by numeric promotion <a href="conversions.html#26917">(&#167;5.6)</a>.) Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>float. </code>If the other operand is not a <code>float</code>, it is first widened to type <code>float</code> by numeric promotion.<p>
<a name="9265"></a>
Operators on floating-point numbers behave as specified by IEEE 754 (with the exception of the remainder operator <a href="expressions.html#24956">(&#167;15.17.3)</a>). In particular, the Java programming language requires support of IEEE 754 <em>denormalized</em> floating-point numbers and <em>gradual underflow</em>, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations do not "flush to zero" if the calculated result is a denormalized number.<p>
<a name="9274"></a>
The Java programming language requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. <em>Inexact</em> results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as <em>round to nearest</em>.<p>
<a name="10346"></a>
The language uses <em>round toward zero</em> when converting a floating value to an integer <a href="conversions.html#25363">(&#167;5.1.3)</a>, which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.<p>
<a name="9290"></a>
Floating-point operators can throw a <code>NullPointerException</code> if unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> of a null reference is required. Other than that, the only floating-point operators that can throw an exception <a href="exceptions.html#44043">(&#167;11)</a> are the increment and decrement operators <code>++</code>(<a href="expressions.html#39547">&#167;15.15.1</a>, <a href="expressions.html#239136">&#167;15.15.2</a>) and <code>--</code>(<a href="expressions.html#4987">&#167;15.14.3</a>, <a href="expressions.html#292383">&#167;15.14.2</a>), which can throw an <code>OutOfMemoryError</code> if boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> is required and there is not sufficient memory available to perform the conversion. <p>
<a name="118702"></a>
An operation that overflows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. As has already been described, NaN is unordered, so a numeric comparison operation involving one or two NaNs returns <code>false</code> and any <code>!=</code> comparison involving NaN returns <code>true</code>, including <code>x!=x</code> when <code>x</code> is NaN.<p>
<a name="9291"></a>
<p>The example program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                // An example of overflow:
                double d = 1e308;
                System.out.print("overflow produces infinity: ");
                System.out.println(d + "*10==" + d*10);
                // An example of gradual underflow:
                d = 1e-305 * Math.PI;
                System.out.print("gradual underflow: " + d + "\n &#32; &#32; &#32;");
                for (int i = 0; i &lt; 4; i++)
                        System.out.print(" " + (d /= 100000));
                System.out.println();
                // An example of NaN:
                System.out.print("0.0/0.0 is Not-a-Number: ");
                d = 0.0/0.0;
                System.out.println(d);
                // An example of inexact results and rounding:
                System.out.print("inexact results with float:");
                for (int i = 0; i &lt; 100; i++) {
                        float z = 1.0f / i;
                        if (z * i != 1.0f)
                                System.out.print(" " + i);
                }
                System.out.println();
                // Another example of inexact results and rounding:
                System.out.print("inexact results with double:");
                for (int i = 0; i &lt; 100; i++) {
                        double z = 1.0 / i;
                        if (z * i != 1.0)
                                System.out.print(" " + i);
                }
                System.out.println();
                // An example of cast to integer rounding:
                System.out.print("cast to int rounds toward 0: ");
                d = 12345.6;
                System.out.println((int)d + " " + (int)(-d));
        }
}
</pre></blockquote><a name="23297"></a>
produces the output:<p>
<blockquote><pre>overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305
        3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345
</pre></blockquote>
<a name="22309"></a>
<p>This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.</p>
<a name="11717"></a>
<p>The results when <code>i</code> is <code>0</code> involve division by zero, so that <code>z</code> becomes positive infinity, and <code>z</code> <code>*</code> <code>0</code> is NaN, which is not equal to <code>1.0</code>.</p>
<a name="11527"></a>
<a name="4.2.5"></a>
<h3>4.2.5    The boolean Type and boolean Values</h3>
<a name="9295"></a>
The <code>boolean</code> type represents a logical quantity with two possible values, indicated by the literals <code>true</code> and <code>false</code> <a href="lexical.html#49652">(&#167;3.10.3)</a>. The boolean operators are:<p>
<ul><a name="17733"></a>
<li>The relational operators <code>==</code> and <code>!=</code> <a href="expressions.html#54508">(&#167;15.21.2)</a>
<a name="17734"></a>
<li>The logical-complement operator <code>!</code> <a href="expressions.html#13350">(&#167;15.15.6)</a>
<a name="17736"></a>
<li>The logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> <a href="expressions.html#5242">(&#167;15.22.2)</a>
<a name="17737"></a>
<li>The conditional-and and conditional-or operators <code>&amp;&amp;</code> <a href="expressions.html#5247">(&#167;15.23)</a> and <code>||</code> <a href="expressions.html#54532">(&#167;15.24)</a>
<a name="19467"></a>
<li>The conditional operator <code>? :</code> <a href="expressions.html#290293">(&#167;15.25)</a>
<a name="21871"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a boolean operand, will convert the boolean operand to a <code>String</code> (either <code>"true"</code> or <code>"false"</code>), and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="17738"></a>
Boolean expressions determine the control flow in several kinds of statements:<p>
<ul><a name="17742"></a>
<li>The <code>if</code> statement <a href="statements.html#5991">(&#167;14.9)</a>
<a name="17743"></a>
<li>The <code>while</code> statement <a href="statements.html#237277">(&#167;14.12)</a>
<a name="17745"></a>
<li>The <code>do</code> statement <a href="statements.html#6045">(&#167;14.13)</a>
<a name="17747"></a>
<li>The <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a>
</ul><a name="48454"></a>
A <code>boolean</code> expression also determines which subexpression is evaluated in the conditional <code>?&#32;:</code> operator <a href="expressions.html#290293">(&#167;15.25)</a>.<p>
<a name="48458"></a>
Only <code>boolean</code> or <code>Boolean</code> expressions can be used in control flow statements and as the first operand of the conditional operator <code>?&#32;:</code>. An integer <code>x</code> can be converted to a <code>boolean</code>, following the C language convention that any nonzero value is <code>true</code>, by the expression <code>x!=0</code>. An object reference <code>obj</code> can be converted to a <code>boolean</code>, following &#32;the C language convention that any reference other than <code>null</code> is <code>true</code>, by the expression <code>obj!=null</code>.<p>
<a name="9299"></a>
A cast of a <code>boolean</code> value to type <code>boolean</code> or <code>Boolean</code> is allowed <a href="conversions.html#25209">(&#167;5.1.1)</a>; no other casts on type <code>boolean</code> are allowed. A <code>boolean</code> can be converted to a string by string conversion <a href="conversions.html#186035">(&#167;5.4)</a>.<p>
<a name="9317"></a>
<a name="4.3"></a>
<h2>4.3    Reference Types and Values</h2>
<a name="9664"></a>
There are three kinds of <em>reference types</em>: class types <a href="classes.html#328796">(&#167;8)</a>, interface types <a href="interfaces.html#238678">(&#167;9)</a>, and array types <a href="arrays.html#27803">(&#167;10)</a>. Reference types may be parameterized <a href="typesValues.html#112898">(&#167;4.5)</a> with type arguments <a href="typesValues.html#108850">(&#167;4.4)</a>.<p>
<blockquote><pre>
<i>
ReferenceType:
        ClassOrInterfaceType
        TypeVariable
        ArrayType

ClassOrInterfaceType:
        ClassType
        InterfaceType


ClassType:
        TypeDeclSpecifier TypeArgumentsopt

InterfaceType:
        TypeDeclSpecifier TypeArgumentsopt

TypeDeclSpecifier:
        TypeName
        ClassOrInterfaceType . Identifier
        </i>
</pre></blockquote><a name="112466"></a>
<p>
<blockquote><pre>
<i>
TypeName:
        Identifier
        TypeName . Identifier

TypeVariable:
        Identifier

ArrayType:
        Type </i>[ ]
</pre></blockquote><a name="9678"></a>
A class or interface type consists of a type declaration specifier, optionally followed by type arguments (in which case it is a parameterized type). Type arguments are described in <a href="typesValues.html#107353">(&#167;4.5.1)</a>. <p>
<a name="121741"></a>
A type declaration specifier may be either a type name <a href="names.html#73064">(&#167;6.5.5)</a>, or a class or interface type followed by "." and an identifier. In the latter case, the specifier has the form <i>T.id,</i> where <i>id</i> must be the simple name of an accessible <a href="names.html#104285">(&#167;6.6)</a> member type ( <a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>) of <i>T,</i> or a compile-time error occurs. The specifier denotes that member type.<p>
<a name="87599"></a>
<p>The sample code:</p>
<blockquote><pre>class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
</pre></blockquote><a name="11032"></a>
declares a class type <code>Point</code>, an interface type <code>Move</code>, and uses an array type <code>int[]</code> (an array of <code>int</code>) to declare the field <code>metrics</code> of the class <code>Point</code>.<p>
<a name="12028"></a>
<a name="4.3.1"></a>
<h3>4.3.1    Objects</h3>
<a name="86707"></a>
An <em>object</em> is a <em>class</em> <em>instance</em> or an array.<p>
<a name="106237"></a>
The reference values (often just <em>references</em>) are <em>pointers </em>to these objects, and a special null reference, which refers to no object.<p>
<a name="49853"></a>
A class instance is explicitly created by a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>. An array is explicitly created by an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>.<p>
<a name="49899"></a>
A new class instance is implicitly created when the string concatenation operator + <a href="expressions.html#39990">(&#167;15.18.1)</a> is used in a non-constant <a href="expressions.html#5313">(&#167;15.28)</a> expression, resulting in a new object of type <code>String</code> (<a href="typesValues.html#26992">&#167;4.3.3</a>). A new array object is implicitly created when an array initializer expression <a href="arrays.html#11358">(&#167;10.6)</a> is evaluated; this can occur when a class or interface is initialized <a href="execution.html#44557">(&#167;12.4)</a>, when a new instance of a class is created <a href="expressions.html#41147">(&#167;15.9)</a>, or when a local variable declaration statement is executed <a href="statements.html#5920">(&#167;14.4)</a>. New objects of the types Boolean, Byte, Short, Character, Integer, Long, Float and Double may be implicitly created by boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a>.<p>
<a name="49960"></a>
<p>Many of these cases are illustrated in the following example:</p>
<blockquote><pre>class Point {
        int x, y;
        Point() { System.out.println("default"); }
        Point(int x, int y) { this.x = x; this.y = y; }
        // A Point instance is explicitly created at class initialization time:
        static Point origin = new Point(0,0);
        // A String can be implicitly created by a + operator:
        public String toString() {
                return "(" + x + "," + y + ")";
        }
}
class Test {
        public static void main(String[] args) {
                // A Point is explicitly created using newInstance:
                Point p = null;
                try {
                        p = (Point)Class.forName("Point").newInstance();
                } catch (Exception e) {
                        System.out.println(e);
                }
                // An array is implicitly created by an array constructor:
                Point a[] = { new Point(0,0), new Point(1,1) };
                // Strings are implicitly created by + operators:
                System.out.println("p: " + p);
                System.out.println("a: { " + a[0] + ", "
                                                                                  &#32;+ a[1] + " }");
                // An array is explicitly created by an array creation expression:
                String sa[] = new String[2];
                sa[0] = "he"; sa[1] = "llo";
                System.out.println(sa[0] + sa[1]);
        }
}
</pre></blockquote><a name="87328"></a>
which produces the output:<p>
<blockquote><pre>default
p: (0,0)
a: { (0,0), (1,1) }
hello
</pre></blockquote><a name="49965"></a>
The operators on references to objects are:<p>
<ul><a name="31321"></a>
<li>Field access, using either a qualified name <a href="names.html#104285">(&#167;6.6)</a> or a field access expression <a href="expressions.html#41267">(&#167;15.11)</a>
<a name="31328"></a>
<li>Method invocation <a href="expressions.html#20448">(&#167;15.12)</a>
<a name="31378"></a>
<li>The cast operator (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>)
<a name="31345"></a>
<li>The string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a>, which, when given a <code>String</code> operand and a reference, will convert the reference to a <code>String</code> by invoking the <code>toString</code> method of the referenced object (using <code>"null"</code> if either the reference or the result of <code>toString</code> is a null reference), and then will produce a newly created <code>String</code> that is the concatenation of the two strings
<a name="31399"></a>
<li>The <code>instanceof</code> operator <a href="expressions.html#80289">(&#167;15.20.2)</a>
<a name="31306"></a>
<li>The reference equality operators <code>==</code> and <code>!=</code> <a href="expressions.html#236163">(&#167;15.21.3)</a>
<a name="19595"></a>
<li>The conditional operator <code>?&#32;:</code> <a href="expressions.html#290293">(&#167;15.25)</a>.
</ul><a name="28239"></a>
There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.<p>
<a name="87600"></a>
<p>The example program:</p>
<blockquote><pre>class Value { int val; }
class Test {
        public static void main(String[] args) {
                int i1 = 3;
                int i2 = i1;
                i2 = 4;
                System.out.print("i1==" + i1);
                System.out.println(" but i2==" + i2);
                Value v1 = new Value();
                v1.val = 5;
                Value v2 = v1;
                v2.val = 6;
                System.out.print("v1.val==" + v1.val);
                System.out.println(" and v2.val==" + v2.val);
        }
}
</pre></blockquote><a name="11050"></a>
produces the output:<p>
<blockquote><pre>i1==3 but i2==4
v1.val==6 and v2.val==6
</pre></blockquote><a name="11053"></a>
because <code>v1.val</code> and <code>v2.val</code> reference the same instance variable <a href="typesValues.html#119097">(&#167;4.12.3)</a> in the one <code>Value</code> object created by the only <code>new</code> expression, while <code>i1</code> and <code>i2</code> are different variables.<p>
<a name="17783"></a>
<p>See <a href="arrays.html#27803">&#167;10</a> and <a href="expressions.html#46168">&#167;15.10</a> for examples of the creation and use of arrays.</p>
<a name="17053"></a>
Each object has an associated lock <a href="memory.html#73817">(&#167;17.1)</a>, which is used by <code>synchronized</code> methods <a href="classes.html#78188">(&#167;8.4.3)</a> and the <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a> to provide control over concurrent access to state by multiple threads (<a href="memory.html#34445">&#167;17</a>).<p>
<a name="11055"></a>
<a name="4.3.2"></a>
<h3>4.3.2    The Class Object</h3>
<a name="26999"></a>
The class <code>Object</code> is a superclass <a href="classes.html#15372">(&#167;8.1)</a> of all other classes. A variable of type <code>Object</code> can hold a reference to the null reference or to any object, whether it is an instance of a class or an array <a href="arrays.html#27803">(&#167;10)</a>. All class and array types inherit the methods of class <code>Object</code>, which are summarized here:<p>
<blockquote><pre>
package java.lang;

public class Object {
<a name="51634"></a>    public final Class&lt;?&gt; getClass() { . . . }
<a name="51635"></a>    public String toString() { . . . }
<a name="51636"></a>    public boolean equals(Object obj) { . . . }
<a name="51637"></a>    public int hashCode() { . . . }
<a name="51638"></a>    protected Object clone()
<a name="86088"></a>            throws CloneNotSupportedException { . . . }
<a name="87378"></a>    public final void wait()
                throws IllegalMonitorStateException,
                        InterruptedException { . . . }
<a name="51641"></a>    public final void wait(long millis)
<a name="87381"></a>            throws IllegalMonitorStateException,
<a name="87383"></a>                    InterruptedException { . . . }
<a name="51642"></a>    public final void wait(long millis, int nanos) { . . . }
<a name="87385"></a>            throws IllegalMonitorStateException,
<a name="87386"></a>                    InterruptedException { . . . }
<a name="87373"></a>    public final void notify() { . . . }
<a name="87374"></a>            throws IllegalMonitorStateException
<a name="87387"></a>    public final void notifyAll() { . . . }
<a name="87389"></a>            throws IllegalMonitorStateException
<a name="51644"></a>    protected void finalize()
<a name="86090"></a>            throws Throwable { . . . }
<a name="51645"></a>}
</pre></blockquote><a name="45610"></a>
The members of <code>Object</code> are as follows:<p>
<ul><a name="123066"></a>
<li>The method <code>getClass</code> returns the <code>Class</code> object that represents the class of the object. A <code>Class</code> object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements. A class method that is declared <code>synchronized</code> <a href="classes.html#260369">(&#167;8.4.3.6)</a> synchronizes on the lock associated with the <code>Class</code> object of the class. The method Object.getClass() must be treated specially by a Java compiler. The type of a method invocation e.getClass(), where the expression e has the static type T, is Class&lt;? extends |T|&gt;.
<a name="118754"></a>
<li>The method <code>toString</code> returns a <code>String</code> representation of the object.
<a name="12104"></a>
<li>The methods <code>equals</code> and <code>hashCode</code> are very useful in hashtables such as <code>java.util.Hashtable</code>. The method <code>equals</code> defines a notion of object equality, which is based on value, not reference, comparison.
<a name="12115"></a>
<li>The method <code>clone</code> is used to make a duplicate of an object.
<a name="12116"></a>
<li>The methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> are used in concurrent programming using threads, as described in <a href="memory.html#29542">&#167;17</a>.
<a name="12117"></a>
<li>The method <code>finalize</code> is run just before an object is destroyed and is described in <a href="execution.html#44748">&#167;12.6</a>.
</ul><a name="26992"></a>
<a name="4.3.3"></a>
<h3>4.3.3    The Class String</h3>
<a name="27000"></a>
Instances of class <code>String</code> represent sequences of Unicode characters. A &#32;<code>String</code> object has a constant (unchanging) value. String literals <a href="lexical.html#101083">(&#167;3.10.5)</a> are references to instances of class <code>String</code>.<p>
<a name="52188"></a>
The string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a> implicitly creates a new <code>String</code> object when the result is not a compile-time constant <a href="expressions.html#5313">(&#167;15.28)</a>.<p>
<a name="97058"></a>
<a name="4.3.4"></a>
<h3>4.3.4    When Reference Types Are the Same</h3>
<a name="96897"></a>
Two reference types are the <em>same compile-time type</em> if they have the same binary name <a href="binaryComp.html#44909">(&#167;13.1)</a> and their type parameters, if any, are the same, applying this definition recursively. When two reference types are the same, they are sometimes said to be the <em>same class</em> or the <em>same interface</em>.<p>
<a name="97070"></a>
At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders. These types may or may not represent the same type declaration. Even if two such types do represent the same type declaration, they are considered distinct.<p>
<a name="96917"></a>
Two reference types are the <em>same run-time type</em> if:<p>
<ul><a name="86567"></a>
<li>They are both class or both interface types, are defined by the same class loader, and have the same binary name <a href="binaryComp.html#44909">(&#167;13.1)</a>, in which case they are sometimes said to be the <em>same run-time class</em> or the <em>same run-time interface</em>.
<a name="108837"></a>
<li>They are both array types, and their component types are the same run-time type<a href="arrays.html#27803">(&#167;10)</a>.
</ul><a name="108850"></a>
<a name="4.4"></a>
<h2>4.4    Type Variables</h2>
<a name="108854"></a>
A type variable <a href="typesValues.html#108850">(&#167;4.4)</a> is an unqualified identifier. Type variables are introduced by generic class declarations <a href="classes.html#299360">(&#167;8.1.2)</a> generic interface declarations <a href="interfaces.html#78598">(&#167;9.1.2)</a> generic method declarations <a href="classes.html#323928">(&#167;8.4.4)</a> and by generic constructor declarations <a href="classes.html#244611">(&#167;8.8.4)</a>.<p>
<blockquote><pre>
<em>TypeParameter:
        TypeVariable TypeBound<sub>opt</sub></em>

<em>TypeBound:
        </em>extends <em>ClassOrInterfaceType AdditionalBoundList<sub>opt</sub></em>

<em>AdditionalBoundList:
        AdditionalBound AdditionalBoundList
        AdditionalBound
</em>
<em>AdditionalBound:
        &amp; InterfaceType
</em></pre></blockquote><a name="118791"></a>
Type variables have an optional bound, <i>T &amp; I<sub>1</sub> ... I<sub>n</sub></i>. The bound consists of either a type variable, or a class or interface type <i>T</i> possibly followed by further interface types <i>I<sub>1</sub> , ..., I<sub>n</sub></i>. If no bound is given for a type variable, <code>Object</code> is assumed. It is a compile-time error if any of the types <i>I<sub>1</sub> ... I<sub>n</sub></i> is a class type or type variable. The erasures <a href="typesValues.html#108979">(&#167;4.6)</a> of all constituent types of a bound must be pairwise different, or a compile-time error occurs.  The order of types in a bound is only significant in that the erasure of a type variable is determined by the first type in its bound, and that a class type or type variable may only appear in the first position. <p>
<a name="108879"></a>
<p>A type variable may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface. </p>
<a name="108880"></a>
See section <a href="names.html#103228">&#167;6.3</a> for the rules defining the scope of type variables.<p>
<a name="112829"></a>
The members of a type variable <i>X</i> with bound <i>T &amp; I<sub>1</sub> ... I<sub>n</sub></i> are the members of the intersection type <a href="typesValues.html#108433">(&#167;4.9)</a> <i>T &amp; I<sub>1</sub> ... I<sub>n</sub></i> appearing at the point where the type variable is declared.<p>
<a name="120145"></a>
 <p>
<a name="120149"></a>
<hr>
<p>
<b>Discussion</b>
</p>
 The following example illustrates what members a type variable has.<p>
<blockquote><pre>package TypeVarMembers;

        class C { 
                void mCDefault() {}     
                public void mCPublic() {}       
                private void mCPrivate() {} 
                protected void mCProtected() {} 
        } 
        class CT extends C implements I {}
        interface I {   
                void mI(); } 
                &lt;T extends C &amp; I&gt; void test(T t) {    
                        t.mI(); // OK
                        t.mCDefault(); // OK
                        t.mCPublic(); // OK 
                        t.mCPrivate(); // compile-time error
                        t.mCProtected(); // OK 
                } 
        }
</pre></blockquote><a name="120163"></a>
The type variable T has the same members as the intersection type C &amp; I, which in turn has the same members as the empty class CT, defined in the same scope with equivalent supertypes. The members of an interface are always public, and therefore always inherited (unless overridden). Hence mI is a member of CT and of T. Among the members of C, all but mCPrivate are inherited by CT, and are therefore members of both CT and T.<p>
<a name="120226"></a>
If C had been declared in a different package than T, then the call to mCDefault would give rise to a compile-time error, as that member would not be accessible at the point where T is declared.<p>
<hr>
<a name="120181"></a>
<p>
<a name="120151"></a>
 <p>
<a name="112898"></a>
<a name="4.5"></a>
<h2>4.5    Parameterized Types</h2>
<a name="107243"></a>
A parameterized type consists of a class or interface name <i>C</i> and an actual type argument list <i>&lt;T<sub>1</sub> , ... , T<sub>n</sub>&gt;</i>. It is a compile time error if <i>C</i> is not the name of a generic class or interface, or if the number of type arguments in the actual type argument list differs from the number of declared type parameters of <i>C.</i> In the following, whenever we speak of a class or interface type, we include the generic version as well, unless explicitly excluded. Throughout this section, let <i>A<sub>1</sub> , ... , A<sub>n</sub></i> be the formal type parameters of <i>C,</i> and let be <i>B<sub>i</sub></i> be the declared bound of <i>A<sub>i</sub></i>. The notation [<i>A<sub>i</sub></i> := <i>T<sub>i</sub></i>] denotes substitution of the type variable <i>A<sub>i</sub></i> with the type <i>T<sub>i</sub></i>, for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, and is used throughout this specification.<p>
<a name="110806"></a>
Let <i>P</i> = <i>G&lt;T<sub>1</sub>, ..., T<sub>n</sub>&gt;</i> be a parameterized type. It must be the case that, after <i>P</i> is subjected to capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> resulting in the type <i>G&lt;X1, ..., Xn&gt;</i>, for each actual type argument <i>X<sub>i</sub></i>,  1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i> , <I>X<sub>i</sub> </i>&lt;: <i>B<sub>i</sub></i>[<i>A<sub>1</sub></i> := <i>X<sub>1</sub>, ..., A<sub>n</sub></i> := <i>X<sub>n</sub></i>] <a href="typesValues.html#120403">(&#167;4.10)</a>, or a compile time error occurs.<p>
<a name="123124"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="107226"></a>
 Example: Parameterized types.<p>
<blockquote><pre>Vector&lt;String&gt; 
Seq&lt;Seq&lt;A&gt;&gt; 
Seq&lt;String&gt;.Zipper&lt;Integer&gt;
Collection&lt;Integer&gt; 
Pair&lt;String,String&gt;

// Vector&lt;int&gt; -- illegal, primitive types cannot be arguments
// Pair&lt;String&gt; -- illegal, not enough arguments
// Pair&lt;String,String,String&gt; -- illegal, too many arguments
<a name="107356"></a>
</pre></blockquote><a name="112348"></a>
<hr>
<p>
<a name="123125"></a>
Two parameterized types are provably distinct if either of the following conditions hold:<p>
<ul><a name="112349"></a>
<li>They are invocations of distinct generic type declarations.
<a name="112350"></a>
<li>Any of their type arguments are provably distinct.
</ul><a name="107353"></a>
<a name="4.5.1"></a>
<h3>4.5.1    Type Arguments and Wildcards</h3>
<a name="113154"></a>
Type arguments may be either reference types or wildcards.<p>
<blockquote><pre>
<i>
TypeArguments:
        &lt; ActualTypeArgumentList &gt;</i>

<em>ActualTypeArgumentList: 
        ActualTypeArgument
        ActualTypeArgumentList , ActualTypeArgument
</em></pre></blockquote><a name="110926"></a>
<p>
<a name="109050"></a>
<p>
<blockquote><pre>
<i>
ActualTypeArgument:
        ReferenceType
        Wildcard</i>
</pre></blockquote><a name="109051"></a>
<blockquote><pre>
<i>
Wildcard:
? WildcardBounds<sub>Opt</sub>



WildcardBounds:
        extends ReferenceType
        super ReferenceType
        </i>
</pre></blockquote><a name="108719"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="108720"></a>
 Examples<p>
<blockquote><pre>void printCollection(Collection&lt;?&gt; c) {  // a wildcard collection
  for (Object o : c) {
    System.out.println(o);
  }
}
</pre></blockquote>
<a name="118816"></a>
<p>
 Note that using Collection&lt;Object&gt; as the type of the incoming parameter, c, would not be nearly as useful; the method could only be used with an actual parameter that had type Collection&lt;Object&gt;, which would be quite rare. In contrast, the use of an unbounded wildcard allows any kind of collection to be used as a parameter.</p>
<a name="108730"></a>
 <p>
 <hr>
<a name="123127"></a>
Wildcards are useful in situations where only partial knowledge about the
type parameter is required. 
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="108739"></a>
 Example - Wildcard parameterized types as component types of array types.<p>
<a name="108740"></a>
<blockquote><pre>public Method getMethod(Class&lt;?&gt;[] parameterTypes) { ... }
</pre></blockquote><a name="108745"></a>
<hr>
Wildcards may be given explicit bounds,  just like regular type variable declarations. An upper bound is signified by the syntax:<p>
<blockquote><pre>? extends B
</pre></blockquote><a name="108752"></a>
, where <i>B</i> is the bound. <p>
<a name="123126"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="108756"></a>
 Example: Bounded wildcards.<p>
<a name="108757"></a>
<blockquote><pre>boolean addAll(Collection&lt;? extends E&gt; c)
</pre></blockquote>
<a name="108761"></a>
<p>
Here, the method is declared within the interface Collection&lt;E&gt;, and is designed to add all the elements of its incoming argument to the collection upon which it is invoked. A natural tendency would be to use Collection&lt;E&gt; as the type of c, but this is unnecessarily restrictive. An alternative would be to declare the method itself to be generic:<p>
<blockquote><pre>
&lt;T&gt; boolean addAll(Collection&lt;T&gt; c)
</pre></blockquote>
<a name="118882"></a>
 <p>
 This version is sufficiently flexible, but note that the type parameter is used only once in the signature. This reflects the fact that the type parameter is not being used to express any kind of interdependency between the type(s) of the argument(s), the return type and/or throws type. In the absence of such interdependency, generic methods are considered bad style, and wildcards are preferred.
<a name="118876"></a>
<hr>
<p>
Unlike ordinary type variables declared in a method signature, no type inference is required when using a wildcard. Consequently, it is permissible to declare lower bounds on a wildcard, using the syntax:
<blockquote><pre>? super B
</pre></blockquote><a name="108770"></a>
, where <i>B</i> is a lower bound.<p>
<a name="108987"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<p>
Example: Lower bounds on wildcards.
<blockquote><pre>Reference(T referent, ReferenceQueue&lt;? super T&gt; queue);
</pre></blockquote>
<a name="108990"></a>
 Here, the referent can be inserted into any queue whose element type is a super type of the type T of the referent.
<a name="108996"></a>
<hr>
<p>
Two type arguments are provably distinct if neither of the arguments is a type variable or wildcard, and the two arguments are not the same type.
<a name="113418"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="113423"></a>
 The relationship of wildcards to established type theory is an interesting one, which we briefly allude to here. <p>
<a name="113424"></a>
Wildcards are a restricted form of existential types. Given a generic type declaration <i>G&lt;T extends B&gt;</i>, <i>G&lt;?&gt;</i> is roughly analogous to <i>Some X &lt;: B. G&lt;X&gt;</i>.<p>
<a name="113435"></a>
Readers interested in a more comprehensive discussion should refer to <em>On Variance-Based Subtyping for Parametric Types</em> by Atsushi Igarashi and Mirko Viroli, in the proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002). <p>
<a name="113574"></a>
Wildcards differ in certain details from the constructs described in the aforementioned paper, in particular in the use of capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> ratther than the close operation described by Igarashi and Viroli. For a formal account of wildcards, see <em>Wild FJ</em> by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005).<p>
<a name="113458"></a>
 Historically, wildcards are a direct descendant of the work by Atsushi Igarashi and Mirko Viroli. This work itself builds upon earlier work by Kresten Thorup and Mads Torgersen ("Unifying Genericity", ECOOP 99), as well as a long tradition of work on declaration based variance that goes back to Pierre America's work on POOL (OOPSLA 89)<p>
<hr>
<a name="113460"></a>
 <p>
<a name="113455"></a>
<a name="4.5.1.1"></a>
<h4>4.5.1.1    Type Argument Containment and Equivalence</h4>
<a name="108951"></a>
A type argument <i>TA<sub>1</sub></i> is said to contain another type argument <i>TA<sub>2</sub></i>, written <i>TA<sub>2</sub></i> &lt;= <i>TA<sub>1</sub></i>, if the set of types denoted by <i>TA<sub>2</sub></i> is provably a subset of the set of types denoted by <i>TA<sub>1</sub></i> under the following rules (where &lt;: denotes subtyping <a href="typesValues.html#120403">(&#167;4.10)</a>):<p>
<a name="108955"></a>
<ul><a name="108956"></a>
<li>? extends T &lt;= ? extends S if <i>T &lt;: S</i>
<a name="108959"></a>
<li>? super T &lt;= ? super S if <i>S &lt;: T</i>
<a name="112561"></a>
<li>T &lt;= T 
<a name="108960"></a>
<li>T &lt;= ? extends T
<a name="108961"></a>
<li>T &lt;= ? super T
</ul><a name="112367"></a>
<a name="4.5.2"></a>
<h3>4.5.2    Members and Constructors of Parameterized Types</h3>
<a name="112370"></a>
Let <i>C</i> be a class or interface declaration with formal type parameters <i>A<sub>1</sub>,...,A<sub>n</sub></i>, and let <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> be an invocation of <i>C</i>, where, for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, <i>T<sub>i</sub></i> are types (rather than wildcards). Then:<p>
<a name="118916"></a>
<ul><a name="112374"></a>
<li>Let <i>m</i> be a member or constructor declaration in <i>C</i>, whose type as declared is <i>T</i>. Then the type of <i>m</i> (<a href="classes.html#21831">&#167;8.2</a>, <a href="classes.html#306589">&#167;8.8.6</a>) in the type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i>, is <i>T</i>[<i>A<sub>1</sub></i> := <i>T<sub>1</sub>, ..., A<sub>n</sub></i> := <i>T<sub>n</sub></i>].
<a name="112375"></a>
<li>Let <i>m</i> be a member or constructor declaration in <i>D</i>, where <i>D</i> is a class extended by <i>C</i> or an interface implemented by <i>C</i>. Let <i>D&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> be the supertype of <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> that corresponds to <i>D</i>. Then the type of <i>m</i> in <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> is the type of <i>m</i> in <i>D&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i>.
</ul><a name="112377"></a>
If any of the type arguments to a parameterized type are wildcards, the type of its members and constructors is undefined. <p>
<a name="112378"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="112379"></a>
 <p>This is of no consequence, as it is impossible to access a member of a parameterized type without performing capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>, and it is impossible to use a wildcard type after the keyword new in a class instance creation expression<p>
<hr>
<a name="112384"></a>
<a name="108979"></a>
<a name="4.6"></a>
<h2>4.6    Type Erasure</h2>
<a name="108601"></a>
<em>Type erasure</em> is a mapping from types (possibly including parameterized types and type variables) to types (that are never parameterized types or type variables). We write |<i>T</i>| for the erasure of type <i>T</i>. The erasure mapping is defined as follows.<p>
<a name="108604"></a>
<ul><a name="108640"></a>
<li>The erasure of a parameterized type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>G&lt;T<sub>1</sub>, ... ,T<sub>n</sub>&gt;</i> is |<i>G</i>|. 
<a name="108658"></a>
<li>The erasure of a nested type <i>T.C</i> is |<i>T</i>|<i>.C.</i> 
<a name="108628"></a>
<li>The erasure of an array type<i> T[]</i> is |<i>T</i>|<i>[].</i> 
<a name="108631"></a>
<li>The erasure of a type variable <a href="typesValues.html#108850">(&#167;4.4)</a> is the erasure of its leftmost bound.
<a name="112593"></a>
<li>The erasure of every other type is the type itself.
</ul><a name="112594"></a>
The erasure of a method signature <i>s</i> is a signature consisting of the same name as <i>s,</i> and the erasures of all the formal parameter types given in<i> s.</i> <p>
<a name="112581"></a>
<a name="4.7"></a>
<h2>4.7    Reifiable Types</h2>
<a name="112582"></a>
Because some type information is erased during compilation, not all types are available at run time. Types that are completely available at run time are known as <i>reifiable types</i>. A type is reifiable if and only if one of the following holds:<p>
<ul><a name="110259"></a>
<li>It refers to a non-generic type declaration.
<a name="110260"></a>
<li>It is a parameterized type in which all type arguments are unbounded wildcards <a href="typesValues.html#107353">(&#167;4.5.1)</a>.
<a name="110261"></a>
<li>It is a raw type <a href="typesValues.html#110257">(&#167;4.8)</a>.
<a name="116457"></a>
<li>It is a primitive type <a href="typesValues.html#85587">(&#167;4.2)</a>.
<a name="110262"></a>
<li>It is an array type <a href="arrays.html#25518">(&#167;10.1)</a> whose component type is reifiable.
</ul>
<a name="113528"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="113529"></a>
<p>
 The decision not to make all generic types reifiable is one of the most crucial, and controversial design decisions involving the language's type system.<p>
<a name="113530"></a>
Ultimately, the most important motivation for this decision is compatibility with existing code. <p>
<a name="113535"></a>
Naively, the addition of new constructs such as genericity has no implications for pre-existing code. The programming language per se, is compatible with earlier versions as long as every program written in the previous versions retains its meaning in the new version. However, this notion, which may be termed language compatibility, is of purely theoretical interest. Real programs (even trivial ones, such as "Hello World") are composed of several compilation units, some of which are provided by the Java platform (such as elements of <code>java.lang</code> or <code>java.util</code>).<p>
<a name="113536"></a>
In practice then, the minimum requirement is platform compatibillity - that any program written for the prior version of the platform continues to function unchanged in the new platform.<p>
<a name="113544"></a>
One way to provide platform compatibillity is to leave existing platform functionality unchanged, only adding new functionality. For example, rather than modify the existing Collections hierarchy in <code>java.util</code>, one might introduce a new library utilizing genericity. <p>
<a name="113552"></a>
The disadvantages of such a scheme is that it is extremely difficult for pre-existing clients of the Collection library to migrate to the new library. Collections are used to exchange data between independently developed modules; if a vendor decides to switch to the new, generic, library, that vendor must also distribute two versions of their code, to be compatible with their clients. Libraries that are dependent on other vendors code cannot be modified to use genericity until the supplier's library is updated. If two modules are mutually dependent, the changes must be made simultaneously. <p>
<a name="113553"></a>
Clearly, platform compatibility, as outlined above, does not provide a realistic path for adoption of a pervasive new feature such as genericity. Therefore, the design of the generic type system seeks to support migration compatibility. Migration compatibiliy allows the evolution of existing code to take advantage of generics without imposing dependencies between independently developed software modules.<p>
<a name="113562"></a>
The price of migration compatibility is that a full and sound reification of the generic type system is not possible, at least while the migration is taking place.<p>
<hr>
<a name="113531"></a>
<a name="110257"></a>
<a name="4.8"></a>
<h2>4.8    Raw Types</h2>
<a name="108436"></a>
To facilitate interfacing with non-generic legacy code, it is also possible to use as a type the erasure <a href="typesValues.html#108979">(&#167;4.6)</a> of a parameterized type <a href="typesValues.html#112898">(&#167;4.5)</a>.  Such a type is called a <i>raw type</i>. <p>
<a name="121922"></a>
<p>
<a name="121923"></a>
<p>
<a name="121924"></a>
<p>
<a name="121925"></a>
More precisely, a raw type is define to be either:<p>
<ul><a name="112798"></a>
<li>The name of a generic type declaration used without any accompanying actual type parameters.
<a name="112802"></a>
<li>Any non-static type member of a raw type <i>R</i> that is not inherited from a superclass or superinterface of <i>R.</i>
</ul>
<a name="112796"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="120231"></a>
 The latter point may not be immediately self evident. Presenting for your consideration, then, the following example:<p>
<blockquote><pre>class Outer&lt;T&gt;{
        T t;
        class Inner {
                T setOuterT(T t1) {t = t1;return t;}
        }
}
</pre></blockquote>
<a name="120239"></a>
 The type of the member(s) of <code>Inner</code> depends on the type parameter of <code>Outer</code>. If <code>Outer</code> is raw, <code>Inner</code> must be treated as raw as well, as their is no valid binding for <code>T</code>.
 <p>
This rule applies only to type members that are not inherited. Inherited type members that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section.<p>
<hr>
<a name="120233"></a>
 <p>
<a name="121788"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="121789"></a>
 Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type:<p>
<blockquote><pre>class Outer&lt;T&gt;{
        class Inner&lt;S&gt; {
                S s;
        }
}
</pre></blockquote><a name="121812"></a>
it is not possible to access <code>Inner</code> as partially raw type (a "rare" type)
<blockquote><pre>Outer.Inner&lt;Double&gt; x = null; // illegal
Double d = x.s;
</pre></blockquote><a name="121815"></a>
because <code>Outer</code> itself is raw, so are all its inner classes, including <code>Inner</code>, and so it is not possible to pass any type parameters to it.<p>
<hr>
<a name="121798"></a>
 <p>
<a name="120230"></a>
The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. <b>It is possible that future versions of the Java programming language will disallow the use of raw types.</b> <p>
<a name="121888"></a>
It is a compile-time error to attempt to use a type member of a parameterized type as a raw type.<p>
<a name="121893"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="121894"></a>
 This means that the ban on "rare" types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type:<p>
<blockquote><pre>Outer&lt;Integer&gt;.Inner x = null; // illegal
</pre></blockquote><a name="121896"></a>
This is the opposite of the case we discussed above. There is no practical justification for this half baked type. In legacy code, no type parameters are used. In non-legacy code, we should use the generic types correctly and pass all the required actual type parameters.<p>
<hr>
<a name="121897"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="108595"></a>
 Variables of a raw type can be assigned from values of any of the type's parametric instances. <p>
<a name="109174"></a>
For instance, it is possible to assign a <code>Vector&lt;String&gt;</code> to a <code>Vector</code>, based on the subtyping rules <a href="typesValues.html#108101">(&#167;4.10.2)</a>.  <p>
<a name="109134"></a>
 The reverse assignment from <code>Vector</code> to <code>Vector&lt;String&gt;</code> is unsafe (since the raw vector might have had a different element type), but is still permitted using unchecked conversion <a href="conversions.html#190772">(&#167;5.1.9)</a> in order to enable interfacing with legacy code. In this case, a compiler will issue an unchecked warning.<p>
<hr>
<a name="108448"></a>
The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of its parameterized invocations.<p>
<a name="112736"></a>
The type of a constructor <a href="classes.html#41652">(&#167;8.8)</a>, instance method (<a href="classes.html#41652">&#167;8.8</a>, <a href="interfaces.html#78651">&#167;9.4</a>), or non-static field <a href="classes.html#40898">(&#167;8.3)</a> <i>M</i> of a raw type <i>C</i> that is not inherited from its superclasses or superinterfaces is the erasure of its type in the generic declaration corresponding to <i>C.</i> The type of a static member of a raw type <i>C</i> is the same as its type in the generic declaration corresponding to <i>C.</i><p>
<a name="112792"></a>
It is a compile-time error to pass actual type parameters to a non-static type member of a raw type that is not inherited from its superclasses or superinterfaces.<p>
<a name="112737"></a>
To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in warning messages.  The rules for generating warnings when accessing members or constructors of raw types are as follows:<p>
<ul><a name="112738"></a>
<li>An invocation of a method or constructor of a raw type generates an unchecked warning if erasure changes any of the types of any of the arguments to the method or constructor.
<a name="112739"></a>
<li>An assignment to a field of a raw type generates an unchecked warning <a href="conversions.html#190772">(&#167;5.1.9)</a> if erasure changes the field's type.
</ul><a name="112740"></a>
No unchecked warning is required for a method call when the argument types do not change (even if the result type and/or throws clause  changes), for reading from a field, or for a class instance creation of a raw type.<p>
<a name="112741"></a>
The supertype of a class may be a raw type. Member accesses for the class are treated as normal, and member accesses for the supertype are treated as for raw types.  In the constructor of the class, calls to super are treated as method calls on a raw type.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="112743"></a>
 Example: Raw types.<p>
<blockquote><pre>class Cell&lt;E&gt;
  E value;
  Cell (E v) { value=v; }
  A get() { return value; }
  void set(E v) { value=v; }
}
Cell x = new Cell&lt;String&gt;("abc");
x.value;          // OK, has type Object
x.get();          // OK, has type Object
x.set("def");     // unchecked warning
</pre></blockquote><a name="121926"></a>
<hr>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="112633"></a>
 For example, <p>
<blockquote><pre>import java.util.*;

class NonGeneric {

    Collection&lt;Number&gt; myNumbers(){return null;}
}
abstract class RawMembers&lt;T&gt; extends NonGeneric implements Collection&lt;String&gt; {
    static Collection&lt;NonGeneric&gt; cng = 
                                                                                new ArrayList&lt;NonGeneric&gt;();

    public static void main(String[] args) {
                RawMembers rw = null;
                Collection&lt;Number&gt; cn = rw.myNumbers(); // ok
                Iterator&lt;String&gt; is = rw.iterator(); // unchecked warning
                Collection&lt;NonGeneric&gt; cnn = rw.cng; // ok - static member
    }
}
</pre></blockquote><a name="112657"></a>
<p>
<code>RawMembers&lt;T&gt;</code> inherits the method<p>
<blockquote><pre>Iterator&lt;String&gt; iterator()
</pre></blockquote><a name="112652"></a>
from the <code>Collection&lt;String&gt;</code> superinterface. However, the type <code>RawMembers</code> inherits <code>iterator()</code> from the erasure of its superinterface, which means that the return type of the member <code>iterator()</code> is the erasure of <code>Iterator&lt;&lt;String&gt;, Iterator</code>. As a result, the attempt to assign to <code>rw.iterator()</code> requires an unchecked conversion <a href="conversions.html#190772">(&#167;5.1.9)</a> from <code>Iterator</code> to <code>Iterator&lt;String&gt;</code>, causing an unchecked warning to be issued.<p>
<a name="112638"></a>
In contrast, the static member <code>cng</code> retains its full parameterized type even when accessed through a object of raw type (note that access to a static member through an instance is considered bad style and is to be discouraged). The member <code>myNumbers</code> is inherited from the <code>NonGeneric</code> (whose erasure is also <code>NonGeneric</code>) and so retains its full parameterized type.<p>
<hr>
<a name="112634"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="113511"></a>
<p>
 Raw types are closly related to wildcards. Both are based on existential types. Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with legacy code. <p>
<a name="113514"></a>
Historically, raw types preceded wildcards; they were first introduced in GJ, and described in the paper <em>Making the future safe for the past: Adding Genericity to the Java Programming Language</em> by Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler, in Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications, (OOPSLA 98) October 1998. <p>
<hr>
<a name="113512"></a>
<p>
<a name="113513"></a>
 <p>
<a name="108433"></a>
<a name="4.9"></a>
<h2>4.9    Intersection Types</h2>
<a name="123179"></a>
An intersection type takes the form <i>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></i>, <i>n</i>&gt;0, where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, are type expressions. Intersection types arise in the processes of capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> and type inference <a href="expressions.html#341287">(&#167;15.12.2.7)</a>. It is not possible to write an intersection type directly as part of a program; no syntax supports this. The values of an intersection type are those objects that are values of all of the types <i>T<sub>i</sub></i>, for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>. <p>
<a name="121564"></a>
The members of an intersection type <i>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></i> are determined as follows:<p>
<ul><a name="120630"></a>
<li>For each <i>T<sub>i</sub></i>,  1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, let <i>C<sub>i</sub></i> be the most specific class or array type such that <i>T<sub>i</sub></i> &lt;: <i>C<sub>i</sub></i> Then there must be some <i>T<sub>k</sub></i> &lt;: <i>C<sub>k</sub></i> such that <i>C<sub>k</sub></i> &lt;: <i>C<sub>i</sub></i> for any <i>i</i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, or a compile-time error occurs. 
<a name="121572"></a>
<li>For  1<img src="chars/lt_equal.gif"><i>j</i><img src="chars/lt_equal.gif"><i>n</i>, if <i>T<sub>j</sub></i> is a type variable, then let <i>IT<sub>j</sub></i> be an interface whose members are the same as the public members of <i>T<sub>j</sub></i>; otherwise, if <i>T<sub>j</sub></i> is an interface, then let <i>IT<sub>j</sub></i> be <i>T<sub>j</sub></i>.
<a name="120638"></a>
<li>Then the intersection type has the same members as a class type <a href="classes.html#328796">(&#167;8)</a> with an empty body, direct superclass <i>C<sub>k</sub></i> and direct superinterfaces <i>IT<sub>1</sub> , ..., IT<sub>n</sub></i>, declared in the same package in which the intersection type appears.
</ul>
<a name="121664"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="121665"></a>
 It is worth dwelling upon the distinction between intersection types and the bounds of type variables. Every type variable bound induces an intersection type. This intersection type is often trivial (i.e., consists of a single type).<p>
</ul><a name="121678"></a>
The form of a bound is restricted (only the first element may be a class or type variable, and only one type variable may appear in the bound) to preclude certain awkward situations coming into existence. However, capture conversion can lead to the creation of type variables whose bounds are more general (e.g., array types).<p>
<hr>
<a name="121666"></a>
<a name="120403"></a>
<a name="4.10"></a>
<h2>4.10    Subtyping</h2>
<a name="108096"></a>
The subtype and supertype relations are binary relations on types. The <em>supertypes</em> of a type are obtained by reflexive and transitive closure over the direct supertype relation, written <i>S &gt;<sub>1</sub> T</i>, which is defined by rules given later in this section. We write <i>S :&gt; T</i> to indicate that the supertype relation holds between <i>S</i> and <i>T</i>. <i>S</i> is a proper supertype of <i>T</i>, written <i>T &lt; S</i>, if <i>S :&gt; T</i> and <i>S <img src="chars/notequal.gif"> T</i>. <p>
<a name="108136"></a>
The <i>subtypes</i> of a type <i>T</i> are all types <i>U</i> such that <i>T</i> is a supertype of <i>U</i>, and the null type. We write <i>T &lt;: S</i> to indicate that that the subtype relation holds between types <i>T</i> and <i>S</i>. <i>T</i> is a <i>proper subtype</i> of <i>S</i>, written <i>T &lt; S</i>, if <i>T &lt;:S</i> and <i>S <img src="chars/notequal.gif"> T</i>. <i>T</i> is a <i>direct subtype</i> of <i>S,</i> written <i>T &lt;<sub>1</sub> S</i>, if <i>S &gt;<sub>1</sub> T</i>.<p>
<a name="108138"></a>
Subtyping does not extend through generic types: <i>T</i> &lt;: <i>U</i> does not imply that <i>C&lt;T&gt;</i> &lt;: <i>C&lt;U&gt;</i>.<p>
<a name="108094"></a>
<p>
<a name="108083"></a>
<a name="4.10.1"></a>
<h3>4.10.1    Subtyping among Primitive Types</h3>
<a name="108084"></a>
The following rules define the direct supertype relation among the primitive types:<p>
<a name="108085"></a>
<blockquote>
double &gt;<sub>1</sub> float <br>
float &gt;<sub>1</sub> long<br>
long &gt;<sub>1</sub> int<br>
int &gt;<sub>1</sub> char <br>
int &gt;<sub>1</sub> short <br>
short &gt;<sub>1</sub> byte
</blockquote>
<p>
<a name="108101"></a>
<a name="4.10.2"></a>
<h3>4.10.2    Subtyping among Class and Interface Types</h3>
<a name="123026"></a>
Let <i>C</i> be a type declaration (<a href="typesValues.html#24887">&#167;4.12.6</a>, <a href="classes.html#15372">&#167;8.1</a>, <a href="interfaces.html#35470">&#167;9.1</a>) with zero or more type parameters <a href="typesValues.html#108850">(&#167;4.4)</a> <i>F<sub>1</sub>, ..., F<sub>n</sub></i> which have corresponding bounds <i>B<sub>1</sub>, ..., B<sub>n</sub></i>. That type declaration defines a set of parameterized types <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C<sub>2</sub> &lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i>, where each argument type <i>T<sub>i</sub></i> ranges over all types that are subtypes of all types listed in the corresponding bound. That is, for each bound type <i>S<sub>i</sub></i> in <i>B<sub>i</sub></i>, <i>T<sub>i</sub></i> is a subtype of <i>S<sub>i</sub></i>[ <i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub>]</i>.<p>
<a name="123035"></a>
Given a type declaration for <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, the <i>direct supertypes</i> of the parameterized type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> are all of the following:<p>
<ul><a name="108015"></a>
<li>the direct superclasses of <i>C</i>.
<a name="107409"></a>
<li>the direct superinterfaces of <i>C</i>.
<a name="112543"></a>
<li>The type <code>Object</code>, if <i>C</i> is an interface type with no direct superinterfaces.
<a name="110252"></a>
<li>The raw type <i>C</i>.
</ul><a name="107909"></a>
The direct supertypes of the type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> , where <i>T<sub>i</sub></i>,1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, are <i>D&lt;U<sub>1</sub> theta, ..., U<sub>k</sub> theta&gt;</i>, where<p>
<ul><a name="107418"></a>
<li><i>D&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is a direct supertype of <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub></i>].
<a name="109010"></a>
<li><i>C&lt;S<sub>1</sub>,...,S<sub>n</sub>&gt;</i> where <i>S<sub>i</sub></i> contains <a href="typesValues.html#113455">(&#167;4.5.1.1)</a> <i>T<sub>i</sub></i> for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>.
</ul><a name="110278"></a>
The direct supertypes of the type <i>C&lt;R<sub>1</sub>,...,R<sub>n</sub>&gt;</i> , where at least one of the <i>R<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a wildcard type argument, are the direct supertypes of <i>C&lt;X<sub>1</sub>,...,X<sub>n</sub>&gt;</i>, where<p>
<a name="112408"></a>
<i>C&lt;X<sub>1</sub>,...,X<sub>n</sub>&gt;</i> is the result of applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to <i>C&lt;R<sub>1</sub>,...,R<sub>n</sub>&gt;</i>.<p>
<a name="112398"></a>
<p>
<a name="112399"></a>
The direct supertypes of an intersection type <a href="typesValues.html#108433">(&#167;4.9)</a> <i>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></i>, are <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>.<p>
<a name="113711"></a>
The direct supertypes of a type variable <a href="typesValues.html#108850">(&#167;4.4)</a> are the types listed in its bound. <p>
<a name="118984"></a>
The direct supertypes of the null type are all reference types other than the null type itself.<p>
<a name="113415"></a>
In addition to the above rules, a type variable is a direct supertype of its lower bound.<p>
<a name="108354"></a>
<a name="4.10.3"></a>
<h3>4.10.3    Subtyping among Array Types</h3>
<a name="108355"></a>
The following rules define the direct subtype relation among array types:<p>
<ul><a name="108356"></a>
<li>If <i>S</i> and <i>T</i> are both reference types, then <i>S[] &gt;<sub>1</sub> T[] </i>iff<i> S &gt;<sub>1</sub> T</i>.
<a name="119005"></a>
<li><code>Object &gt;</code><sub>1</sub><code> Object[]</code>
<a name="110207"></a>
<li><code>Cloneable &gt;</code><sub>1</sub><code> Object[]</code>
<a name="110210"></a>
<li><code>java.io.Serializable &gt;</code><sub>1</sub><code> Object[]</code>
<a name="110211"></a>
<li>If <i>p</i> is a primitive type, then:
<ul>
<a name="114833"></a>
<li><code>Object &gt;</code><sub>1</sub><code> </code>p[]
<a name="114835"></a>
<li><code>Cloneable &gt;</code><sub>1</sub><code> </code>p[] 
<a name="114842"></a>
<li><code>java.io.Serializable &gt;</code><sub>1</sub><code> </code>p[]
</ul>
</ul><a name="107178"></a>
<a name="4.11"></a>
<h2>4.11    Where Types Are Used</h2>
<a name="52309"></a>
Types are used when they appear in declarations or in certain expressions.<p>
<a name="85893"></a>
<p>The following code fragment contains one or more instances of most kinds of usage of a type:</p>
<blockquote><pre>import java.util.Random;
class MiscMath&lt;T extends Number&gt;{
        int divisor;
        MiscMath(int divisor) {
                this.divisor = divisor;
        }
        float ratio(long l) {
                try {
                        l /= divisor;
                } catch (Exception e) {
                        if (e instanceof ArithmeticException)
                                l = Long.MAX_VALUE;
                        else
                                l = 0;
                }
                return (float)l;
        }
        double gausser() {
                Random r = new Random();
                double[] val = new double[2];
                val[0] = r.nextGaussian();
                val[1] = r.nextGaussian();
                return (val[0] + val[1]) / 2;
</pre></blockquote><pre><a name="19670"></a>    }
<a name="119019"></a>   Collection&lt;Number&gt; fromArray(Number[] na) {
<a name="119027"></a>           Collection&lt;Number&gt; cn = new ArrayList&lt;Number&gt;();
<a name="119022"></a>           for (Number n : na) {
<a name="119023"></a>                   cn.add(n)
<a name="119024"></a>           }
<a name="119028"></a>           return cn;
<a name="119021"></a>   }
<a name="119054"></a>   void &lt;S&gt; loop(S s){ this.&lt;S&gt;loop(s);}
<a name="119020"></a>           
</pre><a name="119018"></a>
<p>
<blockquote><pre>}
</pre></blockquote><a name="53860"></a>
In this example, types are used in declarations of the following:<p>
<ul><a name="53864"></a>
<li>Imported types <a href="packages.html#70209">(&#167;7.5)</a>; here the type <code>Random</code>, imported from the type<code> java.util.Random</code> of the package <code>java.util</code>, is declared
<a name="49983"></a>
<li>Fields, which are the class variables and instance variables of classes <a href="classes.html#40898">(&#167;8.3)</a>, and constants of interfaces <a href="interfaces.html#78642">(&#167;9.3)</a>; here the field <code>divisor</code> in the class <code>MiscMath</code> &#32;is declared to be of type <code>int</code>
<a name="49990"></a>
<li>Method parameters <a href="classes.html#38698">(&#167;8.4.1)</a>; here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code>
<a name="52378"></a>
<li>Method results <a href="classes.html#40420">(&#167;8.4)</a>; here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code>
<a name="38145"></a>
<li>Constructor parameters <a href="classes.html#29488">(&#167;8.8.1)</a>; here the parameter of the constructor for<code> MiscMath</code> is declared to be of type <code>int</code>
<a name="12250"></a>
<li>Local variables (<a href="statements.html#5920">&#167;14.4</a>, <a href="statements.html#24588">&#167;14.14</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)
<a name="52411"></a>
<li>Exception handler parameters <a href="statements.html#79311">(&#167;14.20)</a>; here the exception handler parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code>
<a name="119048"></a>
<li>Type variables <a href="typesValues.html#108850">(&#167;4.4)</a>; here the type variable <code>T</code> has <code>Number</code> as its declared bound.
</ul><a name="25979"></a>
and in expressions of the following kinds:<p>
<ul><a name="52468"></a>
<li>Class instance creations <a href="expressions.html#41147">(&#167;15.9)</a>; here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random </code>
<a name="119067"></a>
<li>Generic class <a href="classes.html#299360">(&#167;8.1.2)</a> instance creations <a href="expressions.html#41147">(&#167;15.9)</a>; here <code>Number</code> is used as a type argument in the expression <code>new ArrayList&lt;Number&gt;()</code>
<a name="96936"></a>
<li>Array creations <a href="expressions.html#46168">(&#167;15.10)</a>; here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2
<a name="119008"></a>
<li>Generic method <a href="classes.html#323928">(&#167;8.4.4)</a> or constructor <a href="classes.html#244611">(&#167;8.8.4)</a> invocations <a href="expressions.html#20448">(&#167;15.12)</a>; here the method <code>loop</code> calls itself with an explicit type argument <code>S</code>
<a name="52427"></a>
<li>Casts <a href="expressions.html#238146">(&#167;15.16)</a>; here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast
<a name="25987"></a>
<li>The <code>instanceof</code> operator <a href="expressions.html#80289">(&#167;15.20.2)</a>; here the <code>instanceof</code> operator tests whether <code>e</code> is assignment compatible with the type <code>ArithmeticException</code>
</ul><a name="119039"></a>
<code>. </code>Types are also used as arguments to parameterized types; here the type <code>Number</code> is used as an argument in the parameterized type <code>Collection&lt;Number&gt;</code>.<p>
<a name="18470"></a>
<a name="4.12"></a>
<h2>4.12    Variables</h2>
<a name="10872"></a>
A variable is a storage location and has an associated type, sometimes called its <em>compile-time type</em>, that is either a primitive type <a href="typesValues.html#85587">(&#167;4.2)</a> or a reference type <a href="typesValues.html#9317">(&#167;4.3)</a>.  A variable's value is changed by an assignment <a href="expressions.html#5281">(&#167;15.26)</a> or by a prefix or postfix <code>++</code> (increment) or <code>--</code> (decrement) operator (<a href="expressions.html#292383">&#167;15.14.2</a>, <a href="expressions.html#4987">&#167;15.14.3</a>, <a href="expressions.html#39547">&#167;15.15.1</a>, <a href="expressions.html#239136">&#167;15.15.2</a>).<p>
<a name="24555"></a>
Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language, as long as a program does not give rise to unchecked warnings <a href="typesValues.html#111088">(&#167;4.12.2.1)</a>. Default values are compatible <a href="typesValues.html#96595">(&#167;4.12.5)</a> and all assignments to a variable are checked for assignment compatibility <a href="conversions.html#184206">(&#167;5.2)</a>, usually at compile time, but, in a single case involving arrays, a run-time check is made <a href="arrays.html#11430">(&#167;10.10)</a>.<p>
<a name="28344"></a>
<a name="4.12.1"></a>
<h3>4.12.1    Variables of Primitive Type</h3>
<a name="17088"></a>
A variable of a primitive type always holds a value of that exact primitive type.<p>
<a name="28345"></a>
<a name="4.12.2"></a>
<h3>4.12.2    Variables of Reference Type</h3>
<a name="10877"></a>
A variable of a class type <i>T</i> can hold a null reference or a reference to an instance of class <i>T</i> or of any class that is a subclass of <i>T</i>. A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface. <p>
<a name="111209"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="111210"></a>
 Note that a variable is not guaranteed to always refer to a subtype of its declared type, but only to subclasses or subinterfaces of the declared type. This is due to the possibility of heap pollution discussed below.<p>
<a name="111211"></a>
<hr>
 <p>
<a name="111208"></a>
If <i>T</i> is a primitive type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>T</i>"; if <i>T</i> is a reference type, then a variable of type "array of <i>T</i>" can hold a null reference or a reference to any array of type "array of <i>S</i>" such that type <i>S</i> is a subclass or subinterface of type <i>T</i>. In addition, a variable of type <code>Object[]</code> can hold an array of any reference type. A variable of type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array. <p>
<a name="111088"></a>
<a name="4.12.2.1"></a>
<h4>4.12.2.1    Heap Pollution </h4>
<a name="111097"></a>
It is possible that a variable of a parameterized type refers to an object that is not of that parameterized type. This situation is known as heap pollution. This situation can only occur if the program performed some operation that would give rise to an unchecked warning at compile-time.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="111101"></a>
 For example, the code:<p>
<blockquote><pre>List l = new ArrayList&lt;Number&gt;();
List&lt;String&gt; ls = l; // unchecked warning
</pre></blockquote>
<a name="111113"></a>
 gives rise to an unchecked warning, because it is not possible to ascertain, either at compile-time (within the limits of the compile-time type checking rules) or at run-time, whether the variable l does indeed refer to a <code>List&lt;String&gt;</code>. <p>
<a name="111179"></a>
If the code above is executed, heap pollution arises, as the variable ls, declared to be a <code>List&lt;String&gt;</code>, refers to a value that is not in fact a <code>List&lt;String&gt;</code>. <p>
<a name="111182"></a>
The problem cannot be identified at run-time because type variables are not reified, and thus instances do not carry any information at run-time regarding the actual type parameters used to create them.<p>
<a name="111167"></a>
In a simple example as given above, it may appear that it should be straightforward to identify the situation at compile-time and give a compilation error. However, in the general (and typical) case, the value of the variable l may be the result of an invocation of a separately compiled method, or its value may depend upon arbitrary control flow. <p>
<a name="111141"></a>
The code above is therefore very atypical, and indeed very bad style.<p>
<a name="111150"></a>
Assignment from a value of a raw type to a variable of a parameterized type should only be used when combining legacy code which does not make use of parameterized types with more modern code that does.<p>
<a name="111206"></a>
If no operation that requires an unchecked warning to be issued takes place, heap pollution cannot occur. Note that this does not imply that heap pollution only occurs if an unchecked warning actually occurred. It is possible to run a program where some of the binaries were compiled by a compiler for an older version of the Java programming language, or by a compiler that allows the unchecked warnings to suppressed. This practice is unhealthy at best.<p>
<a name="111207"></a>
Conversely, it is possible that despite executing code that could (and perhaps did) give rise to an unchecked warning, no heap pollution takes place. Indeed, good programming practice requires that the programmer satisfy herself that despite any unchecked warning, the code is correct and heap pollution will not occur.<p>
<hr>
<a name="111151"></a>
 <p>
<a name="111193"></a>
The variable will always refer to an object that is an instance of a class that implements the parameterized type. <p>
<a name="111196"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="111197"></a>
 For instance, the value of <code>l</code> in the example above is always a <code>List</code>.<p>
 <hr>
<a name="119093"></a>
 <p>
<a name="119097"></a>
<a name="4.12.3"></a>
<h3>4.12.3    Kinds of Variables</h3>
<a name="10883"></a>
There are seven kinds of variables:<p>
<ol>
<a name="10884"></a>
<li>A <em>class variable</em> is a field declared using the keyword <code>static</code> within a class declaration <a href="classes.html#37544">(&#167;8.3.1.1)</a>, or with or without the keyword <code>static</code> within an interface declaration <a href="interfaces.html#78642">(&#167;9.3)</a>. A class variable is created when its class or interface is prepared <a href="execution.html#47979">(&#167;12.3.2)</a> and is initialized to a default value <a href="typesValues.html#96595">(&#167;4.12.5)</a>. The class variable effectively ceases to exist when its class or interface is unloaded <a href="execution.html#74294">(&#167;12.7)</a>.
<a name="51516"></a>
<li>An <em>instance variable</em> is a field declared within a class declaration without using the keyword <code>static</code> <a href="classes.html#37544">(&#167;8.3.1.1)</a>. If a class <i>T</i> has a field <i>a</i> that is an instance variable, then a new instance variable <i>a</i> is created and initialized to a default value <a href="typesValues.html#96595">(&#167;4.12.5)</a> as part of each newly created object of class <i>T</i> or of any class that is a subclass of <i>T</i> <a href="classes.html#262560">(&#167;8.1.4)</a>. The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object <a href="execution.html#44748">(&#167;12.6)</a> has been completed.
<a name="10895"></a>
<li><em>Array components</em> are unnamed variables that are created and initialized to default values <a href="typesValues.html#96595">(&#167;4.12.5)</a> whenever a new object that is an array is created <a href="expressions.html#46168">(&#167;15.10)</a>. The array components effectively cease to exist when the array is no longer referenced. See <a href="arrays.html#27803">&#167;10</a> for a description of arrays.
<a name="24632"></a>
<li><em>Method parameters</em> <a href="classes.html#38698">(&#167;8.4.1)</a> name argument values passed to a method. For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked <a href="expressions.html#20448">(&#167;15.12)</a>. The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.
<a name="24657"></a>
<li><em>Constructor parameters</em> <a href="classes.html#29488">(&#167;8.8.1)</a> name argument values passed to a constructor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.html#78435">(&#167;8.8.7)</a> invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
<a name="10903"></a>
<li>An <em>exception-handler parameter</em> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a>. The new variable is initialized with the actual object associated with the exception (<a href="exceptions.html#44153">&#167;11.3</a>, <a href="statements.html#237350">&#167;14.18</a>). The exception-handler parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.
<a name="24801"></a>
<li><em>Local variables</em> are declared by local variable declaration statements <a href="statements.html#5920">(&#167;14.4)</a>. Whenever the flow of control enters a block <a href="statements.html#246838">(&#167;14.2)</a> or <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a>, a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement. A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment <a href="defAssign.html#25979">(&#167;16)</a> prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or <code>for</code> statement is complete.
</ol>
<p><a name="24816"></a>
Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement <a href="statements.html#258896">(&#167;14.11)</a>, where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment <a href="defAssign.html#29542">(&#167;16)</a>, however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression <a href="expressions.html#5281">(&#167;15.26)</a>. 
<a name="24836"></a>
<p>The following example contains several different kinds of variables:
<blockquote><pre>
class Point {
        static int numPoints;                   // numPoints is a class variable
        int x, y;                               // x and y are instance variables
        int[] w = new int[10];                  // w[0] is an array component
        int setX(int x) {                       // x is a method parameter
                int oldx = this.x;              // oldx is a local variable
                this.x = x;
                return oldx;
        }
}
</pre></blockquote><a name="10931"></a>
<a name="4.12.4"></a>
<h3>4.12.4    final Variables</h3>
<a name="96639"></a>
A variable can be declared <code>final</code>. A final variable may only be assigned to once. It is a compile time error if a final variable is assigned to unless it is definitely unassigned <a href="defAssign.html#25979">(&#167;16)</a> immediately prior to the assignment.<p>
<a name="96971"></a>
A blank final is a final variable whose declaration lacks an initializer. <p>
<a name="96975"></a>
Once a <code>final</code> variable has been assigned, it always contains the same value. If a <code>final</code> variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.<p>
<a name="103462"></a>
<p>Declaring a variable <code>final</code> can serve as useful documentation that its value will not change and can help avoid programming errors.</p>
<a name="96976"></a>
<p>In the example:</p>
<blockquote><pre>class Point {
        int x, y;
        int useCount;
        Point(int x, int y) { this.x = x; this.y = y; }
        final static Point origin = new Point(0, 0);
}
</pre></blockquote><a name="96596"></a>
the class <code>Point</code> declares a final class variable <code>origin</code>. The <code>origin</code> variable holds a reference to an object that is an instance of class <code>Point</code> whose coordinates are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always refers to the same <code>Point</code> object, the one created by its initializer. However, an operation on this <code>Point</code> object might change its state-for example, modifying its <code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.<p>
<a name="107782"></a>
We call a variable, of primitive type or type <code>String</code>, that is final and initialized with a compile-time constant expression <a href="expressions.html#5313">(&#167;15.28)</a> a <i>constant variable</i>. Whether a variable is a constant variable or not may have implications with respect to class initialization <a href="execution.html#57946">(&#167;12.4.1)</a>, binary compatibility (<a href="binaryComp.html#44909">&#167;13.1</a>, <a href="binaryComp.html#45139">&#167;13.4.9</a>) and definite assignment (<a href="defAssign.html#25979">&#167;16</a>).<p>
<a name="107779"></a>
<p>
<a name="96595"></a>
<a name="4.12.5"></a>
<h3>4.12.5    Initial Values of Variables</h3>
<a name="10935"></a>
Every variable in a program must have a value before its value is used:<p>
<ul><a name="10946"></a>
<li>Each class variable, instance variable, or array component is initialized with a <em>default value</em> when it is created (<a href="expressions.html#41147">&#167;15.9</a>, <a href="expressions.html#46168">&#167;15.10</a>):
<ul>
<a name="10947"></a>
<li>For type <code>byte</code>, the default value is zero, that is, the value of <code>(byte)0</code>.
<a name="10948"></a>
<li>For type <code>short</code>, the default value is zero, that is, the value of <code>(short)0</code>.
<a name="10949"></a>
<li>For type <code>int</code>, the default value is zero, that is, <code>0</code>.
<a name="10950"></a>
<li>For type <code>long</code>, the default value is zero, that is, <code>0L</code>.
<a name="10951"></a>
<li>For type <code>float</code>, the default value is positive zero, that is, <code>0.0f</code>.
<a name="46977"></a>
<li>For type <code>double</code>, the default value is positive zero, that is, <code>0.0d</code>.
<a name="46978"></a>
<li>For type <code>char</code>, the default value is the null character, that is, <code>'\u0000'</code>.
<a name="46979"></a>
<li>For type <code>boolean</code>, the default value is <code>false</code>.
<a name="10955"></a>
<li>For all reference types <a href="typesValues.html#9317">(&#167;4.3)</a>, the default value is <code>null</code>.
</ul>
<a name="11353"></a>
<li>Each method parameter <a href="classes.html#38698">(&#167;8.4.1)</a> is initialized to the corresponding argument value provided by the invoker of the method <a href="expressions.html#20448">(&#167;15.12)</a>.
<a name="38160"></a>
<li>Each constructor parameter <a href="classes.html#29488">(&#167;8.8.1)</a> is initialized to the corresponding argument value provided by a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a> or explicit constructor invocation <a href="classes.html#78435">(&#167;8.8.7)</a>.
<a name="11354"></a>
<li>An exception-handler parameter <a href="statements.html#79311">(&#167;14.20)</a> is initialized to the thrown object representing the exception (<a href="exceptions.html#44153">&#167;11.3</a>, <a href="statements.html#237350">&#167;14.18</a>). 
<a name="11569"></a>
<li>A local variable (<a href="statements.html#5920">&#167;14.4</a>, <a href="statements.html#24588">&#167;14.14</a>) must be explicitly given a value before it is used, by either initialization <a href="statements.html#5920">(&#167;14.4)</a> or assignment <a href="expressions.html#5281">(&#167;15.26)</a>, in a way that can be verified by the compiler using the rules for definite assignment <a href="defAssign.html#25979">(&#167;16)</a>.
</ul><a name="30962"></a>
The example program:<p>
<blockquote><pre>class Point {
        static int npoints;
        int x, y;
        Point root;
}
class Test {
        public static void main(String[] args) {
                System.out.println("npoints=" + Point.npoints);
                Point p = new Point();
                System.out.println("p.x=" + p.x + ", p.y=" + p.y);
                System.out.println("p.root=" + p.root);
        }
}
</pre></blockquote><a name="12324"></a>
prints:<p>
<blockquote><pre>npoints=0
p.x=0, p.y=0
p.root=null
</pre></blockquote><a name="24882"></a>
illustrating the default initialization of <code>npoints</code>, which occurs when the class <code>Point</code> is prepared <a href="execution.html#47979">(&#167;12.3.2)</a>, and the default initialization of <code>x</code>, <code>y</code>, and <code>root</code>, which occurs when a new <code>Point</code> is instantiated. See <a href="execution.html#44410">&#167;12</a> for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.<p>
<a name="24887"></a>
<a name="4.12.6"></a>
<h3>4.12.6    Types, Classes, and Interfaces</h3>
<a name="24888"></a>
In the Java programming language, every variable and every expression has a type that can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference types are introduced by type declarations, which include class declarations <a href="classes.html#15372">(&#167;8.1)</a> and interface declarations <a href="interfaces.html#35470">(&#167;9.1)</a>. We often use the term <em>type</em> to refer to either a class or an interface.<p>
<a name="97724"></a>
Every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object, the class whose <code>Class</code> object was used to invoke a reflective method to produce the object, or the <code>String</code> class for objects implicitly created by the string concatenation operator <code>+</code> <a href="expressions.html#39990">(&#167;15.18.1)</a>. This class is called the <em>class of the object</em>. (Arrays also have a class, as described at the end of this section.) An object is said to be an instance of its class and of all superclasses of its class.<p>
<a name="96875"></a>
Sometimes a variable or expression is said to have a "run-time type". This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not <code>null</code>. <p>
<a name="96880"></a>
The compile time type of a variable is always declared, and the compile time type of an expression can be deduced at compile time. The compile time type limits the possible values that the variable can hold or the expression can produce at run time. If a run-time value is a reference that is not <code>null</code>, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.<p>
<a name="24895"></a>
Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements <a href="classes.html#34031">(&#167;8.1.5)</a> that interface.<p>
<a name="24918"></a>
<p>Here is an example of creating new objects and of the distinction between the type of a variable and the class of an object:</p>
<blockquote><pre>public interface Colorable {
        void setColor(byte r, byte g, byte b);
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
        byte r, g, b;
        public void setColor(byte rv, byte gv, byte bv) {
                r = rv; g = gv; b = bv;
        }
}
class Test {
        public static void main(String[] args) {
                Point p = new Point();
                ColoredPoint cp = new ColoredPoint();
                p = cp;
                Colorable c = cp;
        }
}
</pre></blockquote><a name="52612"></a>
In this example:<p>
<ul><a name="52613"></a>
<li>The local variable <code>p</code> of the method <code>main</code> of class <code>Test</code> has type <code>Point</code> and is initially assigned a reference to a new instance of class <code>Point</code>.
<a name="52614"></a>
<li>The local variable <code>cp</code> similarly has as its type <code>ColoredPoint</code>, and is initially assigned a reference to a new instance of class <code>ColoredPoint</code>.
<a name="52615"></a>
<li>The assignment of the value of <code>cp</code> to the variable <code>p</code> causes <code>p</code> to hold a reference to a <code>ColoredPoint</code> object. This is permitted because <code>ColoredPoint</code> is a subclass of <code>Point</code>, so the class <code>ColoredPoint</code> is assignment compatible <a href="conversions.html#184206">(&#167;5.2)</a> with the type <code>Point</code>. A <code>ColoredPoint</code> object includes support for all the methods of a <code>Point</code>. In addition to its particular fields <code>r</code>, <code>g</code>, and <code>b</code>, it has the fields of class <code>Point</code>, namely <code>x</code> and <code>y</code>.
<a name="52586"></a>
<li>The local variable <code>c</code> has as its type the interface type <code>Colorable</code>, so it can hold a reference to any object whose class implements <code>Colorable</code>; specifically, it can hold a reference to a <code>ColoredPoint</code>.
</ul>
<a name="24972"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="120141"></a>
 Note that an expression such as <code>new Colorable()</code> is not valid because it is not possible to create an instance of an interface, only of a class.<p>
<a name="120142"></a>
 <p>
<hr>
<a name="24976"></a>
Every array also has a class; the method <code>getClass</code>, when invoked for an array object, will return a class object (of class <code>Class</code>) that represents the class of the array. <p>
<a name="103397"></a>
<p>The classes for arrays have strange names that are not valid identifiers; for example, the class for an array of <code>int</code> components has the name "<code>[I</code>" and so the value of the expression:</p>
<blockquote><pre>new int[10].getClass().getName()
</pre></blockquote><a name="103415"></a>
is the string <code>"[I"</code>; see the specification of <code>Class.getName</code> for details.<p>
<a name="103407"></a>
<a name="90242"></a>
<p>
<a name="90243"></a>
<p>
<a name="90244"></a>
<p>
<a name="90245"></a>
<p>
<a name="90246"></a>
<p>
<a name="90247"></a>
<p>
<a name="90248"></a>
<p>
<a name="90249"></a>
<p>
<a name="90250"></a>
<p>
<a name="90251"></a>
<p>
<a name="90252"></a>
<p>
<a name="90253"></a>
<p>
<a name="90254"></a>
<p>
<a name="90255"></a>
<p>
<a name="90256"></a>
<p>
<a name="90257"></a>
<p>
<a name="90258"></a>
<p>
<a name="90259"></a>
<p>
<a name="90260"></a>
<p>
<a name="90261"></a>
<p>
<a name="90262"></a>
<p>
<a name="90263"></a>
<p>
<a name="90268"></a>
<p>
<a name="90269"></a>
<p>
<a name="90270"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="lexical.html">Prev</a> | <a href="conversions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>

<html>
<head>
<title> Names</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="conversions.html">Prev</a> | <a href="packages.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="48086"></a>
<p><strong>
CHAPTER
 6 </strong></p>
<a name="44352"></a>
<h1>Names</h1>
<hr><p>
<a name="10551"></a>
Names are used to refer to entities declared in a program. A declared entity <a href="names.html#33757">(&#167;6.1)</a> is a package, class type (normal or enum), interface type (normal or annotation type), member (class, interface, field, or method) of a reference type, type parameter (of a class, interface, method or constructor) <a href="typesValues.html#108850">(&#167;4.4)</a>, parameter (to a method, constructor, or exception handler), or local variable.<p>
<a name="56343"></a>
Names in programs are either simple, consisting of a single identifier, or qualified, &#32;consisting of a sequence of identifiers separated by "<code>.</code>" tokens <a href="names.html#31692">(&#167;6.2)</a>.<p>
<a name="56234"></a>
Every declaration that introduces a name has a <i>scope</i> <a href="names.html#103228">(&#167;6.3)</a>, which is the part of the program text within which the declared entity can be referred to by a simple name.<p>
<a name="56241"></a>
Packages and reference types (that is, class types, interface types, and array types) have members <a href="names.html#106443">(&#167;6.4)</a>. A member can be referred to using a qualified name <i>N</i>.<i>x</i>, where <i>N</i> is a simple or qualified name and <i>x</i> is an identifier. If <i>N</i> names a package, then <i>x</i> is a member of that package, which is either a class or interface type or a subpackage. If <i>N</i> names a reference type or a variable of a reference type, then <i>x</i> names a member of that type, which is either a class, an interface, a field, or a method.<p>
<a name="34249"></a>
In determining the meaning of a name <a href="names.html#106941">(&#167;6.5)</a>, the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.<p>
<a name="56266"></a>
Access control <a href="names.html#104285">(&#167;6.6)</a> can be specified in a class, interface, method, or field declaration to control when <i>access</i> to a member is allowed. Access is a different concept from scope; access specifies the part of the program text within which the declared entity can be referred to by a qualified name, a field access expression <a href="expressions.html#41267">(&#167;15.11)</a>, or a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> in which the method is not specified by a simple name. The default access is that a member can be accessed anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.<p>
<a name="27329"></a>
Fully qualified and canonical names <a href="names.html#25430">(&#167;6.7)</a> and naming conventions <a href="names.html#73307">(&#167;6.8)</a> are also discussed in this chapter.<p>
<a name="31249"></a>
The name of a field, parameter, or local variable may be used as an expression <a href="expressions.html#292383">(&#167;15.14.2)</a>. The name of a method may appear in an expression only as part of a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a>. The name of a class or interface type may appear in an expression only as part of a class literal <a href="expressions.html#251530">(&#167;15.8.2)</a>, a qualified this expression <a href="expressions.html#251603">(&#167;15.8.4)</a>, a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>, an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>, a cast expression <a href="expressions.html#238146">(&#167;15.16)</a>, an <code>instanceof</code> expression <a href="expressions.html#80289">(&#167;15.20.2)</a>, an enum constant <a href="classes.html#301020">(&#167;8.9)</a>, or as part of a qualified name for a field or method. The name of a package may appear in an expression only as part of a qualified name for a class or interface type.<p>
<a name="33757"></a>
<a name="6.1"></a>
<h2>6.1    Declarations</h2>
<a name="33759"></a>
A <i>declaration</i> introduces an entity into a program and includes an identifier <a href="lexical.html#40625">(&#167;3.8)</a> that can be used in a name to refer to this entity. A declared entity is one of the following:<p>
<ul><a name="60314"></a>
<li>A package, declared in a <code>package</code> declaration <a href="packages.html#26619">(&#167;7.4)</a>
<a name="60319"></a>
<li>An imported type, declared in a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a>
<a name="27103"></a>
<li>A class, declared in a class type declaration <a href="classes.html#15372">(&#167;8.1)</a>
<a name="27107"></a>
<li>An interface, declared in an interface type declaration <a href="interfaces.html#35470">(&#167;9.1)</a>
<a name="110987"></a>
<li>A type variable <a href="typesValues.html#108850">(&#167;4.4)</a>, declared as a formal type parameter of a generic class <a href="classes.html#299360">(&#167;8.1.2)</a>, interface <a href="interfaces.html#78598">(&#167;9.1.2)</a>, method <a href="classes.html#323928">(&#167;8.4.4)</a> or constructor <a href="classes.html#29488">(&#167;8.8.1)</a>.
<a name="103106"></a>
<li>A member of a reference type (<a href="classes.html#21831">&#167;8.2</a>, <a href="interfaces.html#32392">&#167;9.2</a>, <a href="arrays.html#64347">&#167;10.7</a>), one of the following:
<ul>
<a name="103114"></a>
<li>A member class (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>).
<a name="103122"></a>
<li>A member interface (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>).
<a name="110983"></a>
<li>an enum constant <a href="classes.html#301020">(&#167;8.9)</a>.
<a name="71624"></a>
<li>A field, one of the following:
<ul>
<a name="20168"></a>
<li>A field declared in a class type <a href="classes.html#40898">(&#167;8.3)</a>
<a name="20172"></a>
<li>A constant field declared in an interface type <a href="interfaces.html#78642">(&#167;9.3)</a>
<a name="20173"></a>
<li>The field <code>length</code>, which is implicitly a member of every array type <a href="arrays.html#64347">(&#167;10.7)</a>
</ul>
<a name="33764"></a>
<li>A method, one of the following:
<ul>
<a name="38090"></a>
<li>A method (<code>abstract</code> or otherwise) declared in a class type <a href="classes.html#40420">(&#167;8.4)</a>
<a name="33944"></a>
<li>A method (always <code>abstract</code>) declared in an interface type <a href="interfaces.html#78651">(&#167;9.4)</a>
</ul>
</ul>
<a name="31380"></a>
<li>A parameter, one of the following:
<ul>
<a name="33773"></a>
<li>A parameter of a method or constructor of a class (<a href="classes.html#38698">&#167;8.4.1</a>, <a href="classes.html#29488">&#167;8.8.1</a>)
<a name="33775"></a>
<li>A parameter of an <code>abstract</code> method of an interface <a href="interfaces.html#78651">(&#167;9.4)</a>
<a name="31398"></a>
<li>A parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a>
</ul>
<a name="31392"></a>
<li>A local variable, one of the following:
<ul>
<a name="33776"></a>
<li>A local variable declared in a block <a href="statements.html#5920">(&#167;14.4)</a>
<a name="33777"></a>
<li>A local variable declared in a <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a>
</ul>
</ul><a name="56358"></a>
Constructors <a href="classes.html#41652">(&#167;8.8)</a> are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.<p>
<a name="31692"></a>
<a name="6.2"></a>
<h2>6.2    Names and Identifiers</h2>
<a name="61760"></a>
A <i>name</i> is used to refer to an entity declared in a program.<p>
<a name="61763"></a>
There are two forms of names: simple names and qualified names. A <i>simple name</i> is a single identifier. A <i>qualified name</i> consists of a name, a "<code>.</code>" token, and an identifier.<p>
<a name="21637"></a>
In determining the meaning of a name <a href="names.html#106941">(&#167;6.5)</a>, the context in which the name appears is taken into account. The rules of <a href="names.html#106941">&#167;6.5</a> distinguish among contexts where a name must denote (refer to) a package <a href="names.html#22349">(&#167;6.5.3)</a>, a type <a href="names.html#73064">(&#167;6.5.5)</a>, a variable or value in an expression <a href="names.html#129350">(&#167;6.5.6)</a>, or a method <a href="names.html#21652">(&#167;6.5.7)</a>.<p>
<a name="33483"></a>
Not all identifiers in programs are a part of a name. Identifiers are also used in the following situations:<p>
<ul><a name="33485"></a>
<li>In declarations <a href="names.html#33757">(&#167;6.1)</a>, where an identifier may occur to specify the name by which the declared entity will be known
<a name="33490"></a>
<li>In field access expressions <a href="expressions.html#41267">(&#167;15.11)</a>, where an identifier occurs after a "<code>.</code>" token to indicate a member of an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="33491"></a>
<li>In some method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>, where an identifier may occur after a "<code>.</code>" token and before a "<code>(</code>" token to indicate a method to be invoked for an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="76093"></a>
<li>In qualified class instance creation expressions <a href="expressions.html#41147">(&#167;15.9)</a>, where an identifier occurs immediately to the right of the leftmost new token to indicate a type that must be a member of the compile-time type of the primary expression preceding the "." preceding the leftmost new token.
<a name="33492"></a>
<li>As labels in labeled statements <a href="statements.html#78993">(&#167;14.7)</a> and in <code>break</code> <a href="statements.html#6842">(&#167;14.15)</a> and <code>continue</code> <a href="statements.html#6122">(&#167;14.16)</a> statements that refer to statement labels.
</ul><a name="79896"></a>
In the example:<p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                Class c = System.out.getClass();
                System.out.println(c.toString().length() +
                                args[0].length() + args.length);
        }
}
</pre></blockquote><a name="61602"></a>
the identifiers <code>Test</code>, <code>main</code>, and the first occurrences of <code>args</code> and <code>c</code> are not names; rather, they are used in declarations to specify the names of the declared entities. The names <code>String</code>, <code>Class</code>, <code>System.out.getClass</code>, <code>System.out.println</code>, <code>c.toString</code>, <code>args</code>, and <code>args.length</code> appear in the example. The first occurrence of <code>length</code> is not a name, but rather an identifier appearing in a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a>. The second occurrence of <code>length</code> is not a name, but rather an identifier appearing in a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a>.<p>
<a name="61609"></a>
<p>The identifiers used in labeled statements and their associated <code>break</code> and <code>continue</code> statements are completely separate from those used in declarations. Thus, the following code is valid:</p>
<blockquote><pre>class TestString {
        char[] value;
        int offset, count;
        int indexOf(TestString str, int fromIndex) {
                char[] v1 = value, v2 = str.value;
                int max = offset + (count - str.count);
                int start = offset + ((fromIndex &lt; 0) ? 0 : fromIndex);
        i:
                for (int i = start; i &lt;= max; i++)
                {
                        int n = str.count, j = i, k = str.offset;
                        while (n-- != 0) {
                                if (v1[j++] != v2[k++])
                                        continue i;
                        } 
                        return i - offset;
                }
                return -1;
        }
}
</pre></blockquote><a name="103223"></a>
This code was taken from a version of the class <code>String</code> and its method <code>indexOf</code>, where the label was originally called <code>test</code>. Changing the label to have the same name as the local variable <code>i</code> does not obscure <a href="names.html#104058">(&#167;6.3.2)</a> the label in the scope of the declaration of <code>i</code>. The identifier <code>max</code> could also have been used as the statement label; the label would not obscure the local variable <code>max</code> within the labeled statement.<p>
<a name="103228"></a>
<a name="6.3"></a>
<h2>6.3    Scope of a Declaration</h2>
<a name="103232"></a>
The <i>scope</i> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name (provided it is visible <a href="names.html#34133">(&#167;6.3.1)</a>). A declaration is said to be <i>in scope</i> at a particular point in a program if and only if the declaration's scope includes that point. <p>
<a name="103908"></a>
The scoping rules for various constructs are given in the sections that describe those constructs. For convenience, the rules are repeated here:<p>
<a name="130147"></a>
 The scope of the declaration of an observable <a href="packages.html#13180">(&#167;7.4.3)</a> top level package is all observable compilation units <a href="packages.html#40031">(&#167;7.3)</a>. The declaration of a package that is not observable is never in scope. Subpackage declarations are never in scope.<p>
<a name="130204"></a>
The scope of a type imported by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="130217"></a>
The scope of a member imported by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> or a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="130244"></a>
The scope of a top level type is all type declarations in the package in which the top level type is declared.<p>
<a name="130388"></a>
The scope of a declaration of a member <i>m</i> declared in or inherited by a class type <i>C</i> is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="130397"></a>
The scope of the declaration of a member <i>m</i> declared in or inherited by an interface type <i>I</i> is the entire body of <i>I</i>, including any nested type declarations.<p>
<a name="129659"></a>
The scope of a parameter of a method <a href="classes.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="130123"></a>
The scope of an interface's type parameter is the entire declaration of the interface including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="130454"></a>
The scope of a method's type parameter is the entire declaration of the method, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="130463"></a>
The scope of a constructor's type parameter is the entire declaration of the constructor, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="130283"></a>
The scope of a local variable declaration in a block <a href="statements.html#32644">(&#167;14.4.2)</a> is the rest of the block in which the declaration appears, starting with its own initializer <a href="statements.html#5920">(&#167;14.4)</a> and including any further declarators to the right in the local variable declaration statement. <p>
<a name="130302"></a>
The scope of a local class immediately enclosed by a block (<a href="statements.html#246838">&#167;14.2</a>) is the rest of the immediately enclosing block, including its own class declaration. The scope of a local class immediately enclosed by in a switch block statement group (<a href="statements.html#258896">&#167;14.11</a>)is the rest of the immediately enclosing switch block statement group, including its own class declaration.<p>
<a name="130317"></a>
The scope of a local variable declared in the <em>forInit</em> part of a basic <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a> includes all of the following:<p>
<ul><a name="130322"></a>
<li>Its own initializer
<a name="130325"></a>
<li>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement
<a name="130326"></a>
<li>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement
<a name="130327"></a>
<li>The contained <em>Statement</em>
</ul><a name="130473"></a>
The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a> is the contained <em>Statement</em><p>
<a name="130337"></a>
The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a> is the entire block associated with the <code>catch</code>.<p>
<a name="129926"></a>
These rules imply that declarations of class and interface types need not appear before uses of the types.<p>
<a name="20278"></a>
<p>In the example:</p>
<blockquote><pre>package points;
class Point {
        int x, y;
        PointList list;
        Point next;
}
class PointList {
        Point first;
}
</pre></blockquote>
<a name="34047"></a>
<p>the use of <code>PointList</code> in class <code>Point</code> is correct, because the scope of the class declaration <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any other type declarations in other compilation units of package <code>points</code>.</p>
<a name="34133"></a>
<a name="6.3.1"></a>
<h3>6.3.1    Shadowing Declarations</h3>
<a name="34051"></a>
Some declarations may be <i>shadowed</i> in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.<p>
<a name="84195"></a>
A declaration <i>d</i> of a type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="84205"></a>
A declaration <i>d</i> of a field, local variable, method parameter, constructor parameter or exception handler parameter named <i>n</i> shadows the declarations of any other fields, local variables, method parameters, constructor parameters or exception handler parameters named <i>n</i> that are in scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="84229"></a>
A declaration <i>d</i> of a method named <i>n</i> shadows the declarations of any other methods named <i>n</i> that are in an enclosing scope at the point where <i>d</i> occurs throughout the scope of <i>d</i>.<p>
<a name="103966"></a>
A package declaration never shadows any other declaration. <p>
<a name="130407"></a>
A single-type-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="130409"></a>
<li>any top level type named <i>n</i> declared in another compilation unit of <i>p</i>.
<a name="130410"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration in <i>c.</i>
<a name="130411"></a>
<li>any type named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>.
</ul><a name="130412"></a>
throughout <i>c.</i><p>
<a name="130427"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a field named <i>n</i> shadows the declaration of any static field named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="130430"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a method named <i>n</i> with signature s shadows the declaration of any static method named <i>n</i> with signature <i>s </i>imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="130433"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="130435"></a>
<li>any static type named <i>n</i> imported by a static-import-on-demand declaration in <i>c.</i>
<a name="130442"></a>
<li>any top level type <a href="packages.html#26783">(&#167;7.6)</a> named <i>n</i> declared in another compilation unit <a href="packages.html#40031">(&#167;7.3)</a> of <i>p</i>.
<a name="130446"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> in <i>c</i>.
</ul><a name="130447"></a>
throughout <i>c.</i><p>
<a name="130419"></a>
A type-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="130080"></a>
A static-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="108437"></a>
A declaration <i>d</i> is said to be <i>visible at point <i>p</i> in a program</i> if the scope of <i>d</i> includes <i>p</i>, and <i>d</i> is not shadowed by any other declaration at <i>p</i>. When the program point we are discussing is clear from context, we will often simply say that a declaration is <i>visible</i>.<p>
<a name="104510"></a>
<p>Note that shadowing is distinct from hiding (<a href="classes.html#40898">&#167;8.3</a>, <a href="classes.html#227928">&#167;8.4.8.2</a>, <a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#78642">&#167;9.3</a>, <a href="interfaces.html#252566">&#167;9.5</a>). Hiding, in the technical sense defined in this specification, applies only to members which would otherwise be inherited but are not because of a declaration in a subclass. Shadowing is also distinct from obscuring <a href="names.html#104058">(&#167;6.3.2)</a>.</p>
<a name="62323"></a>
<p>Here is an example of shadowing of a field declaration by a local variable declaration:</p>
<blockquote><pre>class Test {
        static int x = 1;
        public static void main(String[] args) {
                int x = 0;
                System.out.print("x=" + x);
                System.out.println(", Test.x=" + Test.x);
        }
}
</pre></blockquote><a name="34060"></a>
produces the output:<p>
<blockquote><pre>x=0, Test.x=1
</pre></blockquote><a name="34062"></a>
This example declares:<p>
<ul><a name="62327"></a>
<li>a class <code>Test</code>
<a name="62331"></a>
<li>a class (<code>static</code>) variable <code>x</code> that is a member of the class <code>Test</code>
<a name="62332"></a>
<li>a class method <code>main</code> that is a member of the class <code>Test</code>
<a name="62333"></a>
<li>a parameter <code>args</code> of the <code>main</code> method.
<a name="122351"></a>
<li>a local variable <code>x</code> of the <code>main</code> method
<a name="34066"></a>
</ul>
<p>Since the scope of a class variable includes the entire body of the class <a href="classes.html#21831">(&#167;8.2)</a> the class variable <code>x</code> would normally be available throughout the entire body of the method <code>main</code>. In this example, however, the class variable <code>x</code> is shadowed within the body of the method <code>main</code> by the declaration of the local variable <code>x</code>.</p>
<a name="62312"></a>
<p>A local variable has as its scope the rest of the block in which it is declared <a href="statements.html#32644">(&#167;14.4.2)</a>; in this case this is the rest of the body of the <code>main</code> method, namely its initializer "<code>0</code>" and the invocations of <code>print</code> and <code>println</code>.</p>
<a name="62314"></a>
<p>This means that:</p>
<a name="62313"></a>
<ul>
<li>The expression "<code>x</code>" in the invocation of <code>print</code> refers to (denotes) the value of the local variable <code>x</code>.
<a name="128475"></a>
<li>The invocation of <code>println</code> uses a qualified name <a href="names.html#104285">(&#167;6.6)</a> <code>Test.x</code>, which uses the class type name <code>Test</code> to access the class variable <code>x</code>, because the declaration of <code>Test.x</code> is shadowed at this point and cannot be referred to by its simple name.
</ul>
<a name="104040"></a>
<p>The following example illustrates the shadowing of one type declaration by another:</p>
<blockquote><pre>import java.util.*;
class Vector {
        int val[] = { 1 , 2 };
<a name="104044"></a>
<p>}</p>
class Test {
        public static void main(String[] args) {
                Vector v = new Vector();
                System.out.println(v.val[0]);
        }
}
</pre></blockquote><a name="104051"></a>
compiles and prints:<p>
<blockquote><pre>1
</pre></blockquote><a name="104053"></a>
using the class <code>Vector</code> declared here in preference to the generic <a href="classes.html#299360">(&#167;8.1.2)</a> class <code>java.util.Vector</code> that might be imported on demand.<p>
<a name="104058"></a>
<a name="6.3.2"></a>
<h3>6.3.2    Obscured Declarations</h3>
<a name="62307"></a>
A simple name may occur in contexts where it may potentially be interpreted as the name of a variable, a type or a package. In these situations, the rules of <a href="names.html#106941">&#167;6.5</a> specify that a variable will be chosen in preference to a type, and that a type will be chosen in preference to a package. Thus, it is may sometimes be impossible to refer to a visible type or package declaration via its simple name. We say that such a declaration is <i>obscured</i>. <p>
<a name="106440"></a>
<p>Obscuring is distinct from shadowing <a href="names.html#34133">(&#167;6.3.1)</a> and hiding (<a href="classes.html#40898">&#167;8.3</a>, <a href="classes.html#227928">&#167;8.4.8.2</a>, <a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#78642">&#167;9.3</a>, <a href="interfaces.html#252566">&#167;9.5</a>). The naming conventions of <a href="names.html#73307">&#167;6.8</a> help reduce obscuring.</p>
<a name="106443"></a>
<a name="6.4"></a>
<h2>6.4    Members and Inheritance</h2>
<a name="86672"></a>
Packages and reference types have <i>members</i>. <p>
<a name="56531"></a>
<p>This section provides an overview of the members of packages and reference types here, as background for the discussion of qualified names and the determination of the meaning of names. For a complete description of membership, see <a href="typesValues.html#108850">&#167;4.4</a>, <a href="typesValues.html#112367">&#167;4.5.2</a>, <a href="typesValues.html#110257">&#167;4.8</a>, <a href="typesValues.html#108433">&#167;4.9</a>, <a href="packages.html#26535">&#167;7.1</a>, <a href="classes.html#21831">&#167;8.2</a>, <a href="interfaces.html#32392">&#167;9.2</a>, and <a href="arrays.html#64347">&#167;10.7</a>. </p>
<a name="128590"></a>
<p></p>
<a name="128598"></a>
<a name="6.4.1"></a>
<h3>6.4.1    The Members of Type Variables, Parameterized Types, Raw Types and Intersection Types</h3>
<a name="128602"></a>
The members of a type variable were specified in <a href="typesValues.html#108850">&#167;4.4</a>, the members of a parameterized type in <a href="typesValues.html#112367">&#167;4.5.2</a>, those of a raw type in <a href="typesValues.html#110257">&#167;4.8</a>, and the members of an intersection type were specified in <a href="typesValues.html#108433">&#167;4.9</a>.<p>
<a name="128591"></a>
<p></p>
<a name="128594"></a>
<a name="6.4.2"></a>
<h3>6.4.2    The Members of a Package</h3>
<a name="104077"></a>
The members of a package <a href="packages.html#34412">(&#167;7)</a> are specified in <a href="packages.html#26535">&#167;7.1</a>. For convenience, we repeat that specification here:<p>
<a name="130105"></a>
The members of a package are its subpackages and all the top level <a href="packages.html#26783">(&#167;7.6)</a> class types <a href="classes.html#29542">(&#167;8)</a> and top level interface types <a href="interfaces.html#29542">(&#167;9)</a> declared in all the compilation units <a href="packages.html#40031">(&#167;7.3)</a> of the package.<p>
<a name="98547"></a>
<p>In general, the subpackages of a package are determined by the host system <a href="packages.html#37758">(&#167;7.2)</a>. However, the package <code>java</code> always includes the subpackages <code>lang</code> and <code>io</code> and may include other subpackages. No two distinct members of the same package may have the same simple name <a href="packages.html#26535">(&#167;7.1)</a>, but members of different packages may have the same simple name. </p>
<a name="107146"></a>
<p>For example, it is possible to declare a package:</p>
<blockquote><pre>package vector;
public class Vector { Object[] vec; }
</pre></blockquote><a name="34986"></a>
that has as a member a <code>public</code> class named <code>Vector</code>, even though the package <code>java.util</code> also declares a class named <code>Vector</code>. These two class types are different, reflected by the fact that they have different fully qualified names <a href="names.html#25430">(&#167;6.7)</a>. The fully qualified name of this example <code>Vector</code> is <code>vector.Vector</code>, whereas <code>java.util.Vector</code> is the fully qualified name of the <code>Vector</code> class usually included in the Java platform. Because the package <code>vector</code> contains a class named <code>Vector</code>, it cannot also have a subpackage named <code>Vector</code>.<p>
<a name="34757"></a>
<a name="6.4.3"></a>
<h3>6.4.3    The Members of a Class Type</h3>
<a name="104101"></a>
The members of a class type <a href="classes.html#21831">(&#167;8.2)</a> are classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), interfaces (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), fields (<a href="classes.html#40898">&#167;8.3</a>, <a href="interfaces.html#78642">&#167;9.3</a>, <a href="arrays.html#64347">&#167;10.7</a>), and methods (<a href="classes.html#40420">&#167;8.4</a>, <a href="interfaces.html#78651">&#167;9.4</a>). Members are either declared in the type, or <i>inherited</i> because they are accessible members of a superclass or superinterface which are neither private nor hidden nor overridden <a href="classes.html#228745">(&#167;8.4.8)</a>.<p>
<a name="34765"></a>
<p>The members of a class type are all of the following:</p>
<ul><a name="34768"></a>
<li>Members inherited from its direct superclass <a href="classes.html#262560">(&#167;8.1.4)</a>, if it has one (the class <code>Object</code> has no direct superclass)
<a name="128523"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.html#34031">(&#167;8.1.5)</a>
<a name="128527"></a>
<li>Members declared in the body of the class <a href="classes.html#18988">(&#167;8.1.6)</a>
</ul><a name="128532"></a>
Constructors <a href="classes.html#41652">(&#167;8.8)</a> and type variables <a href="typesValues.html#108850">(&#167;4.4)</a> are not members.<p>
<a name="31685"></a>
<p>There is no restriction against a field and a method of a class type having the same simple name. Likewise, there is no restriction against a member class or member interface of a class type having the same simple name as a field or method of that class type.</p>
<a name="56650"></a>
<p>A class may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any of the fields by its simple name results in a compile-time error (<a href="names.html#54547">&#167;6.5.7.2</a>, <a href="classes.html#21831">&#167;8.2</a>).</p>
<a name="31689"></a>
<p>In the example:</p>
<blockquote><pre>
interface Colors {
        int WHITE = 0, BLACK = 1;
}

interface Separates {
        int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
}

class Test implements Colors, Separates {
        public static void main(String[] args) {
                System.out.println(BLACK); // compile-time error: ambiguous
        }
}
</pre></blockquote><a name="25294"></a>
the name <code>BLACK</code> in the method <code>main</code> is ambiguous, because class <code>Test</code> has two members named <code>BLACK</code>, one inherited from <code>Colors</code> and one from <code>Separates</code>.<p>
<a name="23306"></a>
<p>A class type may have two or more methods with the same simple name if the methods have signatures that are not override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a>. Such a method member name is said to be <i>overloaded</i>.</p>
<a name="31700"></a>
<p>A class type may contain a declaration for a method with the same name and the same signature as a method that would otherwise be inherited from a superclass or superinterface. In this case, the method of the superclass or superinterface is not inherited. If the method not inherited is <code>abstract</code>, then the new declaration is said to <i>implement</i> it; if the method not inherited is not <code>abstract</code>, then the new declaration is said to <i>override</i> it.</p>
<a name="31699"></a>
<p>In the example:</p>
<blockquote><pre>class Point {
        float x, y;
        void move(int dx, int dy) { x += dx; y += dy; }
        void move(float dx, float dy) { x += dx; y += dy; }
        public String toString() { return "("+x+","+y+")"; }
}
</pre></blockquote><a name="31707"></a>
the class <code>Point</code> has two members that are methods with the same name, <code>move</code>. The overloaded <code>move</code> method of class <code>Point</code> chosen for any particular method invocation is determined at compile time by the overloading resolution procedure given in <a href="expressions.html#20448">&#167;15.12</a>.<p>
<a name="62345"></a>
<p>In this example, the members of the class <code>Point</code> are the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>Point</code>, the two declared <code>move</code> methods, the declared <code>toString</code> method, and the members that <code>Point</code> inherits from its implicit direct superclass <code>Object</code> <a href="typesValues.html#11055">(&#167;4.3.2)</a>, such as the method <code>hashCode</code>. Note that <code>Point</code> does not inherit the <code>toString</code> method of class <code>Object</code> because that method is overridden by the declaration of the <code>toString</code> method in class <code>Point</code>.</p>
<a name="34849"></a>
<a name="6.4.4"></a>
<h3>6.4.4    The Members of an Interface Type</h3>
<a name="130349"></a>
The members of an interface type <a href="interfaces.html#32392">(&#167;9.2)</a> may be classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), interfaces (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), fields (<a href="classes.html#40898">&#167;8.3</a>, <a href="interfaces.html#78642">&#167;9.3</a>, <a href="arrays.html#64347">&#167;10.7</a>), and methods (<a href="classes.html#40420">&#167;8.4</a>, <a href="interfaces.html#78651">&#167;9.4</a>). The members of an interface are:<p>
<ul><a name="130350"></a>
<li>Those members declared in the interface.
<a name="130353"></a>
<li>Those members inherited from direct superinterfaces.
<a name="130354"></a>
<li>If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method <i>m</i> with signature <i>s,</i> return type <i>r,</i> and <code>throws</code> clause <i>t</i> corresponding to each public instance method <i>m</i> with signature <i>s,</i> return type <i>r,</i> and <code>throws</code> clause <i>t</i> declared in <code>Object</code>, unless a method with the same signature, same return type, and a compatible <code>throws</code> clause is explicitly declared by the interface. It is a compile-time error if the interface explicitly declares such a method <i>m</i> in the case where <i>m</i> is declared to be <code>final</code> in <code>Object</code>.
</ul><a name="129938"></a>
Type variables <a href="typesValues.html#108850">(&#167;4.4)</a> are not members. <p>
<a name="129103"></a>
An interface may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any such field by its simple name results in a compile-time error (<a href="names.html#22022">&#167;6.5.6.1</a>, <a href="interfaces.html#32392">&#167;9.2</a>).<p>
<a name="61795"></a>
<p>In the example:</p>
<blockquote><pre>interface Colors {
        int WHITE = 0, BLACK = 1;
}
interface Separates {
        int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
}
interface ColorsAndSeparates extends Colors, Separates {
        int DEFAULT = BLACK;                                                                    // compile-time error: ambiguous
}
</pre></blockquote><a name="35254"></a>
the members of the interface <code>ColorsAndSeparates</code> include those members inherited from <code>Colors</code> and those inherited from <code>Separates</code>, namely <code>WHITE</code>, <code>BLACK</code> (first of two), <code>CYAN</code>, <code>MAGENTA</code>, <code>YELLOW</code>, and <code>BLACK</code> (second of two). The member name <code>BLACK</code> is ambiguous in the interface <code>ColorsAndSeparates</code>.<p>
<a name="128554"></a>
<a name="6.4.5"></a>
<h3>6.4.5    The Members of an Array Type</h3>
<a name="86520"></a>
The members of an array type are specified in <a href="arrays.html#64347">&#167;10.7</a>. For convenience, we repeat that specification here.<p>
<a name="130087"></a>
The members of an array type are all of the following:<p>
<ul><a name="130089"></a>
<li>The <code>public</code> <code>final</code> field <code>length</code>, which contains the number of components of the array (<code>length</code> may be positive or zero).
<a name="130091"></a>
<li>The <code>public</code> method <code>clone</code>, which overrides the method of the same name in class <code>Object</code> and throws no checked exceptions. The return type of the clone method of an array type <i>T[]</i> is <i>T[].</i>
<a name="130093"></a>
<li>All the members inherited from class <code>Object</code>; the only method of <code>Object</code> that is not inherited is its <code>clone</code> method.
</ul><a name="129676"></a>
<p>
<a name="98552"></a>
The example:<p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int[] ia = new int[3];
                int[] ib = new int[6];
                System.out.println(ia.getClass() == ib.getClass());
                System.out.println("ia has length=" + ia.length);
        }
}
</pre></blockquote><a name="27736"></a>
produces the output:<p>
<blockquote><pre>true
ia has length=3
</pre></blockquote><a name="106936"></a>
This example uses the method <code>getClass</code> inherited from class <code>Object</code> and the field <code>length</code>. The result of the comparison of the <code>Class</code> objects in the first <code>println</code> demonstrates that all arrays whose components are of type <code>int</code> are instances of the same array type, which is <code>int[]</code>.<p>
<a name="106941"></a>
<a name="6.5"></a>
<h2>6.5    Determining the Meaning of a Name</h2>
<a name="106943"></a>
The meaning of a name depends on the context in which it is used. The determination of the meaning of a name requires three steps. First, context causes a name syntactically to fall into one of six categories: <i>PackageName</i>, <i>TypeName</i>, <i>ExpressionName</i>, <i>MethodName</i>, <i>PackageOrTypeName</i>, or <i>AmbiguousName</i>. Second, a name that is initially classified by its context as an <i>AmbiguousName</i> or as a <i>PackageOrTypeName</i> is then reclassified to be a <i>PackageName</i>, <i>TypeName</i>, or <i>ExpressionName</i>. Third, the resulting category then dictates the final determination of the meaning of the name (or a compilation error if the name has no meaning).<p>
<blockquote><pre><i>
PackageName:
        Identifier
        PackageName . Identifier

TypeName:
        Identifier
        PackageOrTypeName . Identifier

ExpressionName:
        Identifier
        AmbiguousName . Identifier

MethodName:
        Identifier
        AmbiguousName . Identifier

PackageOrTypeName:
        Identifier
        PackageOrTypeName . Identifier

AmbiguousName:
        Identifier
        AmbiguousName . Identifier
        </i></pre></blockquote>
<a name="32744"></a>
<p>The use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in <a href="names.html#73307">&#167;6.8</a> are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.</p>
</pre></blockquote><a name="32740"></a>
<a name="6.5.1"></a>
<h3>6.5.1    Syntactic Classification of a Name According to Context</h3>
<a name="32741"></a>
A name is syntactically classified as a <i>PackageName</i> in these contexts:<p>
<ul><a name="32159"></a>
<li>In a package declaration <a href="packages.html#26619">(&#167;7.4)</a>
<a name="32492"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>PackageName</i>
</ul><a name="32149"></a>
A name is syntactically classified as a <i>TypeName</i> in these contexts:<p>
<ul><a name="32174"></a>
<li>In a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a>
<a name="109703"></a>
<li>To the left of the "." in a single static import <a href="packages.html#26741">(&#167;7.5.3)</a> declaration
<a name="109673"></a>
<li>To the left of the "." in a static import-on-demand <a href="packages.html#94114">(&#167;7.5.4)</a> declaration
<a name="111137"></a>
<li>To the left of the "&lt;" in a parameterized type <a href="typesValues.html#112898">(&#167;4.5)</a>
<a name="129151"></a>
<li>In an actual type argument list of a parameterized type
<a name="111147"></a>
<li>In an explicit actual type argument list in a generic method <a href="classes.html#323928">(&#167;8.4.4)</a> or constructor <a href="classes.html#244611">(&#167;8.8.4)</a> invocation
<a name="111153"></a>
<li>In an <code>extends</code> clause in a type variable declaration <a href="classes.html#299360">(&#167;8.1.2)</a>
<a name="128628"></a>
<li>In an <code>extends</code> clause of a wildcard type argument <a href="typesValues.html#107353">(&#167;4.5.1)</a>
<a name="128629"></a>
<li>In a <code>super</code> clause of a wildcard type argument <a href="typesValues.html#107353">(&#167;4.5.1)</a>
<a name="111127"></a>
<li>In an <code>extends</code> clause in a class declaration <a href="classes.html#262560">(&#167;8.1.4)</a>
<a name="32182"></a>
<li>In an <code>implements</code> clause in a class declaration <a href="classes.html#34031">(&#167;8.1.5)</a>
<a name="34302"></a>
<li>In an <code>extends</code> clause in an interface declaration <a href="interfaces.html#253307">(&#167;9.1.3)</a>
<a name="111158"></a>
<li>After the "@" sign in an annotation <a href="interfaces.html#253695">(&#167;9.7)</a>
<a name="32290"></a>
<li>As a <i>Type</i> (or the part of a <i>Type</i> that remains after all brackets are deleted) in any of the following contexts:
<ul>
<a name="32310"></a>
<li>In a field declaration (<a href="classes.html#40898">&#167;8.3</a>, <a href="interfaces.html#78642">&#167;9.3</a>)
<a name="32322"></a>
<li>As the result type of a method (<a href="classes.html#40420">&#167;8.4</a>, <a href="interfaces.html#78651">&#167;9.4</a>)
<a name="32355"></a>
<li>As the type of a formal parameter of a method or constructor (<a href="classes.html#38698">&#167;8.4.1</a>, <a href="classes.html#29488">&#167;8.8.1</a>, <a href="interfaces.html#78651">&#167;9.4</a>)
<a name="32266"></a>
<li>As the type of an exception that can be thrown by a method or constructor (<a href="classes.html#308526">&#167;8.4.6</a>, <a href="classes.html#300902">&#167;8.8.5</a>, <a href="interfaces.html#78651">&#167;9.4</a>)
<a name="32224"></a>
<li>As the type of a local variable <a href="statements.html#5920">(&#167;14.4)</a>
<a name="72827"></a>
<li>As the type of an exception parameter in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a>
<a name="72840"></a>
<li>As the type in a class literal <a href="expressions.html#251530">(&#167;15.8.2)</a>
<a name="104184"></a>
<li>As the qualifying type of a qualified <code>this</code> expression <a href="expressions.html#251603">(&#167;15.8.4)</a>.
<a name="72842"></a>
<li>As the class type which is to be instantiated in an unqualified class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>
<a name="83309"></a>
<li>As the direct superclass or direct superinterface of an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a> which is to be instantiated in an unqualified class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>
<a name="124655"></a>
<li>As the element type of an array to be created in an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>
<a name="124662"></a>
<li>As the qualifying type of field access using the keyword <code>super</code> <a href="expressions.html#20860">(&#167;15.11.2)</a>
<a name="124663"></a>
<li>As the qualifying type of a method invocation using the keyword <code>super</code> <a href="expressions.html#20448">(&#167;15.12)</a>
<a name="32244"></a>
<li>As the type mentioned in the cast operator of a cast expression <a href="expressions.html#238146">(&#167;15.16)</a>
<a name="32248"></a>
<li>As the type that follows the <code>instanceof</code> relational operator <a href="expressions.html#80289">(&#167;15.20.2)</a>
</ul>
</ul><a name="32435"></a>
<p>
<a name="129347"></a>
<p>
<a name="129348"></a>
<p>
<a name="129349"></a>
A name is syntactically classified as an <i>ExpressionName</i> in these contexts:<p>
<ul><a name="32464"></a>
<li>As the qualifying expression in a qualified superclass constructor invocation <a href="classes.html#229267">(&#167;8.8.7.1)</a>
<a name="104200"></a>
<li>As the qualifying expression in a qualified class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>
<a name="104201"></a>
<li>As the array reference expression in an array access expression <a href="expressions.html#239587">(&#167;15.13)</a>
<a name="32459"></a>
<li>As a <i>PostfixExpression</i> <a href="expressions.html#36254">(&#167;15.14)</a>
<a name="32477"></a>
<li>As the left-hand operand of an assignment operator <a href="expressions.html#5281">(&#167;15.26)</a>
</ul><a name="32437"></a>
A name is syntactically classified as a <i>MethodName</i> in these contexts:<p>
<ul><a name="32480"></a>
<li>Before the "<code>(</code>" in a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a>
<a name="111162"></a>
<li>To the left of the "=" sign in an annotation's element value pair <a href="interfaces.html#253695">(&#167;9.7)</a>
</ul><a name="72939"></a>
A name is syntactically classified as a <i>PackageOrTypeName</i> in these contexts:<p>
<ul><a name="72943"></a>
<li>To the left of the "." in a qualified TypeName
<a name="73268"></a>
<li>In a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a>
</ul><a name="32439"></a>
A name is syntactically classified as an <i>AmbiguousName</i> in these contexts:<p>
<ul><a name="32496"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>ExpressionName</i>
<a name="32499"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>MethodName</i>
<a name="111166"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>AmbiguousName</i>
<a name="72113"></a>
<li>In the default value clause of an annotation type element declaration <a href="interfaces.html#239527">(&#167;9.6)</a>
<a name="111181"></a>
<li>To the right of an "=" in an an element value pair <a href="interfaces.html#253695">(&#167;9.7)</a>
</ul><a name="109696"></a>
<a name="6.5.2"></a>
<h3>6.5.2    Reclassification of Contextually Ambiguous Names</h3>
<a name="32133"></a>
An <i>AmbiguousName</i> is then reclassified as follows:<p>
<ul><a name="32505"></a>
<li>If the <i>AmbiguousName</i> is a simple name, consisting of a single <i>Identifier</i>:
<ul>
<a name="32544"></a>
<li>If the <i>Identifier</i> appears within the scope <a href="names.html#103228">(&#167;6.3)</a> of a local variable declaration <a href="statements.html#5920">(&#167;14.4)</a> or parameter declaration (<a href="classes.html#38698">&#167;8.4.1</a>, <a href="classes.html#29488">&#167;8.8.1</a>, <a href="statements.html#79311">&#167;14.20</a>) or field declaration <a href="classes.html#40898">(&#167;8.3)</a> with that name, then the <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>.
<a name="109902"></a>
<li>Otherwise, if a field of that name is declared in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the <i>Identifier</i> by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a>, or by a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> then the <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>. 
<a name="32843"></a>
<li>Otherwise, if the <i>Identifier</i> appears within the scope <a href="names.html#103228">(&#167;6.3)</a> of a top level class <a href="classes.html#328796">(&#167;8)</a> or interface type declaration <a href="interfaces.html#238678">(&#167;9)</a>, a local class declaration <a href="statements.html#247766">(&#167;14.3)</a> or member type declaration (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>) with that name, then the <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="71975"></a>
<li>Otherwise, if a type of that name is declared in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the <i>Identifier</i>, either by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a>, or by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a>, or by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a>, or by a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a>, then the <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="32535"></a>
<li>Otherwise, the <i>AmbiguousName</i> is reclassified as a <i>PackageName</i>. A later step determines whether or not a package of that name actually exists.
</ul>
<a name="32506"></a>
<li>If the <i>AmbiguousName</i> is a qualified name, consisting of a name, a "<code>.</code>", and an <i>Identifier</i>, then the name to the left of the "<code>.</code>" is first reclassified, for it is itself an <i>AmbiguousName</i>. There is then a choice:
<ul>
<a name="32509"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <i>PackageName</i>, then if there is a package whose name is the name to the left of the "<code>.</code>" and that package contains a declaration of a type whose name is the same as the <i>Identifier</i>, then this <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>. Otherwise, this <i>AmbiguousName</i> is reclassified as a <i>PackageName</i>. A later step determines whether or not a package of that name actually exists.
<a name="72049"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <i>TypeName</i>, then if the <i>Identifier</i> is the name of a method or field of the type denoted by TypeName, this <i>AmbiguousName</i> is reclassified as an <i>ExpressionName. </i>Otherwise, if the Identifier is the name of a member type of the type denoted by TypeName, this AmbiguousName is reclassified as a TypeName. Otherwise, a compile-time error results.
<a name="79937"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as an <i>ExpressionName</i>, then let T be the type of the expression denoted by ExpressionName. If the Identifier is the name of a method or field of the type denoted by T, this <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>. Otherwise, if the Identifier is the name of a member type (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>) of the type denoted by T, then this AmbiguousName is reclassified as a TypeName. Otherwise, a compile-time error results.
<a name="60456"></a>
</ul></ul>
<p>As an example, consider the following contrived "library code":</p>
<blockquote><pre>package org.rpgpoet;
import java.util.Random;
interface Music { Random[] wizards = new Random[4]; }
</pre></blockquote><a name="60464"></a>
and then consider this example code in another package:<p>
<blockquote><pre>package bazola;
class Gabriel {
        static int n = org.rpgpoet.Music.wizards.length;
}
</pre></blockquote><a name="60483"></a>
First of all, the name <code>org.rpgpoet.Music.wizards.length</code> is classified as an <i>ExpressionName</i> because it functions as a <i>PostfixExpression</i>. Therefore, each of the names:<p>
<a name="107486"></a>
<p></p>
<blockquote><pre>org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org 
</pre></blockquote><a name="86574"></a>
is initially classified as an <i>AmbiguousName</i>. These are then reclassified:<p>
<ul><a name="60526"></a>
<li>The simple name org is reclassified as a <i>PackageName</i> (since there is no variable or type named org in scope). 
<a name="60530"></a>
<li>Next, assuming that there is no class or interface named <code>rpgpoet</code> in any compilation unit of package org (and we know that there is no such class or interface because package org has a subpackage named <code>rpgpoet</code>), the qualified name <code>org.rpgpoet</code> is reclassified as a <i>PackageName</i>.
<a name="60542"></a>
<li>Next, because package <code>org.rpgpoet</code> has an interface type named <code>Music</code>, the qualified name <code>org.rpgpoet.Music</code> is reclassified as a <i>TypeName</i>.
<a name="80032"></a>
<li>Finally, because the name <code>org.rpgpoet.Music</code> is a <i>TypeName</i>, the qualified name <code>org.rpgpoet.Music.wizards</code> is reclassified as an <i>ExpressionName</i>. 
</ul><a name="22349"></a>
<a name="6.5.3"></a>
<h3>6.5.3    Meaning of Package Names</h3>
<a name="32757"></a>
The meaning of a name classified as a <i>PackageName</i> is determined as follows.<p>
<a name="22481"></a>
<a name="6.5.3.1"></a>
<h4>6.5.3.1    Simple Package Names</h4>
<a name="21719"></a>
If a package name consists of a single <i>Identifier</i>, then this identifier denotes a top level package named by that identifier. If no top level package of that name is in scope <a href="packages.html#70172">(&#167;7.4.4)</a>, then a compile-time error occurs.<p>
<a name="22482"></a>
<a name="6.5.3.2"></a>
<h4>6.5.3.2    Qualified Package Names</h4>
<a name="21727"></a>
If a package name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must also be a package name. The package name <i>Q</i><code>.</code><i>Id</i> names a package that is the member named <i>Id</i> within the package named by <i>Q</i>. If <i>Q</i> does not name an observable package <a href="packages.html#13180">(&#167;7.4.3)</a>, or <i>Id</i> is not the simple name an observable subpackage of that package, then a compile-time error occurs.<p>
<a name="21721"></a>
<a name="6.5.4"></a>
<h3>6.5.4    Meaning of PackageOrTypeNames</h3>
<a name="73065"></a>
<a name="6.5.4.1"></a>
<h4>6.5.4.1    Simple PackageOrTypeNames</h4>
<a name="73113"></a>
If the <i>PackageOrTypeName</i>, <i>Q</i>, occurs in the scope of a type named K<i>Q</i>, then the <i>PackageOrTypeName</i> is reclassified as a <i>TypeName</i>. <p>
<a name="107160"></a>
Otherwise, the <i>PackageOrTypeName</i> is reclassified as a <i>PackageName</i>. The meaning of the <i>PackageOrTypeName</i> is the meaning of the reclassified name.<p>
<a name="73067"></a>
<a name="6.5.4.2"></a>
<h4>6.5.4.2    Qualified PackageOrTypeNames</h4>
<a name="73097"></a>
Given a qualified <i>PackageOrTypeName</i> of the form <i>Q.Id</i>, if the type or package denoted by <i>Q</i> has a member type named <i>Id</i>, then the qualified <i>PackageOrTypeName</i> name is reclassified as a <i>TypeName</i>. <p>
<a name="107161"></a>
Otherwise, it is reclassified as a <i>PackageName</i>. The meaning of the qualified <i>PackageOrTypeName</i> is the meaning of the reclassified name.<p>
<a name="73064"></a>
<a name="6.5.5"></a>
<h3>6.5.5    Meaning of Type Names</h3>
<a name="32763"></a>
The meaning of a name classified as a <i>TypeName</i> is determined as follows.<p>
<a name="21810"></a>
<a name="6.5.5.1"></a>
<h4>6.5.5.1    Simple Type Names</h4>
<a name="110733"></a>
If a type name consists of a single <i>Identifier</i>, then the identifier must occur in the scope of exactly one visible declaration of a type with this name, or a compile-time error occurs. The meaning of the type name is that type. <p>
<a name="21811"></a>
<a name="6.5.5.2"></a>
<h4>6.5.5.2    Qualified Type Names</h4>
<a name="72865"></a>
If a type name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must be either a type name or a package name. If <i>Id</i> names exactly one type that is a member of the type or package denoted by <i>Q</i>, then the qualified type name denotes that type. If <i>Id</i> does not name a member type (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>) within <i>Q</i>, or the member type named <i>Id</i> within <i>Q</i> is not accessible <a href="names.html#104285">(&#167;6.6)</a>, or <i>Id</i> names more than one member type within <i>Q</i>, then a compile-time error occurs. <p>
<a name="32816"></a>
<p>The example:</p>
<blockquote><pre>package wnj.test;
class Test {
        public static void main(String[] args) {
                java.util.Date date =
                        new java.util.Date(System.currentTimeMillis());
                System.out.println(date.toLocaleString());
        }
}
</pre></blockquote><a name="21797"></a>
produced the following output the first time it was run:<p>
<blockquote><pre>Sun Jan 21 22:56:29 1996
</pre></blockquote><a name="21799"></a>
In this example the name <code>java.util.Date</code> must denote a type, so we first use the procedure recursively to determine if <code>java.util</code> is an accessible type or a package, which it is, and then look to see if the type <code>Date</code> is accessible in this package.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="129227"></a>
 <p>
<a name="129228"></a>
 Type names are distinct from type declaration specifiers <a href="typesValues.html#9317">(&#167;4.3)</a>. A type name is always qualified by meas of another type name. In some cases, it is necessary to access an inner class that is a member of a parameterized type:<p>
<blockquote><pre>class GenericOuter&lt;T extends Number&gt; {
        public class Inner&lt;S extends Comparable&lt;S&gt;&gt; {
                        T getT() { return null;}
                        S getS() { return null;}
        }
};

GenericOuter&lt;Integer&gt;.Inner&lt;Double&gt; x1 = null;
Integer i = x1.getT();
Double d = x1.getS();
</pre></blockquote><a name="129236"></a>
If we accessed <code>Inner</code> by qualifying it with a type name, as in:<p>
<blockquote><pre>GenericOuter.Inner x2 = null;
</pre></blockquote><a name="129277"></a>
we would force its use as a raw type, losing type information. <p>
<hr>
<a name="129295"></a>
 <p>
<a name="129353"></a>
<p>
<a name="129350"></a>
<a name="6.5.6"></a>
<h3>6.5.6    Meaning of Expression Names</h3>
<a name="32767"></a>
The meaning of a name classified as an <i>ExpressionName</i> is determined as follows.<p>
<a name="22022"></a>
<a name="6.5.6.1"></a>
<h4>6.5.6.1    Simple Expression Names</h4>
<a name="22023"></a>
If an expression name consists of a single <i>Identifier</i>, then there must be exactly one visible declaration denoting either a local variable, parameter or field in scope at the point at which the the <i>Identifier</i> occurs. Otherwise, a compile-time error occurs.<p>
<a name="110822"></a>
If the declaration declares a final field, the meaning of the name is the value of that field. Otherwise, the meaning of the expression name is the variable declared by the declaration. <p>
<a name="60351"></a>
If the field is an instance variable <a href="classes.html#40898">(&#167;8.3)</a>, the expression name must appear within the declaration of an instance method <a href="classes.html#40420">(&#167;8.4)</a>, constructor <a href="classes.html#41652">(&#167;8.8)</a>, instance initializer <a href="classes.html#246032">(&#167;8.6)</a>, or instance variable initializer <a href="classes.html#38013">(&#167;8.3.2.2)</a>. If it appears within a <code>static</code> method <a href="classes.html#229128">(&#167;8.4.3.2)</a>, static initializer <a href="classes.html#39245">(&#167;8.7)</a>, or initializer for a <code>static</code> variable (<a href="classes.html#38010">&#167;8.3.2.1</a>, <a href="execution.html#44630">&#167;12.4.2</a>), then a compile-time error occurs.<p>
<a name="110834"></a>
The type of the expression name is the declared type of the field, local variable or parameter after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>.<p>
<a name="79966"></a>
In the example:<p>
<blockquote><pre>class Test {
        static int v;
        static final int f = 3;
        public static void main(String[] args) {
                int i;
                i = 1;
                v = 2;
                f = 33;                         // compile-time error
                System.out.println(i + " " + v + " " + f);
        }
}
</pre></blockquote><a name="22130"></a>
the names used as the left-hand-sides in the assignments to <code>i</code>, <code>v</code>, and <code>f</code> denote the local variable <code>i</code>, the field <code>v</code>, and the value of <code>f</code> (not the variable <code>f</code>, because <code>f</code> is a <code>final</code> variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:<p>
<blockquote><pre>1 2 3
</pre></blockquote><a name="22133"></a>
<a name="6.5.6.2"></a>
<h4>6.5.6.2    Qualified Expression Names</h4>
<a name="33085"></a>
If an expression name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a package name, a type name, or an expression name:<p>
<ul><a name="22747"></a>
<li>If <i>Q</i> is a package name, then a compile-time error occurs.
<a name="22294"></a>
<li>If <i>Q</i> is a type name that names a class type <a href="classes.html#328796">(&#167;8)</a>, then:
<ul>
<a name="22298"></a>
<li>If there is not exactly one accessible <a href="names.html#104285">(&#167;6.6)</a> member of the class type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22299"></a>
<li>Otherwise, if the single accessible member field is not a class variable (that is, it is not declared <code>static</code>), then a compile-time error occurs.
<a name="41289"></a>
<li>Otherwise, if the class variable is declared <code>final</code>, then <i>Q</i><code>.</code><i>Id</i> denotes the value of the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22303"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>. Note that this clause covers the use of enum constants <a href="classes.html#301020">(&#167;8.9)</a>, since these always have a corresponding <code>final</code> class variable.
</ul>
<a name="22145"></a>
<li>If <i>Q</i> is a type name that names an interface type <a href="interfaces.html#238678">(&#167;9)</a>, then:
<ul>
<a name="33167"></a>
<li>If there is not exactly one accessible <a href="names.html#104285">(&#167;6.6)</a> member of the interface type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="33169"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
</ul>
<a name="22165"></a>
<li>If <i>Q</i> is an expression name, let <i>T</i> be the type of the expression <i>Q</i>:
<ul>
<a name="22169"></a>
<li>If <i>T</i> is not a reference type, a compile-time error occurs.
<a name="33185"></a>
<li>If there is not exactly one accessible <a href="names.html#104285">(&#167;6.6)</a> member of the type <i>T</i> that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22170"></a>
<li>Otherwise, if this field is any of the following:
<ul>
<a name="33204"></a>
<li>A field of an interface type
<a name="33205"></a>
<li>A <code>final</code> field of a class type (which may be either a class variable or an instance variable)
<a name="33208"></a>
<li>The <code>final</code> field <code>length</code> of an array type
<p>
<a name="33211"></a>
then <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.<p>
</ul>
<a name="22173"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes a variable, the field <i>Id</i> of class <i>T</i>, which may be either a class variable or an instance variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the type of the field member after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>.
</ul></ul>
<a name="98602"></a>
<p>The example:</p>
<blockquote><pre>
class Point {
        int x, y;
        static int nPoints;
}
class Test {
        public static void main(String[] args) {
                int i = 0;
                i.x++;                  // compile-time error
                Point p = new Point();
                p.nPoints();            // compile-time error
        }
}
</pre></blockquote><a name="22187"></a>
encounters two compile-time errors, because the <code>int</code> variable <code>i</code> has no members, and because <code>nPoints</code> is not a method of class <code>Point</code>.<p>
<a name="129354"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="129355"></a>
<a name="129165"></a>
 <p>
<a name="129166"></a>
 Note that expression names may be qualified by type names, but not by types in general. A consequence is that it is not possible to access a class variable through a parameterized type<p>
<blockquote><pre>class Foo&lt;T&gt; {
        public static int classVar = 42;
}
Foo&lt;String&gt;.classVar = 91; // illegal
</pre></blockquote><a name="129174"></a>
Instead, one writes<p>
<blockquote><pre>Foo.classVar = 91;
</pre></blockquote><a name="129167"></a>
This does not restrict the language in any meaningful way. Type parameters may not be used in the types of static variables, and so the actual parameters of a parameterized type can never influence the type of a static variable. Therefore, no expressive power is lost. Technically, the type name <code>Foo</code> above is a raw type, but this use of raw types is harmless, and does not give rise to warnings<p>
<hr>
<a name="129168"></a>
 <p>
<a name="21652"></a>
<a name="6.5.7"></a>
<h3>6.5.7    Meaning of Method Names</h3>
<a name="32771"></a>
A <i>MethodName</i> can appear only in a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> or as an element name in an element-value pair <a href="interfaces.html#253695">(&#167;9.7)</a>. The meaning of a name classified as a <i>MethodName</i> is determined as follows.<p>
<a name="54512"></a>
<a name="6.5.7.1"></a>
<h4>6.5.7.1    Simple Method Names</h4>
<a name="129491"></a>
A simple method name may appear as the element name in an element-value pair. The <em>Identifier</em> in an <em>ElementValuePair</em> must be the simple name of one of the elements of the annotation type identified by <em>TypeName</em> in the containing annotation. Otherwise, a compile-time error occurs. (In other words, the identifier in an element-value pair must also be a method name in the interface identified by <em>TypeName</em>.) <p>
<a name="123679"></a>
Otherwise, a simple method name necessarily appears in the context of a method invocation expression. In that case, if a method name consists of a single <i>Identifier</i>, then <i>Identifier</i> is the method name to be used for method invocation. The <i>Identifier</i> must name at least one visible <a href="names.html#34133">(&#167;6.3.1)</a> method that is in scope at the point where the <i>Identifier</i> appear or a method imported by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> or static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> within the compilation unit within which the <i>Identifier</i> appears.<p>
<a name="104325"></a>
See <a href="expressions.html#20448">&#167;15.12</a> for further discussion of the interpretation of simple method names in method invocation expressions.<p>
<a name="54547"></a>
<a name="6.5.7.2"></a>
<h4>6.5.7.2    Qualified Method Names</h4>
<a name="104276"></a>
A qualified method name can only appear in the context of a method invocation expression. If a method name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a package name, a type name, or an expression name. If <i>Q</i> is a package name, then a compile-time error occurs. Otherwise, <i>Id</i> is the method name to be used for method invocation. If <i>Q</i> is a type name, then <i>Id</i> must name at least one <code>static</code> method of the type <i>Q</i>. If <i>Q</i> is an expression name, then let <i>T</i> be the type of the expression <i>Q</i>; <i>Id</i> must name at least one method of the type <i>T</i>. See <a href="expressions.html#20448">&#167;15.12</a> for further discussion of the interpretation of qualified method names in method invocation expressions.<p>
<a name="129185"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="129210"></a>
 Like expression names, method names may be qualified by type names, but not by types in general. The implications are similar to those for expression names as discussed in <a href="names.html#22133">&#167;6.5.6.2</a>.<p>
<hr>
<a name="129214"></a>
<a name="129211"></a>
<p>
<a name="104285"></a>
<a name="6.6"></a>
<h2>6.6    Access Control</h2>
<a name="33924"></a>
The Java programming language provides mechanisms for <i>access control</i>, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. If access is permitted, then the accessed entity is said to be <i>accessible</i>.<p>
<a name="104333"></a>
Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers. Qualified names are a means of access to members of packages and reference types; related means of access include field access expressions <a href="expressions.html#41267">(&#167;15.11)</a> and method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>. All three are syntactically similar in that a "<code>.</code>" token appears, preceded by some indication of a package, type, or expression having a type and followed by an <i>Identifier</i> that names a member of the package or type. These are collectively known as constructs for <i>qualified access</i>.<p>
<a name="104350"></a>
Access control applies to qualified access and to the invocation of constructors by class instance creation expressions <a href="expressions.html#41147">(&#167;15.9)</a> and explicit constructor invocations <a href="classes.html#229267">(&#167;8.8.7.1)</a>. Accessibility also effects inheritance of class members <a href="classes.html#21831">(&#167;8.2)</a>, including hiding and method overriding <a href="classes.html#227927">(&#167;8.4.8.1)</a>.<p>
<a name="102765"></a>
<a name="6.6.1"></a>
<h3>6.6.1    Determining Accessibility</h3>
<ul><a name="102769"></a>
<li>A package is always accessible.
<a name="102776"></a>
<li>If a class or interface type is declared <code>public</code>, then it may be accessed by any code, provided that the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> in which it is declared is observable. If a top level class or interface type is not declared <code>public</code>, then it may be accessed only from within the package in which it is declared.
<a name="106781"></a>
<li>An array type is accessible if and only if its element type is accessible.
<a name="62410"></a>
<li>A member (class, interface, field, or method) of a reference (class, interface, or array) type or a constructor of a class type is accessible only if the type is accessible and the member or constructor is declared to permit access:
<ul>
<a name="62795"></a>
<li>If the member or constructor is declared <code>public</code>, then access is permitted. All members of interfaces are implicitly <code>public</code>.
<a name="62561"></a>
<li>Otherwise, if the member or constructor is declared <code>protected</code>, then access is permitted only when one of the following is true:
<ul>
<ul>
<a name="62562"></a>
<li>Access to the member or constructor occurs from within the package containing the class in which the <code>protected</code> member or constructor is declared.
<a name="62452"></a>
<li>Access is correct as described in <a href="names.html#62587">&#167;6.6.2</a>.
</ul>
</ul>
<a name="62857"></a>
<li>Otherwise, if the member or constructor is declared <code>private</code>, then access is permitted if and only if it occurs within the body of the top level class <a href="packages.html#26783">(&#167;7.6)</a> that encloses the declaration of the member or constructor. 
<a name="62586"></a>
<li>Otherwise, we say there is default access, which is permitted only when the access occurs from within the package in which the type is declared.
</ul>
</ul><a name="62587"></a>
<a name="6.6.2"></a>
<h3>6.6.2    Details on protected Access</h3>
<a name="62638"></a>
A <code>protected</code> member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.<p>
<a name="60602"></a>
<a name="6.6.2.1"></a>
<h4>6.6.2.1    Access to a protected Member</h4>
<a name="104383"></a>
Let <i>C</i> be the class in which a <code>protected</code> member m is declared. Access is permitted only within the body of a subclass <i>S </i>of <i>C</i>. In addition, if <i>Id</i> denotes an instance field or instance method, then:<p>
<ul><a name="33946"></a>
<li>If the access is by a qualified name <i>Q</i><code>.</code><i>Id</i>, where <i>Q</i> is an <i>ExpressionName</i>, then the access is permitted if and only if the type of the expression <i>Q</i> is <i>S</i> or a subclass of <i>S</i>.
<a name="72727"></a>
<li>If the access is by a field access expression <i>E</i><code>.</code><i>Id</i>, where <i>E</i> is a <i>Primary</i> expression, or by a method invocation expression <i>E</i><code>.</code><i>Id</i><code>(</code>. . .<code>)</code>, where <i>E</i> is a <i>Primary</i> expression, then the access is permitted if and only if the type of <i>E</i> is <i>S</i> or a subclass of <i>S</i>.
</ul><a name="72728"></a>
<a name="6.6.2.2"></a>
<h4>6.6.2.2    Qualified Access to a protected Constructor</h4>
<a name="72596"></a>
Let <i>C</i> be the class in which a <code>protected</code> constructor is declared and let <i>S</i> be the innermost class in whose declaration the use of the <code>protected</code> constructor occurs. Then:<p>
<ul><a name="73445"></a>
<li>If the access is by a superclass constructor invocation <code>super(</code>. . .<code>)</code> or by a qualified superclass constructor invocation of the form <i>E.</i><code>super(. . .)</code>, where <i>E</i> is a <i>Primary</i> expression, then the access is permitted.
<a name="95698"></a>
<li>If the access is by an anonymous class instance creation expression of the form new <i>C</i><code>(. . .){...}</code> or by a qualified class instance creation expression of the form <i>E</i>.<code>new</code> <i>C</i><code>(. . .){...}</code>, where <i>E</i> is a<i> Primary</i> expression, then the access is permitted.
<a name="95700"></a>
<li>Otherwise, if the access is by a simple class instance creation expression of the form <code>new</code> <i>C</i><code>(</code>. . .<code>)</code> or by a qualified class instance creation expression of the form <i>E</i>.<code>new</code> <i>C</i><code>(. . .)</code>, where <i>E</i> is a <i>Primary </i>expression, then the access is not permitted. A <code>protected</code> constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) only from within the package in which it is defined.
</ul><a name="62666"></a>
<a name="6.6.3"></a>
<h3>6.6.3    An Example of Access Control</h3>
<a name="62647"></a>
For examples of access control, consider the two compilation units:<p>
<blockquote><pre>package points;
class PointVec { Point[] vec; }
</pre></blockquote><a name="33960"></a>
and:<p>
<blockquote><pre>package points;
public class Point {
        protected int x, y;
        public void move(int dx, int dy) { x += dx; y += dy; }
        public int getX() { return x; }
        public int getY() { return y; }
}
</pre></blockquote><a name="33968"></a>
which declare two class types in the package <code>points</code>:<p>
<ul><a name="33969"></a>
<li>The class type <code>PointVec</code> is not <code>public</code> and not part of the <code>public</code> interface of the package <code>points</code>, but rather can be used only by other classes in the package.
<a name="33970"></a>
<li>The class type <code>Point</code> is declared <code>public</code> and is available to other packages. It is part of the <code>public</code> interface of the package <code>points</code>.
<a name="33971"></a>
<li>The methods <code>move</code>, <code>getX</code>, and <code>getY</code> of the class <code>Point</code> are declared <code>public</code> and so are available to any code that uses an object of type <code>Point</code>.
<a name="33972"></a>
<li>The fields <code>x</code> and <code>y</code> are declared <code>protected</code> and are accessible outside the package <code>points</code> only in subclasses of class <code>Point,</code> and only when they are fields of objects that are being implemented by the code that is accessing them.
</ul><a name="33976"></a>
See <a href="names.html#36191">&#167;6.6.7</a> for an example of how the <code>protected</code> access modifier limits access. <p>
<a name="36060"></a>
<a name="6.6.4"></a>
<h3>6.6.4    Example: Access to public and Non-public Classes</h3>
<a name="36063"></a>
If a class lacks the <code>public</code> modifier, access to the class declaration is limited to the package in which it is declared <a href="names.html#104285">(&#167;6.6)</a>. In the example:<p>
<blockquote><pre>package points;
public class Point {
        public int x, y;
        public void move(int dx, int dy) { x += dx; y += dy; }
<a name="36080"></a>
<p>}</p>
class PointList {
        Point next, prev;
}
</pre></blockquote><a name="36084"></a>
two classes are declared in the compilation unit. The class <code>Point</code> is available outside the package <code>points</code>, while the class <code>PointList</code> is available for access only within the package. <p>
<a name="107165"></a>
<p>Thus a compilation unit in another package can access <code>points.Point</code>, either by using its fully qualified name:</p>
<blockquote><pre>package pointsUser;
class Test {
        public static void main(String[] args) {
                points.Point p = new points.Point();
                System.out.println(p.x + " " + p.y);
        }
}
</pre></blockquote><a name="36092"></a>
or by using a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> that mentions the fully qualified name, so that the simple name may be used thereafter:<p>
<blockquote><pre>package pointsUser;
import points.Point;
class Test {
        public static void main(String[] args) {
                Point p = new Point();
                System.out.println(p.x + " " + p.y);
        }}
</pre></blockquote><a name="36104"></a>
However, this compilation unit cannot use or import <code>points.PointList</code>, which is not declared <code>public</code> and is therefore inaccessible outside package <code>points</code>.<p>
<a name="36154"></a>
<a name="6.6.5"></a>
<h3>6.6.5    Example: Default-Access Fields, Methods, and Constructors</h3>
<a name="36155"></a>
If none of the access modifiers <code>public</code>, <code>protected</code>, or <code>private</code> are specified, a class member or constructor is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package. <p>
<a name="107169"></a>
<p>If a <code>public</code> class has a method or constructor with default access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.</p>
<a name="60607"></a>
<p>For example, if we have:</p>
<blockquote><pre>package points;
public class Point {
        public int x, y;
        void move(int dx, int dy) { x += dx; y += dy; }
        public void moveAlso(int dx, int dy) { move(dx, dy); }
}
</pre></blockquote><a name="36161"></a>
then a subclass in another package may declare an unrelated <code>move</code> method, with the same signature <a href="classes.html#38649">(&#167;8.4.2)</a> and return type. Because the original <code>move</code> method is not accessible from package <code>morepoints</code>, <code>super</code> may not be used:<p>
<blockquote><pre>package morepoints;
public class PlusPoint extends points.Point {
        public void move(int dx, int dy) {
                super.move(dx, dy);                                                             // compile-time error
                moveAlso(dx, dy);
        }
}
</pre></blockquote><a name="61629"></a>
Because move of <code>Point</code> is not overridden by <code>move</code> in <code>PlusPoint</code>, the method <code>moveAlso</code> in <code>Point</code> never calls the method move in <code>PlusPoint</code>.<p>
<a name="61639"></a>
<p>Thus if you delete the <code>super.move</code> call from <code>PlusPoint</code> and execute the test program:</p>
<blockquote><pre>import points.Point;
import morepoints.PlusPoint;
class Test {
    public static void main(String[] args) {
        PlusPoint pp = new PlusPoint();
        pp.move(1, 1);
<a name="61648"></a>
<p>  }</p>
}
</pre></blockquote><a name="61640"></a>
it terminates normally. If move of <code>Point</code> were overridden by <code>move</code> in <code>PlusPoint</code>, then this program would recurse infinitely, until a <code>StackoverflowError</code> occurred.<p>
<a name="36250"></a>
<a name="6.6.6"></a>
<h3>6.6.6    Example: public Fields, Methods, and Constructors</h3>
<a name="36251"></a>
A <code>public</code> class member or constructor is accessible throughout the package where it is declared and from any other package, provided the package in which it is declared is observable <a href="packages.html#13180">(&#167;7.4.3)</a>. For example, in the compilation unit:<p>
<blockquote><pre>package points;
public class Point {
        int x, y;
        public void move(int dx, int dy) {
                x += dx; y += dy;
                moves++;
        }
        public static int moves = 0;
}
</pre></blockquote><a name="36189"></a>
the <code>public</code> class <code>Point</code> has as <code>public</code> members the <code>move</code> method and the <code>moves</code> field. These <code>public</code> members are accessible to any other package that has access to package <code>points</code>. The fields <code>x</code> and <code>y</code> are not <code>public</code> and therefore are accessible only from within the package <code>points</code>.<p>
<a name="36191"></a>
<a name="6.6.7"></a>
<h3>6.6.7    Example: protected Fields, Methods, and Constructors</h3>
<a name="36201"></a>
Consider this example, where the <code>points</code> package declares:<p>
<blockquote><pre>package points;
public class Point {
        protected int x, y;
        void warp(threePoint.Point3d a) {
                if (a.z &gt; 0)         // compile-time error: cannot access a.z
                        a.delta(this);
        }
}
</pre></blockquote><a name="36204"></a>
and the <code>threePoint</code> package declares:<p>
<blockquote><pre>package threePoint;
import points.Point;
public class Point3d extends Point {
        protected int z;
        public void delta(Point p) {
                p.x += this.x;          // compile-time error: cannot access p.x
                p.y += this.y;          // compile-time error: cannot access p.y

        }
        public void delta3d(Point3d q) {
                q.x += this.x;
                q.y += this.y;
                q.z += this.z;
        }
}
</pre></blockquote><a name="36210"></a>
which defines a class <code>Point3d</code>. A compile-time error occurs in the method <code>delta </code>here: it cannot access the protected members <code>x</code> and <code>y</code> of its parameter <code>p</code>, because while <code>Point3d</code> (the class in which the references to fields <code>x</code> and <code>y</code> occur) is a subclass of <code>Point</code> (the class in which <code>x</code> and <code>y</code> are declared), it is not involved in the implementation of a <code>Point</code> (the type of the parameter <code>p</code>). The method <code>delta3d</code> can access the protected members of its parameter <code>q</code>, because the class <code>Point3d</code> is a subclass of <code>Point</code> and is involved in the implementation of a <code>Point3d</code>.<p>
<a name="36214"></a>
<p>The method <code>delta</code> could try to cast (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>) its parameter to be a <code>Point3d</code>, but this cast would fail, causing an exception, if the class of <code>p</code> at run time were not <code>Point3d</code>.</p>
<a name="61715"></a>
<p>A compile-time error also occurs in the method warp: it cannot access the protected member <code>z</code> of its parameter <code>a</code>, because while the class <code>Point</code> (the class in which the reference to field <code>z</code> occurs) is involved in the implementation of a <code>Point3d</code> (the type of the parameter <code>a</code>), it is not a subclass of <code>Point3d</code> (the class in which <code>z</code> is declared). </p>
<a name="36233"></a>
<a name="6.6.8"></a>
<h3>6.6.8    Example: private Fields, Methods, and Constructors</h3>
<a name="36235"></a>
<code>A</code> <code>private</code> class member or constructor is accessible only within the body of the top level class <a href="packages.html#26783">(&#167;7.6)</a> that encloses the declaration of the member or constructor. It is not inherited by subclasses. In the example:<p>
<blockquote><pre>class Point {
        Point() { setMasterID(); }
        int x, y;
        private int ID;
        private static int masterID = 0;
        private void setMasterID() { ID = masterID++; }
}
</pre></blockquote><a name="36243"></a>
the <code>private</code> members <code>ID,</code> m<code>asterID</code>, and <code>setMasterID</code> may be used only within the body of class <code>Point</code>. They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of <code>Point</code>.<p>
<a name="62528"></a>
<p>See <a href="classes.html#229266">&#167;8.8.8</a> for an example that uses a <code>private</code> constructor.</p>
<a name="25430"></a>
<a name="6.7"></a>
<h2>6.7    Fully Qualified Names and Canonical Names</h2>
<a name="24074"></a>
Every package, top level class, top level interface, and primitive type has a <i>fully qualified name</i>. An array type has a fully qualified name if and only if its element type has a fully qualified name.<p>
<ul><a name="9478"></a>
<li>The fully qualified name of a primitive type is the keyword for that primitive type, namely <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>.
<a name="33330"></a>
<li>The fully qualified name of a named package that is not a subpackage of a named package is its simple name.
<a name="33332"></a>
<li>The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by "<code>.</code>", followed by the simple (member) name of the subpackage.
<a name="28912"></a>
<li>The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.
<a name="33340"></a>
<li>The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by "<code>.</code>", followed by the simple name of the class or interface.
<a name="71701"></a>
<li>A member class or member interface <i>M</i> of another class <i>C</i> has a fully qualified name if and only if <i>C</i> has a fully qualified name. In that case, the fully qualified name of <i>M</i> consists of the fully qualified name of <i>C</i>, followed by ".", followed by the simple name of <i>M</i>.
<a name="79979"></a>
<li>The fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "<code>[]</code>".
</ul><a name="79984"></a>
Examples:<p>
<ul><a name="79981"></a>
<li>The fully qualified name of the type <code>long</code> is "<code>long</code>".
<a name="12351"></a>
<li>The fully qualified name of the package <code>java.lang</code> is "<code>java.lang</code>" because it is subpackage <code>lang</code> of package <code>java</code>.
<a name="33392"></a>
<li>The fully qualified name of the class <code>Object</code>, which is defined in the package <code>java.lang</code>, is "<code>java.lang.Object</code>".
<a name="33394"></a>
<li>The fully qualified name of the interface <code>Enumeration</code>, which is defined in the package <code>java.util</code>, is "<code>java.util.Enumeration</code>".
<a name="33378"></a>
<li>The fully qualified name of the type "array of <code>double</code>" is "<code>double[]</code>".
<a name="33380"></a>
<li>The fully qualified name of the type "array of array of array of array of <code>String</code>" is "<code>java.lang.String[][][][]</code>".
</ul><a name="12352"></a>
In the example:<p>
<blockquote><pre>package points;
class Point { int x, y; }
class PointVec {
        Point[] vec;
}
</pre></blockquote><a name="73301"></a>
the fully qualified name of the type <code>Point</code> is "<code>points.Point</code>"; the fully qualified name of the type <code>PointVec</code> is "<code>points.PointVec</code>"; and the fully qualified name of the type of the field <code>vec</code> of class <code>PointVec</code> is "<code>points.Point[]</code>".<p>
<a name="73354"></a>
Every package, top level class, top level interface, and primitive type has a <i>canonical name</i>. An array type has a canonical name if and only if its element type has a canonical name. A member class or member interface <i>M</i> declared in another class <i>C</i> has a canonical name if and only if <i>C</i> has a canonical name. In that case, the canonical name of <i>M</i> consists of the canonical name of <i>C</i>, followed by ".", followed by the simple name of <i>M</i>. For every package, top level class, top level interface and primitive type, the canonical name is the same as the fully qualified name. The canonical name of an array type is defined only when the component type of the array has a canonical name. In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by "<code>[]</code>".<p>
<a name="81303"></a>
<p>The difference between a fully qualified name and a canonical name can be seen in examples such as:</p>
<blockquote><pre>package p;
class O1 { class I{}}
class O2 extends O1{};

</pre></blockquote><a name="81324"></a>
In this example both <code>p.O1.I</code> and <code>p.O2.I</code> are fully qualified names that denote the same class, but only <code>p.O1.I</code> is its canonical name.<p>
<a name="73307"></a>
<a name="6.8"></a>
<h2>6.8    Naming Conventions</h2>
<a name="9218"></a>
The class libraries of the Java platform attempt to use, whenever possible, names chosen according to the conventions presented here. These conventions help to make code more readable and avoid certain kinds of name conflicts.<p>
<a name="34468"></a>
<p>We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the <code>sin</code> and <code>cos</code> methods of the class <code>java.lang.Math</code> have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.</p>
<a name="9184"></a>
<a name="6.8.1"></a>
<h3>6.8.1    Package Names</h3>
<a name="9253"></a>
Names of packages that are to be made widely available should be formed as described in <a href="packages.html#40169">&#167;7.7</a>. Such names are always qualified names whose first identifier consists of two or three lowercase letters that name an Internet domain, such as <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, <code>org</code>, or a two-letter ISO country code such as <code>uk</code> or <code>jp</code>. Here are examples of hypothetical unique names that might be formed under this convention:<p>
<blockquote><pre>com.JavaSoft.jag.Oak
org.npr.pledge.driver
uk.ac.city.rugby.game
</pre></blockquote>
<a name="32841"></a>
<p>Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier <code>java</code>; package names that start with the identifier <code>java</code> are reserved by Sun for naming Java platform packages.</p>
<a name="81419"></a>
<p>When package names occur in expressions:</p>
<ul><a name="81420"></a>
<li>If a package name is obscured by a field declaration, then <code>import</code> declarations <a href="packages.html#70209">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="34379"></a>
<li>If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
</ul>
<a name="34365"></a>
<p>The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter. (The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.)</p>
</ul><a name="29466"></a>
<a name="6.8.2"></a>
<h3>6.8.2    Class and Interface Type Names</h3>
<a name="32824"></a>
Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized. For example:<p>
<blockquote><pre><code>ClassLoader
</code><code>SecurityManager
</code><code>Thread
</code><code>Dictionary
</code>BufferedInputStream
</code>
</pre></blockquote>
<a name="9111"></a>
<p>Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces <code>java.io.DataInput</code> and <code>java.io.DataOutput</code>; or it may be an adjective describing a behavior, as for the interfaces <code>Runnable</code> and <code>Cloneable</code>.</p>
<a name="12992"></a>
<p>Obscuring involving class and interface type names is rare. Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.</p>
<a name="9322"></a>
<a name="6.8.3"></a>
<h3>6.8.3    Type Variable Names</h3>
<a name="124462"></a>
Type variable names should be pithy (single character if possible)  yet evocative, and should not include lower case letters.<p>
<a name="124585"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="124586"></a>
 This makes it easy to distinguish formal type parameters from ordinary classes and interfaces.<p>
 <hr>
<a name="124589"></a>
 <p>
<a name="124502"></a>
Container types should use the name <code>E</code> for their element type. Maps should use <code>K</code> for the type of their keys and <code>V</code> for the type of their values. The name <code>X</code> should be used for arbitrary exception types. We use <code>T</code> for type, whenever there isn't anything more specific about the type to distinguish it. <p>
<a name="124597"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="124598"></a>
 This is often the case in generic methods. <p>
<hr>
<a name="124599"></a>
 <p>
<a name="124596"></a>
If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor <code>T</code> in the alphabet, such as <code>S</code>. Alternately, it is acceptable to use numeric subscripts (e.g., <code>T1, T2</code>) to distinguish among the different type variables. In such cases, all the variables with the same prefix should be subscripted.<p>
<a name="124617"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="124600"></a>
 If a generic method appears inside a generic class, it's a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes.<p>
<hr>
<a name="124618"></a>
 <p>
 <hr>
<a name="124544"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="124603"></a>
 These conventions are illustrated in the code snippets below:<p>
<blockquote><pre>public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; { ... }
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; { ... }
public class ThreadLocal&lt;T&gt; { ... }
public interface Functor&lt;T, X extends Throwable&gt; {
    T eval() throws X;
}
</pre></blockquote>
<a name="124604"></a>
 <p>
 <hr>
<a name="124556"></a>
When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter.  The names mentioned above (<code>E, K, T, V, X</code>) should not be used for type parameters that do not fall into the designated categories.<p>
<a name="124451"></a>
<a name="6.8.4"></a>
<h3>6.8.4    Method Names</h3>
<a name="34563"></a>
Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized. Here are some additional specific conventions for method names:<p>
<ul><a name="34587"></a>
<li>Methods to <code>get</code> and <code>set</code> an attribute that might be thought of as a variable <i>V</i> should be named <code>get</code><i>V</i> and <code>set</code><i>V</i>. An example is the methods <code>getPriority</code> and <code>setPriority</code> of class <code>Thread</code>.
<a name="34594"></a>
<li>A method that returns the length of something should be named <code>length</code>, as in class <code>String</code>.
<a name="9341"></a>
<li>A method that tests a <code>boolean</code> condition <i>V</i> about an object should be named <code>is</code><i>V</i>. An example is the method <code>isInterrupted</code> of class <code>Thread</code>.
<a name="34650"></a>
<li>A method that converts its object to a particular format <i>F</i> should be named <code>to</code><i>F</i>. Examples are the method <code>toString</code> of class <code>Object</code> and the methods <code>toLocaleString</code> and <code>toGMTString</code> of class <code>java.util.Date</code>.
</ul><a name="34660"></a>
Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java Application Programming Interface classes, will make it easier to use.<p>
<a name="9384"></a>
<p>Method names cannot obscure or be obscured by other names <a href="names.html#21652">(&#167;6.5.7)</a>.</p>
<a name="9351"></a>
<a name="6.8.5"></a>
<h3>6.8.5    Field Names</h3>
<a name="32831"></a>
Names of fields that are not <code>final</code> should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. Note that well-designed classes have very few <code>public</code> or <code>protected</code> fields, except for fields that are constants (<code>final</code> <code>static</code> fields) <a href="names.html#9367">(&#167;6.8.6)</a>.<p>
<a name="56830"></a>
<p>Fields should have names that are nouns, noun phrases, or abbreviations for nouns. Examples of this convention are the fields <code>buf</code>, <code>pos</code>, and <code>count</code> of the class <code>java.io.ByteArrayInputStream</code> and the field <code>bytesTransferred</code> of the class <code>java.io.InterruptedIOException</code>.</p>
<a name="13055"></a>
<p>Obscuring involving field names is rare.</p>
<ul><a name="29526"></a>
<li>If a field name obscures a package name, then an <code>import</code> declaration <a href="packages.html#70209">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="13069"></a>
<li>If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class <a href="statements.html#247766">(&#167;14.3)</a>.
<a name="29539"></a>
<li>Field names cannot obscure method names.
<a name="9539"></a>
<li>If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
</ul><a name="9367"></a>
<a name="6.8.6"></a>
<h3>6.8.6    Constant Names</h3>
<a name="9368"></a>
The names of constants in interface types should be, and <code>final</code> variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore "<code>_</code>" characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech. Examples of names for constants include <code>MIN_VALUE</code>, <code>MAX_VALUE</code>, <code>MIN_RADIX</code>, and <code>MAX_RADIX</code> of the class <code>Character</code>.<p>
<a name="9563"></a>
<p>A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix, as in:</p>
<blockquote><pre>interface ProcessStates {
        int PS_RUNNING = 0;
        int PS_SUSPENDED = 1;
}
</pre></blockquote><a name="13087"></a>
Obscuring involving constant names is rare:<p>
<ul><a name="62840"></a>
<li>Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter.
<a name="62841"></a>
<li>Constant names cannot obscure method names, because they are distinguished syntactically.
</ul><a name="62552"></a>
<a name="6.8.7"></a>
<h3>6.8.7    Local Variable and Parameter Names</h3>
<a name="81404"></a>
Local variable and parameter names should be short, yet meaningful. They are often short sequences of lowercase letters that are not words. For example:<p>
<ul><a name="81405"></a>
<li>Acronyms, that is the first letter of a series of words, as in <code>cp</code> for a variable holding a reference to a <code>ColoredPoint</code>
<a name="12410"></a>
<li>Abbreviations, as in <code>buf</code> holding a pointer to a <code>buffer</code> of some kind
<a name="12434"></a>
<li>Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example:
<ul>
<a name="12435"></a>
<li><code>in</code> and <code>out</code>, whenever some kind of input and output are involved, patterned after the fields of <code>System</code>
<a name="12436"></a>
<li><code>off</code> and <code>len</code>, whenever an offset and length are involved, patterned after the parameters to the <code>read</code> and <code>write</code> methods of the interfaces <code>DataInput</code> and <code>DataOutput</code> of <code>java.io</code>
</ul>
</ul>
<a name="12367"></a>
<p>One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are:</p>
<ul>
<a name="9148"></a>
<li><code>b</code> for a <code>byte</code>
<a name="9149"></a>
<li><code>c</code> for a <code>char</code>
<a name="12485"></a>
<li><code>d</code> for a <code>double</code>
<a name="9150"></a>
<li><code>e</code> for an <code>Exception</code>
<a name="12479"></a>
<li><code>f</code> for a <code>float</code>
<a name="9151"></a>
<li><code>i</code>, <code>j</code>, and <code>k</code> for integers
<a name="12846"></a>
<li><code>l</code> for a <code>long</code>
<a name="9155"></a>
<li><code>o</code> for an <code>Object</code>
<a name="12475"></a>
<li><code>s</code> for a <code>String</code>
<a name="12474"></a>
<li><code>v</code> for an arbitrary value of some type
</ul>
<a name="34406"></a>
<p>Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names <a href="packages.html#40169">(&#167;7.7)</a>.</p>
<a name="65318"></a>
<a name="65358"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="conversions.html">Prev</a> | <a href="packages.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Packages</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="names.html">Prev</a> | <a href="classes.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="34412"></a>
<p><strong>
CHAPTER
 7 </strong></p>
<a name="60384"></a>
<h1>Packages</h1>
<hr><p>
<a name="61541"></a>
Programs are organized as sets of packages. Each package has its own set of names for types, which helps to prevent name conflicts. A top level type is accessible <a href="names.html#104285">(&#167;6.6)</a> outside the package that declares it only if the type is declared <code>public</code>.<p>
<a name="26517"></a>
The naming structure for packages is hierarchical <a href="packages.html#26535">(&#167;7.1)</a>. The members of a package are class and interface types <a href="packages.html#26783">(&#167;7.6)</a>, which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own.<p>
<a name="93733"></a>
A package can be stored in a file system <a href="packages.html#37546">(&#167;7.2.1)</a> or in a database <a href="packages.html#37739">(&#167;7.2.2)</a>. Packages that are stored in a file system may have certain constraints on the organization of their compilation units to allow a simple implementation to find classes easily.<p>
<a name="26522"></a>
A package consists of a number of compilation units <a href="packages.html#40031">(&#167;7.3)</a>. A compilation unit automatically has access to all types declared in its package and also automatically imports<em> </em>all of the public types declared in the predefined package <code>java.lang</code>.<p>
<a name="26526"></a>
<p>For small programs and casual development, a package can be unnamed <a href="packages.html#103097">(&#167;7.4.2)</a> or have a simple name, but if code is to be widely distributed, unique package names should be chosen <a href="packages.html#40169">(&#167;7.7)</a>. This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.</p>
<a name="26535"></a>
<a name="7.1"></a>
<h2>7.1    Package Members</h2>
<a name="103587"></a>
The members of a package are its subpackages and all the top level <a href="packages.html#26783">(&#167;7.6)</a> class types <a href="classes.html#29542">(&#167;8)</a> and top level interface types <a href="interfaces.html#29542">(&#167;9)</a> declared in all the compilation units <a href="packages.html#40031">(&#167;7.3)</a> of the package.<p>
<a name="85252"></a>
For example, in the Java Application Programming Interface:<p>
<ul><a name="37559"></a>
<li>The package <code>java</code> has subpackages <code>awt</code>, <code>applet</code>, <code>io</code>, <code>lang</code>, <code>net</code>, and <code>util</code>, but no compilation units.
<a name="37560"></a>
<li>The package <code>java.awt</code> has a subpackage named <code>image</code>, as well as a number of compilation units containing declarations of class and interface types.
</ul><a name="13127"></a>
If the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of a package is <i>P</i>, and <i>Q</i> is a subpackage of <i>P</i>, then <i>P</i>.<i>Q</i> is the fully qualified name of the subpackage.<p>
<a name="77109"></a>
A package may not contain two members of the same name, or a compile-time error results. <p>
<a name="77111"></a>
<p>Here are some examples:</p>
<ul><a name="37575"></a>
<li>Because the package <code>java.awt</code> has a subpackage <code>image</code>, it cannot (and does not) contain a declaration of a class or interface type named <code>image</code>.
<a name="73657"></a>
<li>If there is a package named <code>mouse</code> and a member type <code>Button</code> in that package (which then might be referred to as <code>mouse.Button</code>), then there cannot be any package with the fully qualified name <code>mouse.Button</code> or <code>mouse.Button.Click</code>.
<a name="103056"></a>
<li>If <code>com.sun.java.jag</code> is the fully qualified name of a type, then there cannot be any package whose fully qualified name is either <code>com.sun.java.jag</code> or <code>com.sun.java.jag.scrabble</code>.
</ul>
<a name="73659"></a>
<p>The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level type <a href="packages.html#26783">(&#167;7.6)</a> declared in that package. There is no special access relationship between a package named <code>oliver</code> and another package named <code>oliver.twist</code>, or between packages named <code>evelyn.wood</code> and <code>evelyn.waugh</code>. For example, the code in a package named <code>oliver.twist</code> has no better access to the types declared within package <code>oliver</code> than code in any other package.</p>
<a name="37758"></a>
<a name="7.2"></a>
<h2>7.2    Host Support for Packages</h2>
<a name="37780"></a>
Each host determines how packages, compilation units, and subpackages are created and stored, and which compilation units are observable <a href="packages.html#40031">(&#167;7.3)</a> in a particular compilation. <p>
<a name="89673"></a>
<p>The observability of compilation units in turn determines which packages are observable, and which packages are in scope.</p>
<a name="73467"></a>
<p>The packages may be stored in a local file system in simple implementations of the Java platform. Other implementations may use a distributed file system or some form of database to store source and/or binary code.</p>
<a name="37546"></a>
<a name="7.2.1"></a>
<h3>7.2.1    Storing Packages in a File System</h3>
<a name="37463"></a>
As an extremely simple example, all the packages and source and binary code on a system might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name. The directory might contain the following immediate subdirectories:<p>
<blockquote><pre>com
gls
jag
java
wnj
</pre></blockquote><a name="37477"></a>
where directory <code>java</code> would contain the Java Application Programming Interface packages; the directories <code>jag</code>, <code>gls</code>, and <code>wnj</code> might contain packages that three of the authors of this specification created for their personal use and to share with each other within this small group; and the directory <code>com</code> would contain packages procured from companies that used the conventions described in <a href="packages.html#40169">&#167;7.7</a> to generate unique names for their packages.<p>
<a name="37480"></a>
<p>Continuing the example, the directory <code>java</code> would contain, among others, the following subdirectories:</p>
<blockquote><pre>applet 
awt
io
lang
net
util
</pre></blockquote><a name="37490"></a>
corresponding to the packages <code>java.applet</code>, <code>java.awt</code>, <code>java.io</code>, <code>java.lang</code>, <code>java.net</code>, and <code>java.util</code> that are defined as part of the Java Application Programming Interface.<p>
<a name="37491"></a>
<p>Still continuing the example, if we were to look inside the directory <code>util</code>, we might see the following files:</p>
<blockquote><pre>
BitSet.java                             Observable.java
BitSet.class                            Observable.class
Date.java                               Observer.java
Date.class                              Observer.class
...
</pre></blockquote><a name="37466"></a>
where each of the <code>.java</code> files contains the source for a compilation unit <a href="packages.html#40031">(&#167;7.3)</a> that contains the definition of a class or interface whose binary compiled form is contained in the corresponding <code>.class</code> file.<p>
<a name="37599"></a>
<p>Under this simple organization of packages, an implementation of the Java platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components. </p>
<a name="91586"></a>
<p>For example, if this simple organization were used on a UNIX system, where the file name separator is <code>/</code>, the package name:</p>
<blockquote><pre>jag.scrabble.board
</pre></blockquote><a name="37601"></a>
would be transformed into the directory name:<p>
<blockquote><pre>jag/scrabble/board
</pre></blockquote><a name="37603"></a>
and:<p>
<blockquote><pre>com.sun.sunsoft.DOE
</pre></blockquote><a name="37605"></a>
would be transformed to the directory name:<p>
<blockquote><pre><code>com/sun/sunsoft/DOE
</code></pre></blockquote><a name="77903"></a>
<p>A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As a convention, the character can be escaped by using, say, the <code>@</code> character followed by four hexadecimal digits giving the numeric value of the character, as in the <code>\u</code><i>xxxx</i> escape <a href="lexical.html#100850">(&#167;3.3)</a>, so that the package name:</p>
<blockquote><pre>
children.activities.crafts.papierM\u00e2ch\u00e9
</pre></blockquote><a name="77910"></a>
which can also be written using full Unicode as:<p>
<blockquote><pre>children.activities.crafts.papierM&acirc;ch&eacute;
</pre></blockquote><a name="37616"></a>
might be mapped to the directory name:<p>
<blockquote><pre>children/activities/crafts/papierM@00e2ch@00e9
</pre></blockquote><a name="37618"></a>
If the <code>@</code> character is not a valid character in a file name for some given host file system, then some other character that is not valid in a identifier could be used instead.<p>
<a name="37739"></a>
<a name="7.2.2"></a>
<h3>7.2.2    Storing Packages in a Database</h3>
<a name="37740"></a>
A host system may store packages and their compilation units and subpackages in a database.<p>
<a name="85462"></a>
<p>Such a database must not impose the optional restrictions <a href="packages.html#26783">(&#167;7.6)</a> on compilation units in file-based implementations. For example, a system that uses a database to store packages may not enforce a maximum of one <code>public</code> class or interface per compilation unit.</p>
<a name="74243"></a>
Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.<p>
<a name="40031"></a>
<a name="7.3"></a>
<h2>7.3    Compilation Units</h2>
<a name="26594"></a>
<em>CompilationUnit </em>is the goal symbol <a href="grammars.html#40415">(&#167;2.1)</a> for the syntactic grammar <a href="grammars.html#151185">(&#167;2.3)</a> of Java programs. It is defined by the following productions:<p>
<blockquote><pre>
<em>CompilationUnit:
        PackageDeclaration<sub>opt</sub> ImportDeclarations<sub>opt</sub> TypeDeclarations<sub>opt</sub>
ImportDeclarations:
        ImportDeclaration
        ImportDeclarations ImportDeclaration

TypeDeclarations:
        TypeDeclaration
        TypeDeclarations TypeDeclaration
        </em>
</pre></blockquote><a name="24124"></a>
Types declared in different compilation units can depend on each other, circularly. A Java compiler must arrange to compile all such types at the same time.<p>
<a name="35022"></a>
A <em>compilation unit</em> consists of three parts, each of which is optional:<p>
<ul><a name="35029"></a>
<li>A <code>package</code> declaration <a href="packages.html#26619">(&#167;7.4)</a>, giving the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of the package to which the compilation unit belongs. A compilation unit that has no package declaration is part of an unnamed package <a href="packages.html#103097">(&#167;7.4.2)</a>.
<a name="35033"></a>
<li><code>import</code> declarations <a href="packages.html#70209">(&#167;7.5)</a> that allow types from other packages and static members of types to be referred to using their simple names
<a name="35037"></a>
<li>Top level type declarations <a href="packages.html#26783">(&#167;7.6)</a> of class and interface types
</ul><a name="70276"></a>
Which compilation units are <em>observable</em> is determined by the host system. However, all the compilation units of the package <code>java</code> and its subpackages <code>lang</code> and <code>io</code> must always be observable. The observability of a compilation unit influences the observability of its package <a href="packages.html#13180">(&#167;7.4.3)</a>.<p>
<a name="26614"></a>
Every compilation unit automatically and implicitly imports every <code>public</code> type name declared by the predefined package <code>java.lang</code>, so that the names of all those types are available as simple names, as described in <a href="packages.html#93721">&#167;7.5.5</a>.<p>
<a name="26619"></a>
<a name="7.4"></a>
<h2>7.4    Package Declarations</h2>
<a name="35052"></a>
A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.<p>
<a name="26621"></a>
<a name="7.4.1"></a>
<h3>7.4.1    Named Packages</h3>
<a name="26626"></a>
A <em>package declaration</em> in a compilation unit specifies the name <a href="names.html#31692">(&#167;6.2)</a> of the package to which the compilation unit belongs.<p>
<blockquote><pre>
<em>PackageDeclaration:
        Annotations<sub>opt</sub> </em><code>package</code><em> PackageName ;</em>
</pre></blockquote><a name="26629"></a>
The keyword <code>package</code> may optionally be preceded by annotation modifiers <a href="interfaces.html#253695">(&#167;9.7)</a>. If an annotation <i>a</i> on a package declaration corresponds to an annotation type<i> T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.PACKAGE</code>, or a compile-time error occurs.<p>
<a name="97206"></a>
The package name mentioned in a package declaration must be the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of the package.<p>
<a name="97186"></a>
<a name="7.4.1.1"></a>
<h4>7.4.1.1    Package Annotations</h4>
<a name="97192"></a>
Annotations may be used on package declarations, with the restriction that at most one annotated package declaration is permitted for a given package. <p>
<hr>
<a name="97373"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="97374"></a>
 The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation. The following scheme is strongly recommended for file-system-based implementations: The sole annotated package declaration, if it exists, is placed in a source file called <code>package-info.java</code> in the directory containing the source files for the package. This file does not contain the source for a class called package-info.java; indeed it would be illegal for it to do so, as package-info is not a legal identifier. Typically <code>package-info.java</code> contains only a package declaration, preceded immediately by the annotations on the package. While the file could technically contain the source code for one or more package-private classes, it would be very bad form. <p>
<a name="97193"></a>
It is recommended that <code>package-info.java</code>, if it is present, take the place of <code>package.html</code> for javadoc and other similar documentation generation systems. If this file is present, the documentation generation tool should look for the package documentation comment immediately preceding the (possibly annotated) package declaration in <code>package-info.java</code>. In this way, package-info.java becomes the sole repository for package level annotations and documentation. If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information. <p>
<hr>
<a name="97187"></a>
 <p>
<a name="103100"></a>
<p>
<a name="103097"></a>
<a name="7.4.2"></a>
<h3>7.4.2    Unnamed Packages</h3>
<a name="70410"></a>
A compilation unit that has no package declaration is part of an unnamed package. <p>
<a name="73463"></a>
<p>Note that an unnamed package cannot have subpackages, since the syntax of a package declaration always includes a reference to a named top level package.</p>
<a name="73468"></a>
As an example, the compilation unit:<p>
<blockquote><pre>class FirstCall {
        public static void main(String[] args) {
                System.out.println("Mr. Watson, come here. "
                                        + "I want you.");
        }
}
</pre></blockquote><a name="35114"></a>
defines a very simple compilation unit as part of an unnamed package.<p>
<a name="73470"></a>
An implementation of the Java platform must support at least one unnamed package; it may support more than one unnamed package but is not required to do so. Which compilation units are in each unnamed package is determined by the host system.<p>
<a name="73469"></a>
<p>In implementations of the Java platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the "current working directory." The precise meaning of "current working directory" depends on the host system.</p>
<a name="73471"></a>
<p>Unnamed packages are provided by the Java platform principally for convenience when developing small or temporary applications or when just beginning development.</p>
<a name="13180"></a>
<a name="7.4.3"></a>
<h3>7.4.3    Observability of a Package</h3>
<a name="70173"></a>
A package is <em>observable</em> if and only if either:<p>
<ul><a name="70174"></a>
<li>A compilation unit containing a declaration of the package is observable.
<a name="70175"></a>
<li>A subpackage of the package is observable.
<a name="89676"></a>
</ul>
<p>One can conclude from the rule above and from the requirements on observable compilation units, that the packages <code>java</code>, <code>java.lang</code>, and <code>java.io</code> are always observable.</p>
<a name="70172"></a>
<a name="7.4.4"></a>
<h3>7.4.4    Scope of a Package Declaration</h3>
<a name="103604"></a>
The scope of the declaration of an observable <a href="packages.html#13180">(&#167;7.4.3)</a> top level package is all observable compilation units <a href="packages.html#40031">(&#167;7.3)</a>. The declaration of a package that is not observable is never in scope. Subpackage declarations are never in scope.<p>
<a name="87388"></a>
<p>It follows that the package <code>java</code> is always in scope <a href="names.html#103228">(&#167;6.3)</a>.</p>
<a name="103625"></a>
Package declarations never shadow other declarations.<p>
<a name="70209"></a>
<a name="7.5"></a>
<h2>7.5    Import Declarations</h2>
<a name="92728"></a>
An <em>import declaration</em> allows a static member or a named type to be referred to by a simple name <a href="names.html#31692">(&#167;6.2)</a> that consists of a single identifier. Without the use of an appropriate <code>import</code> declaration, the only way to refer to a type declared in another package, or a static member of another type, is to use a fully qualified name <a href="names.html#25430">(&#167;6.7)</a>.<p>
<blockquote><pre>
<em>ImportDeclaration:
        SingleTypeImportDeclaration
        TypeImportOnDemandDeclaration   
        SingleStaticImportDeclaration   
        StaticImportOnDemandDeclaration
        </em>
</pre></blockquote><a name="99931"></a>
A single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> imports a single named type, by mentioning its canonical name <a href="names.html#25430">(&#167;6.7)</a>. <p>
<a name="96277"></a>
A type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> imports all the accessible <a href="names.html#104285">(&#167;6.6)</a> types of a named type or package as needed. It is a compile time error to import a type from the unnamed package. <p>
<a name="94659"></a>
A single static import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> imports all accessible static members with a given name from a type, by giving its canonical name.<p>
<a name="94662"></a>
A static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> imports all accessible static members of a named type as needed.<p>
<a name="103634"></a>
The scope of a type imported by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="103647"></a>
The scope of a member imported by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> or a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="69951"></a>
An <code>import</code> declaration makes types available by their simple names only within the compilation unit that actually contains the <code>import</code> declaration. The scope of the entities(s) it introduces specifically does not include the <code>package</code> statement, other <code>import</code> declarations in the current compilation unit, or other compilation units in the same package. See <a href="packages.html#24151">&#167;7.5.6</a> for an illustrative example.<p>
<a name="26699"></a>
<a name="7.5.1"></a>
<h3>7.5.1    Single-Type-Import Declaration</h3>
<a name="13275"></a>
A <em>single-type-import declaration </em>imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type import declaration appears.<p>
<blockquote><pre>
<em>SingleTypeImportDeclaration:
</em>   import<em> TypeName ;</em>
</pre></blockquote><a name="29086"></a>
The <em>TypeName</em> must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible <a href="names.html#104285">(&#167;6.6)</a> or a compile-time error occurs.<p>
<a name="103573"></a>
A single-type-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="103575"></a>
<li>any top level type named <i>n</i> declared in another compilation unit of <i>p</i>.
<a name="103576"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration in <i>c.</i>
<a name="103577"></a>
<li>any type named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>.
</ul><a name="103578"></a>
throughout <i>c.</i><p>
<a name="37971"></a>
<p>The example:</p>
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="98784"></a>
causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the type declaration <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed <a href="names.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.html#104058">(&#167;6.3.2)</a> by a declaration of a field, parameter, local variable, or nested type declaration with the same name.<p>
<a name="98792"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="98793"></a>
 Note that <code>Vector</code> is declared as a generic type. Once imported, the name <code>Vector</code> can be used without qualification in a parameterized type such as <code>Vector&lt;String&gt;,</code> or as the raw type <code>Vector.</code><p>
<a name="98794"></a>
This highlights a limitation of the <code>import</code> declaration. A type nested inside a generic type declaration can be imported, but its outer type is always erased.<p>
<hr>
<a name="98766"></a>
 <p>
<a name="103720"></a>
If two single-type-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored. If the type imported by the the single-type-import declaration is declared in the compilation unit that contains the import declaration, the import declaration is ignored. If a compilation unit contains both a single-static-import <a href="packages.html#26741">(&#167;7.5.3)</a> declaration that imports a type whose simple name is <i>n</i>, and a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> that imports a type whose simple name is <i>n</i>, a compile-time error occurs. <p>
<a name="103501"></a>
If another top level type with the same simple name is otherwise declared in the current compilation unit except by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> or a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a>, then a compile-time error occurs.<p>
<a name="97378"></a>
So the sample program:<p>
<blockquote><pre>import java.util.Vector;
class Vector { Object[] vec; }
</pre></blockquote><a name="29137"></a>
causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:<p>
<blockquote><pre>import java.util.Vector;
import myVector.Vector;
</pre></blockquote><a name="29140"></a>
where <code>myVector</code> is a package containing the compilation unit:<p>
<blockquote><pre>package myVector;
public class Vector { Object[] vec; }
</pre></blockquote><a name="73475"></a>
The compiler keeps track of types by their binary names <a href="binaryComp.html#44909">(&#167;13.1)</a>.<p>
<a name="60471"></a>
<p>Note that an import statement cannot import a subpackage, only a type. For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:</p>
<blockquote><pre>import java.util;              // incorrect: compile-time error
class Test { util.Random generator; }
</pre></blockquote><a name="26725"></a>
<a name="7.5.2"></a>
<h3>7.5.2    Type-Import-on-Demand Declaration</h3>
<a name="26727"></a>
A <em>type-import-on-demand declaration</em> allows all accessible <a href="names.html#104285">(&#167;6.6)</a> types declared in the type or package named by a canonical name to be imported as needed.<p>
<blockquote><pre>
<em>TypeImportOnDemandDeclaration:
        </em>import<em> PackageOrTypeName . * ;</em>
</pre></blockquote><a name="99324"></a>
It is a compile-time error for a type-import-on-demand declaration to name a type or package that is not accessible. Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package. All but one of these declarations are considered <i>redundant</i>; the effect is as if that type was imported only once.<p>
<a name="103752"></a>
If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand <a href="packages.html#26725">(&#167;7.5.2)</a> declaration that name the same type, the effect is as if the static member types of that type were imported only once.<p>
<a name="103759"></a>
<p>
<a name="94574"></a>
It is not a compile-time error to name the current package or <code>java.lang</code> in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.<p>
<a name="103680"></a>
A type-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="91265"></a>
The example:<p>
<blockquote><pre>import java.util.*;
</pre></blockquote><a name="35216"></a>
causes the simple names of all <code>public</code> types declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the type <code>Vector</code> in the package <code>java.util</code> in all places in the compilation unit where that type declaration is not shadowed <a href="names.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.html#104058">(&#167;6.3.2)</a>. The declaration might be shadowed by a single-type-import declaration of a type whose simple name is <code>Vector</code>; by a type named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces. The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector </code>(It would be unusual for any of these conditions to occur.)<p>
<a name="26741"></a>
<a name="7.5.3"></a>
<h3>7.5.3    Single Static Import Declaration</h3>
<a name="94141"></a>
A <em>single-static-import declaration </em>imports all accessible <a href="names.html#104285">(&#167;6.6)</a> static members with a given simple name from a type. This makes these static members available under their simple name in the class and interface declarations of the compilation unit in which the single-static import declaration appears.<p>
<blockquote><pre>
<em>SingleStaticImportDeclaration:
        </em>import static<em> TypeName . Identifier;</em>
</pre></blockquote><a name="93862"></a>
The <em>TypeName</em> must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible <a href="names.html#104285">(&#167;6.6)</a> or a compile-time error occurs. The Identifier must name at least one static member of the named type; a compile-time error occurs if there is no member of that name or if all of the named members are not accessible.<p>
<a name="103685"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a field named <i>n</i> shadows the declaration of any static field named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="103688"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a method named <i>n</i> with signature s shadows the declaration of any static method named <i>n</i> with signature <i>s </i>imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="103691"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="103693"></a>
<li>any static type named <i>n</i> imported by a static-import-on-demand declaration in <i>c.</i>
<a name="103700"></a>
<li>any top level type <a href="packages.html#26783">(&#167;7.6)</a> named <i>n</i> declared in another compilation unit <a href="packages.html#40031">(&#167;7.3)</a> of <i>p</i>.
<a name="103704"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> in <i>c</i>.
</ul><a name="103705"></a>
throughout <i>c.</i><p>
<a name="94681"></a>
Note that it is permissable for one single-static-import declaration to import several fields or types with the same name, or several methods with the same name and signature.<p>
<a name="103711"></a>
If a compilation unit contains both a single-static-import <a href="packages.html#26741">(&#167;7.5.3)</a> declaration that imports a type whose simple name is <i>n</i>, and a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> that imports a type whose simple name is <i>n</i>, a compile-time error occurs. <p>
<a name="93986"></a>
If a single-static-import declaration imports a type whose simple name is <i>n</i>, and the compilation unit also declares a top level type <a href="packages.html#26783">(&#167;7.6)</a> whose simple name is <i>n</i>, a compile-time error occurs.<p>
<a name="94114"></a>
<a name="7.5.4"></a>
<h3>7.5.4    Static-Import-on-Demand Declaration</h3>
<a name="94122"></a>
A <em>static-import-on-demand declaration</em> allows all accessible <a href="names.html#104285">(&#167;6.6)</a> static members declared in the type named by a canonical name to be imported as needed.<p>
<blockquote><pre>
<em>StaticImportOnDemandDeclaration:
        </em> import static<em> TypeName . * ;</em>
</pre></blockquote><a name="93770"></a>
It is a compile-time error for a static-import-on-demand declaration to name a type that does not exist or a type that is not accessible. Two or more static-import-on-demand declarations in the same compilation unit may name the same type or package; the effect is as if there was exactly one such declaration. Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.<p>
<a name="94775"></a>
Note that it is permissable for one static-import-on-demand declaration to import several fields or types with the same name, or several methods with the same name and signature.<p>
<a name="103726"></a>
If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand <a href="packages.html#26725">(&#167;7.5.2)</a> declaration that name the same type, the effect is as if the static member types of that type were imported only once.<p>
<a name="103733"></a>
<p>
<a name="103568"></a>
A static-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="103349"></a>
<p>
<a name="93757"></a>
<p>
<a name="93721"></a>
<a name="7.5.5"></a>
<h3>7.5.5    Automatic Imports</h3>
<a name="26743"></a>
Each compilation unit automatically imports all of the<em> </em>public type names declared in the predefined package<em> </em>java.lang, as if the declaration:<p>
<blockquote><pre>import java.lang.*;
</pre></blockquote><a name="26745"></a>
appeared at the beginning of each compilation unit, immediately following any <code>package</code> statement.<p>
<a name="103101"></a>
<p>
<a name="24151"></a>
<a name="7.5.6"></a>
<h3>7.5.6    A Strange Example</h3>
<a name="24152"></a>
Package names and type names are usually different under the naming conventions described in <a href="names.html#73307">&#167;6.8</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a <code>public</code> class whose <p>
<a name="103175"></a>
<p>
<a name="103176"></a>
name is <code>Mosquito</code>:<p>
<blockquote><pre>package Vector;
public class Mosquito { int capacity; }
</pre></blockquote><a name="24158"></a>
and then the compilation unit:<p>
<blockquote><pre>package strange.example;
import java.util.Vector;
import Vector.Mosquito;
class Test {
        public static void main(String[] args) {
                System.out.println(new Vector().getClass());
                System.out.println(new Mosquito().getClass());
        }
}
</pre></blockquote><a name="24170"></a>
the single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:<p>
<blockquote><pre>class java.util.Vector
class Vector.Mosquito
</pre></blockquote><a name="26783"></a>
<a name="7.6"></a>
<h2>7.6    Top Level Type Declarations</h2>
<a name="26790"></a>
A <em>top level type declaration</em> declares a top level class type <a href="classes.html#29542">(&#167;8)</a> or a top level interface type <a href="interfaces.html#238678">(&#167;9)</a>: <p>
<blockquote><pre>
<em>TypeDeclaration:
        ClassDeclaration
        InterfaceDeclaration
        ;</em>
</pre></blockquote><a name="70047"></a>
By default, the top level types declared in a package are accessible only within the compilation units of that package, but a type may be declared to be <code>public</code> to grant access to the type from code in other packages (<a href="names.html#104285">&#167;6.6</a>, <a href="classes.html#21613">&#167;8.1.1</a>, <a href="interfaces.html#235947">&#167;9.1.1</a>).<p>
<a name="103666"></a>
The scope of a top level type is all type declarations in the package in which the top level type is declared.<p>
<a name="103671"></a>
If a top level type named <i>T</i> is declared in a compilation unit of a package whose fully qualified name is <i>P</i>, then the fully qualified name of the type is <i>P</i>.<i>T</i>.<i> </i>If the type is declared in an unnamed package <a href="packages.html#103097">(&#167;7.4.2)</a>, then the type has the fully qualified name <i>T</i>.<p>
<a name="103452"></a>
<p>
<a name="103128"></a>
<p>
<a name="103129"></a>
Thus in the example:<p>
<blockquote><pre>package wnj.points;
class Point { int x, y; }
</pre></blockquote><a name="70050"></a>
the fully qualified name of class <code>Point</code> is <code>wnj.points.Point</code>. <p>
<a name="26802"></a>
An implementation of the Java platform must keep track of types within packages by their binary names <a href="binaryComp.html#44909">(&#167;13.1)</a>. Multiple ways of naming a type must be expanded to binary names to make sure that such names are understood as referring to the same type. <p>
<a name="73490"></a>
<p>For example, if a compilation unit contains the single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a>:</p>
<a name="103107"></a>
<p></p>
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="26807"></a>
<p>
<a name="103106"></a>
then within that compilation unit the simple name <code>Vector</code> and the fully qualified name <code>java.util.Vector</code> refer to the same type.<p>
<a name="73491"></a>
When packages are stored in a file system <a href="packages.html#37546">(&#167;7.2.1)</a>, the host system may choose to enforce the restriction that it is a compile-time error if a type is not found in a file under a name composed of the type name plus an extension (such as <code>.java</code> or <code>.jav</code>) if either of the following is true:<p>
<ul><a name="40155"></a>
<li>The type is referred to by code in other compilation units of the package in which the type is declared.
<a name="40159"></a>
<li>The type is declared <code>public</code> (and therefore is potentially accessible from code in other packages).
</ul><a name="40156"></a>
<p>
<a name="103105"></a>
This restriction implies that there must be at most one such type per compilation unit. This restriction makes it easy for a compiler for the Java programming language or an implementation of the Java virtual machine to find a named class within a package; for example, the source code for a <code>public</code> type <code>wet.sprocket.Toad</code> would be found in a file <code>Toad.java</code> in the directory <code>wet/sprocket</code>, and the corresponding object code would be found in the file <code>Toad.class</code> in the same directory.<p>
<a name="97383"></a>
<p>When packages are stored in a database <a href="packages.html#37739">(&#167;7.2.2)</a>, the host system must not impose such restrictions. In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is public or is referred to by code in other compilation units.</p>
<a name="103291"></a>
A compile-time error occurs if the name of a top level type appears as the name of any other top level class or interface type declared in the same package <a href="packages.html#26783">(&#167;7.6)</a>.<p>
<a name="103295"></a>
A compile-time error occurs if the name of a top level type is also declared as a type by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the type declaration.<p>
<a name="103304"></a>
<p>
<a name="103305"></a>
<p>
<a name="103306"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
</pre></blockquote><a name="103308"></a>
the class Point is declared in a compilation unit with no package statement, and thus Point is its fully qualified name, whereas in the example:<p>
<blockquote><pre>package vista;
class Point { int x, y; }
</pre></blockquote><a name="103311"></a>
the fully qualified name of the class Point is <code>vista.Point</code>. (The package name vista is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name <a href="packages.html#40169">(&#167;7.7)</a>.)<p>
<a name="103316"></a>
<p>In the example:</p>
<blockquote><pre>package test;
import java.util.Vector;
class Point {
</pre></blockquote><pre><a name="103320"></a>   int x, y;
</pre><blockquote><pre>}
interface Point {                                                                                       // compile-time error #1
        int getR();
        int getTheta();
}
class Vector { Point[] pts; }                                                                                   // compile-time error #2
</pre></blockquote><a name="103327"></a>
<p>
<a name="103328"></a>
the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an <code>interface</code> in the same package. A second error detected at compile time is the attempt to declare the name Vector both by a class type declaration and by a single-type-import declaration.<p>
<a name="103329"></a>
<p>Note, however, that it is not an error for the name of a class to also to name a type that otherwise might be imported by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the class declaration. In the example:</p>
<a name="103336"></a>
<p></p>
<blockquote><pre>package test;
import java.util.*;
class Vector { Point[] pts; }                                                                                   // not a compile-time error
</pre></blockquote><a name="103340"></a>
the declaration of the class <code>Vector</code> is permitted even though there is also a class <code>java.util.Vector</code>. Within this compilation unit, the simple name <code>Vector</code> refers to the class <code>test.Vector</code>, not to <code>java.util.Vector</code> (which can still be referred to by code within the compilation unit, but only by its fully qualified name).<p>
<a name="103116"></a>
<a name="103117"></a>
<p>
<a name="69810"></a>
<p>As another example, the compilation unit:</p>
<blockquote><pre>package points;
class Point {
        int x, y;               // coordinates
        PointColor color;       // color of this point
        Point next;             // next point with this color
        static int nPoints;
}
class PointColor {
        Point first;            // first point with this color
        PointColor(int color) {
                this.color = color;
        }
        private int color;      // color components
}
</pre></blockquote><a name="103120"></a>
defines two classes that use each other in the declarations of their class members. Because the class types <code>Point</code> and <code>PointColor</code> have all the type declarations in package points, including all those in the current compilation unit, as their scope, this example compiles correctly-that is, forward reference is not a problem.<p>
<a name="69901"></a>
It is a compile-time error if a top level type declaration contains any one of the following access modifiers: <code>protected</code>, <code>private</code> or <code>static</code>.<p>
<a name="103130"></a>
<p>
<a name="40169"></a>
<a name="7.7"></a>
<h2>7.7    Unique Package Names</h2>
<a name="37792"></a>
Developers should take steps to avoid the possibility of two published packages having the same name by choosing <em>unique package names</em> for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.<p>
<a name="37825"></a>
<p>If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create &#32;a situation that is difficult or impossible for the user or programmer to resolve. The class <code>ClassLoader</code> can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a na&iuml;ve program.</p>
<a name="26818"></a>
<p>You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as <code>sun.com</code>. You then reverse this name, component by component, to obtain, in this example, <code>com.sun</code>, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names.</p>
<a name="77945"></a>
<p>In some cases, the internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations:</p>
<ul><a name="77954"></a>
<li>If the domain name contains a hyphen, or any other special character not allowed in an identifier <a href="lexical.html#40625">(&#167;3.8)</a>, convert it into an underscore.
<a name="77968"></a>
<li>If any of the resulting package name components are keywords <a href="lexical.html#229308">(&#167;3.9)</a> then append underscore to them.
<a name="103096"></a>
<li>If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
<a name="26819"></a>
</ul>
<p>Such a convention might specify that certain directory name components be division, department, project, machine, or login names. Some possible examples:</p>
<blockquote><pre>com.sun.sunsoft.DOE
com.sun.java.jag.scrabble
com.apple.quicktime.v2
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder
</pre></blockquote><a name="91495"></a>
The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, currently <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, <code>org</code>, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166, 1981. For more information, refer to the documents stored at <code>ftp://rs.internic.net/rfc</code>, for example, <code>rfc920.txt</code> and <code>rfc1032.txt</code>.<p>
<a name="91496"></a>
<p>The name of a package is not meant to imply where the package is stored within the Internet; for example, a package named <code>edu.cmu.cs.bovik.cheese</code> is not necessarily obtainable from Internet address <code>cmu.edu</code> or from <code>cs.cmu.edu</code> or from <code>bovik.cs.cmu.edu</code>. The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.</p>
<a name="60426"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="names.html">Prev</a> | <a href="classes.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>

<html>
<head>
<title> Classes</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="packages.html">Prev</a> | <a href="interfaces.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="328796"></a>
<p><strong>
CHAPTER
 8 </strong></p>
<a name="328799"></a>
<h1>Classes</h1>
<hr><p>
<a name="228205"></a>
Class declarations define new reference types and describe how they are implemented <a href="classes.html#15372">(&#167;8.1)</a>.<p>
<a name="246201"></a>
A <i>nested class</i> is any class whose declaration occurs within the body of another class or interface. A <i>top level class</i> is a class that is not a nested class.<p>
<a name="246214"></a>
This chapter discusses the common semantics of all classes-top level <a href="packages.html#26783">(&#167;7.6)</a> and nested (including member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), local classes <a href="statements.html#247766">(&#167;14.3)</a> and anonymous classes <a href="expressions.html#252986">(&#167;15.9.5)</a>). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs. <p>
<a name="35674"></a>
A named class may be declared <code>abstract</code> <a href="classes.html#34944">(&#167;8.1.1.1)</a> and must be declared <code>abstract</code> if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> <a href="classes.html#54727">(&#167;8.1.1.2)</a>, in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from other packages. Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class <a href="classes.html#262560">(&#167;8.1.4)</a> and may implement interfaces <a href="classes.html#34031">(&#167;8.1.5)</a>. Classes may be generic, that is, they may declare type variables <a href="typesValues.html#108850">(&#167;4.4)</a> whose bindings may differ among different instances of the class.<p>
<a name="303544"></a>
Classes may be decorated with annotations <a href="interfaces.html#253695">(&#167;9.7)</a> just like any other kind of declaration.<p>
<a name="273974"></a>
The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors <a href="classes.html#18988">(&#167;8.1.6)</a>. The scope <a href="names.html#103228">(&#167;6.3)</a> of a member <a href="classes.html#21831">(&#167;8.2)</a> is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers <a href="names.html#104285">(&#167;6.6)</a> <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members <a href="classes.html#21831">(&#167;8.2)</a>. Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.<p>
<a name="15807"></a>
Field declarations <a href="classes.html#40898">(&#167;8.3)</a> describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> <a href="classes.html#35962">(&#167;8.3.1.2)</a>, in which case it can be assigned to only once. Any field declaration may include an initializer.<p>
<a name="245981"></a>
Member class declarations <a href="classes.html#246026">(&#167;8.5)</a> describe nested classes that are members of the surrounding class. Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes <a href="classes.html#295574">(&#167;8.1.3)</a>.<p>
<a name="245982"></a>
Member interface declarations <a href="classes.html#246026">(&#167;8.5)</a> describe nested interfaces that are members of the surrounding class.<p>
<a name="35821"></a>
Method declarations <a href="classes.html#40420">(&#167;8.4)</a> describe code that may be invoked by method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>. A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of a class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> <a href="classes.html#11246">(&#167;8.4.3.3)</a>, in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code <a href="classes.html#31125">(&#167;8.4.3.4)</a>. A <code>synchronized</code> method <a href="classes.html#260369">(&#167;8.4.3.6)</a> automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a>, thus allowing its activities to be synchronized with those of other threads <a href="memory.html#61803">(&#167;17)</a>.<p>
<a name="227762"></a>
Method names may be overloaded <a href="classes.html#227768">(&#167;8.4.9)</a>.<p>
<a name="246235"></a>
Instance initializers <a href="classes.html#246032">(&#167;8.6)</a> are blocks of executable code that may be used to help initialize an instance when it is created <a href="expressions.html#41147">(&#167;15.9)</a>.<p>
<a name="35837"></a>
Static initializers <a href="classes.html#39245">(&#167;8.7)</a> are blocks of executable code that may be used to help initialize a class.<p>
<a name="259034"></a>
Constructors <a href="classes.html#41652">(&#167;8.8)</a> are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded <a href="classes.html#229266">(&#167;8.8.8)</a>.<p>
<a name="15372"></a>
<a name="8.1"></a>
<h2>8.1    Class Declaration</h2>
<a name="23643"></a>
A <em>class declaration</em> specifies a new named reference type. There are two kinds of class declarations - <i>normal class declarations</i> and <i>enum declarations</i>:<p>
<a name="301637"></a>
<blockquote><pre>
<em>ClassDeclaration:
		NormalClassDeclaration	
		EnumDeclaration

NormalClassDeclaration:
	ClassModifiers<sub>opt</sub> class Identifier TypeParameters<sub>opt</sub> Super<sub>opt</sub> Interfaces<sub>opt</sub> 
ClassBody
</em>
</pre></blockquote><a name="299212"></a>
The rules in this section apply to all class declarations unless this specification explicitly states otherwise. In many cases, special restrictions apply to enum declarations. Enum declarations are described in detail in <a href="classes.html#301020">&#167;8.9</a>.<p>
<a name="287266"></a>
The <em>Identifier</em> in a class declaration specifies the name of the class. A compile-time error occurs if a class has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="21613"></a>
<a name="8.1.1"></a>
<h3>8.1.1    Class Modifiers</h3>
<a name="54718"></a>
A class declaration may include <em>class modifiers</em>.<p>
<blockquote><pre>
<em>ClassModifiers:
	ClassModifier
	ClassModifiers ClassModifier

ClassModifier: one of
	Annotation </em>public&#32;protected&#32;private
	abstract&#32;static&#32;final&#32;strictfp 
</pre></blockquote><a name="258803"></a>
Not all modifiers are applicable to all kinds of class declarations. The access modifier <code>public</code> pertains only to top level classes <a href="packages.html#26783">(&#167;7.6)</a> and to member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), and is discussed in <a href="names.html#104285">&#167;6.6</a>, <a href="classes.html#246026">&#167;8.5</a> and <a href="interfaces.html#252566">&#167;9.5</a>. The access modifiers <code>protected</code> and <code>private</code> pertain only to member classes within a directly enclosing class declaration <a href="classes.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.html#247581">&#167;8.5.1</a>. The access modifier <code>static</code> pertains only to member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in a class declaration. <p>
<a name="302590"></a>
If an annotation <i>a</i> on a class declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.TYPE</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259039"></a>
<p>If two or more class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.</p>
<a name="34944"></a>
<a name="8.1.1.1"></a>
<h4>8.1.1.1    abstract Classes</h4>
<a name="301954"></a>
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. Normal classes may have <code>abstract</code> methods (<a href="classes.html#34484">&#167;8.4.3.1</a>, <a href="interfaces.html#78651">&#167;9.4</a>), that is methods that are declared but not yet implemented, only if they are <code>abstract</code> classes. If a normal class that is not <code>abstract</code> contains an <code>abstract</code> method, then a compile-time error occurs. <p>
<a name="329450"></a>
Enum types <a href="classes.html#301020">(&#167;8.9)</a> must not be declared abstract; doing so will result in a compile-time error. It is a compile-time error for an enum type <i>E</i> to have an abstract method <i>m</i> as a member unless <i>E</i> has one or more enum constants, and all of <i>E</i>'s enum constants have class bodies that provide concrete implementations of <i>m</i>. It is a compile-time error for the class body of an enum constant to declare an abstract method. <p>
<a name="329130"></a>
<p>
<a name="301945"></a>
A class <i>C</i> has <code>abstract</code> methods if any of the following is true:<p>
<ul><a name="36417"></a>
<li><i>C</i> explicitly contains a declaration of an <code>abstract</code> method <a href="classes.html#78188">(&#167;8.4.3)</a>.
<a name="250484"></a>
<li>Any of <i>C</i>'s superclasses has an <code>abstract</code> method and <i>C</i> neither declares nor inherits a method that implements <a href="classes.html#227927">(&#167;8.4.8.1)</a> it. 
<a name="14247"></a>
<li>A direct superinterface (<a href="classes.html#34031">&#167;8.1.5</a>) of <i>C</i> declares or inherits a method (which is therefore necessarily <code>abstract</code>) and <i>C</i> neither declares nor inherits a method that implements it.
<a name="259043"></a>
</ul>
<p>In the example:</p>
<a name="324064"></a>
<blockquote><pre>abstract class Point {
	int x = 1, y = 1;
	void move(int dx, int dy) {
		x += dx;
		y += dy;
		alert();
	}
	abstract void alert();
}
abstract class ColoredPoint extends Point {
	int color;
}

class SimplePoint extends Point {
	void alert() { }
}
</pre></blockquote><a name="259046"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared <code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides an implementation of <code>alert</code>, so it need not be <code>abstract</code>.<p>
<a name="259051"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>. <p>
<a name="259044"></a>
<p>Thus, continuing the example just shown, the statement:</p>
<blockquote><pre>	Point p = new Point();
</pre></blockquote><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not <code>abstract</code>, so the statement:<p>
<blockquote><pre>	Point p = new SimplePoint();
</pre></blockquote><a name="227782"></a>
would be correct.<p>
<a name="259056"></a>
<p>A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.</p>
<a name="292198"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="classes.html#38649">(&#167;8.4.2)</a> but incompatible return types. <p>
<a name="292194"></a>
<p>As an example, the declarations:</p>
<blockquote><pre>interface Colorable { void setColor(int color); }
abstract class Colored implements Colorable {
	abstract int setColor(int color);
}
</pre></blockquote><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class <code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, because the one in interface <code>Colorable</code> requires the same method to return no value, while the one in class <code>Colored</code> requires the same method to return a value of type <code>int</code> <a href="classes.html#40420">(&#167;8.4)</a>.<p>
<a name="36521"></a>
<p>A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="classes.html#16830">(&#167;8.8.10)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:</p>
<blockquote><pre>public final class Math {
	private Math() { }		// never instantiate this class
<em>	. . . declarations of class variables and methods . . .
</em><a name="259064"></a>
<p>}</p>
</pre></blockquote><a name="54727"></a>
<a name="8.1.1.2"></a>
<h4>8.1.1.2    final Classes</h4>
<a name="54729"></a>
A class can be declared <code>final</code> if its definition is complete and no subclasses are desired or required. A compile-time error occurs if the name of a <code>final</code> class appears in the <code>extends</code> clause <a href="classes.html#262560">(&#167;8.1.4)</a> of another <code>class</code> declaration; this implies that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a class could never be completed <a href="classes.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="259069"></a>
<p>Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="classes.html#227927">(&#167;8.4.8.1)</a>.</p>
<a name="251946"></a>
<a name="8.1.1.3"></a>
<h4>8.1.1.3    strictfp Classes</h4>
<a name="251947"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the class declaration be explicitly FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>. This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp. <p>
<a name="270918"></a>
<p>Note also that all <code>float</code> or <code>double </code>expressions within all variable initializers, instance initializers, static initializers and constructors of the class will also be explicitly FP-strict.</p>
<a name="299360"></a>
<a name="8.1.2"></a>
<h3>8.1.2    Generic Classes and Type Parameters</h3>
<a name="299365"></a>
A class is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>type parameters</i> of the class. The type parameter section follows the class name and is delimited by angle brackets. It defines one or more type variables that act as parameters. A generic class declaration defines a set of parameterized types, one for each possible invocation of the type parameter section. All of these parameterized types share the same class at runtime.  <p>
<a name="302719"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="299366"></a>
 For instance, executing the code <p>
<blockquote><pre>Vector&lt;String&gt; x = new Vector&lt;String&gt;(); 
Vector&lt;Integer&gt; y = new Vector&lt;Integer&gt;(); 
boolean b = x.getClass() == y.getClass();
</pre></blockquote><a name="299374"></a>
will result in the variable <code>b</code> holding the value <code>true</code>. <p>
<hr>
<a name="302720"></a>
 <p>
<blockquote><pre>
<em>TypeParameters ::= &lt; TypeParameterList &gt;
</em>
<em>TypeParameterList    ::= TypeParameterList , TypeParameter
</em>
                      |<em>  TypeParameter
</em></pre></blockquote><a name="303584"></a>
It is a compile-time error if a generic class is a direct or indirect subclass of <code>Throwable</code>.<p>
<a name="303591"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="303588"></a>
 This restriction is needed since the <code>catch</code> mechanism of the Java virtual machine works only with non-generic classes. <p>
<a name="300549"></a>
 <p>
<a name="329478"></a>
The scope of a class' type parameter is the entire declaration of the class including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="307296"></a>
It is a compile-time error to refer to a type parameter of a class <i>C</i> anywhere in the declaration of a static member of <i>C</i> or the declaration of a static member of any type declaration nested within <i>C</i>. It is a compile-time error to refer to a type parameter of a class <i>C</i> within a static initializer of <i>C</i> or any class nested within <i>C</i>.<p>
<a name="307842"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="299385"></a>
 Example: Mutually recursive type variable bounds.<p>
<blockquote><pre>interface ConvertibleTo&lt;T&gt; { 
   T convert(); 
} 
class ReprChange&lt;T implements ConvertibleTo&lt;S&gt;, 
                 S implements ConvertibleTo&lt;T&gt;&gt; { 
   T t; 
   void set(S s) { t = s.convert(); } 
   S get() { return t.convert(); } 
}
</pre></blockquote><a name="299400"></a>
<hr>
<p>
Parameterized class declarations can be nested inside other declarations.<p>
<hr>
<a name="302723"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="299401"></a>
 This is illustrated in the following example: <p>
<blockquote><pre>class Seq&lt;T&gt; { 
   T head; 
   Seq&lt;T&gt; tail; 
   Seq() { this(null, null); } 
   boolean isEmpty() { return tail == null; }
   Seq(T head, Seq&lt;T&gt; tail) { this.head = head; this.tail = tail; }
   class Zipper&lt;S&gt; { 
		Seq&lt;Pair&lt;T,S&gt;&gt; zip(Seq&lt;S&gt; that) { 
     			if (this.isEmpty() || that.isEmpty())
				return new Seq&lt;Pair&lt;T,S&gt;&gt;(); 
     			else 
				return new Seq&lt;Pair&lt;T,S&gt;&gt;( 
					new Pair&lt;T,S&gt;(this.head, that.head), 
					this.tail.zip(that.tail));
		}
   }
}
class Pair&lt;T, S&gt; {
	T fst; S Snd;
	Pair(T f, S s) {fst = f; snd = s;}
}

class Client {
	{
		Seq&lt;String&gt; strs = 
		new Seq&lt;String&gt;("a", new Seq&lt;String&gt;("b", 
					new Seq&lt;String&gt;()));
   		Seq&lt;Number&gt; nums = 
			new Seq&lt;Number&gt;(new Integer(1), 
					 new Seq&lt;Number&gt;(new Double(1.5), 
													new Seq&lt;Number&gt;()));
		Seq&lt;String&gt;.Zipper&lt;Number&gt; zipper = 
					strs.new Zipper&lt;Number&gt;();
		Seq&lt;Pair&lt;String,Number&gt;&gt; combined = zipper.zip(nums);
	}
}
<a name="302724"></a>
</pre></blockquote><a name="295574"></a>
<hr>
<a name="8.1.3"></a>
<h3>8.1.3    Inner Classes and Enclosing Instances</h3>
<a name="246255"></a>
An <i>inner class</i> is a nested class that is not explicitly or implicitly declared <code>static</code>. Inner classes may not declare static initializers <a href="classes.html#39245">(&#167;8.7)</a> or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields <a href="expressions.html#5313">(&#167;15.28)</a>.<p>
<a name="263434"></a>
<p>To illustrate these rules, consider the example below:</p>
<blockquote><pre>class HasStatic{
	static int j = 100;
}
class Outer{
	class Inner extends HasStatic{
		static final int x = 3;			// ok - compile-time constant
		static int y = 4; 			// compile-time error, an inner class
	}
	static class NestedButNotInner{
		static int z = 5; 			// ok, not an inner class
	}
	interface NeverInner{}				// interfaces are never inner
}
</pre></blockquote><a name="270924"></a>
Inner classes may inherit static members that are not compile-time constants even though they may not declare them. Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language. Member interfaces <a href="classes.html#246026">(&#167;8.5)</a> are always implicitly static so they are never considered to be inner classes. <p>
<a name="296300"></a>
A statement or expression <i>occurs in a static context</i> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement <a href="classes.html#78435">(&#167;8.8.7)</a>.<p>
<a name="247506"></a>
An inner class C is a <i>direct inner class of a class O</i> if <i>O</i> is the immediately lexically enclosing class of <i>C</i> and the declaration of <i>C</i> does not occur in a static context. A class <i>C</i> is an <i>inner class of class O</i> if it is either a direct inner class of <i>O</i> or an inner class of an inner class of <i>O</i>.<p>
<a name="255368"></a>
A class <i>O</i> is the <i>zeroth lexically enclosing class of itself</i>. A class <i>O</i> is the <i>nth lexically enclosing class of a class C</i> if it is the immediately enclosing class of the <i>n</i>-1st lexically enclosing class of <i>C</i>.<p>
<a name="246965"></a>
An instance <i>i</i> of a direct inner class <i>C</i> of a class <i>O</i> is associated with an instance of <i>O</i>, known as the <i>immediately enclosing instance of i</i>. The immediately enclosing instance of an object, if any, is determined when the object is created <a href="expressions.html#253028">(&#167;15.9.2)</a>.<p>
<a name="255371"></a>
An object <i>o</i> is the <i>zeroth lexically enclosing instance of itself</i>. An object <i>o</i> is the <i>nth lexically enclosing instance of an instance i</i> if it is the immediately enclosing instance of the <i>n</i>-1st lexically enclosing instance of <i>i</i>.
<p> 
<a name="247026"></a> When an inner class refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used. A blank final <a href="typesValues.html#10931">(&#167;4.12.4)</a> field of a lexically enclosing class may not be assigned within an inner class.<p>
<a name="250538"></a>
An instance of an inner class <i>I </i>whose declaration occurs in a static context has no lexically enclosing instances. However, if <i>I</i> is immediately declared within a static method or static initializer then <i>I</i> does have an <i>enclosing block</i>, which is the innermost block statement lexically enclosing the declaration of <i>I</i>.<p>
<a name="254910"></a>
Furthermore, for every superclass <i>S</i> of <i>C</i> which is itself a direct inner class of a class <i>SO</i>, there is an instance of <i>SO</i> associated with <i>i</i>, known as the <i>immediately enclosing instance of i with respect to S</i>. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.<p>
<a name="247496"></a>
Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared final. Any local variable, used but not declared in an inner class must be definitely assigned <a href="defAssign.html#25979">(&#167;16)</a> before the body of the inner class.<p>
<a name="247494"></a>
<p>Inner classes include local <a href="statements.html#247766">(&#167;14.3)</a>, anonymous <a href="expressions.html#252986">(&#167;15.9.5)</a> and non-static member classes <a href="classes.html#246026">(&#167;8.5)</a>. Here are some examples:</p>
<blockquote><pre>class Outer {
	int i = 100;
	static void classMethod() {
		final int l = 200;
		class LocalInStaticContext{
			int k = i; // compile-time error
			int m = l; // ok
		}
	}
	
void foo() {
	class Local { // a local class
		int j = i;
		}
	}
}
</pre></blockquote>
<a name="262528"></a>
<p>The declaration of class <code>LocalInStaticContext</code> occurs in a static context-within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are marked <code>final</code>).</p>
<a name="262541"></a>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class. So, for example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:</p>
<a name="324210"></a>
<blockquote><pre>
class WithDeepNesting{
	boolean toBe;
	WithDeepNesting(boolean b) { toBe = b;}
	class Nested {
		boolean theQuestion;
		class DeeplyNested {
			DeeplyNested(){
				theQuestion = toBe || !toBe;
			}
		}
	}
}
</pre></blockquote><a name="270930"></a>
Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).<p>
<a name="324211"></a>
<p>
<a name="324212"></a>
<p>
<a name="324213"></a>
<p>
<a name="262560"></a>
<a name="8.1.4"></a>
<h3>8.1.4    Superclasses and Subclasses</h3>
<a name="303827"></a>
The optional <code>extends</code> clause in a normal class declaration specifies the <em>direct superclass</em> of the current class.<p>
<blockquote><pre>
<em>Super:
	</em>extends <em>ClassType
	</em>
</pre></blockquote><a name="229540"></a>
The following is repeated from <a href="typesValues.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
ClassType:
	TypeDeclSpecifier TypeArguments<sub>opt</sub></em>
</pre></blockquote><a name="29813"></a>
A class is said to be a <em>direct subclass</em> of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The direct superclass of an enum type <code>E</code> is <code>Enum&lt;E&gt;</code>. The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, because it is the primordial class and has no direct superclass.<p>
<a name="303860"></a>
Given a (possibly generic) class declaration for <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i><img src="chars/gtequal.gif">0, <i>C</i><img src="chars/notequal.gif"><i>Object</i>, the direct superclass of the class type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> is the type given in the extends clause of the declaration of <i>C</i> if an extends clause is present, or <code>Object</code> otherwise.<p>
<a name="324340"></a>
Let <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i>&gt;0, be a generic class declaration. The direct superclass of the parameterized class type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> , where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, is <i>D&lt;U<sub>1</sub> theta , ..., U<sub>k</sub> theta&gt;</i>, where <i>D&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is the direct superclass of <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub></i>].<p>
<a name="303851"></a>
The <em>ClassType</em> must name an accessible <a href="names.html#104285">(&#167;6.6)</a> class type, or a compile-time error occurs. If the specified <em>ClassType </em>names a class that is <code>final</code> <a href="classes.html#54727">(&#167;8.1.1.2)</a>, then a compile-time error occurs; <code>final</code> classes are not allowed to have subclasses. It is a compile-time error if the <em>ClassType </em>names the class <code>Enum</code> or any invocation of it. If the TypeName is followed by any type arguments, it must be a correct invocation of the type declaration denoted by TypeName, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.<p>
<a name="34088"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; } // error
</pre></blockquote><a name="29322"></a>
the relationships are as follows:<p>
<ul><a name="29323"></a>
<li>The class <code>Point</code> is a direct subclass of <code>Object</code>.
<a name="29324"></a>
<li>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.
<a name="35258"></a>
<li>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.
<a name="35261"></a>
<li>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.
</ul><a name="270940"></a>
The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the <code>final</code> class <code>ColoredPoint</code>.<p>
<a name="303777"></a>
<p>
<a name="303780"></a>
The <em>subclass </em>relationship is the transitive closure of the direct subclass relationship. A class <i>A</i> is a subclass of class <i>C</i> if either of the following is true:<p>
<ul><a name="34080"></a>
<li><i>A</i> is the direct subclass of <i>C</i>.
<a name="34081"></a>
<li>There exists a class <i>B</i> such that <i>A</i> is a subclass of <i>B</i>, and <i>B</i> is a subclass of <i>C</i>, applying this definition recursively.
</ul><a name="34082"></a>
Class <i>C</i> is said to be a <em>superclass </em>of class <i>A</i> whenever <i>A</i> is a subclass of <i>C</i>.<p>
<a name="36594"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }
</pre></blockquote><a name="35276"></a>
the relationships are as follows:<p>
<ul><a name="36602"></a>
<li>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.
<a name="36604"></a>
<li>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="36611"></a>
<li>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.
<a name="36613"></a>
<li>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="271013"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.
<a name="303579"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.
</ul><a name="271016"></a>
A class <i>C</i> <i>directly depends</i> on a type <i>T</i> if <i>T </i>is mentioned in the <code>extends</code> or <code>implements</code> clause of <i>C</i> either as a superclass or superinterface, or as a qualifier of a superclass or superinterface name. A class <i>C</i> depends on a reference type <i>T</i> if any of the following conditions hold:<p>
<ul><a name="251985"></a>
<li><i>C</i> directly depends on <i>T</i>.
<a name="251987"></a>
<li><i>C</i> directly depends on an interface <i>I</i> that depends <a href="interfaces.html#253307">(&#167;9.1.3)</a> on <i>T</i>.
<a name="251993"></a>
<li><i>C</i> directly depends on a class <i>D</i> that depends on <i>T</i> (using this definition recursively).
</ul><a name="251995"></a>
It is a compile-time error if a class depends on itself.<p>
<a name="250505"></a>
<p>For example:</p>
<blockquote><pre>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
</pre></blockquote><a name="270956"></a>
causes a compile-time error.<p>
<a name="259094"></a>
If circularly declared classes are detected at run time, as classes are loaded <a href="execution.html#44459">(&#167;12.2)</a>, then a <code>ClassCircularityError</code> is thrown.<p>
<a name="34031"></a>
<a name="8.1.5"></a>
<h3>8.1.5    Superinterfaces</h3>
<a name="18953"></a>
The optional <code>implements</code> clause in a class declaration lists the names of interfaces that are <em>direct superinterfaces</em> of the class being declared:<p>
<blockquote><pre>
<em>Interfaces:</em>
	implements <em>InterfaceTypeList

InterfaceTypeList:
	InterfaceType
	InterfaceTypeList , InterfaceType
	</em>
</pre></blockquote><a name="229546"></a>
The following is repeated from <a href="typesValues.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<blockquote><pre><em>
InterfaceType:
	TypeDeclSpecifier TypeArguments<sub>opt</sub></em>
</pre></blockquote><a name="303892"></a>
Given a (possibly generic) class declaration for <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i><img src="chars/gtequal.gif">0, <i>C</i><img src="chars/notequal.gif"><i>Object</i>, the direct superinterfaces of the class type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> are the types given in the implements clause of the declaration of <i>C</i> if an implements clause is present.<p>
<a name="303903"></a>
Let <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i>&gt;0, be a generic class declaration. The direct superinterfaces of the parameterized class type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i>, where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, are all types <i>I&lt;U<sub>1</sub> theta , ..., U<sub>k</sub> theta&gt;</i>, where <i>I&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is a direct superinterface of <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub></i>].<p>
<a name="328872"></a>
Each <em>InterfaceType</em> must name an accessible <a href="names.html#104285">(&#167;6.6)</a> interface type, or a compile-time error occurs. If the <i>TypeName</i> is followed by any type arguments, it must be a correct invocation of the type declaration denoted by <i>TypeName</i>, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. <p>
<a name="328874"></a>
A compile-time error occurs if the same interface is mentioned as a direct superinterface two or more times in a single <code>implements</code> clause names.<p>
<a name="258838"></a>
<p>This is true even if the interface is named in different ways; for example, the code:</p>
<a name="328879"></a>
<p></p>
<blockquote><pre>class Redundant implements java.lang.Cloneable, Cloneable {
	int x;
}
</pre></blockquote><a name="259097"></a>
results in a compile-time error because the names java.lang.<code>Cloneable</code> and <code>Cloneable</code> refer to the same interface.<p>
<a name="31147"></a>
An interface type <i>I</i> is a <em>superinterface</em> of class type <i>C</i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i> has some direct superinterface <i>J</i> for which <i>I</i> is a superinterface, using the definition of "superinterface of an interface" given in <a href="interfaces.html#253307">&#167;9.1.3</a>.
<a name="34121"></a>
<li><i>I</i> is a superinterface of the direct superclass of <i>C</i>.
</ul><a name="29918"></a>
A class is said to <em>implement</em> all its superinterfaces.<p>
<a name="229105"></a>
<p>In the example:</p>
<blockquote><pre>public interface Colorable {
	void setColor(int color);
	int getColor();
}
public enum Finish {MATTE, GLOSSY}
public interface Paintable extends Colorable {
	void setFinish(Finish finish);
	Finish getFinish();
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	int color;
	public void setColor(int color) { this.color = color; }
	public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable
{
	Finish finish;
	public void setFinish(Finish finish) {
		this.finish = finish;
	}
	public Finish getFinish() { return finish; }
}
</pre></blockquote><a name="29896"></a>
the relationships are as follows:<p>
<ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="interfaces.html#253307">&#167;9.1.3</a>.
</ul><a name="29870"></a>
A class can have a superinterface in more than one way. In this example, the class <code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>. Unless the class being declared is <code>abstract</code>, the declarations of all the method members of each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="classes.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="230327"></a>
<p>Thus, the example:</p>
<blockquote><pre>interface Colorable {
	void setColor(int color);
	int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
	int color;
}
</pre></blockquote><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the interface <code>Colorable</code>.<p>
<a name="228059"></a>
<p>It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:</p>
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
	// You can tune a piano, but can you tuna fish?
	int getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return type that matches the method declared in interface <code>Fish</code> and also matches the method declared in interface <code>Piano</code>; it is considered to implement both.<p>
<a name="228080"></a>
<p>On the other hand, in a situation such as this:</p>
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
	// This declaration cannot be correct, no matter what type is used.
	public ??? getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="270984"></a>
It is impossible to declare a method named <code>getNumberOfScales</code> whose signature and return type are compatible with those of both the methods declared in interface <code>Fish</code> and in interface <code>StringBass</code>, because a class cannot have multiple methods with the same signature and different primitive return types <a href="classes.html#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement both interface <code>Fish</code> and interface <code>StringBass</code> <a href="classes.html#228745">(&#167;8.4.8)</a>.<p>
<a name="299564"></a>
A class may not at the same time be a subtype of two interface types which are different invocations of the same generic interface <a href="interfaces.html#78598">(&#167;9.1.2)</a>, or an invocation of a generic interface and a raw type naming that same generic interface.<p>
<hr>
<a name="299568"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="302710"></a>
 Here is an example of an illegal multiple inheritance of an interface:<p>
<blockquote><pre>class B implements I&lt;Integer&gt;
class C extends B implements I&lt;String&gt;
</pre></blockquote>
<p>
<a name="299572"></a>
 This requirement was introduced in order to support translation by type erasure <a href="typesValues.html#108979">(&#167;4.6)</a>.<p>
<a name="302711"></a>
<hr>
 <p>
<a name="18988"></a>
<a name="8.1.6"></a>
<h3>8.1.6    Class Body and Member Declarations</h3>
<a name="77979"></a>
A <em>class body</em> may contain declarations of members of the class, that is, fields <a href="classes.html#40898">(&#167;8.3)</a>, classes <a href="classes.html#246026">(&#167;8.5)</a>, interfaces <a href="classes.html#246026">(&#167;8.5)</a> and methods <a href="classes.html#40420">(&#167;8.4)</a>. A class body may also contain instance initializers <a href="classes.html#246032">(&#167;8.6)</a>, static initializers <a href="classes.html#39245">(&#167;8.7)</a>, and declarations of constructors <a href="classes.html#41652">(&#167;8.8)</a> for the class.<p>
<blockquote><pre>
<em>
ClassBody:
</em>	{ <em>ClassBodyDeclarations<sub>opt</sub></em> }<em>

ClassBodyDeclarations:
	ClassBodyDeclaration
	ClassBodyDeclarations ClassBodyDeclaration

ClassBodyDeclaration:
	ClassMemberDeclaration
	InstanceInitializer
	StaticInitializer
	ConstructorDeclaration

ClassMemberDeclaration:
	FieldDeclaration
	MethodDeclaration
	ClassDeclaration						
	InterfaceDeclaration
	;		</em> 
</pre></blockquote><a name="329405"></a>
The scope of a declaration of a member <i>m</i> declared in or inherited by a class type <i>C</i> is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="250255"></a>
If <i>C</i> itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as <i>m</i> in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member <i>m</i> declared or inherited in C shadows <a href="names.html#34133">(&#167;6.3.1)</a> the other definitions of the same kind and name. <p>
<a name="21831"></a>
<a name="8.2"></a>
<h2>8.2    Class Members</h2>
<a name="40942"></a>
The members of a class type are all of the following:<p>
<ul><a name="40946"></a>
<li>Members inherited from its direct superclass <a href="classes.html#262560">(&#167;8.1.4)</a>, except in class <code>Object</code>, which has no direct superclass
<a name="45862"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.html#34031">(&#167;8.1.5)</a>
<a name="45866"></a>
<li>Members declared in the body of the class <a href="classes.html#18988">(&#167;8.1.6)</a>
</ul><a name="30394"></a>
Members of a class that are declared <code>private</code> are not inherited by subclasses of that class. Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.<p>
<a name="306567"></a>
We use the phrase <i>the type of a member</i> to denote:<p>
<ul><a name="306568"></a>
<li>For a field, its type.
<a name="306572"></a>
<li>For a method, an ordered 3-tuple consisting of:
<ul>
<a name="306592"></a>
<li><b>argument types</b>: a list of the types of the arguments to the method member. 
<a name="306594"></a>
<li><b>return type</b>: the return type of the method member and the 
<a name="306595"></a>
<li><b>throws clause</b>: exception types declared in the throws clause of the method member.
</ul>
</ul><a name="302404"></a>
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.<p>
<a name="36731"></a>
<p>The example:</p>
<a name="324219"></a>
<p></p>
<blockquote><pre>class Point {
	int x, y;
	private Point() { reset(); }
	Point(int x, int y) { this.x = x; this.y = y; }
	private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
	int color;
	void clear() { reset(); }				// error
}
class Test {
	public static void main(String[] args) {
		ColoredPoint c = new ColoredPoint(0, 0);	// error
		c.reset();					// error
	}
}
</pre></blockquote><a name="14620"></a>
causes four compile-time errors:<p>
<ul><a name="16328"></a>
<li>An error occurs because <code>ColoredPoint</code> has no constructor declared with two integer parameters, as requested by the use in <code>main</code>. This illustrates the fact that <code>ColoredPoint</code> does not inherit the constructors of its superclass <code>Point</code>.
<a name="16329"></a>
<li>Another error occurs because <code>ColoredPoint</code> declares no constructors, and therefore a default constructor for it is automatically created <a href="classes.html#16823">(&#167;8.8.9)</a>, and this default constructor is equivalent to:
<blockquote><pre>	ColoredPoint() { super(); }
</pre></blockquote>
<a name="14625"></a>
<p>which invokes the constructor, with no arguments, for the direct superclass of the class <code>ColoredPoint</code>. The error is that the constructor for <code>Point</code> that takes no arguments is <code>private</code>, and therefore is not accessible outside the class <code>Point</code>, even through a superclass constructor invocation <a href="classes.html#78435">(&#167;8.8.7)</a>.</p>
</ul><a name="270990"></a>
<p>
Two more errors occur because the method <code>reset</code> of class <code>Point</code> is <code>private</code>, and therefore is not inherited by class <code>ColoredPoint</code>. The method invocations in method <code>clear</code> of class <code>ColoredPoint</code> and in method <code>main</code> of class <code>Test</code> are therefore not correct.<p>
<a name="30229"></a>
<a name="8.2.1"></a>
<h3>8.2.1    Examples of Inheritance</h3>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.<p>
<a name="40830"></a>
<a name="8.2.1.1"></a>
<h4>8.2.1.1    Example: Inheritance with Default Access</h4>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:<p>
<blockquote><pre>package points;
public class Point {
	int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="40836"></a>
and:<p>
<blockquote><pre>package points;
public class Point3d extends Point {
	int z;
	public void move(int dx, int dy, int dz) {
		x += dx; y += dy; z += dz;
	}
}
</pre></blockquote><a name="40844"></a>
and a third compilation unit, in another package, is:<p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		x += dx; y += dy; z += dz; w += dw; // compile-time errors
	}
}
</pre></blockquote><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.<p>
<a name="40853"></a>
<p>A better way to write the third compilation unit would be:</p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If <code>Point4d</code> is written in this way it will compile without errors.<p>
<a name="40862"></a>
<a name="8.2.1.2"></a>
<h4>8.2.1.2    Inheritance with public and protected</h4>
<a name="40863"></a>
Given the class <code>Point</code>:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	protected int useCount = 0;
	static protected int totalUseCount = 0;
	public void move(int dx, int dy) {
		x += dx; y += dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited in all subclasses of <code>Point</code>. <p>
<a name="292212"></a>
<p>Therefore, this test program, in another package, can be compiled successfully:</p>
<blockquote><pre>class Test extends points.Point {
	public void moveBack(int dx, int dy) {
		x -= dx; y -= dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40879"></a>
<a name="8.2.1.3"></a>
<h4>8.2.1.3    Inheritance with private</h4>
<a name="40880"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x, y;
	void move(int dx, int dy) {
		x += dx; y += dy; totalMoves++;
	}
	private static int totalMoves;
	void printMoves() { System.out.println(totalMoves); }
}
</pre></blockquote><a name="324221"></a>
<p>
<a name="324222"></a>
<p>
<blockquote><pre>class Point3d extends Point {
	int z;
	void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz; totalMoves++;
	}
}
</pre></blockquote><a name="40822"></a>
the class variable <code>totalMoves</code> can be used only within the class <code>Point</code>; it is not inherited by the subclass <code>Point3d</code>. A compile-time error occurs because method <code>move</code> of class <code>Point3d</code> tries to increment <code>totalMoves</code>.<p>
<a name="23530"></a>
<a name="8.2.1.4"></a>
<h4>8.2.1.4    Accessing Members of Inaccessible Classes</h4>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be available at run time to code outside the package in which it is declared by means a <code>public</code> superclass or superinterface. An instance of the class can be assigned to a variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the <code>public</code> superclass or superinterface. (In this situation, the method is necessarily declared <code>public</code>, even though it is declared in a class that is not <code>public</code>.)<p>
<a name="23519"></a>
<p>Consider the compilation unit:</p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public void move(int dx, int dy) {
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="36865"></a>
and another compilation unit of another package:<p>
<blockquote><pre>package morePoints;
class Point3d extends points.Point {
	public int z;
	public void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz;
	}
	public void move(int dx, int dy) {
		move(dx, dy, 0);
	}
}
</pre></blockquote><a name="324223"></a>
<p>
<blockquote><pre>public class OnePoint {
	public static points.Point getOne() { 
		return new Point3d(); 
	}
}
</pre></blockquote><a name="324231"></a>
<p>
<a name="324227"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is not available outside the package <code>morePoints</code>. The two argument version of method <code>move</code> could then be invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is <code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself be <code>public</code>, precisely so that situations such as this will work out correctly). The fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.<p>
<a name="36884"></a>
<p>While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. </p>
<a name="292218"></a>
<p>The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:</p>
<blockquote><pre>package morePoints;
public class Point4d extends Point3d {
	public int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="324232"></a>
<p>
<a name="270996"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be accessed by code in packages other than <code>morePoints</code>, through variables and expressions of the <code>public</code> type <code>Point4d</code>.<p>
<a name="324233"></a>
<p>
<a name="324234"></a>
<p>
<a name="324235"></a>
<p>
<a name="40898"></a>
<a name="8.3"></a>
<h2>8.3    Field Declarations</h2>
<a name="40823"></a>
The variables of a class type are introduced by <em>field declarations</em>:<p>
<blockquote><pre>
<em>
FieldDeclaration:
	FieldModifiers<sub>opt</sub> Type VariableDeclarators </em>;<em>

VariableDeclarators:
	VariableDeclarator
	VariableDeclarators , VariableDeclarator

VariableDeclarator:
	VariableDeclaratorId
	VariableDeclaratorId </em>=<em> VariableInitializer

VariableDeclaratorId:
	Identifier
	VariableDeclaratorId </em>[ ]<em>

VariableInitializer:
	Expression
	ArrayInitializer
</em>
</pre></blockquote><a name="78087"></a>
The <em>FieldModifiers</em> are described in <a href="classes.html#78091">&#167;8.3.1</a>. The <em>Identifier</em> in a <em>FieldDeclarator</em> may be used in a name to refer to the field. Fields are members; the scope <a href="names.html#103228">(&#167;6.3)</a> of a field declaration is specified in <a href="classes.html#18988">&#167;8.1.6</a>. More than one field may be declared in a single field declaration by using more than one declarator; the <em>FieldModifiers</em> and <em>Type</em> apply to all the declarators in the declaration. Variable declarations involving array types are discussed in <a href="arrays.html#25891">&#167;10.2</a>.<p>
<a name="29989"></a>
It is a compile-time error for the body of a class declaration to declare two fields with the same name. Methods, types, and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.html#106941">(&#167;6.5)</a>.<p>
<a name="36999"></a>
If the class declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class. The field declaration also shadows <a href="names.html#34133">(&#167;6.3.1)</a> declarations of any accessible fields in enclosing classes or interfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.<p>
<a name="38152"></a>
If a field declaration hides the declaration of another field, the two fields need not have the same type.<p>
<a name="38148"></a>
A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247092"></a>
<p>Note that a private field of a superclass might be accessible to a subclass (for example, if both classes are members of the same class). Nevertheless, a private field is never inherited by a subclass.</p>
<a name="37087"></a>
<p>It is possible for a class to inherit more than one field with the same name <a href="classes.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.</p>
<a name="37038"></a>
<p>There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<a name="37037"></a>
<p>A hidden field can be accessed by using a qualified name (if it is <code>static</code>) or by using a field access expression <a href="expressions.html#41267">(&#167;15.11)</a> that contains the keyword <code>super</code> or a cast to a superclass type. See <a href="expressions.html#20860">&#167;15.11.2</a> for discussion and an example.</p>
<a name="259125"></a>
<p>A value stored in a field of type <code>float</code> is always an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, a value stored in a field of type <code>double</code> is always an element of the double value set. It is not permitted for a field of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.</p>
<a name="78091"></a>
<a name="8.3.1"></a>
<h3>8.3.1    Field Modifiers</h3>
<blockquote><pre>
<em>FieldModifiers:
	FieldModifier
	FieldModifiers FieldModifier

FieldModifier: one of
	</em>Annotation public&#32;protected&#32;private
	static&#32;final&#32;transient&#32;volatile
</pre></blockquote><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302614"></a>
If an annotation <i>a</i> on a field declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.FIELD</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259130"></a>
<p>If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>FieldModifier</em>.</p>
<a name="37544"></a>
<a name="8.3.1.1"></a>
<h4>8.3.1.1    static Fields</h4>
<a name="230789"></a>
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A <code>static</code> field, sometimes called a <em>class variable</em>, is incarnated when the class is initialized <a href="execution.html#44557">(&#167;12.4)</a>.<p>
<a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <em>instance variable</em>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses. The example program:<p>
<blockquote><pre>class Point {
	int x, y, useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
class Test {
	public static void main(String[] args) {
		Point p = new Point(1,1);
		Point q = new Point(2,2);
		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
		System.out.println("(" + q.x + "," + q.y + ")");
		System.out.println(q.useCount);
		System.out.println(q.origin == Point.origin);
		System.out.println(q.origin.useCount);
	}
}
</pre></blockquote><a name="37584"></a>
prints:<p>
<blockquote><pre>(2,2)
0
true
1
</pre></blockquote><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields of <code>q</code>, because these fields are instance variables in distinct objects. In this example, the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in field access expressions <a href="expressions.html#41267">(&#167;15.11)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways of accessing the <code>origin</code> class variable access the same object, evidenced by the fact that the value of the reference equality expression <a href="expressions.html#236163">(&#167;15.21.3)</a>:<p>
<blockquote><pre><code>q.origin==Point.origin
</code></pre></blockquote><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:<p>
<blockquote><pre>p.origin.useCount++;
</pre></blockquote><a name="259135"></a>
causes the value of <code>q.origin.useCount</code> to be <code>1</code>; this is so because <code>p.origin</code> and <code>q.origin</code> refer to the same variable.<p>
<a name="35962"></a>
<a name="8.3.1.2"></a>
<h4>8.3.1.2    final Fields</h4>
<a name="246472"></a>
A field can be declared <code>final</code> <a href="typesValues.html#10931">(&#167;4.12.4)</a>. Both class and instance variables (<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.<p>
<a name="246476"></a>
It is a compile-time error if a blank final <a href="typesValues.html#10931">(&#167;4.12.4)</a> class variable is not definitely assigned <a href="defAssign.html#63310">(&#167;16.8)</a> by a static initializer <a href="classes.html#39245">(&#167;8.7)</a> of the class in which it is declared.<p>
<a name="246496"></a>
A blank final instance variable must be definitely assigned <a href="defAssign.html#56210">(&#167;16.9)</a> at the end of every constructor <a href="classes.html#41652">(&#167;8.8)</a> of the class in which it is declared; otherwise a compile-time error occurs. <p>
<a name="78119"></a>
<a name="8.3.1.3"></a>
<h4>8.3.1.3    transient Fields</h4>
<a name="37020"></a>
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent state of an object. <p>
<a name="258868"></a>
<p>If an instance of the class <code>Point</code>:</p>
<blockquote><pre>class Point {
	int x, y;
	transient float rho, theta;
}
</pre></blockquote><a name="259140"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> would be saved. This specification does not specify details of such services; see the specification of <code>java.io.Serializable</code> for an example of such a service.<p>
<a name="36930"></a>
<a name="8.3.1.4"></a>
<h4>8.3.1.4    volatile Fields</h4>
<a name="37715"></a>
As described in <a href="memory.html#61803">&#167;17</a>, the Java programming language allows threads to access shared variables.  As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.<p>
<a name="259149"></a>
<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.</p>
<a name="259153"></a>
A field may be declared <code>volatile</code>, in which case the Java memory model <a href="memory.html#61803">(&#167;17)</a> ensures that all threads see a consistent value for the variable.<p>
<a name="14790"></a>
<p>If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> times in all), and another thread repeatedly calls the method <code>two</code>:</p>
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the value of <code>i</code>, because the example includes no synchronization and, under the rules explained in <a href="memory.html#61803">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.<p>
<a name="37738"></a>
<p>One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="classes.html#260369">(&#167;8.4.3.6)</a>:</p>
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static synchronized void one() { i++; j++; }
	static synchronized void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.<p>
<a name="37789"></a>
<p>Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:</p>
<blockquote><pre>class Test {
	static volatile int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote>
<a name="259157"></a>
<p>This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for <code>j</code> is never greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the value observed for <code>i</code>, because method <code>one</code> might be executed many times between the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when method <code>two</code> fetches the value of <code>j</code>.</p>
<p><a name="14791"></a>
See <a href="memory.html#61803">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>
<a name="24510"></a>
<a name="8.3.2"></a>
<h3>8.3.2    Initialization of Fields</h3>
<a name="41082"></a>
If a field declarator contains a <em>variable initializer</em>, then it has the semantics of an assignment <a href="expressions.html#5281">(&#167;15.26)</a> to the declared variable, and:<p>
<ul><a name="37635"></a>
<li>If the declarator is for a class variable (that is, a <code>static</code> field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized <a href="execution.html#44557">(&#167;12.4)</a>.
<a name="37639"></a>
<li>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created <a href="execution.html#44670">(&#167;12.5)</a>. 
<a name="38002"></a>
<p>The example:</p>
</ul><blockquote><pre>class Point {
	int x = 1, y = 5;
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println(p.x + ", " + p.y);
	}
}
</pre></blockquote><a name="30363"></a>
produces the output:<p>
<blockquote><pre>1, 5
</pre></blockquote><a name="30378"></a>
because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.<p>
<a name="259166"></a>
Variable initializers are also used in local variable declaration statements <a href="statements.html#5920">(&#167;14.4)</a>, where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.<p>
<a name="38006"></a>
It is a compile-time error if the evaluation of a variable initializer for a <code>static</code> field of a named class (or of an interface) can complete abruptly with a checked exception <a href="exceptions.html#44121">(&#167;11.2)</a>.<p>
<a name="329518"></a>
It is compile-time error if an instance variable initializer of a named class can throw a checked exception unless that exception or one of its supertypes is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance variable initializer in an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="329198"></a>
<p>
<a name="38010"></a>
<a name="8.3.2.1"></a>
<h4>8.3.2.1    Initializers for Class Variables</h4>
<a name="37971"></a>
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="37934"></a>
If the keyword <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>) occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="259173"></a>
<p>One subtlety here is that, at run time, <code>static</code> variables that are <code>final</code> and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces <a href="interfaces.html#40720">(&#167;9.3.1)</a>. These variables are "constants" that will never be observed to have their default initial values <a href="typesValues.html#96595">(&#167;4.12.5)</a>, even by devious programs. See <a href="execution.html#44630">&#167;12.4.2</a> and <a href="binaryComp.html#45139">&#167;13.4.9</a> for more discussion.</p>
<a name="329328"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="38013"></a>
<a name="8.3.2.2"></a>
<h4>8.3.2.2    Initializers for Instance Variables</h4>
<a name="37982"></a>
Initialization expressions for instance variables may use the simple name of any <code>static</code> variable declared in or inherited by the class, even one whose declaration occurs textually later. <p>
<a name="258899"></a>
<p>Thus the example:</p>
<blockquote><pre>class Test {
	float f = j;
	static int j = 1;
}
</pre></blockquote><a name="259183"></a>
compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes <code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.<p>
<a name="40409"></a>
Initialization expressions for instance variables are permitted to refer to the current object <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> and to use the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>).<p>
<a name="329422"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="287406"></a>
<a name="8.3.2.3"></a>
<h4>8.3.2.3    Restrictions on the use of Fields during Initialization</h4>
<a name="287409"></a>
The declaration of a member needs to appear textually before it is used only if the member is an instance (respectively <code>static</code>) field of a class or interface <i>C</i> and all of the following conditions hold:<p>
<ul><a name="287410"></a>
<li>The usage occurs in an instance (respectively <code>static</code>) variable initializer of <i>C</i> or in an instance (respectively <code>static</code>) initializer of <i>C</i>.
<a name="310502"></a>
<li>The usage is not on the left hand side of an assignment. 
<a name="320043"></a>
<li>The usage is via a simple name.
<a name="287412"></a>
<li><i>C</i> is the innermost class or interface enclosing the usage.
</ul><a name="287413"></a>
A compile-time error occurs if any of the four requirements above are not met.<p>
<a name="287447"></a>
<p>This means that a compile-time error results from the test program:</p>
<blockquote><pre>	class Test {
		int i = j;	// compile-time error: incorrect forward reference
		int j = 1;
	}
</pre></blockquote><a name="287452"></a>
whereas the following example compiles without error:<p>
<blockquote><pre>	class Test {
		Test() { k = 2; }
		int j = 1;
		int i = j;
		int k;
	}
</pre></blockquote><a name="287462"></a>
even though the constructor <a href="classes.html#41652">(&#167;8.8)</a> for <code>Test</code> refers to the field <code>k</code> that is declared three lines later. <p>
<a name="288775"></a>
<p>These restrictions are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:</p>
<blockquote><pre>class Z {
	static int i = j + 2; 
	static int j = 4;
}
</pre></blockquote><a name="288780"></a>
and:<p>
<blockquote><pre>class Z {
	static { i = j + 2; }
	static int i, j;
	static { j = 4; }
}
</pre></blockquote><a name="288786"></a>
result in compile-time errors. Accesses by methods are not checked in this way, so:<p>
<blockquote><pre>class Z {
	static int peek() { return j; }
	static int i = peek();
	static int j = 1;
}
class Test {
	public static void main(String[] args) {
		System.out.println(Z.i);
	}
}
</pre></blockquote><a name="288795"></a>
produces the output:<p>
<blockquote><pre>0
</pre></blockquote><a name="288797"></a>
because the variable initializer for <code>i</code> uses the class method <code>peek</code> to access the value of the variable <code>j</code> before <code>j</code> has been initialized by its variable initializer, at which point it still has its default value <a href="typesValues.html#96595">(&#167;4.12.5)</a>.<p>
<a name="288772"></a>
<p>A more elaborate example is:</p>
<blockquote><pre>class UseBeforeDeclaration {
	static {
		x = 100; // ok - assignment
		int y = x + 1; // error - read before declaration
		int v = x = 3; // ok - x at left hand side of assignment
		int z = UseBeforeDeclaration.x * 2; 
	// ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){x++;} // ok - occurs in a different class
			{x++;} // ok - occurs in a different class
    		};
  }
	{
		j = 200; // ok - assignment
		j = j + 1; // error - right hand side reads before declaration
		int k = j = j + 1; 
		int n = j = 300; // ok - j at left hand side of assignment
		int h = j++; // error - read before declaration
		int l = this.j * 3; // ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){j++;} // ok - occurs in a different class
			{ j = j + 1;} // ok - occurs in a different class
		};
	}
	int w = x = 3; // ok - x at left hand side of assignment
	int p = x; // ok - instance initializers may access static fields
	static int u = (new Object(){int bar(){return x;}}).bar();
	// ok - occurs in a different class
	static int x;
	int m = j = 4; // ok - j at left hand side of assignment
	int o = (new Object(){int bar(){return j;}}).bar(); 
	// ok - occurs in a different class
	int j;
}
</pre></blockquote><a name="40425"></a>
<a name="8.3.3"></a>
<h3>8.3.3    Examples of Field Declarations</h3>
<a name="259192"></a>
The following examples illustrate some (possibly subtle) points about field declarations.<p>
<a name="40428"></a>
<a name="8.3.3.1"></a>
<h4>8.3.3.1    Example: Hiding of Class Variables</h4>
<a name="40429"></a>
The example:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	static double x = 4.7;
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40439"></a>
produces the output:<p>
<blockquote><pre>4.7 2
</pre></blockquote><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> (or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. Therefore, the output from this variant program is:<p>
<blockquote><pre>2 2
</pre></blockquote><a name="229119"></a>
<a name="8.3.3.2"></a>
<h4>8.3.3.2    Example: Hiding of Instance Variables</h4>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables rather than static variables. The code:<p>
<blockquote><pre>class Point {
	int x = 2;
}
class Test extends Point {
	double x = 4.7;
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " + 
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40468"></a>
produces the output:<p>
<blockquote><pre>4.7 2
4.7 2
</pre></blockquote><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be noted, however, that while the field <code>x</code> of class <code>Point</code> is not <em>inherited</em> by class <code>Test</code>, it is nevertheless <em>implemented</em> by instances of class <code>Test</code>. In other words, every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type <code>double</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> as <code>super.x</code>.<p>
<a name="40472"></a>
<p>Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>double</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.</p>
<a name="40473"></a>
<p>If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:</p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " +
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> declared in class <code>Point</code>. The output from this variant program is:<p>
<blockquote><pre>2 2
2 2
</pre></blockquote><a name="40491"></a>
<a name="8.3.3.3"></a>
<h4>8.3.3.3    Example: Multiply Inherited Fields</h4>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword <code>super</code> <a href="expressions.html#20860">(&#167;15.11.2)</a> may be used to access such fields unambiguously. In the example:<p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() { System.out.println(v); }
}
</pre></blockquote><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot be determined which <code>v</code> is intended.<p>
<a name="41191"></a>
<p>The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:</p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() {
		System.out.println((super.v + Frob.v)/2);
	}
}
</pre></blockquote><a name="40515"></a>
It compiles and prints:<p>
<blockquote><pre>2.5
</pre></blockquote>
<a name="40518"></a>
<p>Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:</p>
<blockquote><pre>
interface Color { int RED=0, GREEN=1, BLUE=2; }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
	public static void main(String[] args) {
		System.out.println(GREEN);	// compile-time error
		System.out.println(RED);	// compile-time error
	}
}
</pre></blockquote><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different values. The point of this example is that the reference to <code>RED</code> is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named <code>RED</code> happen to have the same type and the same unchanging value does not affect this judgment.<p>
<a name="40528"></a>
<a name="8.3.3.4"></a>
<h4>8.3.3.4    Example: Re-inheritance of Fields</h4>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code:<p>
<blockquote><pre>public interface Colorable {
	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	. . .
}
class PaintedPoint extends ColoredPoint implements Paintable
{
	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
}
</pre></blockquote><a name="259196"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both through its direct superclass <code>ColoredPoint</code> and through its direct superinterface <code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in interface <code>Colorable</code>.<p>
<a name="324240"></a>
<p>
<a name="40420"></a>
<a name="8.4"></a>
<h2>8.4    Method Declarations</h2>
<a name="40422"></a>
A <em>method</em> declares executable code that can be invoked, passing a fixed number of values as arguments.<p>
<a name="324241"></a>
<p>
<blockquote><pre>
<em>
MethodDeclaration:
	MethodHeader MethodBody

MethodHeader:
	MethodModifiers<sub>opt</sub> TypeParameters<sub>opt</sub> ResultType MethodDeclarator 
Throws<sub>opt</sub>
ResultType:
	Type
	</em>void<em>

MethodDeclarator:
	Identifier ( FormalParameterList<sub>opt</sub> )
	</em>
</pre></blockquote><a name="37508"></a>
The <em>MethodModifiers</em> are described in <a href="classes.html#78188">&#167;8.4.3</a>, the <em>TypeParameters</em> clause of a method in <a href="classes.html#323928">&#167;8.4.4</a>, the <em>Throws</em> clause in <a href="classes.html#308526">&#167;8.4.6</a>, and the <em>MethodBody</em> in <a href="classes.html#37316">&#167;8.4.7</a>. A method declaration either specifies the type of value that the method returns or uses the keyword <code>void</code> to indicate that the method does not return a value.<p>
<a name="30386"></a>
The <em>Identifier</em> in a <em>MethodDeclarator</em> may be used in a name to refer to the method. A class can declare a method with the same name as the class or a field, member class or member interface of the class, but this is discouraged as a matter of syle.<p>
<a name="38703"></a>
For compatibility with older versions of the Java platform, a declaration form for a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the parameter list. This is supported by the obsolescent production:<p>
<blockquote><pre>
<em>
MethodDeclarator:
	MethodDeclarator </em>[ ]
</pre></blockquote><a name="38705"></a>
but should not be used in new code.<p>
<a name="38056"></a>
It is a compile-time error for the body of a class to declare as members two methods with override-equivalent signatures <a href="classes.html#38649">(&#167;8.4.2)</a> (name, number of parameters, and types of any parameters). Methods and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.html#106941">(&#167;6.5)</a>.<p>
<a name="38698"></a>
<a name="8.4.1"></a>
<h3>8.4.1    Formal Parameters</h3>
<a name="37472"></a>
The <em>formal parameters</em> of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the <code>final</code> modifier and/or one or more annotations <a href="interfaces.html#253695">(&#167;9.7)</a>) and an identifier (optionally followed by brackets) that specifies the name of the parameter. The last formal parameter in a list is special; it may be a <i>variable arity parameter</i>, indicated by an elipsis following the type:<p>
<blockquote><pre>
<em>
FormalParameterList:
	LastFormalParameter
	FormalParameters , LastFormalParameter

FormalParameters:
	FormalParameter
	FormalParameters , FormalParameter

FormalParameter:
	VariableModifiers Type VariableDeclaratorId

VariableModifiers:
	VariableModifier
	VariableModifiers VariableModifier

VariableModifier: one of</em>
	final <em>Annotation

LastFormalParameter:
	VariableModifiers Type...<sub>opt</sub> VariableDeclaratorId
	FormalParameter
	</em>
</pre></blockquote><a name="291867"></a>
The following is repeated from <a href="classes.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
VariableDeclaratorId:
	Identifier
	VariableDeclaratorId </em>[ ]
</pre></blockquote><a name="55499"></a>
If a method or constructor has no parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.<p>
<a name="246504"></a>
If two formal parameters of the same method or constructor are declared to have the same name (that is, their declarations mention the same <em>Identifier</em>), then a compile-time error occurs.<p>
<a name="302827"></a>
If an annotation <i>a</i> on a formal parameter corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.PARAMETER</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="246509"></a>
It is a compile-time error if a method or constructor parameter that is declared final is assigned to within the body of the method or constructor.<p>
<a name="37477"></a>
When the method or constructor is invoked <a href="expressions.html#20448">(&#167;15.12)</a>, the values of the actual argument expressions initialize newly created parameter variables, each of the declared <em>Type,</em> before execution of the body of the method or constructor. The <em>Identifier</em> that appears<em> </em>in the <em>DeclaratorId</em> may be used as a simple name in the body of the method or constructor to refer to the formal parameter.<p>
<a name="300870"></a>
If the last formal parameter is a variable arity parameter of type <i>T</i>, it is considered to define a formal parameter of type <i>T[]</i>. The method is then a <i>variable arity method</i>. Otherwise, it is a <i>fixed arity method</i>. Invocations of a variable arity method may contain more actual argument expressions than formal parameters. All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation <a href="expressions.html#45449">(&#167;15.12.4.2)</a>.<p>
<a name="329396"></a>
The scope of a parameter of a method <a href="classes.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="38643"></a>
These parameter names may not be redeclared as local variables of the method, or as exception parameters of catch clauses in a try statement of the method or constructor. However, a parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor. Such a nested class declaration could declare either a local class <a href="statements.html#247766">(&#167;14.3)</a> or an anonymous class <a href="expressions.html#41147">(&#167;15.9)</a>. <p>
<a name="38647"></a>
Formal parameters are referred to only using simple names, never by using qualified names <a href="names.html#104285">(&#167;6.6)</a>.<p>
<a name="246529"></a>
A method or constructor parameter of type <code>float</code> always contains an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, a method or constructor parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a method or constructor parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set. <p>
<a name="246530"></a>
Where an actual argument expression corresponding to a parameter variable is not FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>, evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable the result of such an expression is mapped to the nearest value in the corresponding standard value set by method invocation conversion <a href="conversions.html#12687">(&#167;5.3)</a>.<p>
<a name="38649"></a>
<a name="8.4.2"></a>
<h3>8.4.2    Method Signature</h3>
<a name="302559"></a>
It is a compile-time error to declare two methods with override-equivalent signatures (defined below) in a class. <p>
<a name="310521"></a>
Two methods have the <i>same signature</i> if they have the same name and argument types. <p>
<a name="324242"></a>
Two method or constructor declarations <i>M</i> and <i>N</i> have the <i>same argument types</i> if all of the following conditions hold:<p>
<ul><a name="299803"></a>
<li>They have the same number of formal parameters (possibly zero) 
<a name="299804"></a>
<li>They have the same number of type parameters (possibly zero) 
<a name="324473"></a>
<li>Let <i>&lt;A<sub>1</sub>,...,A<sub>n</sub>&gt;</i> be the formal type parameters of <i>M</i> and let <i>&lt;B<sub>1</sub>,...,B<sub>n</sub>&gt;</i> be the formal type parameters of <i>N</i>. After renaming each occurrence of a <i>B<sub>i</sub></i> in <i>N</i>'s type to <i>A<sub>i</sub></i> the bounds of corresponding type variables and the argument types of <i>M</i> and <i>N</i> are the same.
</ul><a name="324474"></a>
The signature of a method <i>m1</i> is a <i>subsignature</i> of the signature of a method <i>m2</i> if either <p>
<ul>
<a name="308836"></a>
<li><i>m</i>2 has the same signature as <i>m1</i>, or
<a name="308837"></a>
<li>the signature of <i>m1</i> is the same as the erasure of the signature of <i>m</i>2.
</ul>
<a name="308833"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309081"></a>
 The notion of subsignature defined here is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other.<p>
<a name="309082"></a>
Specifically, it allows a method whose signature does not use generic types to override any generified version of that method. This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library.<p>
<a name="309094"></a>
Consider the example:<p>
<blockquote><pre>class CollectionConverter {
    List toList(Collection c) {...}
}
class Overrider extends CollectionConverter{
    List toList(Collection c) {...}
}
</pre></blockquote><a name="309101"></a>
Now, assume this code was written before the introduction of genericity, and now the author of class <code>CollectionConverter</code> decides to generify the code, thus:<p>
<blockquote><pre>class CollectionConverter {
	&lt;T&gt; List&lt;T&gt; toList(Collection&lt;T&gt; c) {...}
}
</pre></blockquote><a name="309105"></a>
Without special dispensation, <code>Overrider.toList()</code> would no longer override <code>CollectionConverter.toList()</code>. Instead, the code would be illegal. This would significantly inhibit the use of genericity, since library writers would hesitate to migrate existing code.<p>
<hr>
<a name="309083"></a>
 <p>
<a name="309142"></a>
Two method signatures <i>m1</i> and <i>m2</i> are <i>override-equivalent</i> iff either <i>m1</i> is a subsignature of <i>m2</i> or <i>m2</i> is a subsignature of <i>m1</i>.<p>
<a name="321243"></a>
<p>The example:</p>
<blockquote><pre>class Point implements Move {
	int x, y;
	abstract void move(int dx, int dy);
	void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="321249"></a>
causes a compile-time error because it declares two <code>move</code> methods with the same (and hence, override-equivalent) signature. This is an error even though one of the declarations is <code>abstract</code>.<p>
<a name="78188"></a>
<a name="8.4.3"></a>
<h3>8.4.3    Method Modifiers</h3>
<blockquote><pre>
<em>MethodModifiers:
	MethodModifier
	MethodModifiers MethodModifier

MethodModifier: one of
	Annotation</em> public&#32;protected&#32;private&#32;abstract&#32;static
	final&#32;synchronized&#32;native&#32;strictfp
</pre></blockquote><a name="320610"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a method declaration, or if a method declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a method declaration that contains the keyword <code>abstract</code> also contains any one of the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A compile-time error occurs if a method declaration that contains the keyword <code>native</code> also contains <code>strictfp</code>.<p>
<a name="302554"></a>
If an annotation <i>a</i> on a method declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.METHOD</code>, or a compile-time error occurs. Annotations are discussed further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259206"></a>
<p>If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>MethodModifier</em>.</p>
<a name="34484"></a>
<a name="8.4.3.1"></a>
<h4>8.4.3.1    abstract Methods</h4>
<a name="227750"></a>
An <code>abstract</code> method declaration introduces the method as a member, providing its signature <a href="classes.html#38649">(&#167;8.4.2)</a>, return type, and <code>throws</code> clause (if any), but does not provide an implementation. The declaration of an <code>abstract</code> method <i>m</i> must appear directly within an <code>abstract</code> class (call it <i>A</i>) unless it occurs within an enum <a href="classes.html#301020">(&#167;8.9)</a>; otherwise a compile-time error results. Every subclass of <i>A</i> that is not <code>abstract</code> must provide an implementation for <i>m</i>, or a compile-time error occurs as specified in <a href="classes.html#34944">&#167;8.1.1.1</a>. <p>
<a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>.<p>
<a name="259211"></a>
<p>It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not inherited by subclasses; therefore such a method could never be used.</p>
<a name="230065"></a>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. <p>
<a name="258918"></a>
<p>This can provide a place to put a documentation comment, to refine the return type, or to declare that the set of checked exceptions <a href="exceptions.html#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:</p>
<a name="324243"></a>
<p></p>
<blockquote><pre>class BufferEmpty extends Exception {
	BufferEmpty() { super(); }
	BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
	BufferError() { super(); }
	BufferError(String s) { super(s); }
}
public interface Buffer {
	char get() throws BufferEmpty, BufferError;
}
public abstract class InfiniteBuffer implements Buffer {
	public abstract char get() throws BufferError;
}
</pre></blockquote><a name="324244"></a>
<p>
<a name="259216"></a>
<p>The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> exception, putatively because it generates the data in the buffer, and thus can never run out of data.</p>
<a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. <p>
<a name="258923"></a>
<p></p>
<a name="324245"></a>
<p>For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:</p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
}
</pre></blockquote><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> method of class <code>Object</code>. (Class <code>Object</code> is the implicit direct superclass of class <code>Point</code>.) Adding the code:<p>
<blockquote><pre>class ColoredPoint extends Point {
	int color;
	public String toString() {
		return super.toString() + ": color " + color; // error
	}
}
</pre></blockquote><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class <code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some other method, as in:<p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
	protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
	int color;
	public String toString() {
		return objString() + ": color " + color;														// correct
	}
}
</pre></blockquote><a name="229128"></a>
<a name="8.4.3.2"></a>
<h4>8.4.3.2    static Methods</h4>
<a name="39431"></a>
A method that is declared <code>static</code> is called a <em>class method</em>. A class method is always invoked without reference to a particular object. An attempt to reference the current object using the keyword <code>this</code> or the keyword <code>super</code> or to reference the type parameters of any surrounding declaration in the body of a class method results in a compile-time error. It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="39033"></a>
A method that is not declared <code>static</code> is called an <em>instance method,</em> and sometimes called a non-<code>static</code> method. An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<a name="8.4.3.3"></a>
<h4>8.4.3.3    final Methods</h4>
<a name="30456"></a>
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding it. It is a compile-time error to attempt to override or hide a <code>final</code> method.<p>
<a name="38958"></a>
A <code>private</code> method and all methods declared immediately within a <code>final</code> class <a href="classes.html#54727">(&#167;8.1.1.2)</a> behave as if they are <code>final</code>, since it is impossible to override them.  <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run time, a machine-code generator or optimizer can "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is <code>null</code>, then a <code>NullPointerException</code> must be thrown even if the method is inlined. The compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.<p>
<a name="258931"></a>
<p>Consider the example:</p>
<blockquote><pre>final class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
	public static void main(String[] args) {
		Point[] p = new Point[100];
		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			p[i].move(i, p.length-1-i);
		}
	}
}
</pre></blockquote><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform the <code>for</code> loop to the form:<p>
<blockquote><pre>		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			Point pi = p[i];
			int j = p.length-1-i;
			pi.x += i;
			pi.y += j;
		}
</pre></blockquote><a name="31122"></a>
The loop might then be subject to further optimizations.<p>
<a name="259226"></a>
<p>Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.</p>
<a name="31125"></a>
<a name="8.4.3.4"></a>
<h4>8.4.3.4    native Methods</h4>
<a name="30468"></a>
A method that is <code>native</code> is implemented in platform-dependent code, typically written in another programming language such as C, C++, FORTRAN,or assembly language. The body of a <code>native</code> method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.<p>
<a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
<p>For example, the class <code>RandomAccessFile</code> of the package <code>java.io</code> might declare the following <code>native</code> methods:</p>
<blockquote><pre>package java.io;
public class RandomAccessFile
	implements DataOutput, DataInput
{	. . .
	public native void open(String name, boolean writeable)
		throws IOException;
	public native int readBytes(byte[] b, int off, int len)
		throws IOException;
	public native void writeBytes(byte[] b, int off, int len)
		throws IOException;
	public native long getFilePointer() throws IOException;
	public native void seek(long pos) throws IOException;
	public native long length() throws IOException;
	public native void close() throws IOException;
<a name="259231"></a>
<p>}</p>
</pre></blockquote><a name="55408"></a>
<a name="8.4.3.5"></a>
<h4>8.4.3.5    strictfp Methods</h4>
<a name="260393"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the method body be explicitly FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>.<p>
<a name="260369"></a>
<a name="8.4.3.6"></a>
<h4>8.4.3.6    synchronized Methods</h4>
<a name="30531"></a>
A <code>synchronized</code> method acquires a monitor <a href="memory.html#56318">(&#167;17.1)</a> before it executes. For a class (<code>static)</code> method, the monitor associated with the <code>Class</code> object for the method's class is used. For an instance method, the monitor associated with <code>this</code> (the object for which the method was invoked) is used. <p>
<a name="258940"></a>
<p>These are the same locks that can be used by the <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a>; thus, the code:</p>
<blockquote><pre>class Test {
	int count;
	synchronized void bump() { count++; }
	static int classCount;
	static synchronized void classBump() {
		classCount++;
	}
}
</pre></blockquote><a name="39096"></a>
has exactly the same effect as:<p>
<blockquote><pre>class BumpTest {
	int count;
	void bump() {
		synchronized (this) {
			count++;
		}
	}
	static int classCount;
	static void classBump() {
		try {
			synchronized (Class.forName("BumpTest")) {
				classCount++;
			}
		} catch (ClassNotFoundException e) {
				...
		}
	}
}
</pre></blockquote><a name="39078"></a>
The more elaborate example:<p>
<blockquote><pre>public class Box {
	private Object boxContents;
	public synchronized Object get() {
		Object contents = boxContents;
		boxContents = null;
		return contents;
	}
	public synchronized boolean put(Object contents) {
		if (boxContents != null)
			return false;
		boxContents = contents;
		return true;
	}
}
</pre></blockquote><a name="324957"></a>
defines a class which is designed for concurrent use. Each instance of the class <code>Box</code> has an instance variable <code>boxContents</code> that can hold a reference to any object. You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a null reference if the box is empty.<p>
<a name="39151"></a>
<p>If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.</p>
<a name="299963"></a>
See <a href="memory.html#61803">&#167;17</a> for more discussion of threads and locks.<p>
<a name="323927"></a>
<p>
<a name="323928"></a>
<a name="8.4.4"></a>
<h3>8.4.4    Generic Methods</h3>
<a name="299964"></a>
A method is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>formal type parameters</i> of the method. The form of the formal type parameter list is identical to a type parameter list of a class or interface, as described in <a href="classes.html#299360">&#167;8.1.2</a>. <p>
<a name="329504"></a>
The scope of a method's type parameter is the entire declaration of the method, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="300615"></a>
Type parameters of generic methods need not be provided explicitly when a generic method is invoked. Instead, they are almost always inferred as specified in <a href="expressions.html#341287">&#167;15.12.2.7</a><p>
<a name="296201"></a>
<a name="8.4.5"></a>
<h3>8.4.5    Method Return Type</h3>
<a name="308529"></a>
The return type of a method declares the type of value a method returns, if it returns a value, or states that the method is <code>void</code>. <p>
<a name="308544"></a>
A method declaration <i>d<sub>1</sub></i> with return type <i>R<sub>1</sub></i> is return-type-substitutable for another method <i>d<sub>2</sub></i> with return type <i>R<sub>2</sub></i>, if and only if the following conditions hold: <p>
<ul><a name="308530"></a>
<li>If <i>R<sub>1</sub></i> is a primitive type, then <i>R<sub>2</sub></i> is identical to <i>R<sub>1</sub></i>.
<a name="308531"></a>
<li>If <i>R<sub>1</sub></i> is a reference type then: 
<ul>
<a name="308532"></a>
<li><i>R<sub>1</sub></i> is either a subtype of <i>R<sub>2</sub></i> or <i>R<sub>1</sub></i> can be converted to a subtype of <i>R<sub>2</sub></i> by unchecked conversion <a href="conversions.html#190772">(&#167;5.1.9)</a>, or
<a name="308536"></a>
<li><i>R<sub>1</sub></i> = | <i>R<sub>2</sub></i> |. 
</ul>
<a name="308537"></a>
<li>If <i>R<sub>1</sub></i> is <code>void</code> then <i>R<sub>2</sub></i> is <code>void</code>.
</ul>
<a name="308527"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309108"></a>
 The notion of return-type substitutability summarizes the ways in which return types may vary among methods that override each other. <p>
<P><a name="309109"></a>
Note that this definition supports <i>covariant returns</i> - that is, the specialization of the return type to a subtype (but only for reference types). <p>
<a name="309119"></a>
Also note that unchecked conversions are allowed as well. This is unsound, and requires an unchecked warning whenever it is used; it is a special allowance is made to allow smooth migration from non-generic to generic code. <p>
<hr>
<a name="309110"></a>
 <p>
<a name="308526"></a>
<a name="8.4.6"></a>
<h3>8.4.6    Method Throws</h3>
<a name="41401"></a>
A <em>throws clause</em> is used to declare any checked exceptions <a href="exceptions.html#44121">(&#167;11.2)</a> that can result from the execution of a method or constructor:<p>
<blockquote><pre>
<em>
Throws:</em>
	throws <em>ExceptionTypeList

ExceptionTypeList:
	ExceptionType
	ExceptionTypeList , ExceptionType

ExceptionType:
	ClassType
	TypeVariable
	</em>
</pre></blockquote><a name="302537"></a>
A compile-time error occurs if any <em>ExceptionType</em> mentioned in a <code>throws</code> clause is not a subtype <a href="typesValues.html#120403">(&#167;4.10)</a> of <code>Throwable</code>. It is permitted but not required to mention other (unchecked) exceptions in a <code>throws</code> clause.<p>
<a name="39177"></a>
For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a supertype of that exception type is mentioned in a <code>throws</code> clause in the declaration of the method or constructor.<p>
<a name="259241"></a>
<p>The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a <code>throws</code> clause. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.</p>
<a name="55271"></a>
The predefined exceptions that are not checked in this way are those for which declaring every possible occurrence would be unimaginably inconvenient:<p>
<ul><a name="41434"></a>
<li>Exceptions that are represented by the subclasses of class <code>Error</code>, for example <code>OutOfMemoryError</code>, are thrown due to a failure in or of the virtual machine. Many of these are the result of linkage failures and can occur at unpredictable points in the execution of a program. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
<a name="41435"></a>
<li>The exceptions that are represented by the subclasses of the class <code>RuntimeException</code>, &#32;for example <code>NullPointerException</code>, result from run--time &#32;integrity checks and are thrown either directly from the program or in library routines. It is beyond the scope of the Java programming language, and perhaps beyond the state of the art, to include sufficient information in the program to reduce to a manageable number the places where these can be proven not to occur.
</ul><a name="230101"></a>
A method that overrides or hides another method <a href="classes.html#228745">(&#167;8.4.8)</a>, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.<p>
<a name="230102"></a>
More precisely, suppose that <i>B</i> is a class or interface, and <i>A</i> is a superclass or superinterface of <i>B</i>, and a method declaration <i>n</i> in <i>B</i> overrides or hides a method declaration <i>m</i> in <i>A</i>. If <i>n</i> has a <code>throws</code> clause that mentions any checked exception types, then <i>m</i> must have a <code>throws</code> clause, and for every checked exception type listed in the <code>throws</code> clause of <i>n</i>, that same exception class or one of its supertypes must occur in the erasure of the <code>throws</code> clause of <i>m</i>; otherwise, a compile-time error occurs.<p>
<a name="308280"></a>
If the unerased <code>throws</code> clause of <i>m</i> does not contain a supertype of each exception type in the <code>throws</code> clause of <i>n</i>, an unchecked warning must be issued.<p>
<a name="302748"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 See <a href="exceptions.html#44043">&#167;11</a> for more information about exceptions and a large example.<p>
<a name="303630"></a>
 Type variables are allowed in throws lists even though they are not allowed in catch clauses. <p>
<blockquote><pre>interface PrivilegedExceptionAction&lt;E extends Exception&gt; { 
  void run() throws E;
} 
class AccessController {
  public static &lt;E extends Exception&gt; 
  Object doPrivileged(PrivilegedExceptionAction&lt;E&gt; action) throws E 
  { ... }
}
class Test {
  public static void main(String[] args) {
    try { 
      AccessController.doPrivileged(
        new PrivilegedExceptionAction&lt;FileNotFoundException&gt;() { 
          public void run() throws FileNotFoundException 
          {... delete a file  ...} 
        }); 
    } catch (FileNotFoundException f) {...} // do something 
  }
}
<a name="24563"></a>
</pre></blockquote><a name="37316"></a>
<hr>
<p>
<a name="8.4.7"></a>
<h3>8.4.7    Method Body</h3>
<a name="32175"></a>
A <em>method body</em> is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation. The body of a method must be a semicolon if and only if the method is either <code>abstract</code> <a href="classes.html#34484">(&#167;8.4.3.1)</a> or <code>native</code> <a href="classes.html#31125">(&#167;8.4.3.4)</a>.<p>
<blockquote><pre>
<em>MethodBody</em>:
<em>	Block</em> 
	;
</pre></blockquote><a name="38770"></a>
A compile-time error occurs if a method declaration is either <code>abstract</code> or <code>native</code> and has a block for its body. A compile-time error occurs if a method declaration is neither <code>abstract</code> nor <code>native</code> and has a semicolon for its body.<p>
<a name="39311"></a>
<p>If an implementation is to be provided for a method declared <code>void</code>, but the implementation requires no executable code, the method body should be written as a block that contains no statements: "<code>{ }</code>".</p>
<a name="228178"></a>
If a method is declared <code>void</code>, then its body must not contain any <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> that has an <em>Expression</em>.<p>
<a name="244552"></a>
If a method is declared to have a return type, then every <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> in its body must have an <em>Expression</em>. A compile-time error occurs if the body of the method can complete normally <a href="statements.html#5894">(&#167;14.1)</a>. <p>
<a name="258957"></a>
<p>In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body."</p>
<a name="228370"></a>
<p>Note that it is possible for a method to have a declared return type and yet contain no return statements. Here is one example:</p>
<blockquote><pre>class DizzyDean {
	int pitch() { throw new RuntimeException("90 mph?!"); }
}
</pre></blockquote><a name="228745"></a>
<a name="8.4.8"></a>
<h3>8.4.8    Inheritance, Overriding, and Hiding</h3>
<a name="227926"></a>
A class <i>C</i> <em>inherits</em> from its direct superclass and direct superinterfaces all  non-private methods (whether <code>abstract</code> or not) of the superclass and superinterfaces that are public, protected or declared with default access in the same package as <i>C</i> and are neither overridden <a href="classes.html#227927">(&#167;8.4.8.1)</a> nor hidden <a href="classes.html#227928">(&#167;8.4.8.2)</a> by a declaration in the class.<p>
<a name="227927"></a>
<a name="8.4.8.1"></a>
<h4>8.4.8.1    Overriding (by Instance Methods)</h4>
<a name="39521"></a>
An instance method <i>m1</i> declared in a class <i>C</i> <em>overrides</em> another instance method, <i>m2</i>, declared in class <i>A</i> iff all of the following are true:<p>
<ol>
<a name="247097"></a>
<li>C is a subclass of <i>A</i>.
<a name="307410"></a>
<li>The signature of <i>m1</i> is a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m2</i>.
<a name="247099"></a>
<li>Either
<ul>
<a name="247100"></a>
<li><i>m2</i> is public, protected or declared with default access in the same package as <i>C</i>, or 
<a name="247101"></a>
<li><i>m1</i> overrides a method <i>m3</i>, <i>m3</i> distinct from <i>m1</i>, <i>m3</i> distinct from <i>m2</i>, such that <i>m3</i> overrides <i>m2</i>.
</ul>
</ol>
<a name="323974"></a>
Moreover, if <i>m1</i> is not <code>abstract</code>, then <i>m1</i> is said to <em>implement</em> any and all declarations of <code>abstract</code> methods that it overrides.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="323975"></a>
 <p>
<a name="323983"></a>
 The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has raw type, while the corresponding parameter in the other has a parameterized type.<p>
<a name="323976"></a>
The rules allow the signature of the overriding method to differ from the overridden one, to accommodate migration of pre-existing code to take advantage of genericity. See section <a href="classes.html#38649">&#167;8.4.2</a> for further analysis.<p>
<hr>
<a name="307478"></a>
 <p>
<a name="227929"></a>
A compile-time error occurs if an instance method overrides a <code>static</code> method. <p>
<a name="258962"></a>
<p>In this respect, overriding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for an instance variable to hide a <code>static</code> variable.</p>
<a name="259251"></a>
<p>An overridden method can be accessed by using a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code>. Note that a qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields. See <a href="expressions.html#239751">&#167;15.12.4.9</a> for discussion and examples of this point.</p>
<a name="246534"></a>
The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.<p>
<a name="324257"></a>
<p>
<a name="227928"></a>
<a name="8.4.8.2"></a>
<h4>8.4.8.2    Hiding (by Class Methods)</h4>
<a name="300965"></a>
If a class declares a <code>static</code> method <i>m,</i> then the declaration <i>m</i> is said to <em>hide</em> any method <i>m',</i> where the signature of <i>m</i> is a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m',</i> in the superclasses and superinterfaces of the class that would otherwise be accessible to code in the class. A compile-time error occurs if a <code>static</code> method hides an instance method.<p>
<a name="258967"></a>
<p>In this respect, hiding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for a <code>static</code> variable to hide an instance variable. Hiding is also distinct from shadowing <a href="names.html#34133">(&#167;6.3.1)</a> and obscuring <a href="names.html#104058">(&#167;6.3.2)</a>.</p>
<a name="259256"></a>
<p>A hidden method can be accessed by using a qualified name or by using a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code> or a cast to a superclass type. In this respect, hiding of methods is similar to hiding of fields.</p>
<a name="324258"></a>
<p></p>
<a name="227965"></a>
<a name="8.4.8.3"></a>
<h4>8.4.8.3    Requirements in Overriding and Hiding</h4>
<a name="227966"></a>
If a method declaration <i>d<sub>1</sub></i> with return type <i>R<sub>1</sub></i> overrides or hides the declaration of another method <i>d<sub>2</sub></i> with return type <i>R<sub>2</sub></i>, then <i>d<sub>1</sub></i> must be return-type substitutable for <i>d<sub>2</sub></i>, or a compile-time error occurs. Furthermore, if <i>R<sub>1</sub></i> is not a subtype of <i>R<sub>2</sub></i>, an unchecked warning must be issued (unless suppressed <a href="interfaces.html#255603">(&#167;9.6.1.5)</a>).<p>
<a name="307722"></a>
A method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.html#308526">(&#167;8.4.6)</a> with that of any method that it overrides or hides; otherwise, &#32;a compile-time error occurs.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="307750"></a>
 <p>
<a name="307751"></a>
 The rules above allow for <i>covariant return types</i> - refining the return type of a method when overriding it.<p>
<a name="307763"></a>
For example, the following declarations are legal although they were illegal in prior versions of the Java programming language:<p>
<blockquote><pre>class C implements Cloneable { 
   C copy() { return (C)clone(); } 
}
class D extends C implements Cloneable { 
   D copy() { return (D)clone(); } 
}
</pre></blockquote><a name="307758"></a>
The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces. <p>
<hr>
<a name="307759"></a>
 <p>
<a name="307463"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="307773"></a>
<p>
 Consider<p>
<blockquote><pre>class StringSorter {
// takes a collection of strings and converts it to a sortedlist
    List toList(Collection c) {...} 
}
</pre></blockquote>
<a name="323955"></a>
 and assume that someone subclasses <code>StringCollector</code><p>
 <blockquote><pre>
class Overrider extends StringSorter{
    List toList(Collection c) {...}
}
</pre></blockquote><a name="323930"></a>
Now, at some point the author of <code>StringSorter</code> decides to generify the code<p>
<blockquote><pre>class StringSorter {
// takes a collection of strings and converts it to a list
    List&lt;String&gt; toList(Collection&lt;String&gt; c) {...}
}
</pre></blockquote><a name="323956"></a>
An unchecked warning would be given when compiling <code>Overrider</code> against the new definition of <code>StringSorter</code> because the return type of <code>Overrider.toList()</code> is <code>List</code>, which is not a subtype of the return type of the overridden method, <code>List&lt;String</code>. <p>
<hr>
<a name="307470"></a>
 <p>
<a name="259261"></a>
<p>In these respects, overriding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for a field to hide a field of another type.</p>
<a name="329241"></a>
It is a compile time error if a type declaration <i>T</i> has a member method <i>m<sub>1</sub></i> and there exists a method <i>m<sub>2</sub></i> declared in <i>T</i> or a supertype of <i>T</i> such that all of the following conditions hold:<p>
<ul><a name="329242"></a>
<li><i>m<sub>1</sub></i> and <i>m<sub>2</sub></i> have the same name.
<a name="329243"></a>
<li><i>m<sub>2</sub></i> is accessible from <i>T</i>.
<a name="329247"></a>
<li>The signature of <i>m<sub>1</sub></i> is not a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m<sub>2</sub></i>.
<a name="329266"></a>
<li><i>m<sub>1</sub></i> or some method <i>m<sub>1</sub></i> overrides (directly or indirectly) has the same erasure as <i>m<sub>2</sub></i> or some method <i>m<sub>2</sub></i> overrides (directly or indirectly).
</ul><a name="328921"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="308935"></a>
 <p>
<a name="303530"></a>
 These restrictions are necessary because generics are implemented via erasure. The rule above implies that methods declared in the same class with the same name must have different erasures. It also implies that a type declaration cannot implement or extend two distinct invocations of the same generic interface. Here are some further examples.<p>
<a name="303527"></a>
A class cannot have two member methods with the same name and type erasure.<p>
<blockquote><pre>class C&lt;T&gt; { T id (T x) {...} }
class D extends C&lt;String&gt; {
   Object id(Object x) {...}
}
</pre></blockquote><a name="303481"></a>
This is illegal since <code>D.id(Object)</code> is a member of <code>D</code>, <code>C&lt;String&gt;.id(String)</code> is declared in a supertype of <code>D</code> and:<p>
<ul><a name="303482"></a>
<li>The two methods have the same name, <code>id</code>
<a name="303483"></a>
<li><code>C&lt;String&gt;.id(String</code>) is accessible to <code>D</code>
<a name="303484"></a>
<li>The signature of <code>D.id(Object)</code> is not a subsignature of that of <code>C&lt;String&gt;.id(String)</code>
<a name="303485"></a>
<li>The two methods have the same erasure
</ul>
<a name="303486"></a>
 <p>
 <hr>
<a name="303487"></a>
 <p>
<a name="303488"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 Two different methods of a class may not override methods with the same erasure.<p>
<blockquote><pre>class C&lt;T&gt; { T id (T x) {...} }
interface I&lt;T&gt; { Tid(T x); }
class D extends C&lt;String&gt; implements I&lt;Integer&gt; {
   String id(String x) {...}
   Integer id(Integer x) {...}
}
</pre></blockquote><a name="303496"></a>
This is also illegal, since <code>D.id(String)</code> is a member of <code>D</code>, <code>D.id(Integer)</code> is declared in <code>D</code> and:<p>
<ul><a name="303497"></a>
<li>the two methods have the same name, <code>id</code>
<a name="303498"></a>
<li>the two methods have different signatures.
<a name="303499"></a>
<li><code>D.id(Integer)</code> is accessible to <code>D</code>
<a name="303500"></a>
<li><code>D.id(String)</code> overrides <code>C&lt;String&gt;.id(String)</code> and <code>D.id(Integer)</code> overrides <code>I.id(Integer)</code> yet the two overridden methods have the same erasure
</ul>
<a name="303501"></a>
 <p>
 <hr>
<a name="300668"></a>
The access modifier <a href="names.html#104285">(&#167;6.6)</a> of an overriding or hiding method must provide at least as much access as the overridden or hidden method, or a compile-time error occurs. In more detail:<p>
<ul><a name="39549"></a>
<li>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.
<a name="39550"></a>
<li>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.
<a name="39551"></a>
<li>If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be <code>private</code>; otherwise, a compile-time error occurs.
</ul>
<a name="259266"></a>
<p>Note that a <code>private</code> method cannot be hidden or overridden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a <code>private</code> method in one of its superclasses, and there is no requirement that the return type or <code>throws</code> clause of such a method bear any relationship to those of the <code>private</code> method in the superclass.</p>
<a name="227941"></a>
<a name="8.4.8.4"></a>
<h4>8.4.8.4    Inheriting Methods with Override-Equivalent Signatures</h4>
<a name="39557"></a>
It is possible for a class to inherit multiple methods with override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> signatures.<p>
<a name="300634"></a>
It is a compile time error if a class <i>C</i> inherits a concrete method whose signatures is a subsignature of another concrete method inherited by <i>C.</i> <p>
<a name="309136"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309137"></a>
 <p>
 This can happen, if a superclass is parametric, and it has two methods that were distinct in the generic declaration, but have the same signature in the particular invocation used.<p>
<hr>
<a name="300667"></a>
 <p>
<a name="300644"></a>
Otherwise, there are two possible cases:<p>
<ul><a name="39561"></a>
<li>If one of the inherited methods is not <code>abstract</code>, then there are two subcases:
<ul>
<a name="39562"></a>
<li>If the method that is not <code>abstract</code> is <code>static</code>, a compile-time error occurs.
<a name="39563"></a>
<li>Otherwise, the method that is not <code>abstract</code> is considered to override, and therefore to implement, all the other methods on behalf of the class that inherits it. If the signature of the non-abstract method is not a subsignature of each of the other inherited methods  an unchecked warning must be issued (unless suppressed <a href="interfaces.html#255603">(&#167;9.6.1.5)</a>). A compile-time error also occurs if the return type of the non-abstract method is not return type substitutable <a href="classes.html#296201">(&#167;8.4.5)</a> for each of the other inherited methods. If the return type of the non-abstract method is not a subtype of the return type of any of the other inherited methods, an unchecked warning must be issued. Moreover, a compile-time error occurs if the inherited method that is not <code>abstract</code> has a <code>throws</code> clause that conflicts <a href="classes.html#308526">(&#167;8.4.6)</a> with that of any other of the inherited methods.
</ul>
<a name="308681"></a>
<li>If all the inherited methods are <code>abstract</code>, then the class is necessarily an <code>abstract</code> class and is considered to inherit all the <code>abstract</code> methods. A compile-time error occurs if, for any two such inherited methods, one of the methods  is not return type substitutable for the other (The <code>throws</code> clauses do not cause errors in this case.)
</ul><a name="39569"></a>
There might be several paths by which the same method declaration might be inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.<p>
<a name="227768"></a>
<a name="8.4.9"></a>
<h3>8.4.9    Overloading</h3>
<a name="39587"></a>
If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name, unless their signatures are override-equivalent.<p>
<a name="39909"></a>
Methods are overridden on a signature-by-signature basis. <p>
<a name="258985"></a>
<p>If, for example, a class declares two <code>public</code> methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. </p>
<a name="39591"></a>
<p>When a method is invoked <a href="expressions.html#20448">(&#167;15.12)</a>, the number of actual arguments (and any explicit type arguments) and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked <a href="expressions.html#292575">(&#167;15.12.2)</a>. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup <a href="expressions.html#45677">(&#167;15.12.4)</a>.</p>
<a name="39598"></a>
<a name="8.4.10"></a>
<h3>8.4.10    Examples of Method Declarations</h3>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method declarations.<p>
<a name="39600"></a>
<a name="8.4.10.1"></a>
<h4>8.4.10.1    Example: Overriding</h4>
<a name="39601"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
	int xLimit, yLimit;
	void move(int dx, int dy) {
		super.move(limit(dx, xLimit), limit(dy, yLimit));
	}
	static int limit(int d, int limit) {
		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
	}
}
</pre></blockquote><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> with its own <code>move</code> method, which limits the distance that the point can move on each invocation of the method. When the <code>move</code> method is invoked for an instance of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be called, even if the reference to the <code>SlowPoint</code> object is taken from a variable whose type is <code>Point</code>.<p>
<a name="39617"></a>
<a name="8.4.10.2"></a>
<h4>8.4.10.2    Example: Overloading, Overriding, and Hiding</h4>
<a name="39618"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name <code>move</code> with another method with a different signature <a href="classes.html#38649">(&#167;8.4.2)</a>.<p>
<a name="39633"></a>
<p>In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.</p>
<a name="39634"></a>
<p>Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="expressions.html#20448">&#167;15.12</a>.</p>
<a name="39638"></a>
<a name="8.4.10.3"></a>
<h4>8.4.10.3    Example: Incorrect Overriding</h4>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0, color;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
}
</pre></blockquote><a name="324259"></a>
<p>
<blockquote><pre>class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	float getX() { return x; }
	float getY() { return y; }
}
</pre></blockquote><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class <code>Point</code> return values of type <code>int</code>, but the wanna-be overriding methods in class <code>RealPoint</code> return values of type <code>float</code>.<p>
<a name="39655"></a>
<a name="8.4.10.4"></a>
<h4>8.4.10.4    Example: Overriding versus Hiding</h4>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	int getX() { return (int)Math.floor(x); }
	int getY() { return (int)Math.floor(y); }
}
</pre></blockquote><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same return types as the methods of class <code>Point</code> that they override, so this code can be successfully compiled.<p>
<a name="324260"></a>
<p>
<a name="324261"></a>
<p>
<a name="39672"></a>
<p>Consider, then, this test program:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		RealPoint rp = new RealPoint();
		Point p = rp;
		rp.move(1.71828f, 4.14159f);
		p.move(1, -1);
		show(p.x, p.y);
		show(rp.x, rp.y);
		show(p.getX(), p.getY());
		show(rp.getX(), rp.getY());
	}
	static void show(int x, int y) {
		System.out.println("(" + x + ", " + y + ")");
	}
	static void show(float x, float y) {
		System.out.println("(" + x + ", " + y + ")");
	}
}
</pre></blockquote><a name="39691"></a>
The output from this program is:<p>
<blockquote><pre>(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)
</pre></blockquote>
<a name="39696"></a>
<p>The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.</p>
<a name="39697"></a>
<p>The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.</p>
<a name="230120"></a>
<p>The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.</p>
<a name="229207"></a>
<a name="8.4.10.5"></a>
<h4>8.4.10.5    Example: Invocation of Hidden Class Methods</h4>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type is the class that actually contains the declaration of the method. In this respect, hiding of static methods is different from overriding of instance methods. The example:<p>
<blockquote><pre>class Super {
	static String greeting() { return "Goodnight"; }
	String name() { return "Richard"; }
}
class Sub extends Super {
	static String greeting() { return "Hello"; }
	String name() { return "Dick"; }
}
class Test {
	public static void main(String[] args) {
		Super s = new Sub();
		System.out.println(s.greeting() + ", " + s.name());
	}
}
</pre></blockquote><a name="229223"></a>
produces the output:<p>
<blockquote><pre>Goodnight, Dick
</pre></blockquote><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure out, at compile time, which class method to invoke, whereas the invocation of <code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance method to invoke.<p>
<a name="229149"></a>
<a name="8.4.10.6"></a>
<h4>8.4.10.6    Large Example of Overriding</h4>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:<p>
<blockquote><pre>import java.io.OutputStream;
import java.io.IOException;
class BufferOutput {
	private OutputStream o;
	BufferOutput(OutputStream o) { this.o = o; }
	protected byte[] buf = new byte[512];
	protected int pos = 0;
	public void putchar(char c) throws IOException {
		if (pos == buf.length)
			flush();
		buf[pos++] = (byte)c;
	}
	public void putstr(String s) throws IOException {
		for (int i = 0; i &lt; s.length(); i++)
			putchar(s.charAt(i));
	}
	public void flush() throws IOException {
		o.write(buf, 0, pos);
		pos = 0;
	}
}
class LineBufferOutput extends BufferOutput {
	LineBufferOutput(OutputStream o) { super(o); }
	public void putchar(char c) throws IOException {
		super.putchar(c);
		if (c == '\n')
			flush();
	}
}
class Test {
	public static void main(String[] args)
		throws IOException
	{
		LineBufferOutput lbo =
			new LineBufferOutput(System.out);
		lbo.putstr("lbo\nlbo");
		System.out.print("print\n");
		lbo.putstr("\n");
	}
}
</pre></blockquote><a name="229188"></a>
This example produces the output:<p>
<blockquote><pre>lbo
print
lbo
</pre></blockquote>
<a name="229192"></a>
<p>The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>BufferOutput</code>.</p>
<a name="229193"></a>
<p>In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.</p>
<a name="229194"></a>
<p>Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.</p>
<a name="229195"></a>
<p>Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="binaryComp.html#44871">&#167;13</a>, especially <a href="binaryComp.html#44952">&#167;13.2</a>.</p>
</pre></blockquote><a name="229203"></a>
<a name="8.4.10.7"></a>
<h4>8.4.10.7    Example: Incorrect Overriding because of Throws</h4>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception type, in its declaration of the class <code>BadPointException</code>:<p>
<blockquote><pre>class BadPointException extends Exception {
	BadPointException() { super(); }
	BadPointException(String s) { super(s); }
}
class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
	void move(int dx, int dy) throws BadPointException {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="39718"></a>
This example results in a compile-time error, because the override of method <code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract between it and <code>Point</code> broken if this exception were thrown.<p>
<a name="39725"></a>
<p>Removing the <code>throws</code> clause does not help:</p>
<blockquote><pre>class CheckedPoint extends Point {
	void move(int dx, int dy) {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote>
<a name="259271"></a>
<p>A different compile-time error now occurs, because the body of the method <code>move</code> cannot throw a checked exception, namely <code>BadPointException</code>, that does not appear in the <code>throws</code> clause for <code>move</code>.</p>
<a name="246026"></a>
<a name="8.5"></a>
<h2>8.5    Member Type Declarations</h2>
<a name="247539"></a>
A <i>member class</i> is a class whose declaration is directly enclosed in another class or interface declaration. Similarly, a <i>member interface</i> is an interface whose declaration is directly enclosed in another class or interface declaration. The scope <a href="names.html#103228">(&#167;6.3)</a> of a member class or interface is specified in <a href="classes.html#18988">&#167;8.1.6</a>. <p>
<a name="289016"></a>
If the class declares a member type with a certain name, then the declaration of that type is said to <em>hide</em> any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class. <p>
<a name="260651"></a>
Within a class <i>C</i>, a declaration <i>d</i> of a member type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs.<p>
<a name="300431"></a>
If a member class or interface declared with simple name <i>C</i> is directly enclosed within the declaration of a class with fully qualified name <i>N</i>, then the member class or interface has the fully qualified name <i>N.C</i>. A class inherits from its direct superclass and direct superinterfaces all the non-private member types of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247722"></a>
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name<p>
<a name="247732"></a>
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once. It may be referred to by its simple name without ambiguity.<p>
<a name="247581"></a>
<a name="8.5.1"></a>
<h3>8.5.1    Modifiers</h3>
<a name="246857"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if a member type declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302512"></a>
Member type declarations may have annotation modifers just like any type or member declaration.<p>
<a name="246853"></a>
<a name="8.5.2"></a>
<h3>8.5.2    Static Member Type Declarations</h3>
<a name="246645"></a>
The <code>static</code> keyword may modify the declaration of a member type <i>C</i> within the body of a non-inner class <i>T</i>. Its effect is to declare that <i>C</i> is not an inner class. Just as a static method of <i>T</i> has no current instance of <i>T</i> in its body, <i>C</i> also has no current instance of <i>T</i>, nor does it have any lexically enclosing instances.<p>
<a name="250215"></a>
It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.<p>
<a name="247136"></a>
Member interfaces are always implicitly <code>static</code>. It is permitted but not required for the declaration of a member interface to explicitly list the <code>static</code> modifier.<p>
<a name="246032"></a>
<a name="8.6"></a>
<h2>8.6    Instance Initializers</h2>
<a name="246072"></a>
An <i>instance initializer</i> declared in a class is executed when an instance of the class is created <a href="expressions.html#41147">(&#167;15.9)</a>, as specified in <a href="classes.html#229267">&#167;8.8.7.1</a>. <p>
<blockquote><pre>
<em>InstanceInitializer:
	Block
</em></pre></blockquote><a name="329432"></a>
It is compile-time error if an instance initializer of a named class can throw a checked exception unless that exception or one of its supertypes is explicitly declared in the <code>throws</code> clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance initializer in an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="329440"></a>
<p>
<a name="273818"></a>
<p>The rules above distinguish between instance initializers in named and anonymous classes. This distinction is deliberate. A given anonymous class is only instantiated at a single point in a program. It is therefore possible to directly propagate information about what exceptions might be raised by an anonymous class' instance initializer to the surrounding expression. Named classes, on the other hand, can be instantiated in many places. Therefore the only way to propagate information about what exceptions might be raised by an instance initializer of a named class is through the throws clauses of its constructors. It follows that a more liberal rule can be used in the case of anonymous classes. Similar comments apply to instance variable initializers.</p>
<a name="273817"></a>
It is a compile-time error if an instance initializer cannot complete normally <a href="statements.html#236365">(&#167;14.21)</a>. If a return statement <a href="statements.html#6767">(&#167;14.17)</a> appears anywhere within an instance initializer, then a compile-time error occurs.<p>
<a name="329413"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="247361"></a>
Instance initializers are permitted to refer to the current object this <a href="expressions.html#251519">(&#167;15.8.3)</a>, to any type variables <a href="typesValues.html#108850">(&#167;4.4)</a> in scope and to use the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>).<p>
<a name="39245"></a>
<a name="8.7"></a>
<h2>8.7    Static Initializers</h2>
<a name="39251"></a>
Any <em>static initializers </em>declared in a class are executed when the class is initialized and, together with any field initializers <a href="classes.html#24510">(&#167;8.3.2)</a> for class variables, may be used to initialize the class variables of the class <a href="execution.html#44557">(&#167;12.4)</a>.<p>
<blockquote><pre>
<em>StaticInitializer</em>:
	static <em>Block</em>
</pre></blockquote><a name="41620"></a>
It is a compile-time error for a static initializer to be able to complete abruptly (<a href="statements.html#5894">&#167;14.1</a>, <a href="expressions.html#79448">&#167;15.6</a>) with a checked exception <a href="exceptions.html#44121">(&#167;11.2)</a>. It is a compile-time error if a static initializer cannot complete normally <a href="statements.html#236365">(&#167;14.21)</a>.<p>
<a name="260750"></a>
The static initializers and class variable initializers are executed in textual order. <p>
<a name="329365"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="41700"></a>
If a <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="39966"></a>
If the keyword <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> or any type variable <a href="typesValues.html#108850">(&#167;4.4)</a> defined outside the initializer or the keyword <code>super</code> (<a href="expressions.html#41267">&#167;15.11</a>, <a href="expressions.html#20448">&#167;15.12</a>) appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="41652"></a>
<a name="8.8"></a>
<h2>8.8    Constructor Declarations</h2>
<a name="78391"></a>
A <em>constructor</em> is used in the creation of an object that is an instance of a class:<p>
<blockquote><pre>
<em>ConstructorDeclaration:
	ConstructorModifiers<sub>opt</sub>&#32;ConstructorDeclarator
		Throws<sub><i>opt</i></sub>&#32;ConstructorBody

ConstructorDeclarator:
	TypeParameters<sub><i>opt</i></sub> SimpleTypeName ( FormalParameterList<sub><i>opt</i></sub> )
	</em>
</pre></blockquote><a name="30689"></a>
The <em>SimpleTypeName </em>in the <em>ConstructorDeclarator</em> must be the simple name of the class that contains the constructor declaration; otherwise a compile-time error occurs. In all other respects, the constructor declaration looks just like a method declaration that has no result type.<p>
<a name="229252"></a>
<p>
<a name="229249"></a>
<p>Here is a simple example:</p>
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
</pre></blockquote><a name="41721"></a>
Constructors are invoked by class instance creation expressions <a href="expressions.html#41147">(&#167;15.9)</a>, by the conversions and concatenations caused by the string concatenation operator + <a href="expressions.html#39990">(&#167;15.18.1)</a>, and by explicit constructor invocations from other constructors <a href="classes.html#78435">(&#167;8.8.7)</a>. Constructors are never invoked by method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>.<p>
<a name="29483"></a>
Access to constructors is governed by access modifiers <a href="names.html#104285">(&#167;6.6)</a>. <p>
<a name="258999"></a>
<p>This is useful, for example, in preventing instantiation by declaring an inaccessible constructor <a href="classes.html#16830">(&#167;8.8.10)</a>.</p>
<a name="39897"></a>
Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.<p>
<a name="29488"></a>
<a name="8.8.1"></a>
<h3>8.8.1    Formal Parameters and Formal Type Parameter</h3>
<a name="41970"></a>
The formal parameters and formal type parameters of a constructor are identical in structure and behavior to the formal parameters of a method <a href="classes.html#38698">(&#167;8.4.1)</a>.<p>
<a name="41990"></a>
<a name="8.8.2"></a>
<h3>8.8.2    Constructor Signature</h3>
<a name="303664"></a>
It is a compile-time error to declare two constructors with override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> <em>signatures</em> in a class. It is a compile-time error to declare two constructors whose signature has the same erasure <a href="typesValues.html#108979">(&#167;4.6)</a> in a class.<p>
<a name="42018"></a>
<a name="8.8.3"></a>
<h3>8.8.3    Constructor Modifiers</h3>
<blockquote><pre>
<em>ConstructorModifiers:
	ConstructorModifier
	ConstructorModifiers</em> ConstructorModifier

<em>ConstructorModifier: one of
	</em> <em>Annotation</em> public&#32;protected&#32;private
</pre></blockquote><a name="36010"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a constructor declaration, or if a constructor declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302183"></a>
If no access modifier is specified for the constructor of a normal class, the constructor has default access. If no access modifier is specified for the constructor of an enum type, the constructor is <code>private</code>. It is a compile-time error if the constructor of an enum type <a href="classes.html#301020">(&#167;8.9)</a> is declared <code>public</code> or <code>protected</code>.<p>
<a name="302508"></a>
If an annotation <i>a</i> on a constructor corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.CONSTRUCTOR</code>, or a compile-time error occurs. Annotations are further discussed in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259286"></a>
<p>Unlike methods, a constructor cannot be <code>abstract</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A constructor is not inherited, so there is no need to declare it <code>final</code> and an <code>abstract</code> constructor could never be implemented. A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be <code>static</code>. There is no practical need for a constructor to be <code>synchronized</code>, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. The lack of <code>native</code> constructors is an arbitrary language design choice that makes it easy for an implementation of the Java virtual machine to verify that superclass constructors are always properly invoked during object creation.</p>
<a name="246538"></a>
<p>Note that a <em>ConstructorModifier</em> cannot be declared <code>strictfp</code>. This difference in the definitions for <em>ConstructorModifier</em> and <em>MethodModifier</em> <a href="classes.html#78188">(&#167;8.4.3)</a> is an intentional language design choice; it effectively ensures that a constructor is FP-strict <a href="expressions.html#249198">(&#167;15.4)</a> if and only if its class is FP-strict.</p>
<a name="244611"></a>
<a name="8.8.4"></a>
<h3>8.8.4    Generic Constructors</h3>
<a name="300912"></a>
It is possible for a constructor to be declared generic, independently of whether the class the constructor is declared in is itself generic. A constructor is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>formal type parameters</i> of the constructor. The form of the formal type parameter list is identical to a type parameter list of a generic class or interface, as described in <a href="classes.html#299360">&#167;8.1.2</a>. <p>
<a name="329511"></a>
The scope of a constructor's type parameter is the entire declaration of the constructor, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="300918"></a>
Type parameters of generic constructor need not be provided explicitly when a generic constructor is invoked. When they are not provided, they are inferred as specified in <a href="expressions.html#341287">&#167;15.12.2.7</a>.<p>
<a name="300906"></a>
<p>
<a name="300902"></a>
<a name="8.8.5"></a>
<h3>8.8.5    Constructor Throws</h3>
<a name="244612"></a>
The <code>throws</code> clause for a constructor is identical in structure and behavior to the <code>throws</code> clause for a method <a href="classes.html#308526">(&#167;8.4.6)</a>.<p>
<a name="306589"></a>
<a name="8.8.6"></a>
<h3>8.8.6    The Type of a Constructor</h3>
<a name="306590"></a>
The type of a constructor consists of its signature and the exception types given its throws clause.<p>
<a name="78435"></a>
<a name="8.8.7"></a>
<h3>8.8.7    Constructor Body</h3>
<a name="42051"></a>
The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass <a href="classes.html#229267">(&#167;8.8.7.1)</a>.<p>
<blockquote><pre>
<em>ConstructorBody:
</em>	{<em> ExplicitConstructorInvocation<sub>opt</sub> BlockStatements<sub><i>opt</i></sub> </em>}
</pre></blockquote><a name="230283"></a>
It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving <code>this</code>.  If the constructor is a constructor for an enum type <a href="classes.html#301020">(&#167;8.9)</a>, it is a compile-time error for it to invoke the superclass constructor explicitly.<p>
<a name="229836"></a>
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class <code>Object</code>, then the constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "<code>super();</code>", an invocation of the constructor of its direct superclass that takes no arguments.<p>
<a name="30734"></a>
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method <a href="classes.html#37316">(&#167;8.4.7)</a>. A <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> may be used in the body of a constructor if it does not include an expression.<p>
<a name="42056"></a>
<p>In the example:</p>
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
	static final int WHITE = 0, BLACK = 1;
	int color;
	ColoredPoint(int x, int y) {
		this(x, y, WHITE);
	}
	ColoredPoint(int x, int y, int color) {
		super(x, y);
		this.color = color;
	}
}
</pre></blockquote><a name="271283"></a>
the first constructor of <code>ColoredPoint</code> invokes the second, providing an additional argument; the second constructor of <code>ColoredPoint</code> invokes the constructor of its superclass <code>Point</code>, passing along the coordinates.<p>
<a name="229264"></a>
<a href="execution.html#44670">&#167;12.5</a> and <a href="expressions.html#41147">&#167;15.9</a> describe the creation and initialization of new class instances.<p>
<a name="229267"></a>
<a name="8.8.7.1"></a>
<h4>8.8.7.1    Explicit Constructor Invocations</h4>
<blockquote><pre>
<em>ExplicitConstructorInvocation:
	NonWildTypeArguments<sub>opt</sub> </em>this ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ;
<em>	NonWildTypeArguments<sub>opt</sub></em> super ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ;<em>
	Primary. NonWildTypeArguments<sub>opt</sub></em> super ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ; 

<em>NonWildTypeArguments:
	&lt; ReferenceTypeList &gt;

ReferenceTypeList: 
	ReferenceType
	ReferenceTypeList , ReferenceType
</em></pre></blockquote><a name="255762"></a>
<p>
<a name="324262"></a>
Explicit constructor invocation statements can be divided into two kinds:<p>
<ul><a name="255763"></a>
<li><i>Alternate constructor invocations</i> begin with the keyword this (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.
<a name="255764"></a>
<li><i>Superclass constructor invocations</i> begin with either the keyword super (possibly prefaced with explicit type arguments) or a <i>Primary</i> expression. They are used to invoke a constructor of the direct superclass. Superclass constructor invocations may be further subdivided:
<ul>
<a name="255765"></a>
<li><i>Unqualified superclass constructor invocations</i> begin with the keyword <code>super</code> (possibly prefaced with explicit type arguments).
<a name="255766"></a>
<li><i>Qualified superclass constructor invocations</i> begin with a <i>Primary</i> expression . They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass <a href="classes.html#295574">(&#167;8.1.3)</a>. This may be necessary when the superclass is an inner class.
</ul>
</ul>
<a name="255697"></a>
<p>Here is an example of a qualified superclass constructor invocation:</p>
</ul>
</ul><blockquote><pre>class Outer {
	class Inner{}
}
class ChildOfInner extends Outer.Inner {
	ChildOfInner(){(new Outer()).super();}
}
</pre></blockquote><a name="287141"></a>
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs. <p>
<a name="291517"></a>
<p>For example, if the first constructor of <code>ColoredPoint</code> in the example above were changed to:</p>
<blockquote><pre>ColoredPoint(int x, int y) {
	this(x, y, color);
}
</pre></blockquote><a name="259296"></a>
then a compile-time error would occur, because an instance variable cannot be used within a superclass constructor invocation.<p>
<a name="329301"></a>
An explicit constructor invocation statement can throw an exception type <i>E</i> iff either:<p>
<ul><a name="329302"></a>
<li>Some subexpression of the constructor invocation's parameter list can throw <i>E</i>; or
<a name="329303"></a>
<li><i>E</i> is declared in the throws clause of the constructor that is invoked.
</ul><a name="328981"></a>
<p>
<a name="255702"></a>
If an anonymous class instance creation expression appears within an explicit constructor invocation statement, then the anonymous class may not refer to any of the enclosing instances of the class whose constructor is being invoked.<p>
<a name="255703"></a>
<p>For example:</p>
<blockquote><pre>class Top {
	int x;
	class Dummy {
		Dummy(Object o) {}
	}
	class Inside extends Dummy {
		Inside() {
			super(new Object() { int r = x; }); // error
		}		
		Inside(final int y) {
			super(new Object() { int r = y; }); // correct
		}
	}
}
</pre></blockquote><a name="255722"></a>
Let <i>C</i> be the class being instantiated, let <i>S</i> be the direct superclass of <i>C</i>, and let <i>i</i> be the instance being created. The evaluation of an explicit constructor invocation proceeds as follows:<p>
<ul><a name="255921"></a>
<li>First, if the constructor invocation statement is a superclass constructor invocation, then the immediately enclosing instance of <i>i</i> with respect to <i>S</i> (if any) must be determined. Whether or not <i>i</i> has an immediately enclosing instance with respect to <i>S</i> is determined by the superclass constructor invocation as follows:
<ul>
<a name="255723"></a>
<li>If <i>S</i> is not an inner class, or if the declaration of <i>S</i> occurs in a static context, no immediately enclosing instance of <i>i</i> with respect to <i>S</i> exists. A compile-time error occurs if the superclass constructor invocation is a qualified superclass constructor invocation.
<a name="255724"></a>
<li>Otherwise:
<ul>
<a name="255725"></a>
<li>If the superclass constructor invocation is qualified, then the <i>Primary</i> expression <i>p</i> immediately preceding "<code>.super</code>" is evaluated. If the primary expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly. Otherwise, the result of this evaluation is the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. Let <i>O</i> be the immediately lexically enclosing class of <i>S</i>; it is a compile-time error if the type of <i>p</i> is not <i>O</i> or a subclass of <i>O</i>.
<a name="255726"></a>
<li>Otherwise:
<ul>
<a name="255730"></a>
<li>If <i>S</i> is a local class <a href="statements.html#247766">(&#167;14.3)</a>, then let <i>O</i> be the innermost lexically enclosing class of <i>S</i>. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
<a name="255734"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.html#246026">(&#167;8.5)</a>. It is a compile-time error if <i>S</i> is not a member of a lexically enclosing class, or of a superclass or superinterface thereof. Let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
</ul>
</ul>
</ul>
<a name="255735"></a>
<li>Second, the arguments to the constructor are evaluated, left-to-right, as in an ordinary method invocation.
<a name="255924"></a>
<li>Next, the constructor is invoked.
<a name="255859"></a>
<li>Finally, if the constructor invocation statement is a superclass constructor invocation and the constructor invocation statement completes normally, then all instance variable initializers of <i>C</i> and all instance initializers of <i>C</i> are executed. If an instance initializer or instance variable initializer <i>I</i> textually precedes another instance initializer or instance variable initializer <i>J</i>, then <i>I</i> is executed before <i>J</i>. This action is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically. An alternate constructor invocation does not perform this additional implicit action.
</ul><a name="324263"></a>
<p>
<a name="229266"></a>
<a name="8.8.8"></a>
<h3>8.8.8    Constructor Overloading</h3>
<a name="16815"></a>
Overloading of constructors is identical in behavior to overloading of methods. The overloading is resolved at compile time by each class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>.<p>
<a name="16823"></a>
<a name="8.8.9"></a>
<h3>8.8.9    Default Constructor</h3>
<a name="229830"></a>
If a class contains no constructor declarations, then a <em>default constructor</em> that takes no parameters is automatically provided:<p>
<ul><a name="229831"></a>
<li>If the class being declared is the primordial class <code>Object</code>, then the default constructor has an empty body.
<a name="229832"></a>
<li>Otherwise, the default constructor takes no parameters and simply invokes the superclass constructor with no arguments.
</ul><a name="16772"></a>
A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have an accessible constructor that takes no arguments.<p>
<a name="257593"></a>
A default constructor has no <code>throws</code> clause.<p>
<a name="260449"></a>
<p>It follows that if the nullary constructor of the superclass has a <code>throws</code> clause, then a compile-time error will occur.</p>
<a name="16773"></a>
In an enum type <a href="classes.html#301020">(&#167;8.9)</a>, the default constructor is implicitly <code>private</code>. Otherwise, if the class is declared <code>public</code>, then the default constructor is implicitly given the access modifier <code>public</code> <a href="names.html#104285">(&#167;6.6)</a>; if the class is declared <code>protected</code>, then the default constructor is implicitly given the access modifier <code>protected</code> <a href="names.html#104285">(&#167;6.6)</a>; if the class is declared <code>private</code>, then the default constructor is implicitly given the access modifier <code>private</code> <a href="names.html#104285">(&#167;6.6)</a>; otherwise, the default constructor has the default access implied by no access modifier. <p>
<a name="259026"></a>
<p>Thus, the example:</p>
<blockquote><pre>public class Point {
	int x, y;
}
</pre></blockquote><a name="16781"></a>
is equivalent to the declaration:<p>
<blockquote><pre>public class Point {
	int x, y;
	public Point() { super(); }
}
</pre></blockquote><a name="16786"></a>
where the default constructor is <code>public</code> because the class <code>Point</code> is <code>public</code>.<p>
<a name="260516"></a>
<p>The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider</p>
<blockquote><pre>package p1;
public class Outer {
 	protected class Inner{}
}

package p2;
class SonOfOuter extends p1.Outer {
	void foo() {
 		new Inner(); // compile-time access error
	}
}

</pre></blockquote><a name="259796"></a>
The constructor for <code>Inner</code> is protected. However, the constructor is protected relative to <code>Inner</code>, while <code>Inner</code> is protected relative to <code>Outer</code>. So, <code>Inner</code> is accessible in <code>SonOfOuter</code>, since it is a subclass of <code>Outer</code>. <code>Inner</code>'s constructor is not accessible in <code>SonOfOuter</code>, because the class <code>SonOfOuter</code> is not a subclass of <code>Inner</code>! Hence, even though <code>Inner</code> is accessible, its default constructor is not.<p>
<a name="16830"></a>
<a name="8.8.10"></a>
<h3>8.8.10    Preventing Instantiation of a Class</h3>
<a name="16831"></a>
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and declaring all constructors to be <code>private</code>. A <code>public</code> class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with <code>public</code> access, and declaring no constructor that is <code>public</code>.<p>
<a name="16833"></a>
<p>Thus, in the example:</p>
<blockquote><pre>class ClassOnly {
	private ClassOnly() { }
	static String just = "only the lonely";
}
</pre></blockquote><a name="16838"></a>
the class <code>ClassOnly</code> cannot be instantiated, while in the example:<p>
<blockquote><pre>package just;
public class PackageOnly {
	PackageOnly() { }
	String[] justDesserts = { "cheesecake", "ice cream" };
}
</pre></blockquote><a name="259306"></a>
the class <code>PackageOnly</code> can be instantiated only within the package <code>just</code>, in which it is declared.<p>
<a name="301020"></a>
<a name="8.9"></a>
<h2>8.9    Enums</h2>
<a name="301628"></a>
An enum declaration has the form: <p>
<blockquote><pre>
<em>
EnumDeclaration:
	ClassModifiers<sub>opt</sub></em> enum<em> Identifier Interfaces<sub>opt</sub> EnumBody

EnumBody:
	{ EnumConstants<sub>opt ,opt</sub> EnumBodyDeclarations<sub>opt</sub> }</em>
</pre></blockquote><a name="301035"></a>
The body of an enum type may contain <i>enum constants</i>. An enum constant defines an instance of the enum type. An enum type has no instances other than those defined by its enum constants.<p>
<hr>
<a name="302015"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="302020"></a>
<p>
 It is a compile-time error to attempt to explicitly instantiate an enum type <a href="expressions.html#386053">(&#167;15.9.1)</a>. The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization. Reflective instantiation of enum types is prohibited. Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants. <p>
<a name="302097"></a>
Because there is only one instance of each enum constant, it is permissible to use the == operator in place of the <code>equals</code> method when comparing two object references if it is known that at least one of them refers to an enum constant. (The <code>equals</code> method in <code>Enum</code> is a final method that merely invokes <code>super.equals</code> on its argument and returns the result, thus performing an identity comparison.) <p>
<hr>
<a name="302021"></a>
 <p>
<blockquote><pre>
<em>
EnumConstants:
	EnumConstant
	EnumConstants , EnumConstant

EnumConstant:
	Annotations Identifier Arguments<sub>opt</sub> ClassBody<sub>opt</sub>

Arguments:
	( ArgumentList<sub>opt</sub> )

EnumBodyDeclarations:
	; ClassBodyDeclarations<sub>opt</sub>
	</em>
</pre></blockquote><a name="302226"></a>
An enum constant may be preceded by annotation <a href="interfaces.html#253695">(&#167;9.7)</a> modifiers. If an annotation <i>a</i> on an enum constant corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.FIELD</code>, or a compile-time error occurs.<p>
<a name="302777"></a>
An enum constant may be followed by arguments, which are passed to the constructor of the enum type when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal overloading rules <a href="expressions.html#292575">(&#167;15.12.2)</a>. If the arguments are omitted, an empty argument list is assumed. If the enum type has no constructor declarations, a parameterless default constructor is provided (which matches the implicit empty argument list). This default constructor is <code>private</code>.<p>
<a name="302235"></a>
The optional class body of an enum constant implicitly defines an anonymous class declaration <a href="expressions.html#252986">(&#167;15.9.5)</a> that extends the immediately enclosing enum type. The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors.<p>
<a name="302240"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="302241"></a>
 Instance methods declared in these class bodies are may be invoked outside the enclosing enum type only if they override accessible methods in the enclosing enum type. <p>
<hr>
<a name="302244"></a>
 <p>
<a name="329467"></a>
Enum types <a href="classes.html#301020">(&#167;8.9)</a> must not be declared abstract; doing so will result in a compile-time error. It is a compile-time error for an enum type <i>E</i> to have an abstract method <i>m</i> as a member unless <i>E</i> has one or more enum constants, and all of <i>E</i>'s enum constants have class bodies that provide concrete implementations of <i>m.</i> It is a compile-time error for the class body of an enum constant to declare an abstract method. <p>
<a name="329147"></a>
<p>
<a name="301974"></a>
An enum type is implicitly <code>final</code> unless it contains at least one enum constant that has a class body. In any case, it is a compile-time error to explicitly declare an enum type to be <code>final</code>.<p>
<a name="301973"></a>
Nested enum types are implicitly <code>static</code>. It is permissable to explicitly declare a nested enum type to be <code>static</code>. <p>
<a name="308753"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="308754"></a>
 This implies that it is impossible to define a local <a href="statements.html#247766">(&#167;14.3)</a> enum, or to define an enum in an inner class <a href="classes.html#295574">(&#167;8.1.3)</a>.<p>
 <hr>
<a name="308756"></a>
 <p>
<a name="301055"></a>
Any constructor or member declarations within an enum declaration apply to the enum type exactly as if they had been present in the class body of a normal class declaration unless explicitly stated otherwise. <p>
<a name="301082"></a>
The direct superclass of an enum type named <i>E</i> is <code>Enum&lt;E&gt;</code>. In addition to the members it inherits from <code>Enum&lt;E&gt;</code>, for each declared enum constant with the name <i>n</i> the enum type has an implicitly declared public <code>static</code> <code>final</code> field named <i>n</i> of type <i>E.</i> These fields are considered to be declared in the same order as the corresponding enum constants, before any static fields explicitly declared in the enum type. Each such field is initialized to the enum constant that corresponds to it. Each such field is also considered to be annotated by the same annotations as the corresponding enum constant. The enum constant is said to be created when the corresponding field is initialized.<p>
<a name="313975"></a>
It is a compile-time error for an enum to declare a finalizer. An instance of an enum may never be finalized.<p>
<a name="302265"></a>
In addition, if <i>E</i> is the name of an enum type, then that type has the following implicitly declared static methods: <p>
<blockquote><pre><a name="301708"></a>
/**
</pre><pre><a name="301709"></a>* Returns an array containing the constants of this enum 
<a name="301748"></a>* type, in the order they're declared.  This method may be
<a name="301749"></a>* used to iterate over the constants as follows:
<a name="301753"></a>*
<a name="301745"></a>*    for(E c : E.values())
<a name="301092"></a>*        System.out.println(c);
<a name="301093"></a>*
<a name="301094"></a>* @return an array containing the constants of this enum 
<a name="301758"></a>* type, in the order they're declared
<a name="301096"></a>*/
<a name="301097"></a>public static E[] values();
<a name="301098"></a>
<a name="301099"></a>/**
<a name="301100"></a>* Returns the enum constant of this type with the specified
<a name="301788"></a>* name.
<a name="301101"></a>* The string must match exactly an identifier used to declare
<a name="301795"></a>* an enum constant in this type.  (Extraneous whitespace 
<a name="301804"></a>* characters are not permitted.)
<a name="301104"></a>* 
<a name="301105"></a>* @return the enum constant with the specified name
<a name="301106"></a>* @throws IllegalArgumentException if this enum type has no
<a name="301824"></a>* constant with the specified name
<a name="301108"></a>*/
<a name="301849"></a>public static E valueOf(String name);
<a name="301110"></a>
</pre></blockquote>
 <p>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
<a name="302063"></a>
 It follows that enum type declarations cannot contain fields that conflict with the enum constants, and cannot contain methods that conflict with the automatically generated methods (<code>values()</code> and <code>valueOf(String)</code>) or methods that override the final methods in <code>Enum</code>: (<code>equals(Object)</code>, <code>hashCode()</code>, <code>clone()</code>,<code> compareTo(Object)</code>, <code>name()</code>, <code>ordinal()</code>, and <code>getDeclaringClass()</code>). <p>
 <hr>
<a name="301111"></a>
<a name="302255"></a>
<p>
<a name="324268"></a>
It is a compile-time error to reference a static field of an enum type that is not a compile-time constant <a href="expressions.html#5313">(&#167;15.28)</a> from constructors, instance initializer blocks, or instance variable initializer expressions of that type. It is a compile-time error for the constructors, instance initializer blocks, or instance variable initializer expressions of an enum constant <i>e</i> to refer to itself or to an enum constant of the same type that is declared to the right of <i>e</i>. <p>
<a name="324269"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="302080"></a>
 <p>
<a name="302079"></a>
 Without this rule, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum types. (A circularity exists in any class with a "self-typed" static field.) Here is an example of the sort of code that would fail: <p>
<blockquote><pre>enum Color {
        RED, GREEN, BLUE;
        static final Map&lt;String,Color&gt; colorMap = 
		new HashMap&lt;String,Color&gt;();
        Color() {
            colorMap.put(toString(), this);
        }
    } 
	</pre></blockquote>
<a name="301135"></a>
 Static initialization of this enum type would throw a NullPointerException because the static variable colorMap is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code won't compile. <p>
<a name="324425"></a>
<p>
<a name="324426"></a>
Note that the example can easily be refactored to work properly: <p>
<blockquote><pre>enum Color {
        RED, GREEN, BLUE;
        static final Map&lt;String,Color&gt; colorMap = 
		new HashMap&lt;String,Color&gt;();
        static {
            for (Color c : Color.values())
                colorMap.put(c.toString(), c);
        }
    } 
	</pre></blockquote>
<a name="301148"></a>
<p>
 The refactored version is clearly correct, as static initialization occurs top to bottom. <p>
 <hr>
<a name="301170"></a>
 <p>
 <hr>
<a name="301176"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="301177"></a>
 Here is program with a nested enum declaration that uses an enhanced for loop to iterate over the constants in the enum: <p>
 <blockquote><pre>
public class Example1 {
    public enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String[] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}
</pre></blockquote>
<p>
<a name="301188"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
WINTER
SPRING
SUMMER
FALL
</pre></blockquote>
<p>
<a name="301195"></a>
 Here is a program illustrating the use of <code>EnumSet</code> to work with subranges: <p>
 <blockquote><pre>
import java.util.*;

public class Example2 {
    enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

    public static void main(String[] args) {
        System.out.print("Weekdays: ");
        for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
            System.out.print(d + " ");
        System.out.println();
    }
}
</pre></blockquote>
<a name="301210"></a>
 <p>
<a name="324427"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
Weekdays: MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY
</pre></blockquote>
<a name="301214"></a>
<code> EnumSet</code> contains a rich family of static factories, so this technique can be generalized to work non-contiguous subsets as well as subranges. At first glance, it might appear wasteful to generate an <code>EnumSet</code> for a single iteration, but they are so cheap that this is the recommended idiom for iteration over a subrange. Internally, an <code>EnumSet</code> is represented with a single long assuming the enum type has 64 or fewer elements. <p>
</pre></blockquote><a name="301218"></a>
Here is a slightly more complex enum declaration for an enum type with an explicit instance field and an accessor for this field. Each member has a different value in the field, and the values are passed in via a constructor. In this example, the field represents the value, in cents, of an American coin. Note, however, that their are no restrictions on the type or number of parameters that may be passed to an enum constructor. <p>
<blockquote><pre>public enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);

    Coin(int value) { this.value = value; }

    private final int value;

    public int value() { return value; }
}
</pre></blockquote>
<a name="301232"></a>
 Switch statements are useful for simulating the addition of a method to an enum type from outside the type. This example "adds" a color method to the <code>Coin</code> type, and prints a table of coins, their values, and their colors. <p>
 <blockquote><pre>
public class CoinTest {
    public static void main(String[] args) {
        for (Coin c : Coin.values())
            System.out.println(c + ":   	"+ c.value() +"&#162; 	" + color(c));
    }
    private enum CoinColor { COPPER, NICKEL, SILVER }
    private static CoinColor color(Coin c) {
        switch(c) {
          case PENNY:
            return CoinColor.COPPER;
          case NICKEL:
            return CoinColor.NICKEL;
          case DIME: case QUARTER:
            return CoinColor.SILVER;
          default:
            throw new AssertionError("Unknown coin: " + c);
        }
    }
}
</pre></blockquote>
<a name="301257"></a>
 Running the program prints: <p>
 <blockquote><pre>
PENNY:          1&#162;      COPPER
NICKEL:         5&#162;      NICKEL
DIME:           10&#162;     SILVER
QUARTER:        25&#162;     SILVER
</pre></blockquote>
<a name="301264"></a>
<a name="324270"></a>
<a name="324271"></a>
 <p>
<a name="324272"></a>
 In the following example, a playing card class is built atop two simple enum types. Note that each enum type would be as long as the entire example in the absence of the enum facility: <p>
<blockquote><pre>
import java.util.*;
public class Card implements Comparable&lt;Card&gt;, java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,JACK, 
QUEEN, KING, ACE }
    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }
    private final Rank rank;
    private final Suit suit;
    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + ", " + suit);
        this.rank = rank;
        this.suit = suit;
    }
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }
    public String toString() { return rank + " of " + suit; }
    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ? suitCompare : rank.compareTo(c.rank));
    }
    private static final List&lt;Card&gt; prototypeDeck = new ArrayList&lt;Card&gt;(52);
    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }
    // Returns a new deck
    public static List&lt;Card&gt; newDeck() {
        return new ArrayList&lt;Card&gt;(prototypeDeck);
    }
}
</pre></blockquote>
<a name="301307"></a>
 Here's a little program that exercises the <code>Card</code> class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand: <p>
<blockquote><pre>
import java.util.*;
class Deal {
    public static void main(String args[]) {
		int numHands     = Integer.parseInt(args[0]);
		int cardsPerHand = Integer.parseInt(args[1]);
		List&lt;Card&gt; deck  = Card.newDeck();
		Collections.shuffle(deck);
		for (int i=0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    	}
    /**
	 * Returns a new ArrayList consisting of the last n elements of 
	 * deck, which are removed from deck.  The returned list is
	 * sorted using the elements' natural ordering.
	*/
    public static &lt;E extends Comparable&lt;E&gt;&gt; ArrayList&lt;E&gt;
            dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        ArrayList&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}
</pre></blockquote>
<a name="301338"></a>
 Running the program produces results like this: <p>
<blockquote><pre>
java Deal 4 5
[FOUR of SPADES, NINE of CLUBS, NINE of SPADES, QUEEN of SPADES, KING of SPADES]
[THREE of DIAMONDS, FIVE of HEARTS, SIX of SPADES, SEVEN of DIAMONDS, KING of 
DIAMONDS]
[FOUR of DIAMONDS, FIVE of SPADES, JACK of CLUBS, ACE of DIAMONDS, ACE of 
HEARTS]
[THREE of HEARTS, FIVE of DIAMONDS, TEN of HEARTS, JACK of HEARTS, QUEEN of 
HEARTS]
</pre></blockquote>
<a name="301346"></a>
 The next example demonstrates the use of constant-specific class bodies to attach behaviors to the constants. (It is anticipated that the need for this will be rare.): <p>
 <blockquote><pre>
import java.util.*;
public enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x * y; }
    },
    DIVIDED_BY {
        double eval(double x, double y) { return x / y; }
    };
    // Perform the arithmetic operation represented by this constant
   // abstract double eval(double x, double y);
    public static void main(String args[]) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);

        for (Operation op : Operation.values())
            System.out.println(x + " " + op + " " + y + " = " + op.eval(x, y));
    }
}
</pre></blockquote>
<a name="301379"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
java Operation 2.0 4.0
2.0 PLUS 4.0 = 6.0
2.0 MINUS 4.0 = -2.0
2.0 TIMES 4.0 = 8.0
2.0 DIVIDED_BY 4.0 = 0.5
</pre></blockquote>
<a name="301388"></a>
 The above pattern is suitable for moderately sophisticated programmers. It is admittedly a bit tricky, but it is much safer than using a case statement in the base type (Operation), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (you'd get a compile-time error). <p>
<a name="302081"></a>
<hr>
 <p>
<a name="239730"></a>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="packages.html">Prev</a> | <a href="interfaces.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Interfaces</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="classes.html">Prev</a> | <a href="arrays.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="238678"></a>
<p><strong>
CHAPTER
 9 </strong></p>
<a name="238680"></a>
<h1>Interfaces</h1>
<hr><p>
<a name="253487"></a>
An interface declaration introduces a new reference type whose members are classes, interfaces, constants and abstract methods. This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods.<p>
<a name="245713"></a>
A <i>nested interface</i> is any interface whose declaration occurs within the body of another class or interface. A <i>top-level interface</i> is an interface that is not a nested interface.<p>
<a name="257087"></a>
We distinguish between two kinds of interfaces - normal interfaces and annotation types.<p>
<a name="245720"></a>
This chapter discusses the common semantics of all interfaces-normal interfaces and annotation types <a href="interfaces.html#239527">(&#167;9.6)</a>, top-level <a href="packages.html#26783">(&#167;7.6)</a> and nested (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>). Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.<p>
<a name="247545"></a>
<p>Programs can use interfaces to make it unnecessary for related classes to share a common abstract superclass or to add methods to <code>Object</code>.</p>
<a name="247549"></a>
An interface may be declared to be a <em>direct extension </em>of one or more other interfaces, meaning that it implicitly specifies all the member types, abstract methods and constants of the interfaces it extends, except for any member types and constants that it may hide.<p>
<a name="30809"></a>
A class may be declared to <em>directly implement</em> one or more interfaces, meaning that any instance of the class implements all the abstract methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing any implementation.<p>
<a name="35467"></a>
A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the abstract methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.<p>
<a name="35470"></a>
<a name="9.1"></a>
<h2>9.1    Interface Declarations</h2>
<a name="27727"></a>
An <i>interface declaration</i> specifies a new named reference type. There are two kinds of interface declarations - <i>normal interface declarations</i> and <i>annotation type declarations</i>:<p>
<a name="257053"></a>
<em>InterfaceDeclaration:       
        NormalInterfaceDeclaration
        AnnotationTypeDeclaration</em>
        </pre></blockquote>
<a name="261856"></a>
<p>
<a name="261864"></a>
Annotation types are described further in <a href="interfaces.html#239527">&#167;9.6</a>.<p>
<blockquote><pre>
<em>
NormalInterfaceDeclaration:
        InterfaceModifiers<sub><i>opt</i></sub></em> interface <em>Identifier TypeParametersopt
                ExtendsInterfaces<sub><i>opt</i></sub> InterfaceBody
                </em>
</pre></blockquote><a name="252341"></a>
The <em>Identifier</em> in an interface declaration specifies the name of the interface. A compile-time error occurs if an interface has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="235947"></a>
<a name="9.1.1"></a>
<h3>9.1.1    Interface Modifiers</h3>
<a name="17033"></a>
An interface declaration may include <em>interface modifiers</em>:<p>
<blockquote><pre>
<em>
InterfaceModifiers:
        InterfaceModifier
        InterfaceModifiers InterfaceModifier

InterfaceModifier: one of
         Annotation </em>public&#32;protected&#32;private
        abstract&#32;static&#32;strictfp
</pre></blockquote><a name="254704"></a>
The access modifier <code>public</code> is discussed in <a href="names.html#104285">&#167;6.6</a>. Not all modifiers are applicable to all kinds of interface declarations. The access modifiers <code>protected</code> and <code>private</code> pertain only to member interfaces within a directly enclosing class declaration <a href="classes.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.html#247581">&#167;8.5.1</a>. The access modifier <code>static</code> pertains only to member interfaces (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in an interface declaration. If an annotation <i>a</i> on an interface declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.TYPE</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="30820"></a>
<a name="9.1.1.1"></a>
<h4>9.1.1.1    abstract Interfaces</h4>
<a name="30821"></a>
Every interface is implicitly <code>abstract</code>. This modifier is obsolete and should not be used in new programs.<p>
<a name="246350"></a>
<a name="9.1.1.2"></a>
<h4>9.1.1.2    strictfp Interfaces</h4>
<a name="251658"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the interface declaration be explicitly FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>. <p>
<a name="252569"></a>
This implies that all nested types declared in the interface are implicitly <code>strictfp</code>.<p>
<a name="78598"></a>
<a name="9.1.2"></a>
<h3>9.1.2    Generic Interfaces and Type Parameters</h3>
<a name="253413"></a>
An interface is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>type parameters</i> of the interface. The type parameter section follows the interface name and is delimited by angle brackets. It defines one or more type variables that act as parameters. A generic interface declaration defines a set of types, one for each possible invocation of the type parameter section. All parameterized types share the same interface at runtime.  <p>
<a name="262586"></a>
The scope of an interface's type parameter is the entire declaration of the interface including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="257817"></a>
It is a compile-time error to refer to a type parameter of an interface <i>I</i> anywhere in the declaration of a field or type member of <i>I</i>.<p>
<a name="253307"></a>
<a name="9.1.3"></a>
<h3>9.1.3    Superinterfaces and Subinterfaces</h3>
<a name="78599"></a>
If an <code>extends</code> clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces. These other named interfaces are the <em>direct superinterfaces</em> of the interface being declared. Any class that <code>implements</code> the declared interface is also considered to implement all the interfaces that this interface <code>extends</code>.<p>
<blockquote><pre>
<em>
ExtendsInterfaces:</em>
        extends <em>InterfaceType
        ExtendsInterfaces , InterfaceType
</em>
</pre></blockquote><a name="21599"></a>
The following is repeated from <a href="typesValues.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
InterfaceType:
        TypeDeclSpecifier TypeArguments<sub>opt</sub>
        </em>
</pre></blockquote><a name="257108"></a>
Given a (possibly generic) interface declaration for <i>I&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i><img src="chars/gtequal.gif">0, the <i>direct superinterfaces</i> of the interface type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>I&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> are the types given in the extends clause of the declaration of <i>I</i> if an extends clause is present.<p>
<a name="257118"></a>
Let <i>I&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i>&gt;0, be a generic interface declaration. The direct superinterfaces of the parameterized interface type <i>I&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> , where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, are all types <i>J&lt;U<sub>1</sub> theta , ..., U<sub>k</sub> theta&gt;</i>, where <i>J&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is a direct superinterface of <i>I&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub></i>, ..., <i>F<sub>n</sub></i> := <i>T<sub>n</sub></i>].<p>
<a name="152015"></a>
Each <em>InterfaceType </em>in the <code>extends</code> clause of an interface declaration must name an accessible interface type; otherwise a compile-time error occurs.<p>
<a name="246991"></a>
An interface <i>I directly depends</i> on a type <i>T</i> if <i>T</i> is mentioned in the <code>extends</code> clause of <i>I</i> either as a superinterface or as a qualifier within a superinterface name. An interface <i>I depends</i> on a reference type <i>T</i> if any of the following conditions hold:<p>
<ul><a name="246992"></a>
<li><i>I</i> directly depends on <i>T</i>.
<a name="246996"></a>
<li><i>I</i> directly depends on a class <i>C</i> that depends <a href="classes.html#34031">(&#167;8.1.5)</a> on <i>T</i>.
<a name="252497"></a>
<li><i>I</i> directly depends on an interface <i>J</i> that depends on <i>T</i> (using this definition recursively).
</ul><a name="252500"></a>
A compile-time error occurs if an interface depends on itself.<p>
<a name="78603"></a>
While every class is an extension of class <code>Object</code>, there is no single interface of which all interfaces are extensions. <p>
<a name="245858"></a>
The <em>superinterface </em>relationship is the transitive closure of the direct superinterface relationship. An interface <i>K</i> is a superinterface of interface <i>I</i> if either of the following is true:<p>
<ul><a name="236096"></a>
<li><i>K</i> is a direct superinterface of <i>I</i>.
<a name="236097"></a>
<li>There exists an interface <i>J</i> such that <i>K</i> is a superinterface of <i>J</i>, and <i>J</i> is a superinterface of <i>I</i>, applying this definition recursively.
</ul><a name="236428"></a>
Interface <i>I</i> is said to be a <em>subinterface </em>of interface <i>K</i> whenever <i>K</i> is a superinterface of <i>I</i>.<p>
<a name="236431"></a>
<a name="9.1.4"></a>
<h3>9.1.4    Interface Body and Member Declarations</h3>
<a name="78608"></a>
The body of an interface may declare members of the interface:<p>
<blockquote><pre>
<em>
InterfaceBody:
        </em>{<em> InterfaceMemberDeclarations<sub><i>opt</i></sub> </em>}<em>

InterfaceMemberDeclarations:
        InterfaceMemberDeclaration
        InterfaceMemberDeclarations InterfaceMemberDeclaration

InterfaceMemberDeclaration:
        ConstantDeclaration
        AbstractMethodDeclaration
        ClassDeclaration 
        InterfaceDeclaration</em>
        <code>;</code>                          
</pre></blockquote><a name="262569"></a>
The scope of the declaration of a member <i>m</i> declared in or inherited by an interface type <i>I</i> is the entire body of <i>I</i>, including any nested type declarations.<p>
<a name="17144"></a>
<a name="9.1.5"></a>
<h3>9.1.5    Access to Interface Member Names</h3>
<a name="17145"></a>
All interface members are implicitly <code>public</code>. They are accessible outside the package where the interface is declared if the interface is also declared <code>public</code> or <code>protected</code>, in accordance with the rules of <a href="names.html#104285">&#167;6.6</a>.<p>
<a name="32392"></a>
<a name="9.2"></a>
<h2>9.2    Interface Members</h2>
<a name="262575"></a>
The members of an interface are:<p>
<ul><a name="262576"></a>
<li>Those members declared in the interface.
<a name="262579"></a>
<li>Those members inherited from direct superinterfaces.
<a name="262580"></a>
<li>If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method <i>m</i> with signature <i>s,</i> return type <i>r,</i> and <code>throws</code> clause <i>t</i> corresponding to each public instance method <i>m</i> with signature <i>s,</i> return type <i>r,</i> and <code>throws</code> clause <i>t</i> declared in <code>Object</code>, unless a method with the same signature, same return type, and a compatible <code>throws</code> clause is explicitly declared by the interface. It is a compile-time error if the interface explicitly declares such a method <i>m</i> in the case where <i>m</i> is declared to be <code>final</code> in <code>Object</code>.
</ul><a name="252465"></a>
It follows that is a compile-time error if the interface declares a method with a signature that is override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> to a public method of <code>Object</code>, but has a different return type or incompatible <code>throws</code> clause.<p>
<a name="256599"></a>
The interface inherits, from the interfaces it extends, all members of those interfaces, except for fields, classes, and interfaces that it hides and methods that it overrides.<p>
<a name="78642"></a>
<a name="9.3"></a>
<h2>9.3    Field (Constant) Declarations</h2>
<blockquote><pre>
<em>
ConstantDeclaration:
        ConstantModifiers<sub><i>opt</i></sub> Type VariableDeclarators ;

ConstantModifiers: 
        ConstantModifier
        ConstantModifier ConstantModifers&#32;

ConstantModifier: one of
        Annotation</em> public&#32;static&#32;final 
</pre></blockquote><a name="40575"></a>
Every field declaration in the body of an interface is implicitly <code>public</code>, <code>static</code>, and <code>final</code>. It is permitted to redundantly specify any or all of these modifiers for such fields.<p>
<a name="254713"></a>
If an annotation <i>a</i> on a field declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.FIELD</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="252384"></a>
If the interface declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superinterfaces of the interface.<p>
<a name="252453"></a>
It is a compile-time error for the body of an interface declaration to declare two fields with the same name.<p>
<a name="40725"></a>
It is possible for an interface to inherit more than one field with the same name <a href="classes.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to either field by its simple name will result in a compile-time error, because such a reference is ambiguous.<p>
<a name="40729"></a>
There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity. <p>
<a name="40720"></a>
<a name="9.3.1"></a>
<h3>9.3.1    Initialization of Fields in Interfaces</h3>
<a name="236695"></a>
Every field in the body of an interface must have an initialization expression, which need not be a constant expression. The variable initializer is evaluated and the assignment performed exactly once, when the interface is initialized <a href="execution.html#44557">(&#167;12.4)</a>.<p>
<a name="247455"></a>
A compile-time error occurs if an initialization expression for an interface field contains a reference by simple name to the same field or to another field whose declaration occurs textually later in the same interface.<p>
<a name="247101"></a>
<p>Thus:</p>
<blockquote><pre>interface Test {
        float f = j;
        int j = 1;
        int k = k+1;
}
</pre></blockquote><a name="41013"></a>
causes two compile-time errors, because <code>j</code> is referred to in the initialization of <code>f</code> before <code>j</code> is declared and because the initialization of <code>k</code> refers to <code>k</code> itself.<p>
<a name="247483"></a>
<p>One subtlety here is that, at run time, fields that are initialized with compile-time constant values are initialized first. This applies also to <code>static</code> <code>final</code> fields in classes <a href="classes.html#38010">(&#167;8.3.2.1)</a>. This means, in particular, that these fields will never be observed to have their default initial values <a href="typesValues.html#96595">(&#167;4.12.5)</a>, even by devious programs. See <a href="execution.html#44630">&#167;12.4.2</a> and <a href="binaryComp.html#45139">&#167;13.4.9</a> for more discussion.</p>
<a name="41024"></a>
If the keyword <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.html#20860">15.11.2</a>, <a href="expressions.html#20448">15.12</a>) occurs in an initialization expression for a field of an interface, then unless the occurrence is within the body of an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a>, a compile-time error occurs.<p>
<a name="40595"></a>
<a name="9.3.2"></a>
<h3>9.3.2    Examples of Field Declarations</h3>
<a name="40743"></a>
The following example illustrates some (possibly subtle) points about field declarations.<p>
<a name="40596"></a>
<a name="9.3.2.1"></a>
<h4>9.3.2.1    Ambiguous Inherited Fields</h4>
<a name="40648"></a>
If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single <em>ambiguous member</em> results. Any use of this ambiguous member will result in a compile-time error. <p>
<a name="261996"></a>
<p>
<a name="261997"></a>
Thus in the example:<p>
<blockquote><pre>interface BaseColors {
        int RED = 1, GREEN = 2, BLUE = 4;
}
interface RainbowColors extends BaseColors {
        int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7;
}
interface PrintColors extends BaseColors {
        int YELLOW = 8, CYAN = 16, MAGENTA = 32;
}
interface LotsOfColors extends RainbowColors, PrintColors {
        int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90;
}
</pre></blockquote><a name="40661"></a>
the interface <code>LotsOfColors</code> inherits two fields named <code>YELLOW</code>. This is all right as long as the interface does not contain any reference by simple name to the field <code>YELLOW</code>. (Such a reference could occur within a variable initializer for a field.)<p>
<a name="40696"></a>
<p>Even if interface <code>PrintColors</code> were to give the value <code>3</code> to <code>YELLOW</code> rather than the value <code>8</code>, a reference to field <code>YELLOW</code> within interface <code>LotsOfColors</code> would still be considered ambiguous.</p>
<a name="40599"></a>
<a name="9.3.2.2"></a>
<h4>9.3.2.2    Multiply Inherited Fields</h4>
<a name="236005"></a>
If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results. This situation does not in itself cause a compile-time error. <p>
<a name="247488"></a>
<p>In the example in the previous section, the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by interface <code>LotsOfColors</code> in more than one way, through interface <code>RainbowColors</code> and also through interface <code>PrintColors</code>, but the reference to field <code>RED</code> in interface <code>LotsOfColors</code> is not considered ambiguous because only one actual declaration of the field <code>RED</code> is involved.</p>
<a name="78651"></a>
<a name="9.4"></a>
<h2>9.4    Abstract Method Declarations</h2>
<blockquote><pre>
<em>
AbstractMethodDeclaration:
        AbstractMethodModifiers<sub><i>opt</i></sub> TypeParameters<sub>opt</sub> ResultType 
MethodDeclarator Throws<sub><i>opt</i></sub> ;

AbstractMethodModifiers:
        AbstractMethodModifier
        AbstractMethodModifiers AbstractMethodModifier

AbstractMethodModifier: one of
        Annotation </em>public&#32;abstract 
</pre></blockquote><a name="36046"></a>
The access modifier <code>public</code> is discussed in <a href="names.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in an abstract method declaration.<p>
<a name="247503"></a>
Every method declaration in the body of an interface is implicitly <code>abstract</code>, so its body is always represented by a semicolon, not a block.<p>
<a name="250791"></a>
Every method declaration in the body of an interface is implicitly <code>public</code>.<p>
<a name="247508"></a>
<p>For compatibility with older versions of the Java platform, it is permitted but discouraged, as a matter of style, to redundantly specify the <code>abstract</code> modifier for methods declared in interfaces.</p>
<a name="247493"></a>
<p>It is permitted, but strongly discouraged as a matter of style, to redundantly specify the <code>public</code> modifier for interface methods.</p>
<a name="38687"></a>
Note that a method declared in an interface must not be declared <code>static</code>, or a compile-time error occurs, because <code>static</code> methods cannot be <code>abstract</code>.<p>
<a name="245194"></a>
Note that a method declared in an interface must not be declared <code>strictfp</code> or <code>native</code> or <code>synchronized</code>, or a compile-time error occurs, because those keywords describe implementation properties rather than interface properties. However, a method declared in an interface may be implemented by a method that is declared <code>strictfp</code> or <code>native</code> or <code>synchronized</code> in a class that implements the interface.<p>
<a name="254723"></a>
If an annotation <i>a</i> on a method declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.METHOD</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="252440"></a>
It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with override-equivalent signatures <a href="classes.html#38649">(&#167;8.4.2)</a>. However, an interface may inherit several methods with such signatures <a href="interfaces.html#40247">(&#167;9.4.1)</a>.<p>
<a name="38671"></a>
Note that a method declared in an interface must not be declared <code>final</code> or a compile-time error occurs. However, a method declared in an interface may be implemented by a method that is declared <code>final</code> in a class that implements the interface.<p>
<a name="257750"></a>
A method in an interface may be generic. The rules for formal type parameters of a generic method in an interface are the same as for a generic method in a class <a href="classes.html#323928">(&#167;8.4.4)</a>.<p>
<a name="40247"></a>
<a name="9.4.1"></a>
<h3>9.4.1    Inheritance and Overriding</h3>
<a name="258295"></a>
An instance method <i>m<sub>1</sub></i> declared in an interface <i>I</i> <em>overrides</em> another instance method, <i>m<sub>2</sub></i>, declared in interface <i>J</i> iff both of the following are true:<p>
<ol>
<a name="257954"></a>
<li><i>I</i> is a subinterface of <i>J.</i>
<a name="257955"></a>
<li>The signature of <i>m<sub>1</sub></i> is a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m<sub>2</sub></i>. 
</ol>
<a name="258312"></a>
If a method declaration <i>d<sub>1</sub></i> with return type <i>R<sub>1</sub></i> overrides or hides the declaration of another method <i>d<sub>2</sub></i> with return type <i>R<sub>2</sub></i>, then <i>d<sub>1</sub></i> must be return-type-substitutable <a href="classes.html#296201">(&#167;8.4.5)</a> for <i>d<sub>2</sub></i><i>,</i> or a compile-time error occurs. Furthermore, if <i>R<sub>1</sub></i> is not a subtype of <i>R<sub>2</sub></i>, an unchecked warning must be issued.<p>
<a name="245222"></a>
Moreover, a method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.html#308526">(&#167;8.4.6)</a> with that of any method that it overrides; otherwise, a compile-time error occurs.<p>
<a name="262510"></a>
It is a compile time error if a type declaration <i>T</i> has a member method <i>m<sub>1</sub></i> and there exists a method <i>m<sub>2</sub></i> declared in <i>T</i> or a supertype of <i>T</i> such that all of the following conditions hold:<p>
<ul><a name="262511"></a>
<li><i>m<sub>1</sub></i> and <i>m<sub>2</sub></i> have the same name.
<a name="262512"></a>
<li><i>m<sub>2</sub></i> is accessible from <i>T.</i>
<a name="262516"></a>
<li>The signature of <i>m<sub>1</sub></i> is not a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m<sub>2</sub></i>.
<a name="262535"></a>
<li><i>m<sub>1</sub></i> or some method <i>m<sub>1</sub></i> overrides (directly or indirectly) has the same erasure as <i>m<sub>2</sub></i> or some method <i>m<sub>2</sub></i> overrides (directly or indirectly).
</ul><a name="262412"></a>
<p>
<a name="236025"></a>
Methods are overridden on a signature-by-signature basis. If, for example, an interface declares two <code>public</code> methods with the same name, and a subinterface overrides one of them, the subinterface still inherits the other method.<p>
<a name="40237"></a>
An interface inherits from its direct superinterfaces all methods of the superinterfaces that are not overridden by a declaration in the interface.<p>
<a name="258891"></a>
It is possible for an interface to inherit several methods with override-equivalent signatures <a href="classes.html#38649">(&#167;8.4.2)</a>. Such a situation does not in itself cause a compile-time error. The interface is considered to inherit all the methods. However, one of the inherited methods must must be return type substitutable for any other inherited method; otherwise, a compile-time error occurs (The <code>throws</code> clauses do not cause errors in this case.)<p>
<a name="40242"></a>
There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never of itself results in a compile-time error.<p>
<a name="236017"></a>
<a name="9.4.2"></a>
<h3>9.4.2    Overloading</h3>
<a name="40243"></a>
If two methods of an interface (whether both declared in the same interface, or both inherited by an interface, or one declared and one inherited) have the same name but different signatures that are not override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a>, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name but different signatures that are not override-equivalent.<p>
<a name="40248"></a>
<a name="9.4.3"></a>
<h3>9.4.3    Examples of Abstract Method Declarations</h3>
<a name="40738"></a>
The following examples illustrate some (possibly subtle) points about abstract method declarations.<p>
<a name="40734"></a>
<a name="9.4.3.1"></a>
<h4>9.4.3.1    Example: Overriding</h4>
<a name="40251"></a>
Methods declared in interfaces are <code>abstract</code> and thus contain no implementation. About all that can be accomplished by an overriding method declaration, other than to affirm a method signature, is to refine the return type or to restrict the exceptions that might be thrown by an implementation of the method. Here is a variation of the example shown in <a href="classes.html#34484">(&#167;8.4.3.1)</a>:<p>
<blockquote><pre>class BufferEmpty extends Exception {
        BufferEmpty() { super(); }
        BufferEmpty(String s) { super(s); }
}
class BufferException extends Exception {
        BufferException() { super(); }
        BufferException(String s) { super(s); }
} 
public interface Buffer {
        char get() throws BufferEmpty, BufferException;
}
public interface InfiniteBuffer extends Buffer {
         char get() throws BufferException;                                                                                             // override
}
</pre></blockquote><a name="40735"></a>
<a name="9.4.3.2"></a>
<h4>9.4.3.2    Example: Overloading</h4>
<a name="40788"></a>
In the example code:<p>
<blockquote><pre>interface PointInterface {
        void move(int dx, int dy);
}
interface RealPointInterface extends PointInterface {
        void move(float dx, float dy);
        void move(double dx, double dy);
}
</pre></blockquote><a name="252555"></a>
the method name <code>move</code> is overloaded in interface <code>RealPointInterface</code> with three different signatures, two of them declared and one inherited. Any non-<code>abstract</code> class that implements interface <code>RealPointInterface</code> must provide implementations of all three method signatures.<p>
<a name="252566"></a>
<a name="9.5"></a>
<h2>9.5    Member Type Declarations</h2>
<a name="245919"></a>
Interfaces may contain member type declarations <a href="classes.html#246026">(&#167;8.5)</a>. A member type declaration in an interface is implicitly <code>static</code> and public.<p>
<a name="245949"></a>
If a member type declared with simple name <i>C</i> is directly enclosed within the declaration of an interface with fully qualified name <i>N</i>, then the member type has the fully qualified name <i>N.C</i>. <p>
<a name="253328"></a>
If the interface declares a member type with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of member types with the same name in superinterfaces of the interface.<p>
<a name="253331"></a>
An interface inherits from its direct superinterfaces all the non-private member types of the superinterfaces that are both accessible to code in the interface and not hidden by a declaration in the interface.<p>
<a name="239523"></a>
An interface may inherit two or more type declarations with the same name. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name. If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once; it may be referred to by its simple name without ambiguity.<p>
<a name="239527"></a>
<a name="9.6"></a>
<h2>9.6    Annotation Types</h2>
<a name="253501"></a>
An annotation type declaration is a special kind of interface declaration. To distinguish an annotation type declaration from an ordinary interface declaration, the keyword <code>interface</code> is preceded by an at sign (<code>@</code>). <p>
<hr>
<a name="258950"></a>
<p>
<b>Discussion</b>
</p>
<a name="258951"></a>
<a name="258952"></a>
<a name="254858"></a>
 <p>
<a name="254859"></a>
 Note that the at sign (<code>@</code>) and the keyword <code>interface</code> are two distinct tokens; technically it is possible to separate them with whitespace, but this is strongly discouraged as a matter of style. <p>
<hr>
<a name="254860"></a>
 <p>
<blockquote><pre>
<em>
    AnnotationTypeDeclaration:
        InterfaceModifiers<sub>opt</sub> @ interface Identifier AnnotationTypeBody

    AnnotationTypeBody:
        </em>{<em> AnnotationTypeElementDeclarations<sub>opt</sub> </em>}<em>

    AnnotationTypeElementDeclarations:
        AnnotationTypeElementDeclaration
        AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration

    AnnotationTypeElementDeclaration:
        AbstractMethodModifiers<sub>opt</sub> Type Identifier ( ) DefaultValue<sub>opt</sub> ;
        ConstantDeclaration
        ClassDeclaration
        InterfaceDeclaration
        EnumDeclaration
        AnnotationTypeDeclaration
        ;

    DefaultValue:
        default ElementValue
        </em>
        </pre></blockquote>
<a name="254970"></a>
<p>
<a name="254971"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 The following restrictions are imposed on annotation type declarations by virtue of their context free syntax: <p>
<ul><a name="254972"></a>
<li>Annotation type declarations cannot be generic. 
<a name="254973"></a>
<li>No extends clause is permitted. (Annotation types implicitly extend <code>annotation.Annotation</code>.)
<a name="254974"></a>
<li>Methods cannot have any parameters
<a name="254975"></a>
<li>Methods cannot have any type parameters 
<a name="254976"></a>
<li>Method declarations cannot have a <code>throws</code> clause
<a name="254977"></a>
 <p>
</ul><a name="254978"></a>
<hr>
<p>
<a name="262001"></a>
Unless explicitly modified herein, all of the rules that apply to ordinary interface declarations apply to annotation type declarations.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="262000"></a>
<p>
<a name="255049"></a>
<a name="255055"></a>
 For example, annotation types share the same namespace as ordinary class and interface types. <p>
<a name="255053"></a>
Annotation type declarations are legal wherever interface declarations are legal, and have the same scope and accessibility. <p>
<hr>
<a name="255051"></a>
 <p>
<a name="260924"></a>
<a name="261998"></a>
The <em>Identifier</em> in an annotation type declaration specifies the name of the annotation type. A compile-time error occurs if an annotation type has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="255087"></a>
If an annotation <i>a</i> on an annotation type declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have either an element whose value is <code>annotation.ElementType.ANNOTATION_TYPE</code>, or an element whose value is <code>annotation.ElementType.TYPE</code>, or a compile-time error occurs. <p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="261999"></a>
<p>
<a name="255818"></a>
<a name="255819"></a>
 By convention, no <em>AbstractMethodModifiers</em> should be present except for annotations.<p>
<hr>
<a name="255820"></a>
 <p>
<a name="255814"></a>
The direct superinterface of an annotation type is always <code>annotation.Annotation</code>. <p>
<a name="255092"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255093"></a>
 A consequence of the fact that an annotation type cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation type is never itself an annotation type. Similarly, <code>annotation.Annotation </code>is not itself an annotation type.<p>
<hr>
<a name="255052"></a>
 <p>
<a name="254942"></a>
It is a compile-time error if the return type of a method declared in an annotation type is any type other than one of the following: one of the primitive types, <code>String</code>, <code>Class</code> and any invocation of <code>Class</code>, an enum type <a href="classes.html#301020">(&#167;8.9)</a>, an annotation type, or an array <a href="arrays.html#27803">(&#167;10)</a> of one of the preceding types. It is also a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any <code>public</code> or <code>protected</code> method declared in class <code>Object</code> or in the interface <code>annotation.Annotation</code>. <p>
<a name="255012"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255013"></a>
 Note that this does not conflict with the prohibition on generic methods, as wildcards eliminate the need for an explicit type parameter. <p>
<hr>
<a name="255014"></a>
 <p>
<a name="254879"></a>
Each method declaration in an annotation type declaration defines an element of the annotation type. Annotation types can have zero or more elements. An annotation type has no elements other than those defined by the methods it explicitly declares. <p>
<a name="255073"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255077"></a>
 Thus, an annotation type declaration inherits several members from <code>annotation.Annotation</code>, including the implicitly declared methods corresponding to the instance methods in <code>Object</code>, yet these methods do not define elements of the annotation type and it is illegal to use them in annotations. <p>
<a name="255083"></a>
Without this rule, we could not ensure that the elements were of the types representable in annotations, or that access methods for them would be available.<p>
<hr>
<a name="255074"></a>
 <p>
<a name="255075"></a>
It is a compile-time error if an annotation type <i>T</i> contains an element of type <i>T,</i> either directly or indirectly.<p>
<hr>
<a name="254148"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="253967"></a>
 For example, this is illegal: <p>
<blockquote><pre>// Illegal self-reference!!
@interface SelfRef {
    SelfRef value();
}
</pre></blockquote><a name="253523"></a>
and so is this: <p>
<blockquote><pre>// Illegal circularity!!
@interface Ping {
    Pong value();
}
@interface Pong {
    Ping value();
}
</pre></blockquote>
<a name="253534"></a>
 Note also that this specification precludes elements whose types are nested arrays. For example, this annotation type declaration is illegal: <p>
 <blockquote><pre>
// Illegal nested array!!
@interface Verboten {
    String[][] value();
}
</pre></blockquote>
<a name="253540"></a>
 <p>
<hr>
<p>
<a name="253974"></a>
An annotation type element may have a default value specified for it. This is done by following its (empty) parameter list with the keyword <code>default</code> and the default value of the element. <p>
<a name="255040"></a>
Defaults are applied dynamically at the time annotations are read; default values are not compiled into annotations. Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element).<p>
<a name="253577"></a>
An <em>ElementValue</em> is used to specify a default value. It is a compile-time error if the type of the element is not commensurate <a href="interfaces.html#253695">(&#167;9.7)</a> with the default value specified. An <em>ElementValue</em> is always FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>.<p>
<a name="253579"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="253582"></a>
The following annotation type declaration defines an annotation type with several elements: <p>
<blockquote><pre>// Normal annotation type declaration with several elements

/**
        * Describes the "request-for-enhancement" (RFE) 
        * that led to the presence of 
        * the annotated API element.
 */
public @interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}
</pre></blockquote><a name="253597"></a>
The following annotation type declaration defines an annotation type with no elements, termed a marker annotation type: <p>
<blockquote><pre>// Marker annotation type declaration

/**
 * Annotation with this type indicates that the specification of the
 * annotated API element is preliminary and subject to change.
 */
public @interface Preliminary { }
<a name="253606"></a>
</pre></blockquote><a name="253607"></a>
<hr>
<p>
By convention, the name of the sole element in a single-element annotation type is <code>value</code>. <p>
<a name="255480"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255479"></a>
 Linguistic support for this convention is provided by the single element annotation construct <a href="interfaces.html#253695">(&#167;9.7)</a>; one must obey the convention in order to take advantage of the construct.<p>
 <hr>
<a name="255481"></a>
 <p>
<a name="254358"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="254353"></a>
 The convention is illustrated in the following annotation type declaration: <p>
<blockquote><pre>// Single-element annotation type declaration

/**
 * Associates a copyright notice with the annotated API element.
 */
public @interface Copyright {
    String value();
}
</pre></blockquote>
<a name="253619"></a>
 The following annotation type declaration defines a single-element annotation type whose sole element has an array type: <p>
<blockquote><pre>
// Single-element annotation type declaration with array-typed 
// element

/**
 * Associates a list of endorsers with the annotated class.
 */
public @interface Endorsers {
    String[] value();
}
</pre></blockquote>
<a name="253630"></a>
 Here is an example of complex annotation types, annotation types that contain one or more elements whose types are also annotation types. <p>
<blockquote><pre>
// Complex Annotation Type

/**
 * A person's name.  This annotation type is not designed to be used
 * directly to annotate program elements, but to define elements
 * of other annotation types.
 */
public @interface Name {
    String first();
    String last();
}

/**
 * Indicates the author of the annotated program element.
 */
public @interface Author {
    Name value();
}

/**
 * Indicates the reviewer of the annotated program element.
 */
public @interface Reviewer {
    Name value();
}
</pre></blockquote>
<a name="253658"></a>
 The following annotation type declaration provides default values for two of its four elements: <p>
 <blockquote><pre>
// Annotation type declaration with defaults on some elements
public @interface RequestForEnhancement {
    int    id();       // No default - must be specified in 
                                                        // each annotation
    String synopsis(); // No default - must be specified in 
                                                        // each annotation
    String engineer()  default "[unassigned]";
    String date()      default "[unimplemented]";
}
</pre></blockquote>
<a name="253669"></a>
 The following annotation type declaration shows a <code>Class</code> annotation whose value is restricted by a bounded wildcard. <p>
 <blockquote><pre>
// Annotation type declaration with bounded wildcard to 
//      restrict <code>Class</code> annotation
// The annotation type declaration below presumes the existence 
// of this interface, which describes a formatter for Java 
// programming language source code
public interface Formatter { ... }

// Designates a formatter to pretty-print the annotated class.
public @interface PrettyPrinter {
    Class&lt;? extends Formatter&gt; value();
}
</pre></blockquote>
<a name="253685"></a>
 Note that the grammar for annotation type declarations permits other element declarations besides method declarations. For example, one might choose to declare a nested enum for use in conjunction with an annotation type: <p>
 <blockquote><pre>
// Annotation type declaration with nested enum type declaration
public @interface Quality {
    enum Level { BAD, INDIFFERENT, GOOD }

    Level value();
}
<a name="255562"></a>
</pre></blockquote><a name="255549"></a>
<hr>
<p>
<a name="9.6.1"></a>
<h3>9.6.1    Predefined Annotation Types</h3>
<a name="255550"></a>
Several annotation types are predefined in the libraries of the Java platform. Some of these predefined annotation types have special semantics. These semantics are specified in this section. This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications. Only those semantics that require special behavior on the part of the Java compiler or virtual machine are specified here.<p>
<a name="255693"></a>
<a name="9.6.1.1"></a>
<h4>9.6.1.1    Target</h4>
<a name="255830"></a>
The annotation type <code>annotation.Target</code> is intended to be used in meta-annotations that indicate the kind of program element that an annotation type is applicable to. <code>Target</code> has one element, of type <code>annotation.ElementType[]</code>. It is a compile-time error if a given enum constant appears more than once in an annotation whose corresponding type is <code>annotation.Target</code>. See sections <a href="packages.html#26621">&#167;7.4.1</a>, <a href="classes.html#21613">&#167;8.1.1</a>, <a href="classes.html#78091">&#167;8.3.1</a>, <a href="classes.html#38698">&#167;8.4.1</a>, <a href="classes.html#78188">&#167;8.4.3</a>, <a href="classes.html#42018">&#167;8.8.3</a>, <a href="classes.html#301020">&#167;8.9</a>, <a href="interfaces.html#235947">&#167;9.1.1</a>, <a href="interfaces.html#78642">&#167;9.3</a>, <a href="interfaces.html#78651">&#167;9.4</a>, <a href="interfaces.html#239527">&#167;9.6</a> and <a href="statements.html#5920">&#167;14.4</a> for the other effects of <code>@annotation.Target</code> annotations.<p>
<a name="255829"></a>
<a name="9.6.1.2"></a>
<h4>9.6.1.2    Retention</h4>
<a name="255873"></a>
Annotations may be present only in the source code, or they may be present in the binary form of a class or interface. An annotation that is present in the binary may or may not be available at run-time via the reflective libraries of the Java platform.<p>
<a name="255874"></a>
The annotation type <code>annotation.Retention</code> is used to choose among the above possibilities. If an annotation <i>a</i> corresponds to a type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Retention</code>, then:<p>
<ul><a name="255883"></a>
<li>If <i>m</i> has an element whose value is <code>annotation.RetentionPolicy.SOURCE</code>, then a Java compiler must ensure that <i>a</i> is not present in the binary representation of the class or interface in which <i>a</i> appears.
<a name="255884"></a>
<li>If <i>m</i> has an element whose value is <code>annotation.RetentionPolicy.CLASS</code>, or <code>annotation.RetentionPolicy.RUNTIME</code> a Java compiler must ensure that <i>a</i> is represented in the binary representation of the class or interface in which <i>a</i> appears, unless <i>m</i> annotates a local variable declaration. An annotation on a local variable declaration is never retained in the binary representation.
</ul><a name="255921"></a>
If <i>T</i> does not have a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Retention</code>, then a Java compiler must treat <i>T</i> as if it does have such a meta-annotation <i>m</i> with an element whose value is <code>annotation.RetentionPolicy.CLASS</code>.<p>
<hr>
<a name="255940"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255941"></a>
 If <i>m</i> has an element whose value is <code>annotation.RetentionPolicy.RUNTIME</code>, the reflective libraries of the Java platform will make a available at run-time as well.<p>
<hr>
<a name="255942"></a>
 <p>
<a name="255872"></a>
<a name="9.6.1.3"></a>
<h4>9.6.1.3    Inherited</h4>
<a name="255964"></a>
The annotation type <code>annotation.Inherited</code> is used to indicate that annotations on a class <i>C</i> corresponding to a given annotation type are inherited by subclasses of <i>C.</i><p>
<a name="255963"></a>
<a name="9.6.1.4"></a>
<h4>9.6.1.4    Override</h4>
<a name="255572"></a>
Programmers occasionally overload a method declaration when they mean to override it. <p>
<hr>
<a name="255575"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255674"></a>
 The classic example concerns the equals method. Programmers write the following: <p>
<blockquote><pre>    public boolean equals(Foo that) { ... }
</pre></blockquote><a name="255578"></a>
when they mean to write: <p>
<blockquote><pre>    public boolean equals(Object that) { ... }
</pre></blockquote><a name="255582"></a>
This is perfectly legal, but class <code>Foo</code> inherits the <code>equals</code> implementation from <code>Object</code>, which can cause some very subtle bugs. <p>
<hr>
<a name="255669"></a>
 <p>
<a name="255656"></a>
The annotation type <code>Override</code> supports early detection of such problems. If a method declaration is annotated with the annotation <code>@Override</code>, but the method does not in fact override any method declared in a superclass, a compile-time error will occur.<p>
<hr>
<a name="255602"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="260147"></a>
 Note that if a method overrides a method from a superinterface but not from a superclass, using <code>@Override</code> will cause a compile-time error. <p>
<a name="260162"></a>
The rationale for this is that a concrete class that implements an interface will necessarily override all the interface's methods irrespective of the <code>@Override</code> annotation, and so it would be confusing to have the semantics of this annotation interact with the rules for implementing interfaces.<p>
<a name="260165"></a>
A by product of this rule is that it is never possible to use the <code>@Override</code> annotation in an interface declaration.<p>
<hr>
<a name="260148"></a>
<p>
<a name="260149"></a>
 <p>
<a name="255603"></a>
<a name="9.6.1.5"></a>
<h4>9.6.1.5    SuppressWarnings</h4>
<a name="255605"></a>
The annotation type <code>SuppressWarnings</code> supports programmer control over warnings otherwise issued by the Java compiler. It contains a single element that is an array of <code>String</code>. If a program declaration is annotated with the annotation <code>@SuppressWarnings(value = {</code><i>S<sub>1</sub>, ... , S<sub>k</sub></i>}), then a Java compiler must not report any warning identified by one of <i>S<sub>1</sub>, ... , S<sub>k</sub></i> if that warning would have been generated as a result of the annotated declaration or any of its parts.<p>
<a name="258980"></a>
Unchecked warnings are identified by the string <code>"unchecked"</code>.<p>
<a name="255712"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255707"></a>
 Recent Java compilers issue more warnings than previous ones did, and these "lint-like" warnings are very useful. It is likely that more such warnings will be added over time. To encourage their use, there should be some way to disable a warning in a particular part of the program when the programmer knows that the warning is inappropriate. <p>
 <hr>
<a name="255717"></a>
 <p>
 <hr>
<a name="255636"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255779"></a>
 Compiler vendors should document the warning names they support in conjunction with this annotation type. They are encouraged to cooperate to ensure that the same names work across multiple compilers.<p>
 <hr>
<a name="255729"></a>
 <p>
<a name="255732"></a>
<a name="9.6.1.6"></a>
<h4>9.6.1.6    Deprecated</h4>
<a name="255700"></a>
A program element annotated <code>@Deprecated</code> is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists. A Java compiler must produce a warning when a deprecated type, method, field, or constructor is used (overridden, invoked, or referenced by name) unless:<p>
<ul><a name="255552"></a>
<li>The use is within an entity that itself is is annotated with the annotation <code>@Deprecated</code>; or 
<a name="255553"></a>
<li>The declaration and use are both within the same outermost class; or 
<a name="255554"></a>
<li>The use site is within an entity that is annotated to suppress the warning with the annotation <code>@SuppressWarnings("deprecation")</code>
</ul><a name="255555"></a>
Use of the annotation <code>@Deprecated</code> on a local variable declaration or on a parameter declaration has no effect.<p>
<a name="253695"></a>
<a name="9.7"></a>
<h2>9.7    Annotations</h2>
<a name="253697"></a>
An <i>annotation</i> is a modifier consisting of the name of an annotation type <a href="interfaces.html#239527">(&#167;9.6)</a> and zero or more element-value pairs, each of which associates a value with a different element of the annotation type. The purpose of an annotation is simply to associate information with the annotated program element. <p>
<a name="254754"></a>
Annotations must contain an element-value pair for every element of the corresponding annotation type, except for those elements with default values, or a compile-time error occurs. Annotations may, but are not required to, contain element-value pairs for elements with default values.<p>
<a name="253702"></a>
Annotations may be used as modifiers in any declaration, whether package <a href="packages.html#26619">(&#167;7.4)</a>, class <a href="classes.html#328796">(&#167;8)</a>, interface, field (<a href="classes.html#40898">&#167;8.3</a>, <a href="interfaces.html#78642">&#167;9.3</a>), method (<a href="classes.html#40420">&#167;8.4</a>, <a href="interfaces.html#78651">&#167;9.4</a>), parameter, constructor <a href="classes.html#41652">(&#167;8.8)</a>, or local variable <a href="statements.html#5920">(&#167;14.4)</a>. <p>
<hr>
<a name="255457"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255459"></a>
 Note that classes include enums <a href="classes.html#301020">(&#167;8.9)</a>, and interfaces include annotation types <a href="interfaces.html#239527">(&#167;9.6)</a><p>
 <hr>
<a name="255458"></a>
 <p>
<a name="255456"></a>
Annotations may also be used on enum constants. Such annotations are placed immediately before the enum constant they annotate. <p>
<a name="253717"></a>
It is a compile-time error if a declaration is annotated with more than one annotation for a given annotation type.<p>
<hr>
<a name="254810"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="254809"></a>
 Annotations are conventionally placed before all other modifiers, but this is not a requirement; they may be freely intermixed with other modifiers. <p>
 <hr>
<a name="254812"></a>
 <p>
<a name="253720"></a>
There are three kinds of annotations. The first (normal annotation) is fully general. The others (marker annotation and single-element annotation) are merely shorthands. <p>
<blockquote><pre>
<em>
Annotations:
        Annotation
        Annotations Annotation

    Annotation:
        NormalAnnotation
        MarkerAnnotation
        SingleElementAnnotation
        </em>
</pre></blockquote><a name="253727"></a>
A normal annotation is used to annotate a program element: <p>
<blockquote><pre>
    NormalAnnotation:
        @ TypeName ( ElementValuePairs<sub>opt</sub> )

    ElementValuePairs:
        ElementValuePair
        ElementValuePairs , ElementValuePair

    ElementValuePair:
        Identifier</em> =<em> ElementValue

    ElementValue:
        ConditionalExpression
        Annotation
        ElementValueArrayInitializer

    ElementValueArrayInitializer:
        { ElementValues<sub>opt ,opt</sub> }

    ElementValues:
        ElementValue
        ElementValues , ElementValue
        </em>
        </pre></blockquote>
<a name="253751"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255113"></a>
 Note that the at-sign (@) is a token unto itself. Technically it is possible to put whitespace in between the at-sign and the <em>TypeName</em>, but this is discouraged. <p>
 <hr>
<a name="255114"></a>
 <p>
<a name="253753"></a>
<em>TypeName</em> names the annotation type corresponding to the annotation. It is a compile-time error if <em>TypeName</em> does not name an annotation type. The annotation type named by an annotation must be accessible <a href="names.html#104285">(&#167;6.6)</a> at the point where the annotation is used, or a compile-time error occurs. <p>
<a name="262082"></a>
The <em>Identifier</em> in an <em>ElementValuePair</em> must be the simple name of one of the elements of the annotation type identified by <em>TypeName</em> in the containing annotation. Otherwise, a compile-time error occurs. (In other words, the identifier in an element-value pair must also be a method name in the interface identified by <em>TypeName</em>.) <p>
<a name="261845"></a>
The return type of this method defines the element type of the element-value pair. An <em>ElementValueArrayInitializer</em> is similar to a normal array initializer <a href="arrays.html#11358">(&#167;10.6)</a>, except that annotations are permitted in place of expressions.<p>
<a name="255269"></a>
An element type <i>T</i> is <i>commensurate</i> with an element value <i>V</i> if and only if one of the following conditions is true:<p>
<ul><a name="255270"></a>
<li><i>T</i> is an array type <i>E[]</i> and either:
<ul>
<a name="255429"></a>
<li><i>V</i> is an <em>ElementValueArrayInitializer</em> and each <em>ElementValueInitializer</em> (analogous to a variable initializer in an array initializer) in <i>V</i> is commensurate with <i>E.</i> Or
<a name="255277"></a>
<li><i>V</i> is an <em>ElementValue</em> that is commensurate with <i>T.</i>
</ul>
<a name="255278"></a>
<li>The type of <i>V</i> is assignment compatible <a href="conversions.html#184206">(&#167;5.2)</a> with <i>T</i> and, furthermore:
<ul>
<a name="255279"></a>
<li>If <i>T</i> is a primitive type or <code>String</code>, <i>V</i> is a constant expression <a href="expressions.html#5313">(&#167;15.28)</a>. 
<a name="258908"></a>
<li><i>V</i> is not null.
<a name="255292"></a>
<li>if <i>T</i> is <code>Class</code>, or an invocation of <code>Class</code>, and <i>V</i> is a class literal <a href="expressions.html#251530">(&#167;15.8.2)</a>.
<a name="255312"></a>
<li>If <i>T</i> is an enum type, and <i>V</i> is an enum constant.
</ul>
</ul><a name="255271"></a>
It is a compile-time error if the element type is not commensurate with the <em>ElementValue</em>. <p>
<a name="255364"></a>
If the element type is not an annotation type or an array type, <em>ElementValue</em> must be a <em>ConditionalExpression</em> <a href="expressions.html#290293">(&#167;15.25)</a>. <p>
<a name="255123"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="255124"></a>
 Note that <code>null</code> is not a legal element value for any element type. <p>
<hr>
<a name="255125"></a>
 <p>
<a name="253780"></a>
If the element type is an array type and the corresponding <em>ElementValue</em> is not an <em>ElementValueArrayInitializer</em>, an array value whose sole element is the value represented by the <em>ElementValue</em> is associated with the element. Otherwise, the value represented by <em>ElementValue</em> is associated with the element.<p>
<a name="253784"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="254840"></a>
 In other words, it is permissible to omit the curly braces when a single-element array is to be associated with an array-valued annotation type element. <p>
<a name="255197"></a>
Note that the array's element type cannot be an array type, that is, nested array types are not permitted as element types. (While the annotation syntax would permit this, the annotation type declaration syntax would not.) <p>
<hr>
<a name="254841"></a>
 <p>
<a name="253787"></a>
An annotation on an annotation type declaration is known as a <i>meta-annotation</i>. An annotation type may be used to annotate its own declaration. More generally, circularities in the transitive closure of the "annotates" relation are permitted. For example, it is legal to annotate an annotation type declaration with another annotation type, and to annotate the latter type's declaration with the former type. (The pre-defined meta-annotation types contain several such circularities.) <p>
<a name="253790"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="253791"></a>
 Here is an example of a normal annotation: <p>
<blockquote><pre>// Normal annotation
@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Provide time-travel functionality",
    engineer = "Mr. Peabody",
    date     = "4/1/2004"
)
public static void travelThroughTime(Date destination) { ... }
</pre></blockquote><a name="253801"></a>
<p>
<a name="253802"></a>
Note that the types of the annotations in the examples in this section are the annotation types defined in the examples in <a href="interfaces.html#239527">&#167;9.6</a>. Note also that the elements are in the above annotation are in the same order as in the corresponding annotation type declaration. This is not required, but unless specific circumstances dictate otherwise, it is a reasonable convention to follow. <p>
<hr>
<a name="254847"></a>
 <p>
<a name="253805"></a>
The second form of annotation, marker annotation, is a shorthand designed for use with marker annotation types: <p>
<blockquote><pre>
<em>
    MarkerAnnotation:
        @ TypeName
        </em>
</pre></blockquote><a name="253810"></a>
It is simply a shorthand for the normal annotation: <p>
<blockquote><pre>        @TypeName()
</pre></blockquote>
<a name="253814"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="254652"></a>
 Example: <p>
 <blockquote><pre>
// Marker annotation
@Preliminary public class TimeTravel { ... }
</pre></blockquote><a name="253818"></a>
<p>
<a name="253819"></a>
Note that it is legal to use marker annotations for annotation types with elements, so long as all the elements have default values. <p>
<hr>
<a name="255134"></a>
 <p>
<a name="253821"></a>
The third form of annotation, single-element annotation, is a shorthand designed for use with single-element annotation types: <p>
<blockquote><pre>
<em>
    SingleElementAnnotation:
        @ TypeName ( ElementValue )
</em>
</pre></blockquote><a name="253826"></a>
It is shorthand for the normal annotation: <p>
<blockquote><pre>@TypeName ( value = ElementValue )
</pre></blockquote>
<a name="253829"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="253830"></a>
 Example: <p>
<blockquote><pre>
// Single-element annotation
@Copyright("2002 Yoyodyne Propulsion Systems, Inc., All rights reserved.")
public class OscillationOverthruster { ... }
</pre></blockquote>
<a name="253836"></a>
 Example with array-valued single-element annotation: <p>
 <blockquote><pre>
// Array-valued single-element annotation
@Endorsers({"Children", "Unscrupulous dentists"})
public class Lollipop { ... }
</pre></blockquote>
<a name="253842"></a>
 Example with single-element array-valued single-element annotation (note that the curly braces are omitted): <p>
<blockquote><pre>
// Single-element array-valued single-element annotation
@Endorsers("Epicurus")
public class Pleasure { ... }
</pre></blockquote>
<a name="253848"></a>
 Example with complex annotation: <p>
 <blockquote><pre>
// Single-element complex annotation
@Author(@Name(first = "Joe", last = "Hacker"))
public class BitTwiddle { ... }
</pre></blockquote>
<a name="253854"></a>
<p>
 Note that it is legal to use single-element annotations for annotation types with multiple elements, so long as one element is named value, and all other elements have default values. <p>
<a name="253856"></a>
Here is an example of an annotation that takes advantage of default values: <p>
<a name="253857"></a>
<blockquote><pre>// Normal annotation with default values
@RequestForEnhancement(
    id       = 4561414,
    synopsis = "Balance the federal budget"
)
public static void balanceFederalBudget() {
    throw new UnsupportedOperationException("Not implemented");
}
</pre></blockquote>
<a name="253867"></a>
 Here is an example of an annotation with a Class element whose value is restricted by the use of a bounded wildcard. <p>
 <blockquote><pre>
// Single-element annotation with Class element restricted by bounded wildcard
// The annotation presumes the existence of this class.
class GorgeousFormatter implements Formatter { ... }
@PrettyPrinter(GorgeousFormatter.class) public class Petunia {...}
// This annotation is illegal, as String is not a subtype of Formatter!!
@PrettyPrinter(String.class) public class Begonia { ... }
</pre></blockquote>
<a name="253879"></a>
 Here is an example of an annotation using an enum type defined inside the annotation type: <p>
 <blockquote><pre>
// Annotation using enum type declared inside the annotation type
@Quality(Quality.Level.GOOD)
public class Karma {
   ...
}
</pre></blockquote>
<a name="254092"></a>
<hr>
<p>

<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="classes.html">Prev</a> | <a href="arrays.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>

<html>
<head>
<title> Arrays</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="interfaces.html">Prev</a> | <a href="exceptions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="27803"></a>
<p><strong>
CHAPTER
 10 </strong></p>
<a name="27805"></a>
<h1>Arrays</h1>
<hr><p>
<a name="25550"></a>
In the Java programming language <em>arrays</em> are objects <a href="typesValues.html#12028">(&#167;4.3.1)</a>, are dynamically created, and may be assigned to variables of type <code>Object</code> <a href="typesValues.html#11055">(&#167;4.3.2)</a>. All methods of class <code>Object</code> may be invoked on an array.<p>
<a name="25500"></a>
An array object contains a number of variables. The number of variables may be zero, in which case the array is said to be <em>empty</em>. The variables contained in an array have no names; instead they are referenced by array access expressions that use nonnegative integer index values. These variables are called the <em>components</em> of the array. If an array has <em>n</em> components, we say <em>n</em> is the <em>length</em> of the array; the components of the array are referenced using integer indices from 0 to <i>n</i>-1, inclusive.<p>
<a name="61129"></a>
All the components of an array have the same type, called the <em>component type</em> of the array. If the component type of an array is <i>T</i>, then the type of the array itself is written <i>T</i>[].<p>
<a name="61371"></a>
The value of an array component of type <code>float</code> is always an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, the value of an array component of type <code>double</code> is always an element of the double value set. It is not permitted for the value of an array component of type <code>float</code> to be an element of the float-extended-exponent value set that is not also an element of the float value set, nor for the value of an array component of type <code>double</code> to be an element of the double-extended-exponent value set that is not also an element of the double value set.<p>
<a name="25502"></a>
The component type of an array may itself be an array type. The components of such an array may contain references to subarrays. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the <em>element type</em> of the original array, and the components at this level of the data structure are called the <em>elements</em> of the original array.<p>
<a name="63008"></a>
<p>There are some situations in which an element of an array can be an array: if the element type is <code>Object</code> or <code>Cloneable</code> or <code>java.io.Serializable</code>, then some or all of the elements may be arrays, because any array object can be assigned to any variable of these types.</p>
<a name="25518"></a>
<a name="10.1"></a>
<h2>10.1    Array Types</h2>
<a name="25519"></a>
An array type is written as the name of an element type followed by some number of empty pairs of square brackets <code>[]</code>. The number of bracket pairs indicates the depth of array nesting. An array's length is not part of its type.<p>
<a name="30943"></a>
The element type of an array may be any type, whether primitive or reference. In particular:<p>
<ul><a name="26084"></a>
<li>Arrays with an interface type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any type that implements the interface.
<a name="26075"></a>
<li>Arrays with an <code>abstract</code> class type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any subclass of the <code>abstract</code> class that is not itself <code>abstract</code>.
</ul><a name="25523"></a>
Array types are used in declarations and in cast expressions <a href="expressions.html#238146">(&#167;15.16)</a>.<p>
<a name="25891"></a>
<a name="10.2"></a>
<h2>10.2    Array Variables</h2>
<a name="17235"></a>
A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator <a href="classes.html#40898">(&#167;8.3)</a> may create an array, a reference to which then becomes the initial value of the variable.<p>
<a name="61598"></a>
Because an array's length is not part of its type, a single variable of array type may contain references to arrays of different lengths.<p>
<a name="25894"></a>
<p>Here are examples of declarations of array variables that do not create arrays:</p>
<blockquote><pre>int[] ai;			// array of int
short[][] as;			// array of array of short
Object[]	ao,		// array of Object
		otherAo;	// array of Object
Collection&lt;?&gt;[] ca;		// array of Collection of unknown type
short		s,		// scalar short 
		aas[][];	// array of array of short
</pre></blockquote><a name="25902"></a>
Here are some examples of declarations of array variables that create array objects:<p>
<blockquote><pre>Exception ae[] = new Exception[3]; 
Object aao[][] = new Exception[2][3];
int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac[] = { 'n', 'o', 't', ' ', 'a', ' ',
				 'S', 't', 'r', 'i', 'n', 'g' }; 
String[] aas = { "array", "of", "String", };
</pre></blockquote><a name="25909"></a>
<p>
The <code>[]</code> may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both, as in this example:<p>
<blockquote><pre>byte[] rowvector, colvector, matrix[];
</pre></blockquote><a name="25911"></a>
This declaration is equivalent to:<p>
<blockquote><pre>byte rowvector[], colvector[], matrix[][];
</pre></blockquote><a name="25915"></a>
Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.<p>
<a name="25953"></a>
If an array variable <i>v</i> has type <i>A</i>[], where <i>A</i> is a reference type, then <i>v</i> can hold a reference to an instance of any array type <i>B</i>[], provided <i>B</i> can be assigned to <i>A</i>. This may result in a run-time exception on a later assignment; see <a href="arrays.html#11430">&#167;10.10</a> for a discussion.<p>
<a name="25959"></a>
<a name="10.3"></a>
<h2>10.3    Array Creation</h2>
<a name="25650"></a>
An array is created by an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a> or an array initializer <a href="arrays.html#11358">(&#167;10.6)</a>.<p>
<a name="25675"></a>
An array creation expression specifies the element type, the number of levels of nested arrays, and the length of the array for at least one of the levels of nesting. The array's length is available as a final instance variable <code>length</code>. It is a compile-time error if the element type is not a reifiable type <a href="typesValues.html#112581">(&#167;4.7)</a><p>
<a name="25676"></a>
An array initializer creates an array and provides initial values for all its components. <p>
<a name="25566"></a>
<a name="10.4"></a>
<h2>10.4    Array Access</h2>
<a name="53523"></a>
A component of an array is accessed by an array access expression <a href="expressions.html#239587">(&#167;15.13)</a> that consists of an expression whose value is an array reference followed by an indexing expression enclosed by <code>[</code> and <code>]</code>, as in <code>A[i]</code>. All arrays are <code>0</code>-origin. An array with length <i>n</i> can be indexed by the integers <code>0</code> to <i>n</i>-1.<p>
<a name="25570"></a>
Arrays must be indexed by <code>int</code> values; <code>short</code>, <code>byte</code>, or <code>char</code> values may also be used as index values because they are subjected to unary numeric promotion <a href="conversions.html#203523">(&#167;)</a> and become <code>int</code> values. An attempt to access an array component with a <code>long</code> index value results in a compile-time error.<p>
<a name="61612"></a>
All array accesses are checked at run time; an attempt to use an index that is less than zero or greater than or equal to the length of the array causes an <code>ArrayIndexOutOfBoundsException</code> &#32;to be thrown.<p>
<a name="54000"></a>
<a name="10.5"></a>
<h2>10.5    Arrays: A Simple Example</h2>
<a name="25421"></a>
The example:<p>
<blockquote><pre>class Gauss {
	public static void main(String[] args) {
		int[] ia = new int[101];
		for (int i = 0; i &lt; ia.length; i++)
			ia[i] = i;
		int sum = 0;
		for (int e : ia)
			sum += e;
		System.out.println(sum);
	}
}
</pre></blockquote><a name="25454"></a>
that produces the output:<p>
<blockquote><pre>5050
</pre></blockquote><a name="25463"></a>
declares a variable <code>ia</code> that has type array of <code>int</code>, that is, <code>int[]</code>. The variable <code>ia</code> is initialized to reference a newly created array object, created by an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>. The array creation expression specifies that the array should have <code>101</code> components. The length of the array is available using the field <code>length</code>, as shown.<p>
<a name="61617"></a>
<p>The example program fills the array with the integers from <code>0</code> to <code>100</code>, sums these integers, and prints the result.</p>
<a name="11358"></a>
<a name="10.6"></a>
<h2>10.6    Array Initializers</h2>
<a name="25749"></a>
An <em>array initializer</em> may be specified in a declaration, or as part of an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>, creating an array and providing some initial values:<p>
<blockquote><pre>
<em>
ArrayInitializer:
	</em>{<em> VariableInitializers<sub><i>opt</i></sub> ,<sub><i>opt</i></sub> </em>}<em>

VariableInitializers:
	VariableInitializer
	VariableInitializers , VariableInitializer
	</em>
</pre></blockquote><a name="25741"></a>
The following is repeated from <a href="classes.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
VariableInitializer:
	Expression
	ArrayInitializer
	</em>
</pre></blockquote><a name="25727"></a>
An array initializer is written as a comma-separated list of expressions, enclosed by braces "<code>{</code>" and "<code>}</code>".<p>
<a name="64369"></a>
The length of the constructed array will equal the number of expressions.<p>
<a name="25755"></a>
The expressions in an array initializer are executed from left to right in the textual order they occur in the source code. The <em>n</em>th variable initializer specifies the value of the <em>n-1</em>st array component. Each expression must be assignment-compatible <a href="conversions.html#184206">(&#167;5.2)</a> with the array's component type, or a compile-time error results. It is a compile-time error if the component type of the array being initialized is not reifiable <a href="typesValues.html#112581">(&#167;4.7)</a>.<p>
<a name="25756"></a>
If the component type is itself an array type, then the expression specifying a component may itself be an array initializer; that is, array initializers may be nested.<p>
<a name="61622"></a>
A trailing comma may appear after the last expression in an array initializer and is ignored.<p>
<a name="25758"></a>
<p>As an example:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int ia[][] = { {1, 2}, null };
		for (int[] ea : ia)
			for (int e: ea)
				System.out.println(e);
	}
}
</pre></blockquote><a name="25767"></a>
prints:<p>
<blockquote><pre>1
2
</pre></blockquote><a name="61627"></a>
before causing a <code>NullPointerException</code> in trying to index the second component of the array <code>ia</code>, which is a null reference.<p>
<a name="64347"></a>
<a name="10.7"></a>
<h2>10.7    Array Members</h2>
<a name="65904"></a>
The members of an array type are all of the following:<p>
<ul><a name="65906"></a>
<li>The <code>public</code> <code>final</code> field <code>length</code>, which contains the number of components of the array (<code>length</code> may be positive or zero).
<a name="65908"></a>
<li>The <code>public</code> method <code>clone</code>, which overrides the method of the same name in class <code>Object</code> and throws no checked exceptions. The return type of the clone method of an array type <i>T[]</i> is <i>T[].</i>
<a name="65910"></a>
<li>All the members inherited from class <code>Object</code>; the only method of <code>Object</code> that is not inherited is its <code>clone</code> method.
</ul><a name="65890"></a>
<p>
<a name="62964"></a>
An array thus has the same public fields and methods as the following class:<p>
<blockquote><pre>class A&lt;T&gt; implements Cloneable, java.io.Serializable {
	public final int length = X;
	public T[] clone() {
		try {
			return (T[])super.clone(); // unchecked warning
		} catch (CloneNotSupportedException e) {
			throw new InternalError(e.getMessage());
		}
	}
}
</pre></blockquote><a name="65838"></a>
Note that the cast in the example above would generate an unchecked warning <a href="conversions.html#190772">(&#167;5.1.9)</a> if arrays were really implemented this way.<p>
<a name="65830"></a>
Every array implements the interfaces <code>Cloneable</code> and <code>java.io.Serializable</code>. <p>
<a name="61641"></a>
<p>That arrays are cloneable is shown by the test program:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int ia1[] = { 1, 2 };
		int ia2[] = ia1.clone();
		System.out.print((ia1 == ia2) + " ");
		ia1[1]++;
		System.out.println(ia2[1]);
	}
}
</pre></blockquote><a name="25812"></a>
which prints:<p>
<blockquote><pre>false 2
</pre></blockquote><a name="61648"></a>
showing that the components of the arrays referenced by <code>ia1</code> and <code>ia2</code> are different variables. (In some early implementations of the Java programming language this example failed to compile because the compiler incorrectly believed that the clone method for an array could throw a <code>CloneNotSupportedException</code>.)<p>
<a name="61654"></a>
A <code>clone</code> of a multidimensional array is shallow, which is to say that it creates only a single new array. Subarrays are shared.<p>
<a name="61652"></a>
<p>This is shown by the example program:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) throws Throwable {
		int ia[][] = { { 1 , 2}, null };
		int ja[][] = ia.clone();
		System.out.print((ia == ja) + " ");
		System.out.println(ia[0] == ja[0] &amp;&amp; ia[1] == ja[1]);
	}
}
</pre></blockquote><a name="25855"></a>
which prints:<p>
<blockquote><pre>false true
</pre></blockquote><a name="61659"></a>
showing that the <code>int[]</code> array that is <code>ia[0]</code> and the <code>int[]</code> array that is <code>ja[0]</code> are the same array.<p>
<a name="40879"></a>
<a name="10.8"></a>
<h2>10.8    Class Objects for Arrays</h2>
<a name="40882"></a>
Every array has an associated <code>Class</code> object, shared with all other arrays with the same component type. The direct superclass of an array type is <code>Object</code>. Every array type implements the interfaces <code>Cloneable</code> and <code>java.io.Serializable</code>.<p>
<a name="62923"></a>
<p>This is shown by the following example code:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		int[] ia = new int[3];
		System.out.println(ia.getClass());
		System.out.println(ia.getClass().getSuperclass());
	}
}
</pre></blockquote><a name="40893"></a>
which prints:<p>
<blockquote><pre>class [I
class java.lang.Object
</pre></blockquote><a name="40896"></a>
where the string "<code>[I</code>" is the run-time type signature for the class object "array with component type <code>int</code>".<p>
<a name="25726"></a>
<a name="10.9"></a>
<h2>10.9    An Array of Characters is Not a String</h2>
<a name="25730"></a>
In the Java programming language, unlike C, an array of <code>char</code> is not a <code>String</code>, and neither a <code>String</code> nor an array of <code>char</code> is terminated by <code>'\u0000'</code> (the NUL character).<p>
<a name="25731"></a>
A <code>String</code> object is immutable, that is, its contents never change, while an array of <code>char</code> has mutable elements. The method <code>toCharArray</code> in class <code>String</code> returns an array of characters containing the same character sequence as a <code>String</code>. The class <code>StringBuffer</code> implements useful methods on mutable arrays of characters.<p>
<a name="11430"></a>
<a name="10.10"></a>
<h2>10.10    Array Store Exception</h2>
<a name="61664"></a>
If an array variable <i>v</i> has type <i>A</i>[], where <i>A</i> is a reference type, then <i>v</i> can hold a reference to an instance of any array type <i>B</i>[], provided <i>B</i> can be assigned to <i>A</i>.<p>
<a name="53134"></a>
<p>Thus, the example:</p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
	public static void main(String[] args) {
		ColoredPoint[] cpa = new ColoredPoint[10];
		Point[] pa = cpa;
		System.out.println(pa[1] == null);
		try {
			pa[0] = new Point();
		} catch (ArrayStoreException e) {
			System.out.println(e);
		}
	}
}
</pre></blockquote><a name="25743"></a>
produces the output:<p>
<blockquote><pre>true
java.lang.ArrayStoreException
</pre></blockquote><a name="26018"></a>
Here the variable <code>pa</code> has type <code>Point[]</code> and the variable <code>cpa</code> has as its value a reference to an object of type <code>ColoredPoint[]</code>. A <code>ColoredPoint</code> can be assigned to a <code>Point</code>; therefore, the value of <code>cpa</code> can be assigned to <code>pa</code>.<p>
<a name="26025"></a>
<p>A reference to this array <code>pa</code>, for example, testing whether <code>pa[1]</code> is <code>null</code>, will not result in a run-time type error. This is because the element of the array of type <code>ColoredPoint[]</code> is a <code>ColoredPoint</code>, and every <code>ColoredPoint</code> can stand in for a <code>Point</code>, since <code>Point</code> is the superclass of <code>ColoredPoint</code>.</p>
<a name="61669"></a>
<p>On the other hand, an assignment to the array <code>pa</code> can result in a run-time error. At compile time, an assignment to an element of <code>pa</code> is checked to make sure that the value assigned is a <code>Point</code>. But since <code>pa</code> holds a reference to an array of <code>ColoredPoint</code>, &#32;the assignment is valid only if the type of the value assigned at run-time is, more specifically, a <code>ColoredPoint</code>.</p>
<a name="26044"></a>
The Java virtual machine checks for such a situation at run-time to ensure that the assignment is valid; if not, an <code>ArrayStoreException</code> is thrown. More formally: an assignment to an element of an array whose type is <i>A</i>[], where <i>A</i> is a reference type, is checked at run-time to ensure that the value assigned can be assigned to the actual element type of the array, where the actual element type may be any reference type that is assignable to <i>A</i>.<p>
<hr>
<a name="65843"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="65852"></a>
 If the element type of an array were not reifiable <a href="typesValues.html#112581">(&#167;4.7)</a>, the virtual machine could not perform the store check described in the preceding paragraph. This is why creation of arrays of non-reifiable types is forbidden. One may declare variables of array types whose element type is not reifiable, but any attempt to assign them a value will give rise to an unchecked warning <a href="conversions.html#190772">(&#167;5.1.9)</a>.<p>
<hr>
<a name="65853"></a>
 <p>
<a name="26055"></a>
<p>
<a name="65888"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="interfaces.html">Prev</a> | <a href="exceptions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>
<html>
<head>
<title> Blocks and Statements</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="binaryComp.html">Prev</a> | <a href="expressions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="44383"></a>
<p><strong>
CHAPTER
 14 </strong></p>
<a name="101241"></a>
<h1>Blocks and Statements</h1>
<hr><p>
<a name="263159"></a>
<p>
<a name="263177"></a>
The sequence of execution of a program is controlled by <em>statements</em>, which are executed for their effect and do not have values.<p>
<a name="17960"></a>
Some statements <em>contain</em> other statements as part of their structure; such other statements are substatements of the statement. We say that statement <i>S</i> <em>immediately &#32;contains</em> statement <i>U</i> if there is no statement <i>T</i> different from <i>S</i> and <i>U</i> such that <i>S</i> contains <i>T</i> and <i>T</i> contains <i>U</i>. In the same manner, some statements contain expressions <a href="expressions.html#348842">(&#167;15)</a> as part of their structure.<p>
<a name="43082"></a>
The first section of this chapter discusses the distinction between normal and abrupt completion of statements <a href="statements.html#5894">(&#167;14.1)</a>. Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.<p>
<a name="43210"></a>
Blocks are explained first <a href="statements.html#246838">(&#167;14.2)</a>, followed by local class declarations <a href="statements.html#247766">(&#167;14.3)</a> and local variable declaration statements <a href="statements.html#5920">(&#167;14.4)</a>.<p>
<a name="43203"></a>
Next a grammatical maneuver that sidesteps the familiar "dangling <code>else</code>" problem <a href="statements.html#32584">(&#167;14.5)</a> is explained.<p>
<a name="43110"></a>
The last section <a href="statements.html#236365">(&#167;14.21)</a> of this chapter addresses the requirement that every statement be <em>reachable</em> in a certain technical sense.<p>
<a name="263147"></a>
<p>
<a name="263148"></a>
<p>
<a name="5894"></a>
<a name="14.1"></a>
<h2>14.1    Normal and Abrupt Completion of Statements</h2>
<a name="256000"></a>
If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to <em>complete normally</em>. However, certain events may prevent a statement from completing normally:<p>
<ul><a name="47062"></a>
<li>The <code>break</code> <a href="statements.html#6842">(&#167;14.15)</a>, <code>continue</code> <a href="statements.html#6122">(&#167;14.16)</a>, and <code>return</code> <a href="statements.html#6767">(&#167;14.17)</a> statements cause a transfer of control that may prevent normal completion of statements that contain them.
<a name="78802"></a>
<li>Evaluation of certain expressions may throw exceptions from the Java virtual machine; these expressions are summarized in <a href="expressions.html#79448">&#167;15.6</a>. An explicit <code>throw</code> <a href="statements.html#237350">(&#167;14.18)</a> statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.
</ul><a name="5898"></a>
If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to <em>complete abruptly</em>. <p>
<a name="255999"></a>
An abrupt completion always has an associated <em>reason</em>, which is one of the following:<p>
<ul><a name="5899"></a>
<li>A <code>break</code> with no label
<a name="78812"></a>
<li>A <code>break</code> with a given label
<a name="5901"></a>
<li>A <code>continue</code> with no label
<a name="78822"></a>
<li>A <code>continue</code> with a given label
<a name="5903"></a>
<li>A <code>return</code> with no value
<a name="5904"></a>
<li>A <code>return</code> with a given value
<a name="78827"></a>
<li>A <code>throw</code> with a given value, including exceptions thrown by the Java virtual machine
</ul><a name="237105"></a>
The terms "complete normally" and "complete abruptly" also apply to the evaluation of expressions <a href="expressions.html#79448">(&#167;15.6)</a>. The only reason an expression can complete abruptly is that an exception is thrown, because of either a <code>throw</code> with a given value <a href="statements.html#237350">(&#167;14.18)</a> or a run-time exception or error (<a href="exceptions.html#44043">&#167;11</a>, <a href="expressions.html#79448">&#167;15.6</a>).<p>
<a name="237118"></a>
If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.<p>
<a name="24642"></a>
Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.<p>
<a name="24647"></a>
Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.<p>
<a name="246838"></a>
<a name="14.2"></a>
<h2>14.2    Blocks</h2>
<a name="6391"></a>
A <em>block</em> is a sequence of statements, local class declarations and local variable declaration statements within braces.<p>
<blockquote><pre>
<em>
Block:
        </em>{<em> BlockStatements<sub><i>opt</i></sub> </em>}<em>

BlockStatements:
        BlockStatement
        BlockStatements BlockStatement

BlockStatement:
        LocalVariableDeclarationStatement
        ClassDeclaration
        Statement
        </em>
</pre></blockquote><a name="5918"></a>
A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.<p>
<a name="247766"></a>
<a name="14.3"></a>
<h2>14.3    Local Class Declarations</h2>
<a name="247773"></a>
A <i>local class</i> is a nested class <a href="classes.html#29542">(&#167;8)</a> that is not a member of any class and that has a name. All local classes are inner classes <a href="classes.html#295574">(&#167;8.1.3)</a>. Every local class declaration statement is immediately contained by a block. Local class declaration statements may be intermixed freely with other kinds of statements in the block.<p>
<a name="263447"></a>
The scope of a local class immediately enclosed by a block (<a href="statements.html#246838">&#167;14.2</a>) is the rest of the immediately enclosing block, including its own class declaration. The scope of a local class immediately enclosed by in a switch block statement group (<a href="statements.html#258896">&#167;14.11</a>)is the rest of the immediately enclosing switch block statement group, including its own class declaration.<p>
<a name="247735"></a>
The name of a local class <i>C</i> may not be redeclared as a local class of the directly enclosing method, constructor, or initializer block within the scope of <i>C</i>, or a compile-time error occurs. However, a local class declaration may be shadowed <a href="names.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the local class declaration's scope. A local class does not have a canonical name, nor does it have a fully qualified name. <p>
<a name="258707"></a>
It is a compile-time error if a local class declaration contains any one of the following access modifiers: <code>public</code>, <code>protected</code>, <code>private</code>, or <code>static</code>.<p>
<a name="253218"></a>
<p>Here is an example that illustrates several aspects of the rules given above:</p>
<blockquote><pre>class Global {
        class Cyclic {}
        void foo() {
                new Cyclic(); // create a Global.Cyclic
                class Cyclic extends Cyclic{}; // circular definition
                {
                        class Local{};
                        {
                                class Local{}; // compile-time error
                        }
                        class Local{}; // compile-time error
                        class AnotherLocal {
                                void bar() {
                                        class Local {}; // ok
                                }
                        }
                }
                class Local{}; // ok, not in scope of prior Local
}
</pre></blockquote><a name="249828"></a>
The first statement of method <code>foo</code> creates an instance of the member class <code>Global.Cyclic</code> rather than an instance of the local class <code>Cyclic</code>, because the local class declaration is not yet in scope. <p>
<a name="249848"></a>
<p>The fact that the scope of a local class encompasses its own declaration (not only its body) means that the definition of the local class <code>Cyclic</code> is indeed cyclic because it extends itself rather than <code>Global.Cyclic</code>. Consequently, the declaration of the local class <code>Cyclic</code> will be rejected at compile time. </p>
<a name="249829"></a>
<p>Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of <code>Local</code> result in compile-time errors. However, <code>Local</code> can be redeclared in the context of another, more deeply nested, class such as <code>AnotherLocal</code>. </p>
<a name="249872"></a>
<p>The fourth and last declaration of <code>Local</code> is legal, since it occurs outside the scope of any prior declaration of <code>Local</code>.</p>
<a name="5920"></a>
<a name="14.4"></a>
<h2>14.4    Local Variable Declaration Statements</h2>
<a name="25561"></a>
A <em>local variable declaration statement</em> declares one or more local variable names.<p>
<blockquote><pre>
<em>
LocalVariableDeclarationStatement:
        LocalVariableDeclaration ;

LocalVariableDeclaration:
        VariableModifiers Type VariableDeclarators
        </em>
</pre></blockquote><a name="238231"></a>
The following are repeated from <a href="classes.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
VariableDeclarators:
        VariableDeclarator
        VariableDeclarators , VariableDeclarator

VariableDeclarator:
        VariableDeclaratorId
        VariableDeclaratorId </em>=<em> VariableInitializer

VariableDeclaratorId:
        Identifier
        VariableDeclaratorId </em>[ ]<em>

VariableInitializer:
        Expression
        ArrayInitializer
        </em>
</pre></blockquote><a name="32641"></a>
Every local variable declaration statement is immediately contained by a block. Local variable declaration statements may be intermixed freely with other kinds of statements in the block.<p>
<a name="35375"></a>
A local variable declaration can also appear in the header of a <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a>. In this case it is executed in the same manner as if it were part of a local variable declaration statement.<p>
<a name="35393"></a>
<a name="14.4.1"></a>
<h3>14.4.1    Local Variable Declarators and Types</h3>
<a name="35391"></a>
Each <em>declarator</em> in a local variable declaration declares one local variable, whose name is the <em>Identifier</em> that appears in the declarator.<p>
<a name="255532"></a>
If the optional keyword final appears at the start of the declarator, the variable being declared is a final variable<a href="typesValues.html#10931">(&#167;4.12.4)</a>.<p>
<a name="259461"></a>
If an annotation a on a local variable declaration corresponds to an annotation type <i>T</i>, and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.LOCAL_VARIABLE</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">(&#167;9.7)</a>.<p>
<a name="35396"></a>
The type of the variable is denoted by the <em>Type</em> that appears in the local variable declaration, followed by any bracket pairs that follow the <em>Identifier</em> in the declarator. <p>
<a name="252173"></a>
<p>Thus, the local variable declaration:</p>
<blockquote><pre>int a, b[], c[][];
</pre></blockquote><a name="35401"></a>
is equivalent to the series of declarations:<p>
<blockquote><pre>int a;
int[] b;
int[][] c;
</pre></blockquote><a name="35405"></a>
Brackets are allowed in declarators as a nod to the tradition of C and C++. The general rule, however, also means that the local variable declaration:<p>
<blockquote><pre>float[][] f[][], g[][][], h[];                                                                                                 // Yechh!
</pre></blockquote><a name="35409"></a>
is equivalent to the series of declarations:<p>
<blockquote><pre>float[][][][] f;
float[][][][][] g;
float[][][] h;
</pre></blockquote><a name="35427"></a>
We do not recommend such "mixed notation" for array declarations.<p>
<a name="247538"></a>
A local variable of type <code>float</code> always contains a value that is an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, a local variable of type <code>double</code> always contains a value that is an element of the double value set. It is not permitted for a local variable of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.<p>
<a name="32644"></a>
<a name="14.4.2"></a>
<h3>14.4.2    Scope of Local Variable Declarations</h3>
<a name="263461"></a>
The scope of a local variable declaration in a block <a href="statements.html#246838">(&#167;14.2)</a> is the rest of the block in which the declaration appears, starting with its own initializer <a href="statements.html#5920">(&#167;14.4)</a> and including any further declarators to the right in the local variable declaration statement. <p>
<a name="248105"></a>
The name of a local variable <i>v</i> may not be redeclared as a local variable of the directly enclosing method, constructor or initializer block within the scope of <em>v</em>, or a compile-time error occurs. The name of a local variable <i>v</i> may not be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block within the scope of <i>v</i>, or a compile-time error occurs. However, a local variable of a method or initializer block may be shadowed <a href="names.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the scope of the local variable. <p>
<a name="253395"></a>
A local variable cannot be referred to using a qualified name <a href="names.html#104285">(&#167;6.6)</a>, only a simple name.<p>
<a name="253396"></a>
<p>The example:</p>
<blockquote><pre>class Test {
        static int x;
        public static void main(String[] args) {
                int x = x;
        }
}
</pre></blockquote><a name="32604"></a>
causes a compile-time error because the initialization of <code>x</code> is within the scope of the declaration of <code>x</code> as a local variable, and the local <code>x</code> does not yet have a value and cannot be used.<p>
<a name="32610"></a>
<p>The following program does compile:</p>
<blockquote><pre>class Test {
        static int x;
        public static void main(String[] args) {
                int x = (x=2)*2;
                System.out.println(x);
        }
}
</pre></blockquote><a name="32611"></a>
because the local variable <code>x</code> is definitely assigned <a href="defAssign.html#25979">(&#167;16)</a> before it is used. It prints:<p>
<blockquote><pre>4
</pre></blockquote>
<a name="5925"></a>
<p>Here is another example:</p>
<blockquote><pre>
class Test {
        public static void main(String[] args) {
                System.out.print("2+1=");
                int two = 2, three = two + 1;
                System.out.println(three);
        }
}
</pre></blockquote><a name="17863"></a>
which compiles correctly and produces the output:<p>
<blockquote><pre>2+1=3
</pre></blockquote><a name="7616"></a>
The initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable <code>three</code> declared earlier in the block.<p>
<a name="35349"></a>
The scope of a local variable declared in a <code>for</code> statement is the rest of the <code>for</code> statement, including its own initializer.<p>
<a name="32558"></a>
If a declaration of an identifier as a local variable of the same method, constructor, or initializer block appears within the scope of a parameter or local variable of the same name, a compile-time error occurs.<p>
<a name="252192"></a>
<p>Thus the following example does not compile:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int i;
                for (int i = 0; i &lt; 10; i++)
                        System.out.println(i);
        }
}
</pre></blockquote>
<a name="249885"></a>
<p>This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well. Hence, the following example compiles without error:</p>
<blockquote><pre>
class Test {
        public static void main(String[] args) {
                int i;
                class Local {
                        {
                                for (int i = 0; i &lt; 10; i++)
                                System.out.println(i);
                        }
                }
                new Local();
        }
}
</pre></blockquote>
<a name="35322"></a>
<p>On the other hand, local variables with the same name may be declared in two separate blocks or <code>for</code> statements neither of which contains the other. Thus:</p>
<blockquote><pre>
class Test {
        public static void main(String[] args) {
                for (int i = 0; i &lt; 10; i++)
                        System.out.print(i + " ");
                for (int i = 10; i &gt; 0; i--)
                        System.out.print(i + " ");
                System.out.println();
        }
}
</pre></blockquote><a name="17897"></a>
compiles without error and, when executed, produces the output:<p>
<blockquote><pre>0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1
</pre></blockquote><a name="32673"></a>
<a name="14.4.3"></a>
<h3>14.4.3    Shadowing of Names by Local Variables</h3>
<a name="32716"></a>
If a name declared as a local variable is already declared as a field name, then that outer declaration is shadowed <a href="names.html#34133">(&#167;6.3.1)</a> throughout the scope of the local variable. Similarly, if a name is already declared as a variable or parameter name, then that outer declaration is shadowed throughout the scope of the local variable (provided that the shadowing does not cause a compile-time error under the rules of <a href="statements.html#32644">&#167;14.4.2</a>). The shadowed name can sometimes be accessed using an appropriately qualified name. <p>
<a name="252205"></a>
<p>For example, the keyword <code>this</code> can be used to access a shadowed field <code>x</code>, using the form <code>this.x</code>. Indeed, this idiom typically appears in constructors <a href="classes.html#41652">(&#167;8.8)</a>:</p>
<blockquote><pre>class Pair {
        Object first, second;
        public Pair(Object first, Object second) {
                this.first = first;
                this.second = second;
        }
}
</pre></blockquote><a name="32573"></a>
In this example, the constructor takes parameters having the same names as the fields to be initialized. This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as fields.<p>
<a name="32717"></a>
<a name="14.4.4"></a>
<h3>14.4.4    Execution of Local Variable Declarations</h3>
<a name="32574"></a>
A local variable declaration statement is an executable statement. Every time it is executed, the declarators are processed in order from left to right. If a declarator has an initialization expression, the expression is evaluated and its value is assigned to the variable. If a declarator does not have an initialization expression, then a Java compiler must prove, using exactly the algorithm given in <a href="defAssign.html#25979">&#167;16</a>, that every reference to the variable is necessarily preceded by execution of an assignment to the variable. If this is not the case, then a compile-time error occurs.<p>
<a name="32578"></a>
Each initialization (except the first) is executed only if the evaluation of the preceding initialization expression completes normally. Execution of the local variable declaration completes normally only if evaluation of the last initialization expression completes normally; if the local variable declaration contains no initialization expressions, then executing it always completes normally.<p>
<a name="32584"></a>
<a name="14.5"></a>
<h2>14.5    Statements</h2>
<a name="32588"></a>
There are many kinds of statements in the Java programming language. Most correspond to statements in the C and C++ languages, but some are unique.<p>
<a name="5958"></a>
As in C and C++, the <code>if</code> statement of the Java programming language suffers from the so-called "dangling <code>else</code> problem," illustrated by this misleadingly formatted example:<p>
<blockquote><pre><a name="17933"></a>
if (door.isOpen())
        if (resident.isVisible())
                resident.greet("Hello!");
else door.bell.ring();          // A "dangling else"
</pre></blockquote><a name="5962"></a>
<p>
The problem is that both the outer <code>if</code> statement and the inner <code>if</code> statement might conceivably own the <code>else</code> clause. In this example, one might surmise that the programmer intended the <code>else</code> clause to belong to the outer <code>if</code> statement. The Java programming language, like C and C++ and many programming languages before them, arbitrarily decree that an <code>else</code> clause belongs to the innermost <code>if</code> to which it might possibly belong. This rule is captured by the following grammar:<p>
<blockquote><pre>
<em>
Statement:
        StatementWithoutTrailingSubstatement
        LabeledStatement
        IfThenStatement
        IfThenElseStatement
        WhileStatement
        ForStatement

StatementWithoutTrailingSubstatement:
        Block
        EmptyStatement
        ExpressionStatement
        AssertStatement
        SwitchStatement
        DoStatement
        BreakStatement
        ContinueStatement
        ReturnStatement
        SynchronizedStatement
        ThrowStatement
        TryStatement

StatementNoShortIf:
        StatementWithoutTrailingSubstatement
        LabeledStatementNoShortIf
        IfThenElseStatementNoShortIf
        WhileStatementNoShortIf
        ForStatementNoShortIf
        </em>
</pre></blockquote><a name="8344"></a>
<p>
<a name="263181"></a>
The following are repeated from <a href="statements.html#5991">&#167;14.9</a> to make the presentation here clearer:<p>
<a name="263196"></a>
<p>
<blockquote><pre>
<em>
IfThenStatement:</em>
        if ( <em>Expression</em> ) <em>Statement

IfThenElseStatement:</em>
        if ( <em>Expression</em> )<em> StatementNoShortIf</em> else <em>Statement

IfThenElseStatementNoShortIf:</em>
        if ( <em>Expression</em> ) <em>StatementNoShortIf</em> else <em>StatementNoShortIf
</em>
</pre></blockquote><a name="263197"></a>
<p>
<a name="5969"></a>
Statements are thus grammatically divided into two categories: those that might end in an <code>if</code> statement that has no <code>else</code> clause (a "short <code>if</code> statement") and those that definitely do not. Only statements that definitely do not end in a short <code>if</code> statement may appear as an immediate substatement before the keyword <code>else</code> in an <code>if</code> statement that does have an <code>else</code> clause.<p>
<a name="263186"></a>
<p>This simple rule prevents the "dangling <code>else</code>" problem. The execution behavior of a statement with the "no short <code>if</code>" restriction is identical to the execution behavior of the same kind of statement without the "no short <code>if</code>" restriction; the distinction is drawn purely to resolve the syntactic difficulty.</p>
<a name="263195"></a>
<a name="263191"></a>
<a name="14.6"></a>
<h2>14.6    The Empty Statement</h2>
<a name="5971"></a>
An <em>empty statement</em> does nothing.<p>
<blockquote><pre>
<em>
EmptyStatement:
        ;
        </em>
</pre></blockquote><a name="5973"></a>
Execution of an empty statement always completes normally.<p>
<a name="78993"></a>
<a name="14.7"></a>
<h2>14.7    Labeled Statements</h2>
<a name="78994"></a>
Statements may have <em>label</em> prefixes.<p>
<blockquote><pre>
<em>
LabeledStatement:
        Identifier : Statement

LabeledStatementNoShortIf:
        Identifier : StatementNoShortIf
</em>
</pre></blockquote><a name="78997"></a>
The <em>Identifier</em> is declared to be the label of the immediately contained <em>Statement</em>.<p>
<a name="17941"></a>
Unlike C and C++, the Java programming language has no <code>goto</code> statement; identifier statement labels are used with <code>break</code> <a href="statements.html#6842">(&#167;14.15)</a> or <code>continue</code> <a href="statements.html#6122">(&#167;14.16)</a> statements appearing anywhere within the labeled statement.<p>
<a name="78998"></a>
Let <i>l</i> be a label, and let <i>m</i> be the immediately enclosing method, constructor, instance initializer or static initializer. It is a compile-time error if <i>l</i> shadows <a href="names.html#34133">(&#167;6.3.1)</a> the declaration of another label immediately enclosed in <i>m</i>.<p>
<a name="247865"></a>
There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable. Use of an identifier to label a statement does not obscure <a href="names.html#104058">(&#167;6.3.2)</a> a package, class, interface, method, field, parameter, or local variable with the same name. Use of an identifier &#32;as a class, interface, method, field, local variable or as the parameter of an exception handler <a href="statements.html#79311">(&#167;14.20)</a> does not obscure a statement label with the same name.<p>
<a name="247869"></a>
A labeled statement is executed by executing the immediately contained <em>Statement</em>. If the statement is labeled by an <em>Identifier</em> and the contained <em>Statement</em> completes abruptly because of a <code>break</code> with the same <em>Identifier</em>, then the labeled statement completes normally. In all other cases of abrupt completion of the <em>Statement</em>, &#32;the labeled statement completes abruptly for the same reason.<p>
<a name="5984"></a>
<a name="14.8"></a>
<h2>14.8    Expression Statements</h2>
<a name="5985"></a>
Certain kinds of expressions may be used as statements by following them with semicolons:<p>
<blockquote><pre>
<em>
ExpressionStatement:
        StatementExpression ;

StatementExpression:
        Assignment
        PreIncrementExpression
        PreDecrementExpression
        PostIncrementExpression
        PostDecrementExpression
        MethodInvocation
        ClassInstanceCreationExpression
        </em>
</pre></blockquote><a name="5988"></a>
An <em>expression statement</em> is executed by evaluating the expression; if the expression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.<p>
<a name="5989"></a>
<p>Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements. Note that the Java programming language does not allow a "cast to <code>void</code>"-<code>void</code> is not a type-so the traditional C trick of writing an expression statement such as:</p>
<blockquote><pre>(void) ... ;           // incorrect!
</pre></blockquote><a name="35457"></a>
does not work. On the other hand, the language allows all the most useful kinds of expressions in expressions statements, and it does not require a method invocation used as an expression statement to invoke a <code>void</code> method, so such a trick is almost never needed. If a trick is needed, either an assignment statement <a href="expressions.html#5281">(&#167;15.26)</a> or a local variable declaration statement <a href="statements.html#5920">(&#167;14.4)</a> can be used instead.<p>
<a name="5991"></a>
<a name="14.9"></a>
<h2>14.9    The if Statement</h2>
<a name="35469"></a>
The <code>if</code> statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.<p>
<blockquote><pre>
<em>
IfThenStatement:</em>
        if (<em> Expression</em> ) <em>Statement

IfThenElseStatement:</em>
        if ( <em>Expression</em> ) <em>StatementNoShortIf </em>else <em>Statement

IfThenElseStatementNoShortIf:</em>
        if ( <em>Expression</em> ) <em>StatementNoShortIf </em>else <em>StatementNoShortIf</em>
</pre></blockquote><a name="24313"></a>
The <em>Expression</em> must have type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.<p>
<a name="237433"></a>
<a name="14.9.1"></a>
<h3>14.9.1    The if-then Statement</h3>
<a name="35473"></a>
An <code>if</code>-<code>then</code> statement is executed by first evaluating the <em>Expression</em>. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>if</code>-<code>then</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="5997"></a>
<li>If the value is <code>true</code>, then the contained <em>Statement</em> is executed; the <code>if</code>-<code>then</code> statement completes normally if and only if execution of the <em>Statement</em> completes normally.
<a name="5998"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>if</code>-<code>then</code> statement completes normally.
</ul><a name="237435"></a>
<a name="14.9.2"></a>
<h3>14.9.2    The if-then-else Statement</h3>
<a name="236506"></a>
An <code>if</code>-<code>then</code>-<code>else</code> statement is executed by first evaluating the <em>Expression</em>. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, then the <code>if</code>-<code>then</code>-<code>else</code> &#32;statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="6000"></a>
<li>If the value is <code>true</code>, then the first contained <em>Statement</em> (the one before the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally if and only if execution of that statement completes normally.
<a name="42708"></a>
<li>If the value is <code>false</code>, then the second contained <em>Statement</em> (the one after the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally if and only if execution of that statement completes normally. 
</ul><a name="35518"></a>
<a name="14.10"></a>
<h2>14.10    The assert Statement</h2>
<a name="257964"></a>
An <i>assertion</i> is a statement containing a boolean expression. An assertion is either <i>enabled</i> or <i>disabled</i>. If the assertion is enabled, evaluation of the assertion causes evaluation of the boolean expression and an error is reported if the expression evaluates to false. If the assertion is disabled, evaluation of the assertion has no effect whatsoever.<p>
<blockquote><pre>
<em>
AssertStatement:

        </em>assert <em>Expression1 ;

</em>   assert <em>Expression1 : Expression2 ;
</em>
</pre></blockquote><a name="257979"></a>
It is a compile-time error if <em>Expression1</em> does not have type <code>boolean</code> or <code>Boolean</code>. In the second form of the assert statement, it is a compile-time error if <em>Expression2</em> is void <a href="expressions.html#228862">(&#167;15.1)</a>.<p>
<a name="258150"></a>
Assertions may be enabled or disabled on a per-class basis. At the time a class is initialized <a href="execution.html#44630">(&#167;12.4.2)</a>, prior to the execution of any field initializers for class variables <a href="classes.html#38010">(&#167;8.3.2.1)</a> and static initializers <a href="classes.html#39245">(&#167;8.7)</a>, the class's class loader determines whether assertions are enabled or disabled as described below. Once a class has been initialized, its assertion status (enabled or disabled) does not change. <p>
<a name="258157"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 There is one case that demands special treatment. Recall that the assertion status of a class is set at the time it is initialized. It is possible, though generally not desirable, to execute methods or constructors prior to initialization. This can happen when a class hierarchy contains a circularity in its static initialization, as in the following example: <p>
<blockquote><pre>public class Foo {
    public static void main(String[] args) {
                Baz.testAsserts(); 
                // Will execute after Baz is initialized.
    }
}
class Bar {
    static {
                Baz.testAsserts(); 
                // Will execute before Baz is initialized!
    }
}
class Baz extends Bar {
    static void testAsserts(){
                boolean enabled = false;
                assert enabled = true;
                System.out.println("Asserts " + 
                        (enabled ? "enabled" : "disabled"));
    }
}
</pre></blockquote>
<a name="258178"></a>
 Invoking Baz.testAsserts() causes Baz to get initialized. Before this can happen, Bar must get initialized. Bar's static initializer again invokes Baz.testAsserts(). Because initialization of Baz is already in progress by the current thread, the second invocation executes immediately, though Baz is not initialized (JLS 12.4.2). <p>
<hr>
<p>
<a name="258179"></a>
If an <code>assert</code> statement executes before its class is initialized, as in the above example, the execution must behave as if assertions were enabled in the class. <p>
<hr>
<a name="258813"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="260849"></a>
 In other words, if the program above is executed without enabling assertions, it must print: <p>
<blockquote><pre>Asserts enabled
Asserts disabled
<a name="258182"></a>
</pre></blockquote><a name="257542"></a>
<hr>
<p>
An <code>assert</code> statement is enabled if and only if the top-level class <a href="classes.html#328796">(&#167;8)</a> that lexically contains it enables assertions. Whether or not a top-level class enables assertions is determined by its defining class loader before the class is initialized <a href="execution.html#44630">(&#167;12.4.2)</a>, and cannot be changed thereafter. <p>
<a name="260850"></a>
An <code>assert</code> statement causes the enclosing top level class (if it exists) to be initialized, if it has not already been initialized <a href="execution.html#57946">(&#167;12.4.1)</a>.<p>
<a name="260851"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="260852"></a>
 Note that an assertion that is enclosed by a top-level interface does not cause initialization.<p>
<a name="260853"></a>
Usually, the top level class enclosing an assertion will already be initialized. However, if the assertion is located within a static nested class, it may be that the initialization has nottaken place.<p>
<a name="260854"></a>
<hr>
 <p>
<a name="257546"></a>
A disabled <code>assert</code> statement does nothing. In particular neither <em>Expression1</em> nor <em>Expression2</em> (if it is present) are evaluated. Execution of a disabled <code>assert</code> statement always completes normally. <p>
<a name="259129"></a>
An enabled <code>assert</code> statement is executed by first evaluating <em>Expression1</em>. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of <em>Expression1</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>assert</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the value of <em>Expression1 </em>:<p>
<ul><a name="257555"></a>
<li>If the value is <code>true</code>, no further action is taken and the assert statement completes normally. 
<a name="257651"></a>
<li>If the value is <code>false</code>, the execution behavior depends on whether <em>Expression2</em> is present: 
<ul>
<a name="257557"></a>
<li>If <em>Expression2</em> is present, it is evaluated. 
<ul>
<a name="257934"></a>
<li>If the evaluation completes abruptly for some reason, the <code>assert</code> statement completes abruptly for the same reason. 
<a name="257935"></a>
<li>If the evaluation completes normally, the resulting value is converted to a <code>String</code> using string conversion <a href="expressions.html#40220">(&#167;15.18.1.1)</a>. 
<ul>
<a name="257940"></a>
<li>If the string conversion completes abruptly for some reason, the <code>assert</code> statement completes abruptly for the same reason. 
<a name="257941"></a>
<li>If the string conversion completes normally, an <code>AssertionError</code> instance whose "detail message" is the result of the string conversion is created. 
<ul>
<a name="257945"></a>
<li>If the instance creation completes abruptly for some reason, the <code>assert</code> statement completes abruptly for the same reason. 
<a name="257946"></a>
<li>If the instance creation completes normally, the <code>assert</code> statement completes abruptly by throwing the newly created <code>AssertionError</code> object.
</ul>
</ul>
</ul>
<a name="257922"></a>
<li>If <em>Expression2</em> is not present, an <code>AssertionError</code> instance with no "detail message" is created. 
<ul>
<a name="257947"></a>
<li>If the instance creation completes abruptly for some reason, the <code>assert</code> statement completes abruptly for the same reason. 
<a name="257948"></a>
<li>If the instance creation completes normally, the <code>assert</code> statement completes abruptly by throwing the newly created <code>AssertionError</code> object. 
</ul></ul></ul>
<p>
<hr>
<a name="258876"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="259453"></a>
 For example, after unmarshalling all of the arguments from a data buffer, a programmer might assert that the number of bytes of data remaining in the buffer is zero. By verifying that the boolean expression is indeed true, the system corroborates the programmer's knowledge of the program and increases one's confidence that the program is free of bugs.<p>
<a name="258877"></a>
Typically, assertion-checking is enabled during program development and testing, and disabled for deployment, to improve performance.<p>
<a name="258878"></a>
Because assertions may be disabled, programs must not assume that the expressions contained in assertions will be evaluated. Thus, these boolean expressions should generally be free of side effects:<p>
<a name="258879"></a>
Evaluating such a boolean expression should not affect any state that is visible after the evaluation is complete. It is not illegal for a boolean expression contained in an assertion to have a side effect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled. <p>
<a name="258880"></a>
Along similar lines, assertions should not be used for argument-checking in public methods. Argument-checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled. <p>
<a name="258900"></a>
Another problem with using assertions for argument checking is that erroneous arguments should result in an appropriate runtime exception (such as <code>IllegalArgumentException</code>, <code>IndexOutOfBoundsException</code> or <code>NullPointerException</code>). An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that <code>AssertionError</code> never be caught, but it is possible to do so, thus the rules for <code>try</code> statements should treat assertions appearing in a <code>try</code> block similarly to the current treatment of throw statements. <p>
<hr>
<a name="258901"></a>
 <p>
<a name="258896"></a>
<a name="14.11"></a>
<h2>14.11    The switch Statement</h2>
<a name="35522"></a>
The <code>switch</code> statement transfers control to one of several statements depending on the value of an expression.<p>
<blockquote><pre>
<em>
SwitchStatement:</em>
        switch ( <em>Expression</em> )<em> SwitchBlock

SwitchBlock:</em>
        {<em> SwitchBlockStatementGroups<sub><i>opt</i></sub> SwitchLabels<sub><i>opt</i></sub> </em>}<em>

SwitchBlockStatementGroups:
        SwitchBlockStatementGroup
        SwitchBlockStatementGroups SwitchBlockStatementGroup

SwitchBlockStatementGroup:
        SwitchLabels BlockStatements

SwitchLabels:
        SwitchLabel
        SwitchLabels SwitchLabel

SwitchLabel:</em>
        case <em>ConstantExpression </em>:
        case <em>EnumConstantName </em>:<em>
        default :

EnumConstantName:
        Identifier
        </em>
</pre></blockquote><a name="256918"></a>
The type of the <em>Expression</em> must be <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>Character</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, or an enum type <a href="classes.html#301020">(&#167;8.9)</a>, or a compile-time error occurs.<p>
<a name="256924"></a>
The body of a <code>switch</code> statement is known as a <em>switch block</em>. Any statement immediately contained by the switch block may be labeled with one or more <code>case</code> or <code>default</code> labels. These labels are said to be <em>associated</em> with the <code>switch</code> statement, as are the values of the constant expressions <a href="expressions.html#5313">(&#167;15.28)</a> in the <code>case</code> labels.<p>
<a name="237328"></a>
All of the following must be true, or a compile-time error will result:<p>
<ul><a name="237329"></a>
<li>Every <code>case</code> constant expression associated with a <code>switch</code> statement must be assignable <a href="conversions.html#184206">(&#167;5.2)</a> to the type of the <code>switch</code> <em>Expression</em>.
<a name="237333"></a>
<li>No switch label is <code>null</code>.
<a name="259424"></a>
<li>No two of the <code>case</code> constant expressions associated with a <code>switch</code> statement may have the same value.
<a name="237334"></a>
<li>At most one <code>default</code> label may be associated with the same <code>switch</code> statement.
</ul>
<a name="259432"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="263129"></a>
 The prohibition against using <code>null</code> as a switch label prevents one from writing code that can never be executed. If the switch expression is of a reference type, such as a boxed primitive type or an enum, a run-time error will occur if the expression evaluates to <code>null</code> at run-time. <p>
</ul><a name="259449"></a>
It follows that if the switch expression is of an enum type, the possible values of the switch labels must all be enum constants of that type.<p>
<a name="259452"></a>
Compilers are encouraged (but not required) to provide a warning if a switch on an enum-valued expression lacks a default case and lacks cases for one or more of the enum type's constants. (Such a statement will silently do nothing if the expression evaluates to one of the missing constants.) <p>
<hr>
<a name="259430"></a>
<a name="252239"></a>
<p>In C and C++ the body of a <code>switch</code> statement can be a statement and statements with <code>case</code> labels do not have to be immediately contained by that statement. Consider the simple loop:</p>
<blockquote><pre>for (i = 0; i &lt; n; ++i) foo();
</pre></blockquote><a name="237282"></a>
where <code>n</code> is known to be positive. A trick known as <em>Duff's device</em> can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:<p>
<blockquote><pre>int q = (n+7)/8;
switch (n%8) {
case 0:         do {    foo();          // Great C hack, Tom,
case 7:                 foo();          // but it's not valid here.
case 6:                 foo();
case 5:                 foo();
case 4:                 foo();
case 3:                 foo();
case 2:                 foo();
case 1:                 foo();
                } while (--q &gt; 0);
}
</pre></blockquote><a name="237295"></a>
Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.<p>
<a name="217138"></a>
When the <code>switch</code> statement is executed, first the <em>Expression</em> is evaluated. If the <em>Expression</em> evaluates to <code>null</code>, a <code>NullPointerException</code> is thrown and the entire <code>switch</code> statement completes abruptly for that reason. Otherwise, if the result is of a reference type, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason. Otherwise, execution continues by comparing the value of the <em>Expression </em>with each <code>case</code> constant. Then there is a choice:<p>
<ul><a name="6012"></a>
<li>If one of the <code>case</code> constants is equal to the value of the expression, then we say that the <code>case</code> matches, and all statements after the matching <code>case</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the matching <code>case</code> label, then the entire <code>switch</code> statement completes normally.
<a name="6013"></a>
<li>If no <code>case</code> matches but there is a <code>default</code> label, then all statements after the matching <code>default</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the <code>default</code> label, then the entire <code>switch</code> statement completes normally.
<a name="6014"></a>
<li>If no <code>case</code> matches and there is no <code>default</code> label, then no further action is taken and the <code>switch</code> statement completes normally.
</ul><a name="237254"></a>
If any statement immediately contained by the <em>Block</em> body of the <code>switch</code> statement completes abruptly, it is handled as follows:<p>
<ul><a name="6017"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>switch</code> statement completes normally.
<a name="237272"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>switch</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.html#78993">(&#167;14.7)</a>.
</ul><a name="237607"></a>
As in C and C++, execution of statements in a switch block "falls through labels." <p>
<a name="252252"></a>
<p>For example, the program:</p>
<blockquote><pre>class Toomany {
        static void howMany(int k) {
                switch (k) {
                case 1:                 System.out.print("one ");
                case 2:                 System.out.print("too ");
                case 3:                 System.out.println("many");
                }
        }
        public static void main(String[] args) {
                howMany(3);
                howMany(2);
                howMany(1);
        }
}
</pre></blockquote><a name="237629"></a>
contains a switch block in which the code for each case falls through into the code for the next case. As a result, the program prints:<p>
<blockquote><pre>many
too many
one too many
</pre></blockquote><a name="237630"></a>
If code is not to fall through case to case in this manner, then <code>break</code> statements should be used, as in this example:<p>
<blockquote><pre>class Twomany {
        static void howMany(int k) {
                switch (k) {
                case 1:         System.out.println("one");
                                break;          // exit the switch
                case 2:         System.out.println("two");
                                break;          // exit the switch
                case 3:         System.out.println("many");
                                break;          // not needed, but good style
                }
        }
        public static void main(String[] args) {
                howMany(1);
                howMany(2);
                howMany(3);
        }
}
</pre></blockquote><a name="237642"></a>
This program prints:<p>
<blockquote><pre>one
two
many
</pre></blockquote><a name="237277"></a>
<a name="14.12"></a>
<h2>14.12    The while Statement</h2>
<a name="237278"></a>
The <code>while</code> statement executes an <em>Expression</em> and a <em>Statement</em> repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<blockquote><pre>
<em>
WhileStatement:</em>
        while ( <em>Expression</em> ) <em>Statement

WhileStatementNoShortIf:</em>
        while ( <em>Expression </em>) <em>StatementNoShortIf</em>
</pre></blockquote><a name="35485"></a>
The <em>Expression</em> must have type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.<p>
<a name="217153"></a>
A <code>while</code> statement is executed by first evaluating the <em>Expression</em>. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>while</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="6028"></a>
<li>If the value is <code>true</code>, then the contained <em>Statement</em> is executed. Then there is a choice:
<ul>
<a name="6029"></a>
<li>If execution of the <em>Statement</em> completes normally, then the entire <code>while</code> statement is executed again, beginning by re-evaluating the <em>Expression</em>.
<a name="6030"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.html#21139">&#167;14.12.1</a> below.
</ul>
<a name="6031"></a>
<li>If the (possibly unboxed) value of the <em>Expression</em> is <code>false</code>, no further action is taken and the <code>while</code> statement completes normally.
</ul><a name="6032"></a>
If the (possibly unboxed) value of the <em>Expression</em> is <code>false</code> the first time it is evaluated, then the <em>Statement</em> &#32;is not executed.<p>
<a name="21139"></a>
<a name="14.12.1"></a>
<h3>14.12.1    Abrupt Completion</h3>
<a name="6033"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6034"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>while</code> statement completes normally.
<ul>
<a name="6035"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the entire <code>while</code> statement is executed again.
<a name="79063"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79064"></a>
<li>If the <code>while</code> statement has label <i>L</i>, then the entire <code>while</code> statement is executed again.
<a name="79065"></a>
<li>If the <code>while</code> statement does not have label <i>L</i>, the <code>while</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="79070"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>while</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.html#78993">(&#167;14.7)</a>.
</ul>
</ul><a name="263259"></a>
<a name="263260"></a>
<a name="6045"></a>
<a name="14.13"></a>
<h2>14.13    The do Statement</h2>
<a name="246911"></a>
The <code>do</code> statement executes a <em>Statement</em> and an <em>Expression</em> repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<blockquote><pre>
<em>
DoStatement:</em>
        do <em>Statement</em> while ( <em>Expression</em> ) ;
</pre></blockquote><a name="35496"></a>
The <em>Expression</em> must have type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.<p>
<a name="6048"></a>
A <code>do</code> statement is executed by first executing the <em>Statement</em>. Then there is a choice:<p>
<ul><a name="217176"></a>
<li>If execution of the <em>Statement</em> completes normally, then the <em>Expression</em> is evaluated. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>do</code> statement completes abruptly for the same reason. Otherwise, there is a choice based on the resulting value:
<ul>
<a name="217172"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6051"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="6052"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.html#45366">&#167;14.13.1</a> below.
</ul><a name="6053"></a>
Executing a <code>do</code> statement always executes the contained <em>Statement</em> at least once.<p>
<a name="45366"></a>
<a name="14.13.1"></a>
<h3>14.13.1    Abrupt Completion</h3>
<a name="43246"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6714"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, then no further action is taken and the <code>do</code> statement completes normally.
<a name="6056"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the <em>Expression</em> is evaluated. Then there is a choice based on the resulting value:
<ul>
<a name="6057"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6058"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79109"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79110"></a>
<li>If the <code>do</code> statement has label <i>L</i>, then the <em>Expression</em> is evaluated. Then there is a choice:
<ul>
<a name="79111"></a>
<li>If the value of the <em>Expression</em> is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="79112"></a>
<li>If the value of the <em>Expression</em> is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79113"></a>
<li>If the <code>do</code> statement does not have label <i>L</i>, the <code>do</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="24581"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>do</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule <a href="statements.html#78993">(&#167;14.7)</a>.
</ul><a name="24585"></a>
<a name="14.13.2"></a>
<h3>14.13.2    Example of do statement</h3>
<a name="252264"></a>
The following code is one possible implementation of the <code>toHexString</code> method of class <code>Integer</code>:<p>
<blockquote><pre>public static String toHexString(int i) {
        StringBuffer buf = new StringBuffer(8);
        do {
                buf.append(Character.forDigit(i &amp; 0xF, 16));
                i &gt;&gt;&gt;= 4;
        } while (i != 0);
        return buf.reverse().toString();
}
</pre></blockquote><a name="24586"></a>
Because at least one digit must be generated, the <code>do</code> statement is an appropriate control structure.<p>
<a name="24588"></a>
<a name="14.14"></a>
<h2>14.14    The for Statement</h2>
<a name="35537"></a>
<p>
<blockquote><pre>
<em>
ForStatement:
        BasicForStatement
        EnhancedForStatement
</em>
</pre></blockquote><a name="259651"></a>
The <code>for</code> statement has two forms:<p>
<ul><a name="259149"></a>
<li>The basic <code>for</code> statement.
<a name="259151"></a>
<li>The enhanced <code>for</code> statement
</ul><a name="259150"></a>
<a name="14.14.1"></a>
<h3>14.14.1    The basic for Statement</h3>
<a name="259162"></a>
The basic for statement executes some initialization code, then executes an <em>Expression</em>, a <em>Statement</em>, and some update code repeatedly until the value of the <em>Expression</em> is <code>false</code>.<p>
<blockquote><pre>
<em>
BasicForStatement:</em>
        for ( <em>ForInit<sub><i>opt</i></sub></em> ; <em>Expression<sub><i>opt</i></sub></em> ; <em>ForUpdate<sub><i>opt</i></sub></em> ) <em>Statement

ForStatementNoShortIf:</em>
        for ( <em>ForInit<sub><i>opt</i></sub></em> ; <em>Expression<sub><i>opt</i></sub></em> ; <em>ForUpdate<sub><i>opt</i></sub></em> )<em>
         StatementNoShortIf

ForInit:
        StatementExpressionList
        LocalVariableDeclaration

ForUpdate:
        StatementExpressionList

StatementExpressionList:
        StatementExpression
        StatementExpressionList , StatementExpression
        </em>
</pre></blockquote><a name="35529"></a>
The <em>Expression</em> must have type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.<p>
<a name="45367"></a>
<a name="14.14.1.1"></a>
<h4>14.14.1.1    Initialization of for statement</h4>
<a name="11751"></a>
A <code>for</code> statement is executed by first executing the <em>ForInit</em> code:<p>
<ul><a name="6081"></a>
<li>If the <em>ForInit</em> code is a list of statement expressions <a href="statements.html#5984">(&#167;14.8)</a>, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <em>ForInit</em> statement expressions to the right of the one that completed abruptly are not evaluated.
</ul><a name="263472"></a>
If the <em>ForInit</em> code is a local variable declaration, it is executed as if it were a local variable declaration statement <a href="statements.html#5920">(&#167;14.4)</a> appearing in a block. The scope of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a> includes all of the following:<p>
<ul><a name="263477"></a>
<li>Its own initializer
<a name="263480"></a>
<li>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement
<a name="263481"></a>
<li>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement
<a name="263482"></a>
<li>The contained <em>Statement</em>
</ul><a name="263345"></a>
If execution of the local variable declaration completes abruptly for any reason, the <code>for</code> statement completes abruptly for the same reason.<p>
<ul><a name="6083"></a>
<li>If the <em>ForInit</em> part is not present, no action is taken.
</ul><a name="45370"></a>
<a name="14.14.1.2"></a>
<h4>14.14.1.2    Iteration of for statement</h4>
<a name="217196"></a>
Next, a <code>for</code> iteration step is performed, as follows:<p>
<ul><a name="217202"></a>
<li>If the <em>Expression</em> is present, it is evaluated. If the result is of type <code>Boolean</code>, it is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly, the <code>for</code> statement completes abruptly for the same reason. Otherwise, there is then a choice based on the presence or absence of the <em>Expression</em> and the resulting value if the <em>Expression</em> is present:
<ul>
<a name="6086"></a>
<li>If the <em>Expression</em> is not present, or it is present and the value resulting from its evaluation (including any possible unboxing) is <code>true</code>, then the contained <em>Statement</em> is executed. Then there is a choice:
<ul>
<a name="6087"></a>
<li>If execution of the <em>Statement</em> completes normally, then the following two steps are performed in sequence:
<ul>
<a name="45351"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <em>ForUpdate</em> statement expressions to the right of the one that completed abruptly are not evaluated. If the <em>ForUpdate</em> part is not present, no action is taken.
<a name="236152"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="236156"></a>
<li>If execution of the <em>Statement</em> completes abruptly, see <a href="statements.html#45371">&#167;14.14.1.3</a> below.
</ul>
<a name="236157"></a>
<li>If the <em>Expression</em> is present and the value resulting from its evaluation (including any possible unboxing) is <code>false</code>, no further action is taken and the <code>for</code> statement completes normally.
</ul>
</ul><a name="6092"></a>
If the (possibly unboxed) value of the <em>Expression</em> is <code>false</code> the first time it is evaluated, then the <em>Statement</em> is not executed.<p>
<a name="6093"></a>
If the <em>Expression</em> is not present, then the only way a <code>for</code> statement can complete normally is by use of a <code>break</code> statement.<p>
<a name="45371"></a>
<a name="14.14.1.3"></a>
<h4>14.14.1.3    Abrupt Completion of for statement</h4>
<a name="43248"></a>
Abrupt completion of the contained <em>Statement</em> is handled in the following manner:<p>
<ul><a name="6095"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>for</code> statement completes normally.
<a name="6096"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with no label, then the following two steps are performed in sequence:
<ul>
<a name="6097"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the <em>ForUpdate</em> &#32;part is not present, no action is taken.
<a name="6098"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79161"></a>
<li>If execution of the <em>Statement</em> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79162"></a>
<li>If the <code>for</code> statement has label <i>L</i>, then the following two steps are performed in sequence:
<ul>
<a name="79163"></a>
<li>First, if the <em>ForUpdate</em> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the<em> ForUpdate</em> is not present, no action is taken.
<a name="79164"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79165"></a>
<li>If the <code>for</code> statement does not have label <i>L</i>, the <code>for</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="6104"></a>
<li>If execution of the <em>Statement</em> completes abruptly for any other reason, the <code>for</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="statements.html#78993">(&#167;14.7)</a>.
</ul><a name="259170"></a>
<a name="14.14.2"></a>
<h3>14.14.2    The enhanced for statement</h3>
<a name="259171"></a>
The enhanced <code>for</code> statement has the form:<p>
<a name="259172"></a>
<p>
<blockquote><pre>
<em>
EnhancedForStatement:</em>
        for ( <em>VariableModifiers<sub>opt</sub> Type Identifier</em>:</em> Expression</em>)<em> Statement
</em></pre></blockquote><a name="259173"></a>
The <i>Expression</i> must either have type <code>Iterable</code> or else it must be of an array type <a href="arrays.html#25518">(&#167;10.1)</a>, or a compile-time error occurs.<p>
<a name="263523"></a>
The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a> is the contained <em>Statement</em><p>
<a name="259187"></a>
The meaning of the enhanced <code>for</code> statement is given by translation into a basic <code>for</code> statement. <p>
<a name="259199"></a>
If the type of <i>Expression</i> is a subtype of <code>Iterable</code>, then let <i>I</i> be the type of the expression <i>Expression</i>.<code>iterator()</code>. The enhanced <code>for</code> statement is equivalent to a basic <code>for</code> statement of the form:<p>
<pre><a name="259190"></a>
for (I #i = Expression.iterator(); #i.hasNext(); ) {
</pre><pre><a name="259195"></a>        VariableModifiersopt Type Identifier = #i.next();
<a name="259196"></a>   Statement
<a name="259197"></a>}
</pre><a name="259366"></a>
Where <i>#i</i> is a compiler-generated identifier that is distinct from any other identifiers (compiler-generated or otherwise) that are in scope <a href="names.html#103228">(&#167;6.3)</a> at the point where the enhanced <code>for</code> statement occurs.<p>
<a name="259200"></a>
Otherwise, the <i>Expression</i> necessarily has an array type, <i>T[]</i>. Let <i>L<sub>1</sub> ... L<sub>m</sub></i> be the (possibly empty) sequence of labels immediately preceding the enhanced <code>for</code> statement. Then the meaning of the enhanced <code>for</code> statement is given by the following basic <code>for</code> statement:<p>
<blockquote><pre><a name="259201"></a>
<i>T</i>[] <i>a</i> = <i>Expression</i>;
<i>L</i><sub>1</sub>: <i>L</i><sub>2</sub>: ... <i>L</i><sub>m</sub>:
for (int <i>i</i> = 0; <i>i</i> &lt; <i>a</i>.length; <i>i</i>++) {
        <i>VariableModifiers<sub>opt</sub> Type Identifier</i> = <i>a</i>[<i>i</i>];
        <i>Statement</i>
}
</pre></blockquote><a name="259354"></a>
Where <i>a</i> and <i>i</i> are compiler-generated identifiers that are distinct from any other identifiers (compiler-generated or otherwise) that are in scope at the point where the enhanced <code>for</code> statement occurs.<p>
<a name="259290"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="259292"></a>
 The following example, which calculates the sum of an integer array, shows how enhanced for works for arrays: <p>
<blockquote><pre>    int sum(int[] a) {
        int sum = 0;
        for (int i : a)
            sum += i;
        return sum;
    }
        </pre></blockquote>
<a name="259301"></a>
 Here is an example that combines the enhanced for statement with auto-unboxing to translate a histogram into a frequency table:<p>
 <blockquote><pre>
    Map&lt;String, Integer&gt; histogram = ...;
    double total = 0;
    for (int i : histogram.values())
        total += i;
    for (Map.Entry&lt;String, Integer&gt; e : histogram.entrySet())
        System.out.println(e.getKey() + "       " + e.getValue() / total);
<a name="259315"></a>
</pre></blockquote><a name="6842"></a>
<hr>
<p>
<a name="14.15"></a>
<h2>14.15    The break Statement</h2>
<a name="35540"></a>
A break statement transfers control out of an enclosing statement.<p>
<blockquote><pre>
<em>
BreakStatement:</em>
        break <em>Identifier<sub><i>opt</i></sub></em> ;
</pre></blockquote><a name="43392"></a>
A <code>break</code> statement with no label attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block; this statement, which is called the <em>break target</em>, then immediately completes normally. <p>
<a name="256041"></a>
To be precise, a <code>break</code> statement with no label always completes abruptly, the reason being a <code>break</code> with no label. If no <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement in the immediately enclosing method, constructor or initializer encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="79188"></a>
A <code>break</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement <a href="statements.html#78993">(&#167;14.7)</a> that has the same <em>Identifier</em> as its label; this statement, which is called the <em>break target</em>, then immediately completes normally. In this case, the <code>break</code> target need not be a <code>while</code>, <code>do</code>, <code>for</code>, or <code>switch</code> statement. A break statement must refer to a label within the immediately enclosing method or initializer block. There are no non-local jumps.<p>
<a name="247471"></a>
To be precise, a <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>break</code> with label <em>Identifier</em>. If no labeled statement with <em>Identifier</em> &#32;as its label encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="43504"></a>
It can be seen, then, that a <code>break</code> statement always completes abruptly.<p>
<a name="43404"></a>
<p>The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.html#79311">(&#167;14.20)</a> within the break target whose <code>try</code> blocks contain the <code>break</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>break</code> statement.</p>
<a name="18004"></a>
<p>In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes <i>P</i> and <i>Q</i>, where <i>Q</i> may be the same as <i>P</i>, there is at most one edge from <i>P</i> to <i>Q</i>. Nodes are represented by integers, and there is an edge from node <i>i</i> to node <code>edges[</code><i>i</i>][<i>j</i>] for every <i>i</i> and <i>j</i> for which the array reference <code>edges[</code><i>i</i>][<i>j</i>] does not throw an <code>IndexOutOfBoundsException</code>.</p>
<a name="42801"></a>
<p>The task of the method <code>loseEdges</code>, given integers <i>i</i> and <i>j</i>, is to construct a new graph by copying a given graph but omitting the edge from node <i>i</i> to node <i>j</i>, if any, and the edge from node <i>j</i> to node <i>i</i>, if any:</p>
<blockquote><pre>
class Graph {
        int edges[][];
                public Graph(int[][] edges) { this.edges = edges; }
        public Graph loseEdges(int i, int j) {
                int n = edges.length;
                int[][] newedges = new int[n][];
                for (int k = 0; k &lt; n; ++k) {
                        edgelist: {
                                int z;
                                search: {
                                        if (k == i) {
                                                for (z = 0; z &lt; edges[k].length; ++z)
                                                        if (edges[k][z] == j)
                                                                break search;
                                        } else if (k == j) {
                                                for (z = 0; z &lt; edges[k].length; ++z)
                                                        if (edges[k][z] == i)
                                                                break search;
                                        }
                                        // No edge to be deleted; share this list.
                                        newedges[k] = edges[k];
                                        break edgelist;
                                } //search
                                // Copy the list, omitting the edge at position z.
                                int m = edges[k].length - 1;
                                int ne[] = new int[m];
                                System.arraycopy(edges[k], 0, ne, 0, z);
                                System.arraycopy(edges[k], z+1, ne, z, m-z);
                                newedges[k] = ne;
                        } //edgelist
                }
                return new Graph(newedges);
        }
}
</pre></blockquote><a name="42887"></a>
Note the use of two statement labels, <code>edgelist</code> and <code>search</code>, and the use of <code>break</code> statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node <i>i</i> to node <i>j</i>, and the test for an edge from node <i>j</i> to node <i>i</i>.<p>
<a name="6122"></a>
<a name="14.16"></a>
<h2>14.16    The continue Statement</h2>
<a name="6123"></a>
A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements of these three kinds are called <em>iteration statements</em>. Control passes to the loop-continuation point of an iteration statement.<p>
<blockquote><pre>
<em>
ContinueStatement:</em>
        continue <em>Identifier<sub><i>opt</i></sub></em> ;
</pre></blockquote><a name="6125"></a>
A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block; this statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one. <p>
<a name="256040"></a>
To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label. If no <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer block encloses the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="247489"></a>
A <code>continue</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement <a href="statements.html#78993">(&#167;14.7)</a> that has the same <em>Identifier</em> as its label; that statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one. The continue target must be a <code>while</code>, <code>do</code>, or <code>for</code> statement or a compile-time error occurs. A continue statement must refer to a label within the immediately enclosing method or initializer block. There are no non-local jumps.<p>
<a name="79215"></a>
More precisely, a <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>continue</code> with label <em>Identifier</em>. If no labeled statement with <em>Identifier</em> as its label contains the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="43498"></a>
It can be seen, then, that a <code>continue</code> statement always completes abruptly.<p>
<a name="6136"></a>
See the descriptions of the <code>while</code> statement <a href="statements.html#237277">(&#167;14.12)</a>, <code>do</code> statement <a href="statements.html#6045">(&#167;14.13)</a>, and <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a> for a discussion of the handling of abrupt termination because of <code>continue</code>.<p>
<a name="252288"></a>
<p>The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.html#79311">(&#167;14.20)</a> within the continue target whose <code>try</code> blocks contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.</p>
<a name="42935"></a>
<p>In the <code>Graph</code> example in the preceding section, one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This <code>break</code> can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:</p>
<blockquote><pre>class Graph {
        . . .
        public Graph loseEdges(int i, int j) {
                int n = edges.length;
                int[][] newedges = new int[n][];
                edgelists: for (int k = 0; k &lt; n; ++k) {
                        int z;
                        search: {
                                if (k == i) {
                                        . . .
                                } else if (k == j) {
                                        . . .
                                }
                                newedges[k] = edges[k];
                                continue edgelists;
                        } // search
                        . . .
                } // edgelists
                return new Graph(newedges);
        }
}
</pre></blockquote><a name="42984"></a>
Which to use, if either, is largely a matter of programming style.<p>
<a name="6767"></a>
<a name="14.17"></a>
<h2>14.17    The return Statement</h2>
<a name="124158"></a>
A <code>return</code> statement returns control to the invoker of a method (<a href="classes.html#40420">&#167;8.4</a>, <a href="expressions.html#20448">&#167;15.12</a>) or constructor (<a href="classes.html#41652">&#167;8.8</a>, <a href="expressions.html#41147">&#167;15.9</a>).<p>
<blockquote><pre>
<em>
ReturnStatement:</em>
        return <em>Expression<sub><i>opt</i></sub> </em>;
</pre></blockquote><a name="236030"></a>
A <code>return</code> statement with no <em>Expression </em>must be contained in the body of a method that is declared, using the keyword <code>void</code>, not to return any value <a href="classes.html#40420">(&#167;8.4)</a>, or in the body of a constructor <a href="classes.html#41652">(&#167;8.8)</a>. A compile-time error occurs if a <code>return</code> statement appears within an instance initializer or a static initializer <a href="classes.html#39245">(&#167;8.7)</a>. A <code>return</code> statement with no <em>Expression</em> attempts to transfer control to the invoker of the method or constructor that contains it. <p>
<a name="256046"></a>
To be precise, a <code>return</code> statement with no <em>Expression</em> always completes abruptly, the reason being a <code>return</code> with no value.<p>
<a name="6148"></a>
A <code>return</code> statement with an <em>Expression</em> must be contained in a method declaration that is declared to return a value <a href="classes.html#40420">(&#167;8.4)</a> or a compile-time error occurs. The <em>Expression</em> must denote a variable or value of some type <i>T</i>, or a compile-time error occurs. The type <i>T</i> must be assignable <a href="conversions.html#184206">(&#167;5.2)</a> to the declared result type of the method, or a compile-time error occurs.<p>
<a name="247542"></a>
A <code>return</code> statement with an <em>Expression</em> attempts to transfer control to the invoker of the method that contains it; the value of the <em>Expression</em> becomes the value of the method invocation. More precisely, execution of such a <code>return</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <i>V</i>, then the <code>return</code> statement completes abruptly, the reason being a <code>return</code> with value <i>V</i>. If the expression is of type <code>float</code> and is not FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>, then the value may be an element of either the float value set or the float-extended-exponent value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>. If the expression is of type <code>double</code> and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.<p>
<a name="43495"></a>
It can be seen, then, that a <code>return</code> statement always completes abruptly.<p>
<a name="43508"></a>
<p>The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="statements.html#79311">(&#167;14.20)</a> within the method or constructor whose <code>try</code> blocks contain the <code>return</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>return</code> statement.</p>
<a name="237350"></a>
<a name="14.18"></a>
<h2>14.18    The throw Statement</h2>
<a name="79254"></a>
A <code>throw</code> statement causes an exception <a href="exceptions.html#44043">(&#167;11)</a> to be thrown. The result is an immediate transfer of control <a href="exceptions.html#44153">(&#167;11.3)</a> that may exit multiple statements and multiple constructor, instance initializer, static initializer and field initializer evaluations, and method invocations until a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a> is found that catches the thrown value. If no such <code>try</code> statement is found, then execution of the thread (<a href="memory.html#61803">&#167;17</a>) that executed the <code>throw</code> is terminated <a href="exceptions.html#44153">(&#167;11.3)</a> after invocation of the <code>uncaughtException</code> method for the thread group to which the thread belongs.<p>
<blockquote><pre>
<em>
ThrowStatement:</em>
        throw <em>Expression </em>;
</pre></blockquote><a name="263518"></a>
A throw statement can throw an exception type <i>E</i> iff the static type of the throw expression is <i>E</i> or a subtype of <i>E</i>, or the thrown expression can throw <i>E</i>. <p>
<a name="236072"></a>
The <em>Expression</em> in a throw statement must denote a variable or value of a reference type which is assignable <a href="conversions.html#184206">(&#167;5.2)</a> to the type <code>Throwable</code>, or a compile-time error occurs. Moreover, at least one of the following three conditions must be true, or a compile-time error occurs:<p>
<ul><a name="236073"></a>
<li>The exception is not a checked exception <a href="exceptions.html#44121">(&#167;11.2)</a>-specifically, one of the following situations is true:
<ul>
<a name="39922"></a>
<li>The type of the <em>Expression</em> is the class <code>RuntimeException</code> or a subclass of <code>RuntimeException</code>.
<a name="236074"></a>
<li>The type of the <em>Expression</em> is the class <code>Error</code> or a subclass of <code>Error</code>.
</ul>
<a name="236078"></a>
<li>The <code>throw</code> statement is contained in the <code>try</code> block of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a> and the type of the <em>Expression</em> is assignable <a href="conversions.html#184206">(&#167;5.2)</a> to the type of the parameter of at least one <code>catch</code> clause of the <code>try</code> statement. (In this case we say the thrown value is <em>caught</em> by the <code>try</code> statement.)
<a name="236082"></a>
<li>The <code>throw</code> statement is contained in a method or constructor declaration and the type of the <em>Expression</em> is assignable <a href="conversions.html#184206">(&#167;5.2)</a> to at least one type listed in the <code>throws</code> clause (<a href="classes.html#308526">&#167;8.4.6</a>, <a href="classes.html#300902">&#167;8.8.5</a>) of the declaration.
</ul><a name="254469"></a>
A <code>throw</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>throw</code> completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a non-<code>null</code> value <i>V</i>, then the <code>throw</code> statement completes abruptly, the reason being a <code>throw</code> with value <i>V</i>. If evaluation of the <em>Expression</em> completes normally, producing a <code>null</code> value, then an instance <i>V'</i> of class <code>NullPointerException</code> is created and thrown instead of <code>null</code>. The <code>throw</code> statement then completes abruptly, the reason being a <code>throw</code> with value <i>V'</i>.<p>
<a name="254470"></a>
It can be seen, then, that a <code>throw</code> statement always completes abruptly.<p>
<a name="254474"></a>
If there are any enclosing <code>try</code> statements <a href="statements.html#79311">(&#167;14.20)</a> whose <code>try</code> blocks contain the <code>throw</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>throw</code> statement.<p>
<a name="79283"></a>
If a <code>throw</code> statement is contained in a method declaration, but its value is not caught by some <code>try</code> statement that contains it, then the invocation of the method completes abruptly because of the <code>throw</code>.<p>
<a name="79284"></a>
If a <code>throw</code> statement is contained in a constructor declaration, but its value is not caught by some <code>try</code> statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the <code>throw</code>.<p>
<a name="43567"></a>
If a <code>throw</code> statement is contained in a static initializer <a href="classes.html#39245">(&#167;8.7)</a>, then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some <code>try</code> statement that contains it. If at run-time, despite this check, the value is not caught by some <code>try</code> statement that contains the <code>throw</code> statement, then the value is rethrown if it is an instance of class <code>Error</code> or one of its subclasses; otherwise, it is wrapped in an <code>ExceptionInInitializerError</code> object, which is then thrown <a href="execution.html#44630">(&#167;12.4.2)</a>.<p>
<a name="248568"></a>
If a <code>throw</code> statement is contained in an instance initializer <a href="classes.html#246032">(&#167;8.6)</a>, then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the throws clause of every constructor of the class.<p>
<a name="255757"></a>
By convention, user-declared throwable types should usually be declared to be subclasses of class <code>Exception</code>, which is a subclass of class <code>Throwable</code> (<a href="exceptions.html#44278">&#167;11.5</a>).<p>
<a name="263209"></a>
<p>
<a name="263218"></a>
<p>
<a name="255769"></a>
<a name="14.19"></a>
<h2>14.19    The synchronized Statement</h2>
<a name="79291"></a>
A <code>synchronized</code> statement acquires a mutual-exclusion lock <a href="memory.html#56318">(&#167;17.1)</a> on behalf of the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.<p>
<blockquote><pre>
<em>
SynchronizedStatement:</em>
        synchronized ( <em>Expression </em>)<em> Block</em>
</pre></blockquote><a name="217233"></a>
<p>
<a name="263215"></a>
The type of <em>Expression</em> must be a reference type, or a compile-time error occurs. <p>
<a name="217245"></a>
A <code>synchronized</code> statement is executed by first evaluating the <em>Expression</em>.<p>
<a name="236514"></a>
If evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>synchronized</code> statement completes abruptly for the same reason.<p>
<a name="236515"></a>
Otherwise, if the value of the <em>Expression</em> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="247651"></a>
Otherwise, let the non-<code>null</code> value of the <em>Expression</em> be <i>V</i>. The executing thread locks the lock associated with <i>V</i>. Then the <i>Block</i> is executed. If execution of the <em>Block</em> completes normally, then the lock is unlocked and the <code>synchronized</code> statement completes normally. If execution of the <em>Block</em> completes abruptly for any reason, then the lock is unlocked and the <code>synchronized</code> statement then completes abruptly for the same reason.<p>
<a name="79305"></a>
Acquiring the lock associated with an object does not of itself prevent other threads from accessing fields of the object or invoking unsynchronized methods on the object. Other threads can also use <code>synchronized</code> methods or the <code>synchronized</code> &#32;statement in a conventional manner to achieve mutual exclusion.<p>
<a name="79306"></a>
The locks acquired by <code>synchronized</code> statements are the same as the locks that are acquired implicitly by <code>synchronized</code> methods; see <a href="classes.html#260369">&#167;8.4.3.6</a>. A single thread may hold a lock more than once. <p>
<a name="252313"></a>
<p>The example:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                Test t = new Test();
                synchronized(t) {
                        synchronized(t) {
                                System.out.println("made it!");
                        }
                }
        }
}
</pre></blockquote><a name="22901"></a>
prints:<p>
<blockquote><pre>made it!
</pre></blockquote><a name="22903"></a>
This example would deadlock if a single thread were not permitted to lock a lock more than once.<p>
<a name="79311"></a>
<a name="14.20"></a>
<h2>14.20    The try statement</h2>
<a name="79312"></a>
A <code>try</code> statement executes a block. If a value is thrown and the <code>try</code> statement has one or more <code>catch</code> clauses that can catch it, then control will be transferred to the first such <code>catch</code> clause. If the <code>try</code> statement has a <code>finally</code> clause, then another block of code is executed, no matter whether the <code>try</code> block completes normally or abruptly, and no matter whether a <code>catch</code> clause is first given control. <p>
<blockquote><pre>
<em>
TryStatement:</em>
        try <em>Block Catches</em>
        try <em>Block Catches<sub><i>opt</i></sub> Finally

Catches:
        CatchClause
        Catches CatchClause

CatchClause:</em>
        catch ( <em>FormalParameter</em> ) <em>Block

Finally:</em>
        finally <em>Block</em>
</pre></blockquote><a name="250063"></a>
<p>
<a name="263219"></a>
<a name="263220"></a>
The following is repeated from <a href="classes.html#38698">&#167;8.4.1</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
FormalParameter:
        VariableModifiers Type VariableDeclaratorId
        </em>
</pre></blockquote><a name="237406"></a>
The following is repeated from <a href="classes.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
VariableDeclaratorId:
        Identifier
        VariableDeclaratorId </em>[ ]
</pre></blockquote><a name="79317"></a>
The <em>Block</em> immediately after the keyword <code>try</code> is called the <code>try</code> block of the <code>try</code> statement. The <em>Block</em> immediately after the keyword <code>finally</code> is called the <code>finally</code> block of the <code>try</code> statement.<p>
<a name="79318"></a>
A <code>try</code> statement may have <code>catch</code> clauses (also called <em>exception handlers</em>). A &#32;<code>catch</code> clause must have exactly one parameter (which is called an <em>exception parameter</em>); the declared type of the exception parameter must be the class <code>Throwable</code> or a subclass (not just a subtype) of <code>Throwable</code>, or a compile-time error occurs.In particular, it is a compile-time error if the declared type of the exception parameter is a type variable <a href="typesValues.html#108850">(&#167;4.4)</a>. The scope of the parameter variable is the <em>Block</em> of the <code>catch</code> clause. <p>
<a name="247654"></a>
An exception parameter of a catch clause must not have the same name as a local variable or parameter of the method or initializer block immediately enclosing the catch clause, or a compile-time error occurs.<p>
<a name="263496"></a>
The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement <a href="statements.html#79311">(&#167;14.20)</a> is the entire block associated with the <code>catch</code>.<p>
<a name="247671"></a>
Within the <em>Block</em> of the <code>catch</code> clause, the name of the parameter may not be redeclared as a local variable of the directly enclosing method or initializer block, nor may it be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method or initializer block, or a compile-time error occurs. However, an exception parameter may be shadowed <a href="names.html#34133">(&#167;6.3.1)</a> anywhere inside a class declaration nested within the Block of the catch clause. <p>
<a name="263512"></a>
A <code>try</code> statement can throw an exception type <i>E</i> iff either:<p>
<ul><a name="263513"></a>
<li>The <code>try</code> block can throw <i>E</i> and <i>E</i> is not assignable to any <code>catch</code> parameter of the <code>try</code> statement and either no <code>finally</code> block is present or the <code>finally</code> block can complete normally; or
<a name="263514"></a>
<li>Some <code>catch</code> block of the <code>try</code> statement can throw <i>E</i> and either no <code>finally</code> block is present or the <code>finally</code> block can complete normally; or
<a name="263515"></a>
<li>A <code>finally</code> block is present and can throw <i>E</i>.
</ul><a name="263385"></a>
<p>
<a name="247536"></a>
It is a compile-time error if an exception parameter that is declared final is assigned to within the body of the catch clause. <p>
<a name="263504"></a>
It is a compile-time error if a <code>catch</code> clause catches checked exception type <i>E1</i> but there exists no checked exception type <i>E2</i> such that all of the following hold:<p>
<ul><a name="263505"></a>
<li><i>E2</i> &lt;: <i>E1</i>
<a name="263506"></a>
<li>The <code>try</code> block corresponding to the <code>catch</code> clause can throw <i>E2</i>
<a name="263507"></a>
<li>No preceding <code>catch</code> block of the immediately enclosing <code>try</code> statement catches <i>E2</i> or a supertype of <i>E2</i>.
</ul><a name="263509"></a>
unless <i>E1</i> is the class <code>Exception</code>.<p>
<a name="45880"></a>
Exception parameters cannot be referred to using qualified names <a href="names.html#104285">(&#167;6.6)</a>, only by simple names.<p>
<a name="24142"></a>
Exception handlers are considered in left-to-right order: the earliest possible <code>catch</code> clause accepts the exception, receiving as its actual argument the thrown exception object.<p>
<a name="24143"></a>
A <code>finally</code> clause ensures that the <code>finally</code> block is executed after the <code>try</code> block and any <code>catch</code> block that might be executed, no matter how control leaves the <code>try</code> block or <code>catch</code> block.<p>
<a name="79319"></a>
Handling of the <code>finally</code> block is rather complex, so the two cases of a <code>try</code> statement with and without a <code>finally</code> block are described separately.<p>
<a name="24134"></a>
<a name="14.20.1"></a>
<h3>14.20.1    Execution of try-catch</h3>
<a name="79320"></a>
A <code>try</code> statement without a <code>finally</code> block is executed by first executing the <code>try</code> block. Then there is a choice:<p>
<ul><a name="79321"></a>
<li>If execution of the <code>try</code> block completes normally, then no further action is taken and the <code>try</code> statement completes normally.
<a name="79322"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79323"></a>
<li>If the run-time type of <i>V</i> is assignable <a href="conversions.html#184206">(&#167;5.2)</a> to the <em>Parameter</em> of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i> is assigned to the parameter of the selected <code>catch</code> clause, and the <em>Block</em> of that <code>catch</code> clause is executed. If that block completes normally, then the <code>try</code> statement completes normally; if that block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
<a name="79324"></a>
<li>If the run-time type of <i>V</i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
</ul>
<a name="79325"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason, then the <code>try</code> statement completes abruptly for the same reason.
</ul>
<a name="256055"></a>
<p>In the example:</p>
<blockquote><pre>class BlewIt extends Exception {
        BlewIt() { }
        BlewIt(String s) { super(s); }
}
class Test {
        static void blowUp() throws BlewIt { throw new BlewIt(); }
        public static void main(String[] args) {
                try {
                        blowUp();
                } catch (RuntimeException r) {
                        System.out.println("RuntimeException:" + r);
                } catch (BlewIt b) {
                        System.out.println("BlewIt");
                }
        }
}
</pre></blockquote><a name="236651"></a>
the exception <code>BlewIt</code> is thrown by the method <code>blowUp</code>. The <code>try</code>-catch statement in the body of <code>main</code> has two <code>catch</code> clauses. The run-time type of the exception is <code>BlewIt</code> which is not assignable to a variable of type <code>RuntimeException</code>, but is assignable to a variable of type <code>BlewIt</code>, so the output of the example is:<p>
<blockquote><pre>BlewIt
</pre></blockquote><a name="236653"></a>
<a name="14.20.2"></a>
<h3>14.20.2    Execution of try-catch-finally</h3>
<a name="79326"></a>
A <code>try</code> statement with a <code>finally</code> block is executed by first executing the <code>try</code> block. Then there is a choice:<p>
<ul><a name="79327"></a>
<li>If execution of the <code>try</code> block completes normally, then the <code>finally</code> block is executed, and then there is a choice:
<ul>
<a name="160341"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160342"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i>.
</ul>
<a name="79328"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79329"></a>
<li>If the run-time type of <i>V</i> is assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i> is assigned to the parameter of the selected <code>catch</code> clause, and the <em>Block</em> of that <code>catch</code> clause is executed. Then there is a choice:
<ul>
<a name="79330"></a>
<li>If the <code>catch</code> block completes normally, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="160348"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160349"></a>
<li>If the <code>finally</code> block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
</ul>
<a name="79331"></a>
<li>If the <code>catch</code> block completes abruptly for reason <i>R</i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79332"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i>.
<a name="79333"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and reason <i>R</i> is discarded).
</ul>
</ul>
<a name="79334"></a>
<li>If the run-time type of <i>V</i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79335"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
<a name="79336"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and the <code>throw</code> of value <i>V</i> is discarded and forgotten).
</ul>
</ul>
<a name="79337"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason <i>R</i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79338"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i>.
<a name="79339"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i> (and reason <i>R</i> is discarded).
</ul></ul>
<a name="252337"></a>
<p>The example:</p>
<blockquote><pre>class BlewIt extends Exception {
        BlewIt() { }
        BlewIt(String s) { super(s); }
}
class Test {
        static void blowUp() throws BlewIt {
                throw new NullPointerException();
        }
        public static void main(String[] args) {
                try {
                        blowUp();
                } catch (BlewIt b) {
                        System.out.println("BlewIt");
                } finally {
                        System.out.println("Uncaught Exception");
                }
        }
}


</pre></blockquote><a name="263146"></a>
produces the output:<p>
<blockquote><pre>Uncaught Exception
java.lang.NullPointerException
        at Test.blowUp(Test.java:7)
        at Test.main(Test.java:11)
</pre></blockquote><a name="236703"></a>
The <code>NullPointerException</code> (which is a kind of <code>RuntimeException</code>) that is thrown by method <code>blowUp</code> is not caught by the <code>try</code> statement in <code>main</code>, because a <code>NullPointerException</code> is not assignable to a variable of type <code>BlewIt</code>. This causes the <code>finally</code> clause to execute, after which the thread executing <code>main</code>, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace. However, a backtrace is not required by this specification.<p>
<a name="259553"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="259555"></a>
 The problem with mandating a backtrace is that an exception can be created at one point in the program and thrown at a later one. It is prohibitively expensive to store a stack trace in an exception unless it is actually thrown (in which case the trace may be generated while unwinding the stack). Hence we do not mandate a back trace in every exception.<p>
 <hr>
<a name="257388"></a>
 <p>
<a name="236365"></a>
<a name="14.21"></a>
<h2>14.21    Unreachable Statements</h2>
<a name="237365"></a>
It is a compile-time error if a statement cannot be executed because it is <em>unreachable</em>. Every Java compiler must carry out the conservative flow analysis specified here to make sure all statements are reachable.<p>
<a name="237366"></a>
This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of <code>while</code>, <code>do</code>, and <code>for</code> statements whose condition expression has the constant value <code>true</code>, the values of expressions are not taken into account in the flow analysis. <p>
<a name="252350"></a>
<p>For example, a Java compiler will accept the code:</p>
<blockquote><pre>{
        int n = 5;
        while (n &gt; 7) k = 2;
}
</pre></blockquote><a name="79350"></a>
even though the value of <code>n</code> is known at compile time and in principle it can be known at compile time that the assignment to <code>k</code> can never be executed.<p>
<a name="252357"></a>
A Java compiler must operate according to the rules laid out in this section.<p>
<a name="79351"></a>
The rules in this section define two technical terms:<p>
<ul><a name="79352"></a>
<li>whether a statement is <em>reachable</em>
<a name="79353"></a>
<li>whether a statement <em>can complete normally</em>
</ul><a name="79354"></a>
The definitions here allow a statement to complete normally only if it is reachable.<p>
<a name="236611"></a>
To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if."<p>
<a name="236612"></a>
The rules are as follows:<p>
<ul><a name="236613"></a>
<li>The block that is the body of a constructor, method, instance initializer or static initializer is reachable.
<a name="160362"></a>
<li>An empty block that is not a switch block can complete normally iff it is reachable. A nonempty block that is not a switch block can complete normally iff the last statement in it can complete normally. The first statement in a nonempty block that is not a switch block is reachable iff the block is reachable. Every other statement <i>S</i> in a nonempty block that is not a switch block is reachable iff the statement preceding <i>S</i> can complete normally.
<a name="247970"></a>
<li>A local class declaration statement can complete normally iff it is reachable.
<a name="160365"></a>
<li>A local variable declaration statement can complete normally iff it is reachable.
<a name="79357"></a>
<li>An empty statement can complete normally iff it is reachable.
<a name="79359"></a>
<li>A labeled statement can complete normally if at least one of the following is true:
<ul>
<a name="21184"></a>
<li>The contained statement can complete normally.
<a name="21188"></a>
<li>There is a reachable <code>break</code> statement that exits the labeled statement.
</ul>
</ul><ul><a name="21187"></a>
<p>The contained statement is reachable iff the labeled statement is reachable.
</ul><ul><a name="79360"></a>
<li>An expression statement can complete normally iff it is reachable.
<a name="236410"></a>
<li>The <code>if</code> statement, whether or not it has an <code>else</code> part, is handled in an unusual manner. For this reason, it is discussed separately at the end of this section.
<a name="258093"></a>
<li>An <code>assert</code> statement can complete normally iff it is reachable.
<a name="258103"></a>
<li>A <code>switch</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79367"></a>
<li>The last statement in the switch block can complete normally.
<a name="237563"></a>
<li>The switch block is empty or contains only switch labels.
<a name="248980"></a>
<li>There is at least one switch label after the last switch block statement group. 
<a name="248989"></a>
<li>The switch block does not contain a <code>default</code> label.
<a name="248981"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>switch</code> statement.
</ul>
<a name="237548"></a>
<li>A switch block is reachable iff its <code>switch</code> statement is reachable.
<a name="237550"></a>
<li>A statement in a switch block is reachable iff its <code>switch</code> statement is reachable and at least one of the following is true:
<ul>
<a name="79370"></a>
<li>It bears a <code>case</code> or <code>default</code> label.
<a name="79371"></a>
<li>There is a statement preceding it in the <code>switch</code> block and that preceding statement can complete normally.
</ul>
<a name="79372"></a>
<li>A <code>while</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79373"></a>
<li>The <code>while</code> statement is reachable and the condition expression is not a constant expression with value <code>true</code>.
<a name="79374"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>while</code> statement.
</ul>
</ul><ul><a name="79375"></a>
<p>The contained statement is reachable iff the <code>while</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79376"></a>
<li>A <code>do</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79377"></a>
<li>The contained statement can complete normally and the condition expression is not a constant expression with value <code>true</code>.
<a name="248990"></a>
<li>The <code>do</code> statement contains a reachable <code>continue</code> statement with no label, and the <code>do</code> statement is the innermost <code>while</code>, <code>do</code>, or <code>for</code> statement that contains that <code>continue</code> statement, and the condition expression is not a constant expression with value <code>true</code>.
<a name="248991"></a>
<li>The <code>do</code> statement contains a reachable <code>continue</code> statement with a label L, and the <code>do</code> statement has label L, and the condition expression is not a constant expression with value <code>true</code>.
<a name="79378"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>do</code> statement.
</ul>
</ul><ul><a name="79379"></a>
<p>The contained statement is reachable iff the <code>do</code> statement is reachable.
</ul><ul><a name="79380"></a>
<li>A basic <code>for</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79381"></a>
<li>The <code>for</code> statement is reachable, there is a condition expression, and the condition expression is not a constant expression with value <code>true</code>.
<a name="79382"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>for</code> statement.
</ul>
</ul><ul><a name="79383"></a>
<p>The contained statement is reachable iff the <code>for</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79384"></a>
<li>An enhanced <code>for</code> statement can complete normally iff it is reachable.
<a name="259548"></a>
<li>A <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement cannot complete normally.
<a name="79385"></a>
<li>A <code>synchronized</code> statement can complete normally iff the contained statement can complete normally. The contained statement is reachable iff the <code>synchronized</code> statement is reachable.
<a name="79386"></a>
<li>A <code>try</code> statement can complete normally iff both of the following are true:
<ul>
<a name="79387"></a>
<li>The <code>try</code> block can complete normally or any <code>catch</code> block can complete <code>normally</code>.
<a name="79388"></a>
<li>If the <code>try</code> statement has a <code>finally</code> block, then the <code>finally</code> block can complete normally.
</ul>
<a name="79389"></a>
<li>The <code>try</code> block is reachable iff the <code>try</code> statement is reachable.
<a name="79390"></a>
<li>A <code>catch</code> block <i>C</i> is reachable iff both of the following are true:
<ul>
<a name="79391"></a>
<li>Some expression or <code>throw</code> statement in the <code>try</code> block is reachable and can throw an exception whose type is assignable to the parameter of the <code>catch</code> clause <i>C</i>. (An expression is considered reachable iff the innermost statement containing it is reachable.)
<a name="79392"></a>
<li>There is no earlier <code>catch</code> block <i>A</i> in the <code>try</code> statement such that the type of <i>C</i>'s parameter is the same as or a subclass of the type of <i>A</i>'s parameter. 
</ul>
<a name="236212"></a>
<li>If a <code>finally</code> block is present, it is reachable iff the <code>try</code> statement is reachable.
<a name="236419"></a>
</ul>
<p>One might expect the <code>if</code> statement to be handled in the following manner, but these are not the rules that the Java programming language actually uses:</p>
<ul>
<a name="236554"></a>
<li>HYPOTHETICAL: An <code>if-then</code> statement can complete normally iff at least one of the following is <code>true</code>:
<ul>
<a name="236555"></a>
<li>The <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
<a name="236407"></a>
<li>The <code>then</code>-statement can complete normally.
</ul><a name="236408"></a>
<li>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.<p>
<a name="236409"></a>
<li>HYPOTHETICAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>. The <code>else</code> statement is reachable iff the <code>if</code>-<code>then</code>-<code>else </code>statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
<a name="236422"></a>
</ul>
<p>This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for "conditional compilation" purposes, the actual rules differ.</p>
<a name="252364"></a>
<p>
The actual rules for the if statement are as follows:<p>
<ul><a name="236424"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code> statement can complete normally iff it is reachable. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable.
<a name="236428"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable. The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.
<a name="252376"></a>
</ul>
<p>As an example, the following statement results in a compile-time error:</p>
<blockquote><pre>while (false) { x=3; }
</pre></blockquote><a name="236453"></a>
because the statement <code>x=3;</code> is not reachable; but the superficially similar case:<p>
<blockquote><pre>if (false) { x=3; }
</pre></blockquote><a name="236454"></a>
does not result in a compile-time error. An optimizing compiler may realize that the statement <code>x=3;</code> will never be executed and may choose to omit the code for that statement from the generated <code>class</code> file, but the statement <code>x=3;</code> is not regarded as "unreachable" in the technical sense specified here.<p>
<a name="238244"></a>
<p>The rationale for this differing treatment is to allow programmers to define "flag variables" such as:</p>
<blockquote><pre>static final boolean DEBUG = false;
</pre></blockquote><a name="236471"></a>
and then write code such as:<p>
<blockquote><pre>if (DEBUG) { x=3; }
</pre></blockquote><a name="236477"></a>
The idea is that it should be possible to change the value of <code>DEBUG</code> from <code>false</code> to <code>true</code> or from <code>true</code> to <code>false</code> and then compile the code correctly with no other changes to the program text.<p>
<a name="238425"></a>
<p>This ability to "conditionally compile" has a significant impact on, and relationship to, binary compatibility <a href="binaryComp.html#44871">(&#167;13)</a>. If a set of classes that use such a "flag" variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. A change to the value of a flag is, therefore, not binary compatible with preexisting binaries <a href="binaryComp.html#45139">(&#167;13.4.9)</a>. (There are other reasons for such incompatibility as well, such as the use of constants in <code>case</code> labels in <code>switch</code> statements; see <a href="binaryComp.html#45139">&#167;13.4.9</a>.)</p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="binaryComp.html">Prev</a> | <a href="expressions.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>

<html>
<head>
<title> Expressions</title>
<meta name="collection" content="community">
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>

<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="statements.html">Prev</a> | <a href="defAssign.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>

<a name="348842"></a>
<p><strong>
CHAPTER
 15 </strong></p>
<a name="44393"></a>
<h1>Expressions</h1>
<hr><p>
<a name="11757"></a>
Much of the work in a program is done by evaluating <em>expressions</em>, either for their side effects, such as assignments to variables, or for their values, which can be used as arguments or operands in larger expressions, or to affect the execution sequence in statements, or both.<p>
<a name="236101"></a>
This chapter specifies the meanings of expressions and the rules for their evaluation.<p>
<a name="228862"></a>
<a name="15.1"></a>
<h2>15.1    Evaluation, Denotation, and Result</h2>
<a name="290570"></a>
When an expression in a program is <em>evaluated</em> (<em>executed</em>), the <em>result </em>denotes one of three things:<p>
<ul><a name="228896"></a>
<li>A variable <a href="typesValues.html#18470">(&#167;4.12)</a> (in C, this would be called an <em>lvalue</em>)
<a name="19788"></a>
<li>A value (<a href="typesValues.html#85587">&#167;4.2</a>, <a href="typesValues.html#9317">&#167;4.3</a>)
<a name="229505"></a>
<li>Nothing (the expression is said to be void)
</ul><a name="233971"></a>
Evaluation of an expression can also produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations.<p>
<a name="229523"></a>
An expression denotes nothing if and only if it is a method invocation <a href="expressions.html#20448">(&#167;15.12)</a> that invokes a method that does not return a value, that is, a method declared <code>void</code> <a href="classes.html#40420">(&#167;8.4)</a>. Such an expression can be used only as an expression statement <a href="statements.html#5984">(&#167;14.8)</a>, because every other context in which an expression can appear requires the expression to denote something. An expression statement that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.<p>
<a name="249221"></a>
Value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> is applied to the result of every expression that produces a value.<p>
<a name="39859"></a>
Each expression occurs in either:<p>
<ul><a name="338150"></a>
<li>The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in an annotation, or in the code for a method.
<a name="338152"></a>
<li>An annotation of a package or of a top-level type declaration .
</ul><a name="229188"></a>
<a name="15.2"></a>
<h2>15.2    Variables as Values</h2>
<a name="229204"></a>
If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the <em>value</em> of the expression.<p>
<a name="249233"></a>
If the value of a variable of type <code>float</code> or <code>double</code> is used in this manner, then value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> is applied to the value of the variable.<p>
<a name="198550"></a>
<a name="15.3"></a>
<h2>15.3    Type of an Expression</h2>
<a name="229255"></a>
If an expression denotes a variable or a value, then the expression has a type known at compile time. The rules for determining the type of an expression are explained separately below for each kind of expression.<p>
<a name="264235"></a>
<p>The value of an expression is  assignment compatible <a href="conversions.html#184206">(&#167;5.2)</a> with the type of the expression, unless heap pollution <a href="typesValues.html#111088">(&#167;4.12.2.1)</a> occurs. Likewise the value stored in a variable is always compatible with the type of the variable, unless heap pollution occurs. In other words, the value of an expression whose type is <i>T</i> is always suitable for assignment to a variable of type <i>T</i>.</p>
<a name="264237"></a>
<p>Note that an expression whose type is a class type <i>F</i> that is declared <code>final</code> is guaranteed to have a value that is either a null reference or an object whose class is <i>F</i> itself, because <code>final</code> types have no subclasses.</p>
<a name="249198"></a>
<a name="15.4"></a>
<h2>15.4    FP-strict Expressions</h2>
<a name="272660"></a>
If the type of an expression is <code>float</code> or <code>double</code>, then there is a question as to what value set <a href="typesValues.html#9208">(&#167;4.2.3)</a> the value of the expression is drawn from. This is governed by the rules of value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>; these rules in turn depend on whether or not the expression is <em>FP-strict</em>.<p>
<a name="272652"></a>
Every compile-time constant expression <a href="expressions.html#5313">(&#167;15.28)</a> is FP-strict. If an expression is not a compile-time constant expression, then consider all the class declarations, interface declarations, and method declarations that contain the expression. If <em>any</em> such declaration bears the <code>strictfp</code> modifier, then the expression is FP-strict.<p>
<a name="286261"></a>
If a class, interface, or method, <i>X</i>, is declared <code>strictfp</code>, then <i>X</i> and any class, interface, method, constructor, instance initializer, static initializer or variable initializer within <i>X</i> is said to be <em>FP-strict</em>. Note that an annotation <a href="interfaces.html#253695">(&#167;9.7)</a> element value <a href="interfaces.html#239527">(&#167;9.6)</a> is always FP-strict, because it is always a compile-time constant <a href="expressions.html#5313">(&#167;15.28)</a>.<p>
<a name="272653"></a>
It follows that an expression is not FP-strict if and only if it is not a compile-time constant expression <em>and</em> it does not appear within any declaration that has the <code>strictfp</code> modifier.<p>
<a name="290065"></a>
Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FP-strict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats. Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.<p>
<a name="290072"></a>
<a name="15.5"></a>
<h2>15.5    Expressions and Run-Time Checks</h2>
<a name="233993"></a>
If the type of an expression is a primitive type, then the value of the expression is of that same primitive type. But if the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than <code>null</code>, is not necessarily known at compile time. There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression. They are as follows:<p>
<ul><a name="79422"></a>
<li>Method invocation <a href="expressions.html#20448">(&#167;15.12)</a>. The particular method used for an invocation <code>o.m(</code>...<code>)</code> is chosen based on the methods that are part of the class or interface that is the type of <code>o</code>. For instance methods, the class of the object referenced by the run-time value of <code>o</code> participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked. (The overriding method may or may not choose to further invoke the original overridden <code>m</code> method.)
<a name="79436"></a>
<li>The <code>instanceof</code> operator <a href="expressions.html#80289">(&#167;15.20.2)</a>. An expression whose type is a reference type may be tested using <code>instanceof</code> to find out whether the class of the object referenced by the run-time value of the expression is assignment compatible <a href="conversions.html#184206">(&#167;5.2)</a> with some other reference type.
<a name="35797"></a>
<li>Casting (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>). The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast. For reference types, this may require a run-time check that throws an exception if the class of the referenced object, as determined at run time, is not assignment &#32;compatible <a href="conversions.html#184206">(&#167;5.2)</a> with the target type.
<a name="35800"></a>
<li>Assignment to an array component of reference type (<a href="arrays.html#11430">&#167;10.10</a>, <a href="expressions.html#239587">&#167;15.13</a>, <a href="expressions.html#322847">&#167;15.26.1</a>). The type-checking rules allow the array type <i>S</i><code>[]</code> to be treated as a subtype of <i>T</i><code>[]</code> if <i>S</i> is a subtype of <i>T</i>, but this requires a run-time check for assignment to an array component, similar to the check performed for a cast.
<a name="79438"></a>
<li>Exception handling <a href="statements.html#79311">(&#167;14.20)</a>. An exception is caught by a <code>catch</code> clause only if the class of the thrown exception object is an <code>instanceof</code> the type of the formal parameter of the <code>catch</code> clause.
</ul><a name="338173"></a>
Situations where the class of an object is not statically known may lead to run-time type errors.<p>
<a name="338174"></a>
In addition, there are situations where the statically known type may not be accurate at run-time. Such situations can arise in a program that gives rise to unchecked warnings. Such warnings are given in response to operations that cannot be statically guaranteed to be safe, and cannot immediately be subjected to dynamic checking because they involve non-reifiable <a href="typesValues.html#112581">(&#167;4.7)</a> types. As a result, dynamic checks later in the course of program execution may detect inconsistencies and result in run-time type errors.<p>
<a name="35847"></a>
 <p>
<a name="338172"></a>
A run-time type error can occur only in these situations:<p>
<ul><a name="79443"></a>
<li>In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast operator (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>); in this case a <code>ClassCastException</code> is thrown.
<a name="338180"></a>
<li>In an implicit, compiler-generated cast introduced to ensure the validity of an operation on a non-reifiable type.
<a name="79444"></a>
<li>In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the actual run-time component type of the array (<a href="arrays.html#11430">&#167;10.10</a>, <a href="expressions.html#239587">&#167;15.13</a>, <a href="expressions.html#322847">&#167;15.26.1</a>); in this case an <code>ArrayStoreException</code> is thrown.
<a name="79445"></a>
<li>When an exception is not caught by any <code>catch</code> handler <a href="exceptions.html#44153">(&#167;11.3)</a>; in this case the thread of control that encountered the exception first invokes the method <code>uncaughtException</code> &#32; for its thread group and then terminates.
</ul><a name="79448"></a>
<a name="15.6"></a>
<h2>15.6    Normal and Abrupt Completion of Evaluation</h2>
<a name="79449"></a>
Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression. If all the steps are carried out without an exception being thrown, the expression is said to <em>complete normally</em>. <p>
<a name="217304"></a>
If, however, evaluation of an expression throws an exception, then the expression is said to <em>complete abruptly</em>. An abrupt completion always has an associated <em>reason</em>, which is always a <code>throw</code> with a given value.<p>
<a name="217294"></a>
Run-time exceptions are thrown by the predefined operators as follows:<p>
<ul><a name="43791"></a>
<li>A class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>, array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>, or string concatenation operator expression <a href="expressions.html#39990">(&#167;15.18.1)</a> throws an <code>OutOfMemoryError</code> if there is insufficient memory available.
<a name="43795"></a>
<li>An array creation expression throws a <code>NegativeArraySizeException</code> if the value of any dimension expression is less than zero <a href="expressions.html#46168">(&#167;15.10)</a>.
<a name="43780"></a>
<li>A field access <a href="expressions.html#41267">(&#167;15.11)</a> throws a <code>NullPointerException</code> if the value of the object reference &#32;expression is <code>null</code>.
<a name="43784"></a>
<li>A method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> that invokes an instance method throws a <code>NullPointerException</code> if the target reference is <code>null</code>.
<a name="43730"></a>
<li>An array access <a href="expressions.html#239587">(&#167;15.13)</a> throws a <code>NullPointerException</code> if the value of the array reference &#32;expression is <code>null</code>.
<a name="43758"></a>
<li>An array access <a href="expressions.html#239587">(&#167;15.13)</a> throws an <code>ArrayIndexOutOfBoundsException</code> if the value &#32;of the array index expression is negative or greater than or equal to the <code>length</code> of the array.
<a name="217340"></a>
<li>A cast <a href="expressions.html#238146">(&#167;15.16)</a> throws a <code>ClassCastException</code> if a cast is found to be impermissible at run time.
<a name="217346"></a>
<li>An integer division <a href="expressions.html#5047">(&#167;15.17.2)</a> or integer remainder <a href="expressions.html#24956">(&#167;15.17.3)</a> operator throws an <code>ArithmeticException</code> if the value of the right-hand operand expression is zero.
<a name="373566"></a>
<li>An assignment to an array component of reference type <a href="expressions.html#322847">(&#167;15.26.1)</a>, a metthod invocation <a href="expressions.html#20448">(&#167;15.12)</a>, a prefix or postfix increment (<a href="expressions.html#292383">&#167;15.14.2</a>, <a href="expressions.html#39547">&#167;15.15.1</a>) or decrement operator (<a href="expressions.html#4987">&#167;15.14.3</a>, <a href="expressions.html#239136">&#167;15.15.2</a>) may all throw an <code>OutOfMemoryError</code> as a result of boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a>.
<a name="234027"></a>
<li>An assignment to an array component of reference type <a href="expressions.html#322847">(&#167;15.26.1)</a> throws an <code>ArrayStoreException</code> when the value to be assigned is not compatible with the component type of the array.
</ul><a name="21217"></a>
A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly. A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly. Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle.<p>
<a name="6969"></a>
If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly. The terms "complete normally" and &#32;"complete abruptly" are also applied to the execution of statements <a href="statements.html#5894">(&#167;14.1)</a>. A &#32;statement may complete abruptly for a variety of reasons, not just because an exception is thrown.<p>
<a name="79456"></a>
If evaluation of an expression requires evaluation of a subexpression, abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.<p>
<a name="4779"></a>
<a name="15.7"></a>
<h2>15.7    Evaluation Order</h2>
<a name="264242"></a>
The Java programming language guarantees that the operands of operators appear to be evaluated in a specific <em>evaluation order</em>, namely, from left to right.<p>
<a name="264247"></a>
<p>It is recommended that code not rely crucially on this specification. Code is usually clearer when each expression contains at most one side effect, as its outermost &#32;operation, and when code does not depend on exactly which exception arises as a consequence of the left-to-right evaluation of expressions.</p>
<a name="18498"></a>
<a name="15.7.1"></a>
<h3>15.7.1    Evaluate Left-Hand Operand First</h3>
<a name="264252"></a>
The left-hand operand of a binary operator appears to be fully evaluated before any part of the right-hand operand is evaluated. For example, if the left-hand operand contains an assignment to a variable and the right-hand operand contains a reference to that same variable, then the value produced by the reference will reflect the fact that the assignment occurred first.<p>
<a name="18540"></a>
<p>Thus:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int <i>i</i> = 2;
                int j = (i=3) * i;
                System.out.println(j);
        }
}
</pre></blockquote><a name="18539"></a>
prints:<p>
<blockquote><pre><code>9
</code></pre></blockquote><a name="35994"></a>
It is not permitted for it to print <code>6</code> instead of <code>9</code>.<p>
<a name="240786"></a>
<p>If the operator is a compound-assignment operator <a href="expressions.html#5304">(&#167;15.26.2)</a>, then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied combining operation. So, for example, the test program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int a = 9;
                a += (a = 3);                                                                   // first example
                System.out.println(a);
                int b = 9;
                b = b + (b = 3);                                                                        // second example
                System.out.println(b);
        }
}
</pre></blockquote><a name="18725"></a>
prints:<p>
<blockquote><pre>12
12
</pre></blockquote><a name="264257"></a>
because the two assignment statements both fetch and remember the value of the left-hand operand, which is <code>9</code>, before the right-hand operand of the addition is evaluated, thereby setting the variable to <code>3</code>. It is not permitted for either example to produce the result <code>6</code>. Note that both of these examples have unspecified behavior in C, according to the ANSI/ISO standard.<p>
<a name="264262"></a>
If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.<p>
<a name="18857"></a>
<p>Thus, the test program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int j = 1;
                try {
                        int <i>i</i> = forgetIt() / (j = 2);
                } catch (Exception e) {
                        System.out.println(e);
                        System.out.println("Now j = " + j);
                }
        }
        static int forgetIt() throws Exception {
                throw new Exception("I'm outta here!");
        }
}
</pre></blockquote><a name="18858"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: I'm outta here!
Now j = 1
</pre></blockquote><a name="264267"></a>
That is, the left-hand operand <code>forgetIt()</code> of the operator <code>/</code> throws an exception before the right-hand operand is evaluated and its embedded assignment of <code>2</code> to <code>j</code> occurs.<p>
<a name="18740"></a>
<a name="15.7.2"></a>
<h3>15.7.2    Evaluate Operands before Operation</h3>
<a name="18749"></a>
The Java programming language also guarantees that every operand of an operator (except the conditional operators <code>&amp;&amp;</code>, <code>||</code>, and <code>?</code> <code>:</code>) appears to be fully evaluated before any part of the operation itself is performed.<p>
<a name="264272"></a>
If the binary operator is an integer division <code>/</code> <a href="expressions.html#5047">(&#167;15.17.2)</a> or integer remainder <code>%</code> <a href="expressions.html#24956">(&#167;15.17.3)</a>, then its execution may raise an <code>ArithmeticException</code>, but this exception is thrown only after both operands of the binary operator have been evaluated and only if these evaluations completed normally.<p>
<a name="36160"></a>
<p>So, for example, the program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int divisor = 0;
                try {
                        int <i>i</i> = 1 / (divisor * loseBig());
                } catch (Exception e) {
                        System.out.println(e);
                }
        }
        static int loseBig() throws Exception {
                throw new Exception("Shuffle off to Buffalo!");
        }
}
</pre></blockquote><a name="36174"></a>
always prints:<p>
<blockquote><pre>java.lang.Exception: Shuffle off to Buffalo!
</pre></blockquote><a name="36176"></a>
and not:<p>
<blockquote><pre>java.lang.ArithmeticException: / by zero
</pre></blockquote><a name="264277"></a>
since no part of the division operation, including signaling of a divide-by-zero exception, may appear to occur before the invocation of <code>loseBig</code> completes, even though the implementation may be able to detect or infer that the division operation would certainly result in a divide-by-zero exception.<p>
<a name="385809"></a>
<p>
<a name="23213"></a>
<a name="15.7.3"></a>
<h3>15.7.3    Evaluation Respects Parentheses and Precedence</h3>
<a name="23217"></a>
Java programming language implementations must respect the order of evaluation as indicated explicitly by parentheses and implicitly by operator precedence. An implementation may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in <a href="memory.html#61803">&#167;17</a>), for all possible computational values that might be involved.<p>
<a name="23218"></a>
In the case of floating-point calculations, this rule applies also for infinity and not-a-number (NaN) values. For example, <code>!(x&lt;y)</code> may not be rewritten as <code>x&gt;=y</code>, because these expressions have different values if either <code>x</code> or <code>y</code> is NaN or both are NaN.<p>
<a name="264283"></a>
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered. <p>
<a name="264281"></a>
<p>For example, it is not correct for a Java compiler to rewrite <code>4.0*x*0.5</code> as <code>2.0*x</code>; while roundoff happens not to be an issue here, there are large values of <code>x</code> for which the first expression produces infinity (because of overflow) but the second expression produces a finite result.</p>
<a name="385810"></a>
<p></p>
<a name="238102"></a>
<p>So, for example, the test program:</p>
<blockquote><pre>strictfp class Test {
        public static void main(String[] args) {
                double d = 8e+307;
                System.out.println(4.0 * d * 0.5);
                System.out.println(2.0 * d);
        }
}
</pre></blockquote><a name="23231"></a>
prints:<p>
<blockquote><pre>Infinity
1.6e+308
</pre></blockquote><a name="264288"></a>
because the first expression overflows and the second does not.<p>
<a name="264295"></a>
In contrast, integer addition and multiplication <em>are</em> provably associative in the Java programming language.<p>
<a name="264300"></a>
<p>For example <code>a+b+c</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are local variables (this simplifying assumption avoids issues involving multiple threads and <code>volatile</code> variables), will always produce the same answer whether evaluated as <code>(a+b)+c</code> or <code>a+(b+c)</code>; if the expression <code>b+c</code> occurs nearby in the code, a smart compiler may be able to use this common subexpression.</p>
<a name="23789"></a>
<a name="15.7.4"></a>
<h3>15.7.4    Argument Lists are Evaluated Left-to-Right</h3>
<a name="264305"></a>
In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas. Each argument expression appears to be fully evaluated before any part of any argument expression to its right.<p>
<a name="23791"></a>
<p>Thus:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                String s = "going, ";
                print3(s, s, s = "gone");
        }
        static void print3(String a, String b, String c) {
                System.out.println(a + b + c);
        }
}
</pre></blockquote><a name="23800"></a>
always prints:<p>
<blockquote><pre>going, going, gone
</pre></blockquote><a name="264310"></a>
because the assignment of the string <code>"gone"</code> to <code>s</code> occurs after the first two arguments to <code>print3</code> have been evaluated.<p>
<a name="264315"></a>
If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.<p>
<a name="23804"></a>
<p>Thus, the example:</p>
<blockquote><pre>class Test {
        static int id;
        public static void main(String[] args) {
                try {
                        test(id = 1, oops(), id = 3);
                } catch (Exception e) {
                        System.out.println(e + ", id=" + id);
                }
        }
        static int oops() throws Exception {
                throw new Exception("oops");
        }
        static int test(int a, int b, int c) {
                return a + b + c;
        }
}
</pre></blockquote><a name="23821"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: oops, id=1
</pre></blockquote><a name="264320"></a>
because the assignment of <code>3</code> to <code>id</code> is not executed.<p>
<a name="23451"></a>
<a name="15.7.5"></a>
<h3>15.7.5    Evaluation Order for Other Expressions</h3>
<a name="23452"></a>
The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified. See, specifically, the detailed explanations of evaluation order for the following kinds of expressions:<p>
<ul><a name="249837"></a>
<li>class instance creation expressions <a href="expressions.html#251881">(&#167;15.9.4)</a>
<a name="249842"></a>
<li>array creation expressions <a href="expressions.html#23605">(&#167;15.10.1)</a>
<a name="249846"></a>
<li>method invocation expressions <a href="expressions.html#45677">(&#167;15.12.4)</a>
<a name="23491"></a>
<li>array access expressions <a href="expressions.html#23958">(&#167;15.13.1)</a>
<a name="240795"></a>
<li>assignments involving array components <a href="expressions.html#5281">(&#167;15.26)</a>
</ul><a name="23302"></a>
<a name="15.8"></a>
<h2>15.8    Primary Expressions</h2>
<a name="36225"></a>
Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, class literals, field accesses, method invocations, and array accesses. A parenthesized expression is also treated syntactically as a primary expression.<p>
<blockquote><pre>
<em>
Primary:
        PrimaryNoNewArray
        ArrayCreationExpression

PrimaryNoNewArray:
        Literal
        Type . class</em>
        void <em>. class
        this
        ClassName.this</em>
        ( <em>Expression</em> )<em>
        ClassInstanceCreationExpression
        FieldAccess
        MethodInvocation
        ArrayAccess
        </em>
</pre></blockquote><a name="224125"></a>
<a name="15.8.1"></a>
<h3>15.8.1    Lexical Literals</h3>
<a name="36407"></a>
A literal <a href="lexical.html#48272">(&#167;3.10)</a> denotes a fixed, unchanging value.<p>
<a name="36387"></a>
The following production from <a href="lexical.html#48272">&#167;3.10</a> is repeated here for convenience:<p>
<blockquote><pre>
<em>
Literal:
        IntegerLiteral
        FloatingPointLiteral
        BooleanLiteral
        CharacterLiteral
        StringLiteral
        NullLiteral
        </em>
</pre></blockquote><a name="36400"></a>
The type of a literal is determined as follows:<p>
<ul><a name="43814"></a>
<li>The type of an integer literal that ends with <code>L</code> or <code>l</code> is <code>long</code>; the type of any other integer literal is <code>int</code>.
<a name="251041"></a>
<li>The type of a floating-point literal that ends with <code>F</code> or <code>f</code> is <code>float</code> and its value must be an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>. The type of any other floating-point literal is <code>double</code> and its value must be an element of the double value set.
<a name="36429"></a>
<li>The type of a boolean literal is <code>boolean</code>.
<a name="36436"></a>
<li>The type of a character literal is <code>char</code>.
<a name="36437"></a>
<li>The type of a string literal is <code>String</code>.
<a name="250692"></a>
<li>The type of the null literal <code>null</code> is the null type; its value is the null reference.
</ul><a name="250775"></a>
Evaluation of a lexical literal always completes normally.<p>
<a name="385811"></a>
<p>
<a name="251530"></a>
<a name="15.8.2"></a>
<h3>15.8.2    Class Literals </h3>
<a name="250782"></a>
A <i>class literal</i> is an expression consisting of the name of a class, interface, array, or primitive type, or the pseudo-type <code>void</code>, followed by a `.' and the token <code>class</code>. The type of a class literal, <i>C</i>.<code>Class</code>, where <i>C</i> is the name of a class, interface or array type, is <code>Class</code>&lt;<i>C</i>&gt;. If <i>p</i> is the name of a primitive type, let <i>B</i> be the type of an expression of type <i>p</i> after boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a>. Then the type of <i>p</i>.<code>class</code> is <code>Class</code>&lt;<i>B</i>&gt;. The type of <code>void.class</code> is <code>Class&lt;Void&gt;</code>.<p>
<a name="322932"></a>
A class literal evaluates to the <code>Class</code> object for the named type (or for void) as defined by the defining class loader of the class of the current instance. <p>
<a name="322906"></a>
It is a compile time error if any of the following occur:<p>
<ul><a name="322938"></a>
<li>The named type is a type variable <a href="typesValues.html#108850">(&#167;4.4)</a> or a parameterized type <a href="typesValues.html#112898">(&#167;4.5)</a> or an array whose element type is a type variable or parameterized type.
<a name="322945"></a>
<li>The named type does not denote a type that is accessible <a href="names.html#104285">(&#167;6.6)</a> and in scope <a href="names.html#103228">(&#167;6.3)</a> at the point where the class literal appears.
</ul><a name="385812"></a>
<p>
<a name="251519"></a>
<a name="15.8.3"></a>
<h3>15.8.3    this </h3>
<a name="251520"></a>
The keyword <code>this</code> may be used only in the body of an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class. If it appears anywhere else, a compile-time error occurs.<p>
<a name="264342"></a>
When used as a primary expression, the keyword <code>this</code> denotes a value that is a reference to the object for which the instance method was invoked <a href="expressions.html#20448">(&#167;15.12)</a>, or to the object being constructed. The type of <code>this</code> is the class <i>C</i> within which the keyword <code>this</code> occurs. At run time, the class of the actual object referred to may be the class <i>C</i> or any subclass of <i>C</i>.<p>
<a name="31984"></a>
<p>In the example:</p>
<blockquote><pre>class IntVector {
        int[] v;
        boolean equals(IntVector other) {
                if (this == other)
                        return true;
                if (v.length != other.v.length)
                        return false;
                for (int <i>i</i> = 0; <i>i</i> &lt; v.length; i++)
                        if (v[i] != other.v[i])
                                return false;
                return true;
        }
}
</pre></blockquote><a name="264347"></a>
the class <code>IntVector</code> implements a method <code>equals</code>, which compares two vectors. If the <code>other</code> vector is the same vector object as the one for which the <code>equals</code> method was invoked, then the check can skip the length and value comparisons. The <code>equals</code> method implements this check by comparing the reference to the <code>other</code> object to <code>this</code>.<p>
<a name="20077"></a>
The keyword <code>this</code> is also used in a special explicit constructor invocation statement, which can appear at the beginning of a constructor body <a href="classes.html#78435">(&#167;8.8.7)</a>.<p>
<a name="251603"></a>
<a name="15.8.4"></a>
<h3>15.8.4    Qualified this</h3>
<a name="250907"></a>
Any lexically enclosing instance can be referred to by explicitly qualifying the keyword this.<p>
<a name="250970"></a>
Let <i>C</i> be the class denoted by <i>ClassName</i>. Let <i>n</i> be an integer such that <i>C</i> is the <i>n</i>th lexically enclosing class of the class in which the qualified this expression appears. The value of an expression of the form <i>ClassName</i>.<code>this</code> is the <i>n</i>th lexically enclosing instance of <code>this</code> <a href="classes.html#295574">(&#167;8.1.3)</a>. The type of the expression is <i>C</i>. It is a compile-time error if the current class is not an inner class of class <i>C</i> or <i>C</i> itself.<p>
<a name="236822"></a>
<a name="15.8.5"></a>
<h3>15.8.5    Parenthesized Expressions</h3>
<a name="236823"></a>
A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression. If the contained expression denotes a variable then the parenthesized expression also denotes that variable. <p>
<a name="249265"></a>
The use of parentheses only effects the order of evaluation, with one fascinating exception. <p>
<a name="385477"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="385479"></a>
 Consider the case if the smallest possible negative value of type <code>long</code>. This value, 9223372036854775808L, is allowed only as an operand of the unary minus operator <a href="lexical.html#251110">(&#167;3.10.1)</a>. Therefore, enclosing it in parentheses, as in -(9223372036854775808L) causes a compile time error.<p>
 <hr>
<a name="385480"></a>
<a name="385481"></a>
 <p>
<a name="385478"></a>
In particular, the presence or absence of parentheses around an expression does not (except for the case noted above) affect in any way:<p>
<ul><a name="292506"></a>
<li>the choice of value set <a href="typesValues.html#9208">(&#167;4.2.3)</a> for the value of an expression of type <code>float</code> or <code>double</code>.
<a name="292519"></a>
<li>whether a variable is definitely assigned, definitely assigned when true, definitely assigned when false, definitely unassigned, definitely unassigned when true, or definitely unassigned when false (<a href="defAssign.html#25979">&#167;16</a>).
</ul><a name="41147"></a>
<a name="15.9"></a>
<h2>15.9    Class Instance Creation Expressions</h2>
<a name="36595"></a>
A class instance creation expression is used to create new objects that are instances of classes.<p>
<blockquote><pre>
<em>
ClassInstanceCreationExpression:
</em>   new<em> TypeArguments<sub>opt</sub> ClassOrInterfaceType </em>(<em> ArgumentList<sub><i>opt</i></sub> </em>)<em>
ClassBodyopt
        Primary. </em>new <em>TypeArguments<sub>opt</sub> Identifier TypeArguments<sub>opt</sub> </em>(<em>
ArgumentList<sub>opt</sub> </em>)<em> ClassBody<sub>opt</sub>

ArgumentList:
        Expression
        ArgumentList , Expression
        </em>
</pre></blockquote><a name="252035"></a>
A class instance creation expression specifies a class to be instantiated, possibly followed by type arguments (if the class being instantiated is generic <a href="classes.html#299360">(&#167;8.1.2)</a>), followed by (a possibly empty) list of actual value arguments to the constructor. It is also possible to pass explicit type arguments to the constructor itself (if it is a generic constructor <a href="classes.html#244611">(&#167;8.8.4)</a>). The type arguments to the constructor immediately follow the keyword new. It is a compile-time error if any of the type arguments used in a class instance creation expression are wildcard type arguments <a href="typesValues.html#107353">(&#167;4.5.1)</a>. Class instance creation expressions have two forms: <p>
<ul><a name="253146"></a>
<li><i>Unqualified class instance creation expressions </i>begin with the keyword <code>new</code>. An unqualified class instance creation expression may be used to create an instance of a class, regardless of whether the class is a top-level <a href="packages.html#26783">(&#167;7.6)</a>, member (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), local <a href="statements.html#247766">(&#167;14.3)</a> or anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a>.
<a name="253111"></a>
<li><i>Qualified class instance creation expressions </i>begin with a <i>Primary</i>. A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses.
</ul><a name="386993"></a>
A class instance creation expression can throw an exception type <i>E</i> iff either:<p>
<ul><a name="386994"></a>
<li>The expression is a qualified class instance creation expression and the qualifying expression can throw <i>E</i>; or
<a name="386995"></a>
<li>Some expression of the argument list can throw <i>E</i>; or
<a name="386996"></a>
<li><i>E</i> is listed in the throws clause of the type of the constructor that is invoked; or
<a name="386997"></a>
<li>The class instance creation expression includes a <i>ClassBody</i>, and some instnance initializer block or instance variable initializer expression in the <i>ClassBody</i> can throw <i>E</i>.
</ul><a name="252044"></a>
Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an <i>anonymous class</i> <a href="expressions.html#252986">(&#167;15.9.5)</a> and creates an instance of it. <p>
<a name="386051"></a>
We say that a class is <i>instantiated</i> when an instance of the class is created by a class instance creation expression. Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created instance are, what constructor should be invoked to create the new instance and what arguments should be passed to that constructor.<p>
<a name="386053"></a>
<a name="15.9.1"></a>
<h3>15.9.1    Determining the Class being Instantiated</h3>
<a name="386055"></a>
If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class. Then:<p>
<ul><a name="253179"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then let <i>T</i> be the <i>ClassOrInterfaceType</i> after the <i>new</i> token. It is a compile-time error if the class or interface named by <i>T</i> is not accessible <a href="names.html#104285">(&#167;6.6)</a> or if <i>T</i> is an enum type <a href="classes.html#301020">(&#167;8.9)</a>. If <i>T</i> denotes a class, then an anonymous direct subclass of the class named by <i>T</i> is declared. It is a compile-time error if the class denoted by <i>T</i> is a <code>final</code> class. If <i>T</i> denotes an interface then an anonymous direct subclass of <code>Object</code> that implements the interface named by <i>T</i> is declared. In either case, the body of the subclass is the <i>ClassBody</i> given in the class instance creation expression. The class being instantiated is the anonymous subclass.
<a name="253194"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. Let <i>T</i> be the name of the <i>Identifier</i> after the <i>new</i> token. It is a compile-time error if <i>T</i> is not the simple name <a href="names.html#31692">(&#167;6.2)</a> of an accessible <a href="names.html#104285">(&#167;6.6)</a> non-<code>final</code> inner class <a href="classes.html#295574">(&#167;8.1.3)</a> that is a member of the compile-time type of the <i>Primary</i>. It is also a compile-time error if <i>T</i> is ambiguous <a href="classes.html#246026">(&#167;8.5)</a> or if <i>T</i> denotes an enum type. An anonymous direct subclass of the class named by <i>T</i> is declared. The body of the subclass is the <i>ClassBody</i> given in the class instance creation expression. The class being instantiated is the anonymous subclass.
</ul><a name="253236"></a>
If a class instance creation expression does not declare an anonymous class, then:<p>
<ul><a name="253239"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then the <em>ClassOrInterfaceType </em>must denote a class that is accessible <a href="names.html#104285">(&#167;6.6)</a> and is not an enum type and not <code>abstract</code>, or a compile-time error occurs. In this case, the class being instantiated is the class denoted by <i>ClassOrInterfaceType</i>.
<a name="253242"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. It is a compile-time error if <i>Identifier</i> is not the simple name <a href="names.html#31692">(&#167;6.2)</a> of an accessible <a href="names.html#104285">(&#167;6.6)</a> non-<code>abstract</code> inner class <a href="classes.html#295574">(&#167;8.1.3)</a> <i>T</i> that is a member of the compile-time type of the <i>Primary</i>. It is also a compile-time error if <i>Identifier</i> is ambiguous <a href="classes.html#246026">(&#167;8.5)</a>, or if <i>Identifier</i> denotes an enum type <a href="classes.html#301020">(&#167;8.9)</a>. The class being instantiated is the class denoted by <i>Identifier</i>.
</ul><a name="253435"></a>
The type of the class instance creation expression is the class type being instantiated.<p>
<a name="253028"></a>
<a name="15.9.2"></a>
<h3>15.9.2    Determining Enclosing Instances</h3>
<a name="253034"></a>
Let <i>C</i> be the class being instantiated, and let <i>i</i> the instance being created. If <i>C</i> is an inner class then <i>i</i> may have an immediately enclosing instance. The immediately enclosing instance of <i>i</i> <a href="classes.html#295574">(&#167;8.1.3)</a> is determined as follows:<p>
<ul><a name="253038"></a>
<li>If <i>C</i> is an anonymous class, then:
<ul>
<a name="254032"></a>
<li>If the class instance creation expression occurs in a static context <a href="classes.html#295574">(&#167;8.1.3)</a>, then <i>i</i> has no immediately enclosing instance.
<a name="254034"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> is this.
</ul>
<a name="254064"></a>
<li>If <i>C</i> is a local class <a href="statements.html#247766">(&#167;14.3)</a>, then let <i>O</i> be the innermost lexically enclosing class of <i>C</i>. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. Then:
<ul>
<a name="254067"></a>
<li>If <i>C</i> occurs in a static context, then <i>i</i> has no immediately enclosing instance.
<a name="267182"></a>
<li>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254059"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> is the <i>n</i>th lexically enclosing instance of <code>this</code> <a href="classes.html#295574">(&#167;8.1.3)</a>.
</ul>
<a name="253336"></a>
<li>Otherwise, <i>C</i> is an inner member class <a href="classes.html#246026">(&#167;8.5)</a>.
<ul>
<a name="253064"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then:
<ul>
<a name="253350"></a>
<li>If the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254073"></a>
<li>Otherwise, if <i>C</i> is a member of an enclosing class then let <i>O</i> be the innermost lexically enclosing class of which <i>C</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. The immediately enclosing instance of <i>i</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
<a name="253408"></a>
<li>Otherwise, a compile-time error occurs.
</ul>
<a name="253340"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. The immediately enclosing instance of <i>i</i> is the object that is the value of the <i>Primary</i> expression.
</ul>
</ul><a name="253300"></a>
In addition, if <i>C</i> is an anonymous class, and the direct superclass of <i>C</i>, <i>S</i>, is an inner class then <i>i</i> may have an immediately enclosing instance with respect to <i>S</i> which is determined as follows:<p>
<ul><a name="253304"></a>
<li>If <i>S</i> is a local class <a href="statements.html#247766">(&#167;14.3)</a>, then let <i>O</i> be the innermost lexically enclosing class of S. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. Then:
<ul>
<a name="267205"></a>
<li>If <i>S</i> occurs within a static context, then <i>i</i> has no immediately enclosing instance with respect to <i>S</i>.
<a name="267208"></a>
<li>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254087"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
</ul>
<a name="253365"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.html#246026">(&#167;8.5)</a>.
<ul>
<a name="253366"></a>
<li>If the class instance creation expression is an unqualified class instance creation expression, then:
<ul>
<a name="253367"></a>
<li>If the class instance creation expression occurs in a static context, then a compile-time error occurs.
<a name="254096"></a>
<li>Otherwise, if <i>S</i> is a member of an enclosing class then let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of the class in which the class instance creation expression appears. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
<a name="253368"></a>
<li>Otherwise, a compile-time error occurs.
</ul>
<a name="253369"></a>
<li>Otherwise, the class instance creation expression is a qualified class instance creation expression. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the object that is the value of the Primary expression.
</ul>
</ul><a name="253029"></a>
<a name="15.9.3"></a>
<h3>15.9.3    Choosing the Constructor and its Arguments</h3>
<a name="253097"></a>
Let <i>C</i> be the class type being instantiated. To create an instance of <i>C</i>, <i>i</i>, a constructor of <i>C</i> is chosen at compile-time by the following rules:<p>
<ul><a name="253098"></a>
<li>First, the actual arguments to the constructor invocation are determined.
<ul>
<a name="253099"></a>
<li>If <i>C</i> is an anonymous class, and the direct superclass of <i>C</i>, <i>S</i>, is an inner class, then:
<ul>
<a name="254143"></a>
<li>If the <i>S</i> is a local class and <i>S</i> occurs in a static context, then the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
<a name="254144"></a>
<li>Otherwise, the immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the first argument to the constructor, followed by the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
</ul>
<a name="253100"></a>
<li>Otherwise the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
</ul>
<a name="253101"></a>
<li>Once the actual arguments have been determined, they are used to select a constructor of <i>C</i>, using the same rules as for method invocations <a href="expressions.html#20448">(&#167;15.12)</a>. As in method invocations, a compile-time method matching error results if there is no unique most-specific constructor that is both applicable and accessible.
</ul><a name="253105"></a>
Note that the type of the class instance creation expression may be an anonymous class type, in which case the constructor being invoked is an anonymous constructor.<p>
<a name="251881"></a>
<a name="15.9.4"></a>
<h3>15.9.4    Run-time Evaluation of Class Instance Creation Expressions</h3>
<a name="36655"></a>
At run time, evaluation of a class instance creation expression is as follows.<p>
<a name="265442"></a>
First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.<p>
<a name="23746"></a>
Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an <code>OutOfMemoryError</code> <a href="expressions.html#36687">(&#167;15.9.6)</a>.<p>
<a name="23753"></a>
The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its default value <a href="typesValues.html#96595">(&#167;4.12.5)</a>.<p>
<a name="36584"></a>
Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.<p>
<a name="36513"></a>
Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements <a href="classes.html#41652">(&#167;8.8)</a> and is described in detail in <a href="execution.html#44670">&#167;12.5</a>.<p>
<a name="23747"></a>
The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.<p>
<a name="252986"></a>
<a name="15.9.5"></a>
<h3>15.9.5    Anonymous Class Declarations</h3>
<a name="252987"></a>
An anonymous class declaration is automatically derived from a class instance creation expression by the compiler.<p>
<a name="252992"></a>
An anonymous class is never <code>abstract</code> <a href="classes.html#34944">(&#167;8.1.1.1)</a>. An anonymous class is always an inner class <a href="classes.html#295574">(&#167;8.1.3)</a>; it is never <code>static</code> (<a href="classes.html#21613">&#167;8.1.1</a>, <a href="classes.html#246853">&#167;8.5.2</a>). An anonymous class is always implicitly <code>final</code> <a href="classes.html#54727">(&#167;8.1.1.2)</a>.<p>
<a name="253002"></a>
<a name="15.9.5.1"></a>
<h4>15.9.5.1    Anonymous Constructors</h4>
<a name="253003"></a>
An anonymous class cannot have an explicitly declared constructor. Instead, the compiler must automatically provide an <i>anonymous constructor</i> for the anonymous class. The form of the anonymous constructor of an anonymous class <i>C</i> with direct superclass <i>S</i> is as follows:<p>
<ul><a name="253005"></a>
<li>If <i>S</i> is not an inner class, or if <i>S</i> is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression in which <i>C</i> is declared. The actual arguments to the class instance creation expression are used to determine a constructor cs of <i>S</i>, using the same rules as for method invocations <a href="expressions.html#20448">(&#167;15.12)</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <i>cs</i>.
<a name="290200"></a>
<p>The body of the constructor consists of an explicit constructor invocation <a href="classes.html#229267">(&#167;8.8.7.1)</a> of the form <code>super(...)</code>, where the actual arguments are the formal parameters of the constructor, in the order they were declared.</p>
<a name="253006"></a>
<li>Otherwise, the first formal parameter of the constructor of <i>C</i> represents the value of the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. The type of this parameter is the class type that immediately encloses the declaration of <i>S</i>. The constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class. The <i>n</i>th formal parameter e corresponds to the <i>n</i>-1st actual argument. The actual arguments to the class instance creation expression are used to determine a constructor <i>cs</i> of <i>S</i>, using the same rules as for method invocations <a href="expressions.html#20448">(&#167;15.12)</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <i>cs</i>. The body of the constructor consists of an explicit constructor invocation <a href="classes.html#229267">(&#167;8.8.7.1)</a> of the form <i>o</i>.<code>super(...)</code>, where <i>o</i> is the first formal parameter of the constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared.
</ul><a name="264352"></a>
In all cases, the <code>throws</code> clause of an anonymous constructor must list all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.<p>
<a name="289502"></a>
Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor <i>cs</i>). This does not, in itself, cause any errors at either compile time or run time.<p>
<a name="36687"></a>
<a name="15.9.6"></a>
<h3>15.9.6    Example: Evaluation Order and Out-of-Memory Detection</h3>
<a name="36695"></a>
If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. This check occurs before any argument expressions are evaluated.<p>
<a name="36696"></a>
<p>So, for example, the test program:</p>
<blockquote><pre>class List {
        int value;
        List next;
        static List head = new List(0);
        List(int n) { value = n; next = head; head = this; }
}
class Test {
        public static void main(String[] args) {
                int id = 0, oldid = 0;
                try {
                        for (;;) {
                                ++id;
                                new List(oldid = id);
                        }
                } catch (Error e) {
                        System.out.println(e + ", " + (oldid==id));
                }
        }
}
</pre></blockquote><a name="36716"></a>
prints:<p>
<blockquote><pre>java.lang.OutOfMemoryError: List, false
</pre></blockquote><a name="36788"></a>
because the out-of-memory condition is detected before the argument expression <code>oldid</code> <code>=</code> <code>id</code> is evaluated.<p>
<a name="264357"></a>
<p>Compare this to the treatment of array creation expressions <a href="expressions.html#46168">(&#167;15.10)</a>, for which the out-of-memory condition is detected after evaluation of the dimension expressions <a href="expressions.html#36736">(&#167;15.10.3)</a>.</p>
<a name="46168"></a>
<a name="15.10"></a>
<h2>15.10    Array Creation Expressions</h2>
<a name="46169"></a>
An array instance creation expression is used to create new arrays <a href="arrays.html#27803">(&#167;10)</a>.<p>
<blockquote><pre>
<em>
ArrayCreationExpression:
</em>   new<em> PrimitiveType DimExprs Dims<sub><i>opt
        </i></sub></em>new <em>ClassOrInterfaceType DimExprs Dims<sub><i>opt
</i></sub>      </em>new<em> PrimitiveType Dims ArrayInitializer
        </em>new<em> ClassOrInterfaceType Dims ArrayInitializer
        </em>
</pre></blockquote><a name="250757"></a>
<p>
<blockquote><pre>
<em>
DimExprs:
        DimExpr
        DimExprs DimExpr

DimExpr:
        </em>[<em> Expression </em>]<em>

Dims:
        </em>[ ]<em>
        Dims </em>[ ]
</pre></blockquote><a name="224310"></a>
An array creation expression creates an object that is a new array whose elements are of the type specified by the <em>PrimitiveType</em> or <i>ClassOrInterfaceType</i>. It is a compile-time error if the <i>ClassOrInterfaceType</i> does not denote a reifiable type <a href="typesValues.html#112581">(&#167;4.7)</a>. Otherwise, the <i>ClassOrInterfaceType</i> may name any named reference type, even an <code>abstract</code> class type <a href="classes.html#34944">(&#167;8.1.1.1)</a> or an interface type <a href="interfaces.html#238678">(&#167;9)</a>. <p>
<a name="319111"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 The rules above imply that the element type in an array creation expression cannot be a parameterized type, other than an unbounded wildcard.<p>
 <hr>
<a name="316745"></a>
 <p>
<a name="321991"></a>
The type of the creation expression is an array type that can denoted by a copy of the creation expression from which the <code>new</code> keyword and every <em>DimExpr</em> expression and array initializer have been deleted.<p>
<a name="264361"></a>
<p>For example, the type of the creation expression:</p>
<blockquote><pre>new double[3][3][]
</pre></blockquote><a name="224312"></a>
is:<p>
<blockquote><pre>double[][][]
</pre></blockquote><a name="23548"></a>
The type of each dimension expression within a <em>DimExpr</em> must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to an integral type, or a compile-time error occurs. Each expression undergoes unary numeric promotion <a href="conversions.html#203523">(&#167;)</a>. The promoted type must be <code>int</code>, or a compile-time error occurs; this means, specifically, that the type of a dimension expression must not be <code>long</code>.<p>
<a name="260981"></a>
If an array initializer is provided, the newly allocated array will be initialized with the values provided by the array initializer as described in <a href="arrays.html#11358">&#167;10.6</a>.<p>
<a name="23605"></a>
<a name="15.10.1"></a>
<h3>15.10.1    Run-time Evaluation of Array Creation Expressions</h3>
<a name="36668"></a>
At run time, evaluation of an array creation expression behaves as follows. If there are no dimension expressions, then there must be an array initializer. The value of the array initializer is the value of the array creation expression. Otherwise:<p>
<a name="23552"></a>
First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.<p>
<a name="23543"></a>
Next, the values of the dimension expressions are checked. If the value of any <em>DimExpr</em> expression is less than zero, then an <code>NegativeArraySizeException</code> is thrown.<p>
<a name="36922"></a>
Next, space is allocated for the new array. If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an <code>OutOfMemoryError</code>.<p>
<a name="23658"></a>
Then, if a single <em>DimExpr</em> appears, a single-dimensional array is created of the specified length, and each component of the array is initialized to its default value <a href="typesValues.html#96595">(&#167;4.12.5)</a>.<p>
<a name="264375"></a>
If an array creation expression contains <em>N</em> <em>DimExpr</em> expressions, then it effectively executes a set of nested loops of depth <i>N</i>-1 to create the implied arrays of arrays. <p>
<a name="264373"></a>
<p>For example, the declaration:</p>
<blockquote><pre><code>float[][] matrix = new float[3][3];
</code></pre></blockquote><a name="23642"></a>
is equivalent in behavior to:<p>
<blockquote><pre>float[][] matrix = new float[3][];
for (int d = 0; d &lt; matrix.length; d++)
        matrix[d] = new float[3];
</pre></blockquote><a name="23645"></a>
and:<p>
<blockquote><pre>Age[][][][][] Aquarius = new Age[6][10][8][12][];
</pre></blockquote><a name="23647"></a>
is equivalent to:<p>
<blockquote><pre>Age[][][][][] Aquarius = new Age[6][][][][];
for (int d1 = 0; d1 &lt; Aquarius.length; d1++) {
        Aquarius[d1] = new Age[10][][][];
        for (int d2 = 0; d2 &lt; Aquarius[d1].length; d2++) {
                Aquarius[d1][d2] = new Age[8][][];
                for (int d3 = 0; d3 &lt; Aquarius[d1][d2].length; d3++) {
                        Aquarius[d1][d2][d3] = new Age[12][];
                }
        }
}
</pre></blockquote><a name="36995"></a>
with <i>d,</i> <i>d1</i>, <i>d2</i> and <i>d3</i> replaced by names that are not already locally declared. Thus, a single <code>new</code> expression actually creates one array of length 6, 6 arrays of length 10, 6 x 10 = 60 arrays of length 8, and 6 x 10 x 8 = 480 arrays of length 12. This example leaves the fifth dimension, which would be arrays containing the actual array elements (references to <code>Age</code> objects), initialized only to null references. These arrays can be filled in later by other code, such as:<p>
<blockquote><pre>Age[] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius[1][9][6][9] = Hair;
</pre></blockquote>
<a name="264386"></a>
<p>A multidimensional array need not have arrays of the same length at each level. </p>
<a name="264384"></a>
<p>Thus, a triangular matrix may be created by:</p>
<blockquote><pre>
float triang[][] = new float[100][];
for (int <i>i</i> = 0; <i>i</i> &lt; triang.length; i++)
        triang[i] = new float[i+1];
</pre></blockquote><a name="286280"></a>
<a name="15.10.2"></a>
<h3>15.10.2    Example: Array Creation Evaluation Order</h3>
<a name="264396"></a>
In an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>, there may be one or more dimension expressions, each within brackets. Each dimension expression is fully evaluated before any part of any dimension expression to its right.<p>
<a name="23510"></a>
<p>Thus:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int <i>i</i> = 4;
                int ia[][] = new int[i][i=3];
                System.out.println(
                        "[" + ia.length + "," + ia[0].length + "]");
        }
}
</pre></blockquote><a name="23519"></a>
prints:<p>
<blockquote><pre>[4,3]
</pre></blockquote><a name="23521"></a>
because the first dimension is calculated as <code>4</code> before the second dimension expression sets <code>i</code> to <code>3</code>.<p>
<a name="23522"></a>
<p>If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated. Thus, the example: </p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int[][] a = { { 00, 01 }, { 10, 11 } };
                int <i>i</i> = 99;
                try {
                        a[val()][i = 1]++;
                } catch (Exception e) {
                        System.out.println(e + ", i=" + i);
                }
        }
        static int val() throws Exception {
                throw new Exception("unimplemented");
        }
}
</pre></blockquote><a name="23536"></a>
prints:<p>
<blockquote><pre>java.lang.Exception: unimplemented, i=99
</pre></blockquote><a name="23538"></a>
because the embedded assignment that sets <code>i</code> to <code>1</code> is never executed.<p>
<a name="36736"></a>
<a name="15.10.3"></a>
<h3>15.10.3    Example: Array Creation and Out-of-Memory Detection</h3>
<a name="36885"></a>
If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. This check occurs only after evaluation of all dimension expressions has completed normally. <p>
<a name="36744"></a>
<p>So, for example, the test program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int len = 0, oldlen = 0;
                Object[] a = new Object[0];
                try {
                        for (;;) {
                                ++len;
                                Object[] temp = new Object[oldlen = len];
                                temp[0] = a;
                                a = temp;
                        }
                } catch (Error e) {
                        System.out.println(e + ", " + (oldlen==len));
                }
        }
}
</pre></blockquote><a name="36764"></a>
prints:<p>
<blockquote><pre>java.lang.OutOfMemoryError, true
</pre></blockquote><a name="36901"></a>
because the out-of-memory condition is detected after the dimension expression <code>oldlen</code> = <code>len</code> is evaluated.<p>
<a name="264401"></a>
<p>Compare this to class instance creation expressions <a href="expressions.html#41147">(&#167;15.9)</a>, which detect the out-of-memory condition before evaluating argument expressions <a href="expressions.html#36687">(&#167;15.9.6)</a>.</p>
<a name="385816"></a>
<p></p>
<a name="41267"></a>
<a name="15.11"></a>
<h2>15.11    Field Access Expressions</h2>
<a name="37024"></a>
A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword <code>super</code>. (It is also possible to refer to a field of the current instance or current class by using a simple name; see <a href="names.html#129350">&#167;6.5.6</a>.)<p>
<blockquote><pre>
<em>
FieldAccess:
        Primary . Identifier
</em>   super<em> . Identifier
        ClassName .</em>super<em> . Identifier
        </em>
</pre></blockquote><a name="37051"></a>
The meaning of a field access expression is determined using the same rules as for qualified names <a href="names.html#104285">(&#167;6.6)</a>, but limited by the fact that an expression cannot denote a package, class type, or interface type.<p>
<a name="37055"></a>
<a name="15.11.1"></a>
<h3>15.11.1    Field Access Using a Primary</h3>
<a name="37056"></a>
The type of the <em>Primary</em> must be a reference type <i>T</i>, or a compile-time error occurs. The meaning of the field access expression is determined as follows:<p>
<ul><a name="20394"></a>
<li>If the identifier names several accessible member fields of type <i>T</i>, then the field access is ambiguous and a compile-time error occurs.
<a name="37075"></a>
<li>If the identifier does not name an accessible member field of type <i>T</i>, then the field access is undefined and a compile-time error occurs.
<a name="20398"></a>
<li>Otherwise, the identifier names a single accessible member field of type <i>T</i> and the type of the field access expression is the type of the member field after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>. At run time, the result of the field access expression is computed as follows:
<ul>
<a name="37316"></a>
<li>If the field is <code>static</code>:
<ul>
<a name="292199"></a>
<li>The <em>Primary</em> expression is evaluated, and the result is discarded. If evaluation of the <em>Primary</em> expression completes abruptly, the field access expression completes abruptly for the same reason.
<a name="292203"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified class variable in the class or interface that is the type of the <em>Primary</em> expression.
<a name="292204"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified class variable in the class that is the type of the <em>Primary</em> expression.
</ul>
<a name="37320"></a>
<li>If the field is not <code>static</code>:
<ul>
<a name="37110"></a>
<li>The <em>Primary</em> expression is evaluated. If evaluation of the <em>Primary</em> expression completes abruptly, the field access expression completes abruptly for the same reason.
<a name="292217"></a>
<li>If the value of the <em>Primary</em> is <code>null</code>, then a <code>NullPointerException</code> is thrown.
<a name="20427"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified instance variable in the object referenced by the value of the <em>Primary</em>.
<a name="264406"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified instance variable in the object referenced by the value of the <em>Primary</em>.
</ul>
</ul>
</ul><a name="37135"></a>
Note, specifically, that only the type of the <em>Primary</em> expression, not the class of the actual object referred to at run time, is used in determining which field to use.<p>
<a name="21262"></a>
<p>Thus, the example:</p>
<a name="385817"></a>
<p></p>
<blockquote><pre>class <i>S</i> { int x = 0; }
class T extends <i>S</i> { int x = 1; }
class Test {
        public static void main(String[] args) {
                T t = new T();
                System.out.println("t.x=" + t.x + when("t", t));
                S s = new S();
                System.out.println("s.x=" + s.x + when("s", s));
                s = t;
                System.out.println("s.x=" + s.x + when("s", s));
        }
</pre></blockquote><a name="385818"></a>
<p>
<blockquote><pre>       static String when(String name, Object t) {
                return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
        }
}
</pre></blockquote><a name="20906"></a>
produces the output:<p>
<blockquote><pre>t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class <i>S</i> at run time.
s.x=0 when s holds a class T at run time.
</pre></blockquote><a name="45446"></a>
The last line shows that, indeed, the field that is accessed does not depend on the run-time class of the referenced object; even if <code>s</code> holds a reference to an object of class <code>T</code>, the expression <code>s.x</code> refers to the <code>x</code> field of class <code>S</code>, because the type of the expression <code>s</code> is <code>S</code>. Objects of class <code>T</code> contain two fields named <code>x</code>, one for class <code>T</code> and one for its superclass <code>S</code>.<p>
<a name="22264"></a>
<p>This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations. The power of late binding and overriding is available, but only when instance methods are used. Consider the same example using instance methods to access the fields:</p>
<blockquote><pre>class <i>S</i> { int x = 0; int z() { return x; } }
class T extends <i>S</i> { int x = 1; int z() { return x; } }
class Test {
        public static void main(String[] args) {
                T t = new T();
                System.out.println("t.z()=" + t.z() + when("t", t));
                S s = new S();
                System.out.println("s.z()=" + s.z() + when("s", s));
                s = t;
                System.out.println("s.z()=" + s.z() + when("s", s));
        }
        static String when(String name, Object t) {
                return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
        }
}
</pre></blockquote><a name="238134"></a>
Now the output is:<p>
<blockquote><pre>t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class <i>S</i> at run time.
s.z()=1 when s holds a class T at run time.
</pre></blockquote><a name="37254"></a>
The last line shows that, indeed, the method that is accessed <em>does</em> depend on the run-time class of referenced object; when <code>s</code> holds a reference to an object of class <code>T</code>, the expression <code>s.z()</code> refers to the <code>z</code> method of class <code>T</code>, despite the fact that the type of the expression <code>s</code> is <code>S</code>. Method <code>z</code> of class <code>T</code> overrides method <code>z</code> of class <code>S</code>.<p>
<a name="22234"></a>
<p>The following example demonstrates that a null reference may be used to access a class (<code>static</code>) variable without causing an exception:</p>
<blockquote><pre>class Test {
        static String mountain = "Chocorua";
        static Test favorite(){
                System.out.print("Mount ");
                return null;
        }
        public static void main(String[] args) {
                System.out.println(favorite().mountain);
        }
}
</pre></blockquote><a name="22242"></a>
It compiles, executes, and prints:<p>
<blockquote><pre>Mount Chocorua
</pre></blockquote>
<a name="264411"></a>
<p>Even though the result of <code>favorite()</code> is <code>null</code>, a <code>NullPointerException</code> is <em>not</em> thrown. That "<code>Mount </code>" is printed demonstrates that the <em>Primary</em> expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field <code>mountain</code> is <code>static</code>).</p>
<a name="20860"></a>
<a name="15.11.2"></a>
<h3>15.11.2    Accessing Superclass Members using super</h3>
<a name="20451"></a>
The special forms using the keyword <code>super</code> are valid only in an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class; these are exactly the same situations in which the keyword <code>this</code> may be used <a href="expressions.html#251519">(&#167;15.8.3)</a>. The forms involving <code>super</code> may not be used anywhere in the class <code>Object</code>, since <code>Object</code> has no superclass; if <code>super</code> appears in class <code>Object</code>, then a compile-time error results.<p>
<a name="264416"></a>
Suppose that a field access expression <code>super.</code><i>name</i> appears within class <i>C</i>, and the immediate superclass of <i>C</i> is class <i>S</i>. Then <code>super.</code><i>name</i> is treated exactly as if it had been the expression <code>((</code><i>S</i>)this).<i>name</i>; thus, it refers to the field named <i>name</i> of the current object, but with the current object viewed as an instance of the superclass. Thus it can access the field named <i>name</i> that is visible in class <i>S</i>, even if that field is hidden by a declaration of a field named <i>name</i> in class <i>C</i>. <p>
<a name="20763"></a>
<p>The use of <code>super</code> is demonstrated by the following example:</p>
<blockquote><pre>interface I { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1 { int x = 2; }
class T3 extends T2 {
        int x = 3;
        void test() {
                System.out.println("x=\t\t"+x);
                System.out.println("super.x=\t\t"+super.x);
                System.out.println("((T2)this).x=\t"+((T2)this).x);
                System.out.println("((T1)this).x=\t"+((T1)this).x);
                System.out.println("((I)this).x=\t"+((I)this).x);
        }
}

class Test {
        public static void main(String[] args) {
                new T3().test();
        }
}
</pre></blockquote><a name="385824"></a>
<p>
<a name="20520"></a>
which produces the output:<p>
<a name="385821"></a>
<p>
<blockquote><pre>
x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0
</pre></blockquote><a name="385826"></a>
<p>
<a name="37491"></a>
Within class <code>T3</code>, the expression <code>super.x</code> is treated exactly as if it were:<p>
<a name="385822"></a>
<p>
<blockquote><pre><code>((T2)this).x
</code>
</pre></blockquote><a name="251555"></a>
Suppose that a field access expression <i>T</i>.<code>super</code>.<i>name</i> appears within class <i>C</i>, and the immediate superclass of the class denoted by <i>T</i> is a class whose fully qualified name is <i>S</i>. Then <i>T</i>.<code>super</code>.<i>name </i>is treated exactly as if it had been the expression <code>((<i>S</i>)<i>T</i>.this).</code><i>name</i>. <p>
<a name="292181"></a>
Thus the expression <i>T</i>.<code>super</code>.<i>name</i> can access the field named name that is visible in the class named by <i>S</i>, even if that field is hidden by a declaration of a field named <i>name</i> in the class named by <i>T</i>.<p>
<a name="292184"></a>
It is a compile-time error if the current class is not an inner class of class <i>T</i> or <i>T</i> itself.<p>
<a name="385823"></a>
<a name="385828"></a>
<p>
<a name="20448"></a>
<a name="15.12"></a>
<h2>15.12    Method Invocation Expressions</h2>
<a name="37518"></a>
A method invocation expression is used to invoke a class or instance method.<p>
<blockquote><pre>
<em>
MethodInvocation:
        MethodName </em>(<em> ArgumentList<sub><i>opt</i></sub></em> )<em>
        Primary . NonWildTypeArguments<sub>opt</sub> Identifier </em>(<em> ArgumentList<sub><i>opt</i></sub> </em>)
        super <em>. NonWildTypeArguments<sub>opt</sub> Identifier </em>(<em> ArgumentList<sub><i>opt</i></sub> </em>)<em>
        ClassName . </em>super<em> . NonWildTypeArguments<sub>opt</sub> Identifier </em>(<em> ArgumentList<sub>opt</sub> </em>)<em>
        TypeName . NonWildTypeArguments Identifier </em>(<em> ArgumentList<sub>opt</sub> </em>)
</pre></blockquote><a name="8506"></a>
The definition of <em>ArgumentList</em> from <a href="expressions.html#41147">&#167;15.9</a> is repeated here for convenience:<p>
<blockquote><pre>
<em>
ArgumentList:
        Expression
        ArgumentList , Expression
        </em>
<a name="264431"></a>
</pre></blockquote>
<p>Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading. Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.</p>
</pre></blockquote><a name="38751"></a>
Determining the method that will be invoked by a method invocation expression involves several steps. The following three sections describe the compile-time processing of a method invocation; the determination of the type of the method invocation expression is described in <a href="expressions.html#23617">&#167;15.12.3</a>.<p>
<a name="21692"></a>
<a name="15.12.1"></a>
<h3>15.12.1    Compile-Time Step 1: Determine Class or Interface to Search</h3>
<a name="37532"></a>
 The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to check for definitions of methods of that name. There are several cases to consider, depending on the form that precedes the left parenthesis, as follows:<p>
<ul><a name="37552"></a>
<li>If the form is <em>MethodName</em>, then there are three subcases:
<ul>
<a name="37575"></a>
<li>If it is a simple name, that is, just an <em>Identifier</em>, then the name of the method is the <em>Identifier</em>. If the <i>Identifier</i> appears within the scope <a href="names.html#103228">(&#167;6.3)</a> of a visible method declaration with that name, then there must be an enclosing type declaration of which that method is a member. Let <i>T</i> be the innermost such type declaration. The class or interface to search is <i>T</i>.
<a name="37556"></a>
<li>If it is a qualified name of the form <em>TypeName</em> <code>.</code> <em>Identifier</em>, then the name of the method is the <em>Identifier</em> and the class to search is the one named by the <em>TypeName</em>. If <em>TypeName</em> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code>static</code> methods and interfaces have no <code>static</code> methods.
<a name="37591"></a>
<li>In all other cases, the qualified name has the form <em>FieldName</em> <code>.</code> <em>Identifier</em>; then the name of the method is the <em>Identifier</em> and the class or interface to search is the declared type <i>T</i> of the field named by the <em>FieldName</em>, if <i>T</i> is a class or interface type, or the upper bound of <i>T</i> if <i>T</i> is a type variable.
</ul>
<a name="37589"></a>
<li>If the form is <i>Primary.NonWildTypeArguments<sub>opt</sub> Identifier</i>, then the name of the method is the <em>Identifier</em>. Let <i>T</i> be the type of the <em>Primary</em> expression; then the class or interface to be searched is <i>T</i> if <i>T</i> is a class or interface type, or the upper bound of <i>T</i> if <i>T</i> is a type variable.
<a name="37600"></a>
<li>If the form is <code>super</code>.<i>NonWildTypeArguments<sub>opt</sub> Identifier</i>, then the name of the method is the <em>Identifier</em> and the class to be searched is the superclass of the class whose declaration contains the method invocation. Let <i>T</i> be the type declaration immediately enclosing the method invocation. It is a compile-time error if any of the following situations occur:
<ul>
<a name="256960"></a>
<li><i>T</i> is the class <code>Object</code>.
<a name="334792"></a>
<li><i>T</i> is an interface.
</ul>
<a name="348791"></a>
<li>If the form is <i>ClassName</i>.<code>super</code>.<i>NonWildTypeArguments<sub>opt</sub> Identifier</i>, then the name of the method is the <i>Identifier</i> and the class to be searched is the superclass of the class <i>C</i> denoted by <i>ClassName</i>. It is a compile-time error if <i>C</i> is not a lexically enclosing class of the current class. It is a compile-time error if <i>C</i> is the class <code>Object</code>. Let <i>T</i> be the type declaration immediately enclosing the method invocation. It is a compile-time error if any of the following situations occur:
<ul>
<a name="348792"></a>
<li><i>T</i> is the class <code>Object</code>.
<a name="348798"></a>
<li><i>T</i> is an interface.
</ul>
<a name="289785"></a>
<li>If the form is <i>TypeName.NonWildTypeArguments Identifier</i>, then the name of the method is the <i>Identifier</i> and the class to be searched is the class <i>C</i> denoted by <i>TypeName</i>. If <em>TypeName</em> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code>static</code> methods and interfaces have no <code>static</code> methods.
</ul><a name="292575"></a>
<a name="15.12.2"></a>
<h3>15.12.2    Compile-Time Step 2: Determine Method Signature</h3>
<a name="19915"></a>
The second step searches the type determined in the previous step for member methods. This step uses the name of the method and the types of the argument expressions to locate methods that are both <em>accessible</em> and <em>applicable</em>, that is, declarations that can be correctly invoked on the given arguments. There may be more than one such method, in which case the <em>most specific</em> one is chosen. The descriptor (signature plus return type) of the most specific method is one used at run time to perform the method dispatch.<p>
<a name="316797"></a>
A method is <i>applicable</i> if it is either applicable by subtyping <a href="expressions.html#301185">(&#167;15.12.2.2)</a>, applicable by method invocation conversion <a href="expressions.html#352591">(&#167;15.12.2.3)</a>, or it is an applicable variable arity method <a href="expressions.html#301239">(&#167;15.12.2.4)</a>.<p>
<a name="300192"></a>
The process of determining applicability begins by determining the potentially applicable methods <a href="expressions.html#316811">(&#167;15.12.2.1)</a>. The remainder of the process is split into three phases. <p>
<a name="301506"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 The purpose of the division into phases is to ensure compatibility with older versions of the Java programming language.<p>
<hr>
<a name="301507"></a>
 <p>
<a name="300130"></a>
The first phase <a href="expressions.html#301185">(&#167;15.12.2.2)</a> performs overload resolution without permitting boxing or unboxing conversion, or the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the second phase.<p>
<a name="300193"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<P>
 This guarantees that any calls that were valid in older versions of the language are not considered ambiguous as a result of the introduction of variable arity methods, implicit boxing and/or unboxing.<p>
 <hr>
<a name="301508"></a>
 <p>
<a name="300131"></a>
The second phase <a href="expressions.html#352591">(&#167;15.12.2.3)</a> performs overload resolution while allowing boxing and unboxing, but still precludes the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the third phase.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
<a name="301455"></a>
 This ensures that a variable arity method is never invoked if an applicable fixed arity method exists.<p>
 <hr>
<a name="301509"></a>
 <p>
<a name="300151"></a>
The third phase <a href="expressions.html#301239">(&#167;15.12.2.4)</a> allows overloading to be combined with variable arity methods, boxing and unboxing.<p>
<a name="316777"></a>
Deciding whether a method is applicable will, in the case of generic methods <a href="classes.html#323928">(&#167;8.4.4)</a>, require that actual type arguments be determined. Actual type arguments may be passed explicitly or implicitly. If they are passed implicitly, they must be inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> from the types of the argument expressions.<p>
<a name="344974"></a>
If several applicable methods have been identified during one of the three phases of applicability testing, then the <i>most specific</i> one is chosen, as specified in section <a href="expressions.html#301183">&#167;15.12.2.5</a>. See the following subsections for details.<p>
<a name="325980"></a>
<p>
<a name="316811"></a>
<a name="15.12.2.1"></a>
<h4>15.12.2.1    Identify Potentially Applicable Methods</h4>
<a name="316812"></a>
A member method is <i>potentially applicable</i> to a method invocation if and only if all of the following are true:<p>
<ul><a name="316813"></a>
<li>The name of the member is identical to the name of the method in the method invocation.
<a name="316817"></a>
<li>The member is accessible <a href="names.html#104285">(&#167;6.6)</a> to the class or interface in which the method invocation appears.
<a name="316818"></a>
<li>The arity of the member is lesser or equal to the arity of the method invocation.
<a name="352569"></a>
<li>If the member is a variable arity method with arity <i>n</i>, the arity of the method invocation is greater or equal to <i>n</i>-1.
<a name="316819"></a>
<li>If the member is a fixed arity method with arity <i>n</i>, the arity of the method invocation is equal to <i>n</i>.
<a name="316820"></a>
<li>If the method invocation includes explicit type parameters, and the member is a generic method, then the number of actual type parameters is equal to the number of formal type parameters.
<a name="316821"></a>
</ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="357780"></a>
 The clause above implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type parameters. Indeed, it may turn out to be applicable. In such a case, the type parameters will simply be ignored.<p>
<a name="357793"></a>
This rule stems from issues of compatibility and principles of substitutability. Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one. However, the overriding (non-generic) method must be applicable to calls to the generic method, including calls that explicitly pass type parameters. Otherwise the subtype would not be substitutable for its generified supertype.<p>
<hr>
<a name="357782"></a>
 <p>
<a name="357779"></a>
Whether a member method is accessible at a method invocation depends on the access modifier (<code>public</code>, none, <code>protected</code>, or <code>private</code>) in the member's declaration and on where the method invocation appears.<p>
<a name="316825"></a>
The class or interface determined by compile-time step 1 <a href="expressions.html#21692">(&#167;15.12.1)</a> is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search. <p>
<a name="316826"></a>
In addition, if the method invocation has, before the left parenthesis, a <i>MethodName</i> of the form <i>Identifier</i>, then the search process also examines all methods that are (a) imported by single-static-import declarations <a href="packages.html#26741">(&#167;7.5.3)</a> and static-import-on-demand declarations <a href="packages.html#94114">(&#167;7.5.4)</a> within the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> within which the method invocation occurs, and (b) not shadowed <a href="names.html#34133">(&#167;6.3.1)</a> at the place where the method invocation appears.<p>
<a name="316839"></a>
If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.<p>
<a name="316808"></a>
<p>
<a name="386070"></a>
<a name="301185"></a>
<a name="15.12.2.2"></a>
<h4>15.12.2.2    Phase 1: Identify Matching Arity Methods Applicable by Subtyping</h4>
<a name="373662"></a>
Let <i>m</i> be a potentially applicable method <a href="expressions.html#316811">(&#167;15.12.2.1)</a>, let <i>e<sub>1</sub>, ..., e<sub>n</sub></i> be the actual argument expressions of the method invocation and let <i>A<sub>i</sub></i> be the type of <i>e<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>. Then:<p>
<ul><a name="341216"></a>
<li>If <i>m</i> is a generic method, then let <i>F<sub>1</sub> ... F<sub>n</sub></i> be the types of the formal parameters of <i>m</i> and let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be the formal type parameters of <i>m</i>, and let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>. Then:
<ul>
<a name="341217"></a>
<li>If the method invocation does not provide explicit type arguments then let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation of <i>m</i>, using a set of initial constraints consisting of the constraints <i>A<sub>i</sub> &lt;&lt; F<sub>i</sub></i> for each actual argument expression <i>e<sub>i</sub></i> whose type is a reference type, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>.
<a name="341224"></a>
<li>Otherwise let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the explicit type arguments given in the method invocation.
</ul><a name="341238"></a>
<p>Then let <i>S<sub>i</sub> = F<sub>i</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, be the types inferred for of the formal parameters of <i>m</i>.
<a name="310538"></a>
<li>Otherwise, let <i>S<sub>1</sub> ... S<sub>n</sub></i> be the types of the formal parameters of <i>m</i>.
</ul><a name="310430"></a>
The method <i>m</i> is <i>applicable by subtyping</i> if and only if both of the following conditions hold:<p>
<ul><a name="310694"></a>
<li>For 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, either:
<ul>
<a name="316760"></a>
<li><i>A<sub>i</sub></i> is a subtype <a href="typesValues.html#120403">(&#167;4.10)</a> of <i>S<sub>i</sub> (A<sub>i</sub> &lt;: S<sub>i</sub>)</i> or
<a name="316762"></a>
<li><i>A<sub>i</sub></i> is convertible to some type <i>C<sub>i</sub></i> by unchecked conversion <a href="conversions.html#190772">(&#167;5.1.9)</a>, and <i>C<sub>i</sub> &lt;: S<sub>i</sub></i>.
</ul>
<a name="310697"></a>
<li>If <i>m</i> is a generic method as described above then <i>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul><a name="352577"></a>
If no method applicable by subtyping is found, the search for applicable methods continues with phase 2 <a href="expressions.html#352591">(&#167;15.12.2.3)</a>. Otherwise, the most specific method <a href="expressions.html#301183">(&#167;15.12.2.5)</a> is chosen among the methods that are applicable by subtyping.<p>
<a name="352591"></a>
<a name="15.12.2.3"></a>
<h4>15.12.2.3    Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion</h4>
<a name="310556"></a>
Let <i>m</i> be a potentially applicable method <a href="expressions.html#316811">(&#167;15.12.2.1)</a>, let <i>e<sub>1</sub>, ..., e<sub>n</sub></i> be the actual argument expressions of the method invocation and let <i>A<sub>i</sub></i> be the type of <i>e<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>. Then:<p>
<ul><a name="341175"></a>
<li>If <i>m</i> is a generic method, then let<i> F<sub>1</sub> ... F<sub>n</sub></i> be the types of the formal parameters of <i>m</i>, and let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be the formal type parameters of <i>m</i>, and let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>. Then:
<ul>
<a name="341192"></a>
<li>If the method invocation does not provide explicit type arguments then let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation of <i>m</i>, using a set of initial constraints consisting of the constraints <i>A<sub>i</sub> &lt;&lt; Fi</i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>.
<a name="341185"></a>
<li>Otherwise let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the explicit type arguments given in the method invocation.
<a name="373700"></a>
</ul>
<p>Then let <i>S<sub>i</sub> = F<sub>i</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i>  1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, be the types inferred for the formal parameters of <i>m</i>.</p>
<a name="373701"></a>
<li>Otherwise, let <i>S<sub>1</sub> ... S<sub>n</sub></i> be the types of the formal parameters of <i>m</i>.
</ul><a name="301346"></a>
The method <i>m</i> is applicable by method invocation conversion if and only if both of the following conditions hold:<p>
<ul><a name="310706"></a>
<li>For  1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, the type of <i>e<sub>i</sub></i>, <i>A<sub>i</sub></i>, can be converted by method invocation conversion <a href="conversions.html#12687">(&#167;5.3)</a> to <i>S<sub>i</sub></i>.
<a name="310711"></a>
<li>If <i>m</i> is a generic method as described above then <i>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul><a name="301223"></a>
If no method applicable by method invocation conversion is found, the search for applicable methods continues with phase 3 <a href="expressions.html#301239">(&#167;15.12.2.4)</a>. Otherwise, the most specific method <a href="expressions.html#301183">(&#167;15.12.2.5)</a> is chosen among the methods that are applicable by method invocation conversion.<p>
<a name="301239"></a>
<a name="15.12.2.4"></a>
<h4>15.12.2.4    Phase 3: Identify Applicable Variable Arity Methods</h4>
<a name="310586"></a>
Let <i>m</i> be a potentially applicable method <a href="expressions.html#316811">(&#167;15.12.2.1)</a> with variable arity, let <i>e<sub>1</sub>, ..., e<sub>k</sub></i> be the actual argument expressions of the method invocation and let <i>A<sub>i</sub></i> be the type of <i>e<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>. Then:<p></SUB>
<ul><a name="310590"></a>
<li>If <i>m</i> is a generic method, then let <i>F<sub>1</sub> ... F<sub>n</sub></i>, where 1<img src="chars/lt_equal.gif"><i>n</i><img src="chars/lt_equal.gif"><i>k</i>+1, be the types of the formal parameters of <i>m</i>, where <i>F<sub>n</sub> = T[] </i>for some type <i>T</i>, and let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be the formal type parameters of <i>m</i>, and let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>. Then:
<ul>
<a name="341119"></a>
<li>If the method invocation does not provide explicit type arguments then let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation of <i>m</i>, using a set of initial constraints consisting of the constraints <i>A<sub>i</sub> &lt;&lt; F<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i> and the constraints <i>A<sub>j</sub> &lt;&lt; T</i>, <i>n</i><img src="chars/lt_equal.gif"><i>j</i><img src="chars/lt_equal.gif"><i>k</i>.
<a name="341118"></a>
<li>Otherwise let <i>U<sub>1</sub> ... U<sub>p</sub></i> be the explicit type arguments given in the method invocation.
</ul>
<a name="341131"></a>
<p>Then let <i>S<sub>i</sub> = F<sub>i</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, be the types inferred for the formal parameters of <i>m</i>.
<a name="310597"></a>
<li>Otherwise, let <i>S<sub>1</sub> ... S<sub>n</sub></i>, where <i>n</i><img src="chars/lt_equal.gif"><i>k</i>+1, be the types of the formal parameters of <i>m</i>.
</ul><a name="301372"></a>
The method <i>m</i> is an <i>applicable variable-arity method </i>if and only if all three of the following conditions hold:<p>
<ul><a name="301379"></a>
<li>For 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, the type of <i>e<sub>i</sub></i>, <i>A<sub>i</sub></i>, can be converted by method invocation conversion to <i>S<sub>i</sub></i>.
<a name="301382"></a>
<li>If <i>k</i><img src="chars/gtequal.gif"></i>n</i>, then for <i>n</i><img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>, the type of <i>e<sub>i</sub></i>, <i>A<sub>i</sub></i>, can be converted by method invocation conversion to the component type of <i>S<sub>n</sub></i>.
<a name="310718"></a>
<li>If <i>m</i> is a generic method as described above then <i>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = U<sub>1</sub>, ..., R<sub>p</sub> = U<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul><a name="301243"></a>
If no applicable variable arity method is found, a compile-time error occurs. Otherwise, the most specific method <a href="expressions.html#301183">(&#167;15.12.2.5)</a> is chosen among the applicable variable-arity methods.<p>
<a name="385835"></a>
<p>
<a name="301183"></a>
<a name="15.12.2.5"></a>
<h4>15.12.2.5    Choosing the Most Specific Method</h4>
<a name="308804"></a>
If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the <em>most specific</em> method is chosen.<p>
<a name="308810"></a>
<p>The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.</p>
<a name="312934"></a>
One fixed-arity member method named <i>m</i> is <i>more specific</i> than another member method of the same name and arity if all of the following conditions hold:<p>
<ul><a name="312935"></a>
<li>The declared types of the parameters of the first member method are <i>T<sub>1</sub>,&#32;. . . ,&#32;T<sub>n</sub></i>.
<a name="312936"></a>
<li>The declared types of the parameters of the other method are <i>U<sub>1</sub>, . . . ,&#32;U<sub>n</sub></i>.
<a name="312937"></a>
<li>If the second method is generic then let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be its formal type parameters, let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>, let <i>A<sub>1</sub> ... A<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation under the initial constraints <i>T<sub>i</sub> &lt;&lt; U<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i> and let <i>S<sub>i</sub> = U<sub>i</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>; otherwise let <i>S<sub>i</sub> = U<sub>i</sub></i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>.
<a name="385598"></a>
<li>For all <i>j</i> from 1 to <i>n</i>, <i>T<sub>j</sub> &lt;: S<sub>j</sub></i>.
<a name="385547"></a>
<li>If the second method is a generic method as described above then <i>A<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul><a name="312939"></a>
In addition, one variable arity member method named <i>m</i> is more specific than another variable arity member method of the same name if either:<p>
<ul><a name="385961"></a>
<li>One member method has <i>n</i> parameters and the other has <i>k</i> parameters, where <i>n</i><img src="chars/gtequal.gif"><i>k</i>. The types of the parameters of the first member method are <i>T<sub>1</sub>,&#32;. . . ,&#32;T<sub>n-1</sub> ,&#32;T<sub>n</sub>[]</i>, the types of the parameters of the other method are <i>U<sub>1</sub>, . . . ,&#32;U<sub>k-1</sub>,&#32;U<sub>k</sub>[]</i>. If the second method is generic then let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be its formal type parameters, let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>, let <i>A<sub>1</sub> ... A<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation under the initial constraints <i>T</sub>i</sub> &lt;&lt; U<sub>i</sub></i>,1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>-1, <i>T<sub>i</sub> &lt;&lt; U<sub>k</sub></i>, <i>k</i><img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i> and let <i>S<sub>i</sub> = U<sub>i</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>; otherwise let <i>S<sub>i</sub> = U<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>. Then:
<ul>
<a name="352882"></a>
<li>for all <i>j</i> from 1 to <i>k-1</i>, <i>T<sub>j</sub> &lt;: S<sub>j</sub></i>, and,
<a name="385701"></a>
<li>for all <i>j</i> from <i>k</i> to <i>n</i>, <i>T<sub>j</sub> &lt;: S<sub>k</sub></i>, and,
<a name="352949"></a>
<li>If the second method is a generic method as described above then <i>A<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul>
<a name="312952"></a>
<li>One member method has <i>k</i> parameters and the other has <i>n</i> parameters, where <i>n</i><img src="chars/gtequal.gif"><i>k</i>. The types of the parameters of the first method are <i>U<sub>1</sub>, . . . , U<sub>k-1</sub>,&#32;U<sub>k</sub>[]</i>, the types of the parameters of the other method are <i>T<sub>1</sub>,&#32;. . ., T<sub>n-1</sub>,&#32;T<sub>n</sub>[]</i>. If the second method is generic then let <i>R<sub>1</sub> ... R<sub>p</sub></i> <i>p</i><img src="chars/gtequal.gif">1, be its formal type parameters, let <i>B<sub>l</sub></i> be the declared bound of <i>R<sub>l</sub></i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>, let <i>A<sub>1</sub> ... A<sub>p</sub></i> be the actual type arguments inferred <a href="expressions.html#341287">(&#167;15.12.2.7)</a> for this invocation under the initial constraints <i>U<sub>i</sub> &lt;&lt; T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>-1, <i>U<sub>k</sub> &lt;&lt; T<sub>i</sub></i>, <i>k</i><img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i> and let <i>S<sub>i</sub> = T<sub>i</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i> 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>; otherwise let <i>S<sub>i</sub> = T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>. Then:
<ul>
<a name="316768"></a>
<li>for all <i>j</i> from 1 to <i>k-1</i> , <i>U<sub>j</sub>  &lt;: S<sub>j</sub></i>, and,
<a name="385753"></a>
<li>for all <i>j</i> from <i>k</i> to <i>n</i> , <i>U<sub>k</sub>  &lt;: S<sub>j</sub></i>, and,
<a name="316769"></a>
<li>If the second method is a generic method as described above then <i>A<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub> = A<sub>1</sub>, ..., R<sub>p</sub> = A<sub>p</sub>]</i>, 1<img src="chars/lt_equal.gif"><i>l</i><img src="chars/lt_equal.gif"><i>p</i>.
</ul>
</ul><a name="316770"></a>
The above conditions are the only circumstances under which one method may be more specific than another.<p>
<a name="309995"></a>
A method <i>m<sub>1</sub></i> is <em>strictly more specific</em> than another method <i>m<sub>2</sub></i> if and only if <i>m<sub>1</sub></i> is more specific than <i>m<sub>2</sub></i> and <i>m<sub>2</sub></i> is not more specific than <i>m<sub>1</sub></i>.<p>
<a name="308848"></a>
A method is said to be <em>maximally specific </em>for a method invocation if it is accessible and applicable and there is no other method that is applicable and accessible that is strictly more specific.<p>
<a name="308850"></a>
If there is exactly one maximally specific method, then that method is in fact <em>the most specific</em> method; it is necessarily more specific than any other accessible method that is applicable. It is then subjected to some further compile-time checks as described in <a href="expressions.html#23617">&#167;15.12.3</a>.<p>
<a name="308857"></a>
It is possible that no method is the most specific, because there are two or more methods that are maximally specific. In this case:<p>
<ul><a name="308858"></a>
<li>If all the maximally specific methods have override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> signatures, then:
<ul>
<a name="308859"></a>
<li>If exactly one of the maximally specific methods is not declared <code>abstract</code>, it is the most specific method.
<a name="308876"></a>
<li>Otherwise, if all the maximally specific methods are declared <code>abstract</code>, and the signatures of all of the maximally specific methods have the same erasure <a href="typesValues.html#108979">(&#167;4.6)</a>, then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that have the most specific return type. However, the most specific method is considered to throw a checked exception if and only if that exception or its erasure is declared in the <code>throws</code> clauses of each of the maximally specific methods.
</ul>
<a name="308877"></a>
<li>Otherwise, we say that the method invocation is <em>ambiguous</em>, and a compile-time error occurs.
</ul><a name="385836"></a>
<p>
<a name="386071"></a>
<p>
<a name="386072"></a>
<p>
<a name="340382"></a>
<a name="15.12.2.6"></a>
<h4>15.12.2.6    Method Result and Throws Types</h4>
<ul><a name="341293"></a>
<li>The result type of the chosen method is determined as follows:
<ul>
<a name="341294"></a>
<li>If the method being invoked is declared with a return type of <code>void</code>, then the result is <code>void</code>.
<a name="341295"></a>
<li>Otherwise, if unchecked conversion was necessary for the method to be applicable then the result type is the erasure <a href="typesValues.html#108979">(&#167;4.6)</a> of the method's declared return type.
<a name="341302"></a>
<li>Otherwise, if the method being invoked is generic, then for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, let <i>F<sub>i</sub></i> be the formal type parameters of the method, let <i>A<sub>i</sub></i> be the actual type arguments inferred for the method invocation, and let <i>R</i> be the declared return type of the method being invoked. The result type is obtained by applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to <i>R[F<sub>1</sub> := A<sub>1</sub>, ..., F<sub>n</sub> := A<sub>n</sub>]</i>.
<a name="341306"></a>
<li>Otherwise, the result type is obtained by applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to the type given in the method declaration.
</ul>
</ul><a name="341288"></a>
The exception types of the throws clause of the chosen method are determined as follows:<p>
<ul><a name="341327"></a>
<li>If unchecked conversion was necessary for the method to be applicable then the throws clause is composed of the erasure <a href="typesValues.html#108979">(&#167;4.6)</a> of the types in the method's declared throws clause.
<a name="341335"></a>
<li>Otherwise, if the method being invoked is generic, then for 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, let <i>F<sub>i</sub></i> be the formal type parameters of the method, let <i>A<sub>i</sub></i> be the actual type arguments inferred for the method invocation, and let <i>E<sub>j</sub></i>, 1<img src="chars/lt_equal.gif"><i>j</i><img src="chars/lt_equal.gif"><i>m</i> be the exception types declared in the throws clause of the method being invoked. The throws clause consists of the types to <i>E<sub>j</sub>[F<sub>1</sub> := A<sub>1</sub>, ..., F<sub>n</sub> := A<sub>n</sub>]</i>.
<a name="341380"></a>
<li>Otherwise, the type of the throws clause is the type given in the method declaration.
</ul><a name="387000"></a>
A method invocation expression can throw an exception type <i>E</i> iff either:<p>
<ul><a name="387001"></a>
<li>The method to be invoked is of the form <i>Primary.Identifier</i> and the <i>Primary</i> expression can throw <i>E</i>; or
<a name="387002"></a>
<li>Some expression of the argument list can throw<i> E</i>; or
<a name="387003"></a>
<li><i>E</i> is listed in the throws clause of the type of method that is invoked.
</ul><a name="386930"></a>
<p>
<a name="341287"></a>
<a name="15.12.2.7"></a>
<h4>15.12.2.7    Inferring Type Arguments Based on Actual Arguments</h4>
<a name="340390"></a>
In this section, we describe the process of inferring type arguments for method and constructor invocations. This process is invoked as a subroutine when testing for method (or constructor) applicability (<a href="expressions.html#301185">&#167;15.12.2.2</a> - <a href="expressions.html#301239">&#167;15.12.2.4</a>).<p>
<a name="345852"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="345865"></a>
 The process of type inference is inherently complex. Therefore, it is useful to give an informal overview of the process before delving into the detailed specification.<p>
<a name="345866"></a>
Inference begins with an initial set of constraints. Generally, the constraints require that the statically known types of the actual arguments are acceptable given the declared formal argument types. We discuss the meaning of "acceptable" below.<p>
<a name="345893"></a>
Given these initial constraints, one may derive a set of supertype and/or equality constraints on the formal type parameters of the method or constructor. <p>
<a name="345918"></a>
Next, one must try and find a solution that satisfies the constraints on the type parameters. As a first approximation, if a type parameter is constrained by an equality constraint, then that constraint gives its solution. Bear in mind that the constraint may equate one type parameter with another, and only when the entire set of constraints on all type variables is resolved will we have a solution.<p>
<a name="345925"></a>
A supertype constraint <i>T :&gt; X</i> implies that the solution is one of supertypes of <i>X</i>. Given several such constraints on <i>T</i>, we can intersect the sets of supertypes implied by each of the constraints, since the type parameter must be a member of all of them. We can then choose the most specific type that is in the intersection.<p>
<a name="345932"></a>
Computing the intersection is more complicated than one might first realize. Given that a type parameter is constrained to be a supertype of two distinct invocations of a generic type, say <code>List&lt;Object&gt;</code> and <code>List&lt;String&gt;</code>, the naive intersection operation might yield <code>Object</code>. However, a more sophisticated analysis yields a set containing <code>List&lt;?&gt;</code>. Similarly, if a type parameter, <code>T</code>, is constrained to be a supertype of two unrelated interfaces <code>I</code> and <code>J</code>, we might infer <code>T</code> must be <code>Object</code>, or we might obtain a tighter bound of <code>I</code> &amp; <code>J</code>. These issues are discussed in more detail later in this section.<p>
<hr>
<a name="345867"></a>
 <p>
<a name="345845"></a>
We will use the following notational conventions in this section:<p>
<ul><a name="346204"></a>
<li>Type expressions are represented using the letters <i>A</i>, <i>F</i>, <i>U</i>, <i>V</i> and <i>W</i>. The letter <i>A</i> is only used to denote the type of an actual parameter, and <i>F</i> is only used to denote the type of a formal parameter.
<a name="346215"></a>
<li>Type parameters are represented using the letters <i>S</i> and <i>T</i>
<a name="346205"></a>
<li>Arguments to parameterized types are represented using the letters <i>X</i>, <i>Y</i>.
<a name="346206"></a>
<li>Generic type declarations are represented using the letters <i>G</i> and <i>H</i>.
</ul><a name="346203"></a>
Inference begins with a set of <i>initial constraints</i> of the form <i>A &lt;&lt; F, A = F</i>, or <i>A &gt;&gt; F</i>, where <i>U &lt;&lt; V</i> indicates that type <i>U</i> is convertible to type <i>V</i> by method invocation conversion <a href="conversions.html#12687">(&#167;5.3)</a>, and <i>U &gt;&gt; V</i> indicates that type <i>V</i> is convertible to type <i>U</i> by method invocation conversion. <p>
<a name="345913"></a>
 <hr>
 <p
 <b>Discussion</b>
 </p>
 <p>
<a name="345896"></a>
In a simpler world, the constraints could be of the form <i>A &lt;: F</i> - simply requiring that the actual argument types be subtypes of the formal ones. However, reality is more involved. As discussed earlier, method applicability testing consists of up to three phases; this is required for compatibility reasons. Each phase imposes slightly different constraints. If a method is applicable by subtyping <a href="expressions.html#301185">(&#167;15.12.2.2)</a>, the constraints are indeed subtyping constraints. If a method is applicable by method invocation conversion <a href="expressions.html#352591">(&#167;15.12.2.3)</a>, the constraints imply that the actual type is convertible to the formal type by method invocation conversion. The situation is similar for the third phase <a href="expressions.html#301239">(&#167;15.12.2.4)</a>, but the exact form of the constraints differ due to the variable arity.<p>
<hr>
<a name="345906"></a>
 <p>
<a name="345894"></a>
These constraints are then reduced to a set of simpler constraints of the forms <i>T :&gt; X, T = X</i> or <i>T &lt;: X</i>, where <i>T</i> is a type parameter of the method. This reduction is achieved by the procedure given below:<p>
<a name="348892"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="364967"></a>
 It may be that the initial constraints are unsatisfiable; we say that inference is overconstrained. In that case, we do not necessarily derive unsatisfiable constraints on the type parameters. Instead, we may infer actual type arguments for the invocation, but once we substitute the actual type arguments for the formal type parameters, the applicability test may fail because the actual argument types are not acceptable given the substituted formals.<p>
<a name="345957"></a>
An alternative strategy would be to have type inference itself fail in such cases. Compilers may choose to do so, provided the effect is equivalent to that specified here.<p>
<hr>
<a name="345950"></a>
 <p>
<a name="340396"></a>
Given a constraint of the form <i>A &lt;&lt; F, A = F</i>, or <i>A &gt;&gt; F:</i><p>
<ul><a name="340397"></a>
<li>If <i>F</i> does not involve a type parameter <i>T<sub>j</sub></i> then no constraint is implied on <i>T<sub>j</sub></i>.
<a name="364968"></a>
<li>Otherwise, <i>F</i> involves a type parameter <i>T<sub>j</sub></i>.
<ul>
<a name="340398"></a>
<li>If <i>A</i> is the type of <code>null</code>, no constraint is implied on <i>T<sub>j</sub></i>.
<a name="340399"></a>
<li>Otherwise, if the constraint has the form <i>A &lt;&lt;F</i>
<ul>
<a name="340400"></a>
<li>If <i>A</i> is a primitive type, then <i>A</i> is converted to a reference type <i>U</i> via boxing conversion and this algorithm is applied recursively to the constraint <i>U &lt;&lt; F</i>.
<a name="340401"></a>
<li>Otherwise, if <i>F = T<sub>j</sub></i>, then the constraint <i>T<sub>j</sub> :&gt; A</i> is implied.
<a name="340402"></a>
<li>If <i>F = U[]</i>, where the type <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> is an array type <i>V[],</i> or a type variable with an upper bound that is an array type <i>V[]</i>, where <i>V</i> is a reference type, this algorithm is applied recursively to the constraint <i>V &lt;&lt;U</i>.
</ul></ul></ul>
<a name="365006"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365004"></a>
 This follows from the covariant subtype relation among array types. The constraint <i>A &lt;&lt; F</i>, in this case means that <i>A &lt;&lt; U[]</i>. <i>A</i> is therefore necessarily an array type <i>V[]</i>, or a type variable whose upper bound is an array type <i>V[]</i> - otherwise the relation <i>A &lt;&lt; U[]</i> could never hold true. It follows that <i>V[] &lt;&lt; U[]</i>. Since array subtyping is covariant, it must be the case that <i>V &lt;&lt; U</i>.<p>
 <hr>
<a name="364993"></a>
<ul><ul><ul>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, U, Y<sub>k+1</sub>, ...&gt;</i>, 1<img src="chars/lt_equal.gif"><i>k</i><img src="chars/lt_equal.gif"><i>n</i> where <i>U</i> is a type expression that involves <i>T<sub>j</sub></i>, then if <i>A</i> has a supertype of the form <i>G&lt;..., X<sub>k-1</sub>, V, X<sub>k+1</sub>, ...&gt;</i> where <i>V</i> is a type expression, this algorithm is applied recursively to the constraint <i>V = U</i>.
</ul></ul></ul>
<a name="365010"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365011"></a>
 For simplicity, assume that <i>G</i> takes a single type argument. If the method invocation being examined is to be applicable, it must be the case that <i>A</i> is a subtype of some invocation of <i>G</i>. Otherwise, <i>A &lt;&lt; F</i> would never be true. <p>
In other words, <i>A &lt;&lt; F</i>, where <i>F = G&lt;U&gt;</i>, implies that <i>A &lt;&lt; G&lt;V&gt;</i> for some <i>V</i>. Now, since <i>U</i> is a type expression (and therefore, <i>U</i> is not a wildcard type argument), it must be the case that <i>U = V</i>, by the non-variance of ordinary parameterized type invocations.<p>
<a name="365027"></a>
The formulation above merely generalizes this reasoning to generics with an arbitrary number of type arguments.<p>
<hr>
<ul><ul><ul>
<a name="365013"></a>
<a name="364997"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, ? extends U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> has a supertype that is one of:
<ul>
<a name="340406"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, V, X<sub>k+1</sub>, ...&gt;</i>, where <i>V</i> is a type expression. Then this algorithm is applied recursively to the constraint <i>V &lt;&lt; U</i>.
<a name="365034"></a>
</ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365035"></a>
 Again, let's keep things as simple as possible, and consider only the case where <i>G</i> has a single type argument.<p>
<i>A &lt;&lt;F</i> in this case means <i>A &lt;&lt; G&lt;? extends U&gt;</i>. As above, it must be the case that <i>A</i> is a subtype of some invocation of <i>G</i>. However, <i>A</i> may now be a subtype of either <i>G&lt;V&gt;</i>, or <i>G&lt;? extends V&gt;</i>, or <i>G&lt;? super V&gt;</i>. We examine these cases in turn. The first variation is described (generalized to multiple arguments) by the sub-bullet directly above. We therefore have <i>A = G&lt;V&gt; &lt;&lt; G&lt;? extends U&gt;</i>. The rules of subtyping for wildcards imply that <i>V &lt;&lt; U</i>.<p>
<hr>
<a name="365037"></a>
 <p>
<ul><ul>
<ul>
<ul>
<a name="340408"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, ? extends V, X<sub>k+1</sub>, ...&gt;</i>. Then this algorithm is applied recursively to the constraint  <i>V &lt;&lt; U</i>.
<a name="365042"></a>
 <p>
</ul>
</ul>
</ul>
</ul><a name="365044"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
Extending the analysis above, we have <i>A = G&lt;? extends V&gt; &lt;&lt; G&lt;? extends U&gt;</i>. The rules of subtyping for wildcards again imply that <i>V &lt;&lt; U</i>.<p>
<hr>
<a name="365045"></a>
 <p>
<ul><ul>
<ul>
<ul>
<a name="340409"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
<a name="365064"></a>
 <p>
</ul>
</ul>
</ul>
</ul><a name="365066"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
Here, we have <i>A = G&lt;? super V&gt; &lt;&lt; G&lt;? extends U&gt;</i>. In general, we cannot conclude anything in this case. However, it is not necessarily an error. It may be that <i>U</i> will eventually be inferred to be <code>Object</code>, in which case the call may indeed be valid. Therefore, we simply refrain from placing any constraint on <i>U</i>.<p>
<hr>
<a name="365067"></a>
 <p>
<ul><ul>
<ul>
<a name="340410"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, ? super U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> has a supertype that is one of:
<ul>
<a name="340411"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, V, X<sub>k+1</sub>, ...&gt;</i>. Then this algorithm is applied recursively to the constraint <i>V &gt;&gt; U</i>.
<a name="365086"></a>
</ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365087"></a>
 As usual, we consider only the case where <i>G</i> has a single type argument.<p>
<i>A &lt;&lt;F</i> in this case means <i>A &lt;&lt; G&lt;? super U&gt;</i>. As above, it must be the case that <i>A</i> is a subtype of some invocation of <i>G</i>. <i>A</i> may now be a subtype of either <i>G&lt;V&gt;</i>, or <i>G&lt;? extends V&gt;</i>, or <i>G&lt;? super V&gt;</i>. We examine these cases in turn. The first variation is described (generalized to multiple arguments) by the sub-bullet directly above. We therefore have <i>A = G&lt;V&gt; &lt;&lt; G&lt;? super U&gt;</i>. The rules of subtyping for wildcards imply that <i>V &gt;&gt; U</i>.<p>
<hr>
<a name="365089"></a>
 <p>
<ul><ul>
<ul>
<ul>
<a name="340414"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, ? super V, X<sub>k+1</sub>, ...&gt;</i>. Then this algorithm is applied recursively to the constraint <i>V &gt;&gt; U</i>.
<a name="365104"></a>
 <p>
</ul>
</ul>
</ul>
</ul><a name="365105"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
We have <i>A = G&lt;? super V&gt; &lt;&lt; G&lt;? super U&gt;</i>. The rules of subtyping for lower-bounded wildcards again imply that <i>V &gt;&gt; U</i>.<p>
<hr>
<a name="365106"></a>
 <p>
<ul><ul>
<ul>
<ul>
<a name="340415"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
<a name="365122"></a>
 <p>
</ul>
</ul>
</ul>
</ul><a name="365123"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
Here, we have <i>A = G&lt;? extends V&gt; &lt;&lt; G&lt;? super U&gt;</i>. In general, we cannot conclude anything in this case. However, it is not necessarily an error. It may be that <i>U</i> will eventually be inferred to the <code>null</code> type, in which case the call may indeed be valid. Therefore, we simply refrain from placing any constraint on <i>U</i>.<p>
<a name="365124"></a>
 <hr>
 <p>
<ul><ul>
<ul>
<a name="340416"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
<a name="340417"></a>
<li>Otherwise, if the constraint has the form <i>A = F</i>
<a name="365139"></a>
 <p>
</ul>
</ul><a name="365140"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
Such a constraint is never part of the initial constraints. However, it can arise as the algorithm recurses. We have seen this occur above, when the constraint <i>A &lt;&lt; F</i> relates two parameterized types, as in <i>G&lt;V&gt; &lt;&lt; G&lt;U&gt;</i>.<p>
<hr>
<a name="365141"></a>
 <p>
<ul><ul>
<ul>
<a name="340418"></a>
<li>If <i>F = T<sub>j</sub></i>, then the constraint <i>T<sub>j</sub> = A</i> is implied.
<a name="340419"></a>
<li>If <i>F = U[]</i> where the type <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> is an array type <i>V[]</i>, or a type variable with an upper bound that is an array type <i>V[]</i>, where <i>V</i> is a reference type, this algorithm is applied recursively to the constraint <i>V = U</i>.
<a name="365153"></a>
 <p>
</ul>
</ul>
</ul><a name="365154"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
Clearly, if the array types <i>U[]</i> and <i>V[]</i> are the same, their component types must be the same.<p>
<hr>
<a name="365155"></a>
 <p>
<ul><ul>
<ul>
<a name="340420"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, U, Y<sub>k+1</sub>, ...&gt;</i>, 1<img src="chars/lt_equal.gif"><i>k</i><img src="chars/lt_equal.gif"><i>n</i> where <i>U</i> is type expression that involves <i>T<sub>j</sub></i>, then if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, V, X<sub>k+1</sub>,...&gt;</i> where <i>V</i> is a type expression, this algorithm is applied recursively to the constraint <i>V = U</i>.
<a name="340421"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, ? extends U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> is one of:
<ul>
<a name="340423"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, ? extends V, X<sub>k+1</sub>, ...&gt;</i>. Then this algorithm is applied recursively to the constraint  <i>V = U</i>.
<a name="340424"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
<a name="340425"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, ? super U, Y<sub>k+1</sub> ,...&gt;</i>, where <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> is one of:
<ul>
<a name="340428"></a>
<li><i>G&lt;..., X<sub>k-1</sub>, ? super V, X<sub>k+1</sub>, ...&gt;</i>. Then this algorithm is applied recursively to the constraint <i>V = U</i>.
<a name="340429"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
<a name="340430"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
<a name="340431"></a>
<li>Otherwise, if the constraint has the form <i>A &gt;&gt; F</i>
</ul></ul>
<a name="365165"></a>
 <p>
 <hr>
 <p>
<b>Discussion</b>
</p>
<p>
<a name="365281"></a>
 Such situations arise when the algorithm recurses, due to the contravariant subtyping rules associated with lower-bounded wildcards (those of the form <i>G&lt;? super X&gt;</i>).<p>
It might be tempting to consider <i>A&gt;&gt; F</i> as being the same as <i>F &lt;&lt; A</i>, but the problem of inference is not symmetric. We need to remember which participant in the relation includes a type to be inferred.<p>
<hr>
<a name="365167"></a>
 <p>
<ul><ul>
<ul>
<a name="340432"></a>
<li>If <i>F = T<sub>j</sub></i>, then the constraint <i>T<sub>j</sub> &lt;: A</i> is implied.
<a name="366834"></a>
 </ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366835"></a>
 We do not make use of such constraints in the main body of the inference algorithm. However, they are used in section <a href="expressions.html#340522">&#167;15.12.2.8</a>.<p>
 <hr>
<a name="366841"></a>
 <p>
 <ul><ul><ul>
<a name="340433"></a>
<li>If <i>F = U[]</i>, where the type <i>U</i> involves <i>T<sub>j</sub></i>, then if <i>A</i> is an array type <i>V[]</i>, or a type variable with an upper bound that is an array type <i>V[]</i>, where <i>V</i> is a reference type, this algorithm is applied recursively to the constraint <i>V &gt;&gt; U</i>. Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul></ul></ul>
<a name="365179"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365180"></a>
 This follows from the covariant subtype relation among array types. The constraint <i>A &gt;&gt; F</i>, in this case means that <i>A &gt;&gt; U[]</i>. <i>A</i> is therefore necessarily an array type <i>V[]</i>, or a type variable whose upper bound is an array type <i>V[]</i> - otherwise the relation <i>A &gt;&gt; U[]</i> could never hold true. It follows that <i>V[] &gt;&gt; U[]</i>. Since array subtyping is covariant, it must be the case that <i>V &gt;&gt; U</i>.<p>
 <hr>
 <ul><ul><ul>
<a name="340434"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> is a type expression that involves <i>T<sub>j</sub></i>, then:
<ul>
<a name="340435"></a>
<li>If <i>A</i> is an instance of a non-generic type, then no constraint is implied on <i>T<sub>j</sub></i>.
</ul></ul></ul></ul>
<a name="365200"></a>
 <p>
<a name="365201"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 In this case (once again restricting the analysis to the unary case), we have the constraint <i>A &gt;&gt; F = G&lt;U&gt;</i>. <i>A</i> must be a supertype of the generic type <i>G</i>. However, since <i>A</i> is not a parameterized type, it cannot depend upon the type argument <i>U</i> in any way. It is a supertype of <i>G&lt;X&gt;</i> for every <i>X</i> that is a valid type argument to <i>G</i>. No meaningful constraint on <i>U</i> can be derived from <i>A</i>.<p>
<a name="340436"></a>
<hr>
<ul><ul><ul><ul>
<li>If <i>A</i> is an invocation of a generic type declaration <i>H</i>, where <i>H</i> is either <i>G</i> or superclass or superinterface of <i>G</i>, then:
<ul>
<a name="340440"></a>
<li>If <i>H</i><img src="chars/notequal.gif"><i>G</i>, then let <i>S<sub>1</sub>, ..., S<sub>n</sub></i> be the formal type parameters of <i>G</i>, and let <i>H&lt;U<sub>1</sub>, ..., U<sub>l</sub>&gt;</i> be the unique invocation of <i>H</i> that is a supertype of <i>G&lt;S<sub>1</sub> , ..., S<sub>n</sub>&gt;</i>, and let <i>V = H&lt;U<sub>1</sub>, ..., U<sub>l</sub>&gt;[S<sub>k</sub> = U]</i>. Then, if <i>V :&gt; F</i> this algorithm is applied recursively to the constraint <i>A &gt;&gt; V</i>.
<a name="366635"></a>
</ul></ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366636"></a>
 Our goal here is to simplify the relationship between <i>A</i> and <i>F</i>. We aim to recursively invoke the algorithm on a simpler case, where the actual type argument is known to be an invocation of the same generic type declaration as the formal. <p>
Let's consider the case where both <i>H</i> and <i>G</i> have only a single type argument. Since we have the constraint <i>A = H&lt;X&gt; &gt;&gt; F = G&lt;U&gt;</i>, where <i>H</i> is distinct from <i>G</i>, it must be the case that <i>H</i> is some proper superclass or superinterface of <i>G</i>. There must be a (non-wildcard) invocation of <i>H</i> that is a supertype of <i>F = G&lt;U&gt;</i>. Call this invocation <i>V</i>.<p>
<a name="366696"></a>
If we replace <i>F</i> by <i>V</i> in the constraint, we will have accomplished the goal of relating two invocations of the same generic (as it happens, <i>H</i>).<p>
<a name="366700"></a>
How do we compute <i>V</i>? The declaration of <i>G</i> must introduce a formal type parameter <i>S</i>, and there must be some (non-wildcard) invocation of <i>H</i>,<i> H&lt;U1&gt;</i>, that is a supertype of <i>G&lt;S&gt;</i>. Substituting the type expression <i>U</i> for <i>S</i> will then yield a (non-wildcard) invocation of <i>H</i>, <i>H&lt;U1&gt;[S = U]</i>, that is a supertype of <i>G&lt;U&gt;</i>. For example, in the simplest instance, <i>U1</i> might be <i>S</i>, in which case we have <i>G&lt;S&gt; &lt;: H&lt;S&gt;</i>, and <i>G&lt;U&gt; &lt;: H&lt;U&gt; = H&lt;S&gt;[S = U] = V</i>. <p>
<a name="366669"></a>
It may be the case that <i>H&lt;U1&gt;</i> is independent of <i>S</i> - that is, <i>S</i> does not occur in <i>U1</i> at all. However, the substitution described above is still valid - in this situation, <i>V = H&lt;U1&gt;[S = U] = H&lt;U1&gt;</i>. Furthermore, in this circumstance, <i>G&lt;T&gt; &lt;: H&lt;U1&gt;</i> for any <i>T</i>, and in particular <i>G&lt;U&gt; &lt;: H&lt;U1&gt; = V</i>.<p>
<a name="366675"></a>
Regardless of whether <i>U1</i> depends on <i>S</i>, we have determined the type <i>V</i>, the invocation of <i>H</i> that is a supertype of <i>G&lt;U&gt;</i>. We can now invoke the algorithm recursively on the constraint <i>H&lt;X&gt; = A &gt;&gt; V = H&lt;U1&gt;[S = U]</i>. We will then be able to relate the type arguments of both invocations of <i>H</i> and extract the relevant constraints from them.<p>
<hr>
<a name="366637"></a>
 <p>
<ul><ul>
<ul>
<ul>
<ul>
<a name="340444"></a>
<li>Otherwise, if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, W, X<sub>k+1</sub>, ...&gt;</i>, where <i>W</i> is a type expression this algorithm is applied recursively to the constraint <i>W = U</i>.
<a name="365217"></a>
 <p>
 </ul></ul></ul></ul></ul>
<a name="365219"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 We have <i>A = G&lt;W&gt; &gt;&gt; F = G&lt;U&gt;</i> for some type expression <i>W</i>. Since <i>W</i> is a type expression (and not a wildcard type argument), it must be the case that <i>W = U</i>, by the non-variance of parameterized types.<p>
 <hr>
<a name="365215"></a>
 <p>
 <ul><ul><ul><ul><ul>
<a name="340445"></a>
<li>Otherwise, if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, ? extends W, X<sub>k+1</sub>, ...&gt;</i>, this algorithm is applied recursively to the constraint <i>W &gt;&gt; U</i>.
<a name="365255"></a>
</ul></ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="365256"></a>
 We have <i>A = G&lt;? extends W&gt; &gt;&gt; F = G&lt;U&gt;</i> for some type expression <i>W</i>. It must be the case that <i>W &gt;&gt; U</i>, by the subtyping rules for wildcard types.<p>
 <hr>
<a name="365257"></a>
 <p>
 <ul><ul><ul><ul><ul>
<a name="340446"></a>
<li>Otherwise, if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, ? super W, X<sub>k+1</sub>, ...&gt;</i>, this algorithm is applied recursively to the constraint <i>W &lt;&lt; U</i>.
<a name="365270"></a>
 <p>
 </ul></ul></ul></ul></ul>
 <p>
 <hr>
 <b>Discussion</b>
 </p>
 <p>
<a name="365271"></a>
 We have <i>A = G&lt;? super W&gt; &gt;&gt; F = G&lt;U&gt;</i> for some type expression <i>W</i>. It must be the case that <i>W &lt;&lt; U</i>, by the subtyping rules for wildcard types.<p>
<hr>
<ul><ul><ul><ul><ul>
<a name="365272"></a>
 <p>
<a name="340447"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
</ul>
<a name="340448"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
<a name="340449"></a>
<li>If <i>F</i> has the form <i>G&lt;..., Y<sub>k-1</sub>, ? extends U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> is a type expression that involves <i>T<sub>j</sub></i>, then:
<ul>
<a name="340450"></a>
<li>If <i>A</i> is an instance of a non-generic type, then no constraint is implied on <i>T<sub>j</sub></i>.
<a name="366707"></a>
</ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366708"></a>
 Once again restricting the analysis to the unary case, we have the constraint <i>A &gt;&gt; F = G&lt;? extends U&gt;</i>. A must be a supertype of the generic type <i>G</i>. However, since <i>A</i> is not a parameterized type, it cannot depend upon <i>U</i> in any way. It is a supertype of the type <i>G&lt;? extends X&gt;</i> for every <i>X</i> such that <i>? extends X</i> is a valid type argument to <i>G</i>. No meaningful constraint on <i>U</i> can be derived from <i>A</i>.<p>
<hr>
<a name="340451"></a>
<ul><ul><ul><ul>
<li>If <i>A</i> is an invocation of a generic type declaration <i>H</i>, where <i>H</i> is either <i>G</i> or superclass or superinterface of <i>G</i>, then:
<ul>
<a name="340455"></a>
<li>If <i>H</i><img src="chars/notequal.gif"><i>G</i>, then let <i>S<sub>1</sub>, ..., S<sub>n</sub></i> be the formal type parameters of <i>G</i>, and let <i>H&lt;U<sub>1</sub>, ..., U<sub>l</sub>&gt;</i> be the unique invocation of <i>H</i> that is a supertype of <i>G&lt;S<sub>1</sub> , ..., S<sub>n</sub>&gt;</i>, and let <i>V = H&lt;? extends U<sub>1</sub>, ..., ? extends U<sub>l</sub>&gt;[S<sub>k</sub> = U]</i>. Then this algorithm is applied recursively to the constraint <i>A &gt;&gt; V</i>.
</ul>
</ul>
</ul>
</ul>
</ul><a name="386134"></a>
<p>
<hr>
<a name="386135"></a>
<p>
<b>Discussion</b>
</p>
<a name="366776"></a>
 <p>
<a name="366777"></a>
 Our goal here is once more to simplify the relationship between <i>A</i> and <i>F</i>, and recursively invoke the algorithm on a simpler case, where the actual type argument is known to be an invocation of the same generic type as the formal. <p>
<a name="366778"></a>
Assume both <i>H</i> and <i>G</i> have only a single type argument. Since we have the constraint <i>A = H&lt;X&gt; &gt;&gt; F = G&lt;? extends U&gt;</i>, where <i>H</i> is distinct from <i>G</i>, it must be the case that <i>H</i> is some proper superclass or superinterface of <i>G</i>. There must be an invocation of <ik>H&lt;Y&gt;</i> such that <i>H&lt;X&gt; &gt;&gt; H&lt;Y&gt;</i> that we can use instead of <i>F = G&lt;? extends U&gt;</i>.<p>
<a name="366780"></a>
How do we compute <i>H&lt;Y&gt;</i>? As before, note that the declaration of <i>G</i> must introduce a formal type parameter <i>S</i>, and there must be some (non-wildcard) invocation of <i>H</i>, <i>H&lt;U1&gt;</i>, that is a supertype of <i>G&lt;S&gt;</i>. However, substituting <i>? extends U</i> for <i>S</i> is not generally valid. To see this, assume <i>U1 = T[]</i>. <p>
<a name="386081"></a>
Instead, we produce an invocation of <i>H</i>, <i>H&lt;? extends U1&gt;[S = U]</i>. In the simplest instance, <i>U1</i> might be <i>S</i>, in which case we have <i>G&lt;S&gt; &lt;: H&lt;S&gt;</i>, and <i>G&lt;? extends U&gt; &lt;: H&lt;? extends U&gt; = H&lt;? extends S&gt;[S = U] = V</i>. <p>
<hr>
<a name="366783"></a>
 <p>
<ul><ul>
<ul>
<ul>
<ul>
<a name="340456"></a>
<li>Otherwise, if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, ? extends W, X<sub>k+1</sub>, ...&gt;</i>, this algorithm is applied recursively to the constraint <i>W &gt;&gt;U</i>.
</ul></ul></ul></ul></ul>
<a name="366744"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366745"></a>
 We have <i>A = G&lt;? extends W&gt; &gt;&gt; F = G&lt;? extends U&gt;</i> for some type expression <i>W</i>. By the subtyping rules for wildcards it must be the case that <i>W &gt;&gt; U</i>.<p>
 <hr>
<a name="366746"></a>
 <p>
 <ul><ul><ul><ul><ul>
<a name="340457"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
</ul>
<a name="340458"></a>
<li>If <i>F</i> has the form <i>G&lt;... , Y<sub>k-1</sub>, ? super U, Y<sub>k+1</sub>, ...&gt;</i>, where <i>U</i> is a type expression that involves <i>T<sub>j</sub></i>, then <i>A</i> is either:
<ul>
<a name="340459"></a>
<li>If <i>A</i> is an instance of a non-generic type, then no constraint is implied on <i>T<sub>j</sub></i>.
</ul>
</ul>
</ul>
</ul><a name="386141"></a>
<p>
<hr>
<a name="366722"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366723"></a>
 Restricting the analysis to the unary case, we have the constraint <i>A &gt;&gt; F = G&lt;? super U&gt;</i>. <i>A</i> must be a supertype of the generic type <i>G</i>. However, since <i>A</i> is not a parameterized type, it cannot depend upon <i>U</i> in any way. It is a supertype of the type <i>G&lt;? super X&gt;</i> for every <i>X</i> such that <i>? super X</i> is a valid type argument to <i>G</i>. No meaningful constraint on <i>U</i> can be derived from <i>A</i>.<p>
 <hr>
<ul><ul>
<ul>
<ul>
<a name="340460"></a>
<li>If <i>A</i> is an invocation of a generic type declaration <i>H</i>, where <i>H</i> is either <i>G</i> or superclass or superinterface of <i>G</i>, then:
<ul>
<a name="340464"></a>
<li>If <i>H</i><img src="chars/notequal.gif"><i>G</i>, then let <i>S<sub>1</sub>, ..., S<sub>n</sub></i> be the formal type parameters of <i>G</i>, and let <i>H&lt;U<sub>1</sub>, ..., U<sub>l</sub>&gt;</i> be the unique invocation of <i>H</i> that is a supertype of <i>G&lt;S<sub>1</sub> , ..., S<sub>n</sub>&gt;</i>, and let <i>V = H&lt;? super U<sub>1</sub>, ..., ? super U<sub>l</sub>&gt;[S<sub>k</sub> = U]</i>. Then this algorithm is applied recursively to the constraint <i>A &gt;&gt; V</i>.
<a name="366807"></a>
</ul></ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366808"></a>
 The treatment here is analogous to the case where <i>A = G&lt;? extends U&gt;</i>. Here our example would produce an invocation <i>H&lt;? super U1&gt;[S = U]</i><p>
 <hr>
<a name="366815"></a>
 <p>
 <ul><ul><ul><ul><ul>
<a name="340465"></a>
<li>Otherwise, if <i>A</i> is of the form <i>G&lt;..., X<sub>k-1</sub>, ? super W, ..., X<sub>k+1</sub>, ...&gt;</i>, this algorithm is applied recursively to the constraint <i>W &lt;&lt; U</i>.
</ul></ul></ul></ul></ul>
<a name="366762"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="366763"></a>
 We have <i>A = G&lt;? super W&gt; &gt;&gt; F = G&lt;? super U&gt;</i> for some type expression <i>W</i>. It must be the case that <i>W &lt;&lt; U</i>, by the subtyping rules for wildcard types.<p>
 <hr>
 <ul><ul><ul><ul><ul>
<a name="366764"></a>
 <p>
<a name="340466"></a>
<li>Otherwise, no constraint is implied on <i>T<sub>j</sub></i>.
<a name="346046"></a>
</ul></ul></ul></ul></ul>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="364982"></a>
 This concludes the process of determining constraints on the formal type parameters of a method.
 <p>
Note that this process does not impose any constraints on the type parameters based on their declared bounds. Once the actual type arguments are inferred, they will be tested against the declared bounds of the formal type parameters as part of applicability testing.<p>
<a name="386096"></a>
Note also that type inference does not affect soundness in any way. If the types inferred are nonsensical, the invocation will yield a type error. The type inference algorithm should be viewed as a heuristic, designed to perfdorm well in practice. If it fails to infer the desired result, explicit type paramneters may be used instead.<p>
<hr>
<a name="346050"></a>
 <p>
<a name="346045"></a>
Next, for each type variable <i>T<sub>j</sub></i>, 1<img src="chars/lt_equal.gif"><i>j</i><img src="chars/lt_equal.gif"><i>n</i>, the implied equality constraints are resolved as follows: <p>
<a name="340472"></a>
For each implied equality constraint <i>T<sub>j</sub> = U</i> or <i>U = T<sub>j</sub></i>:<p>
<ul><a name="340473"></a>
<li>If <i>U</i> is not one of the type parameters of the method, then <i>U</i> is the type inferred for <i>T<sub>j</sub></i>. Then all remaining constraints involving <i>T<sub>j</sub></i> are rewritten such that <i>T<sub>j</sub></i> is replaced with <i>U</i>. There are necessarily no further equality constraints involving <i>T<sub>j</sub></i>, and processing continues with the next type parameter, if any.
<a name="340474"></a>
<li>Otherwise, if <i>U</i> is <i>T<sub>j</sub></i>, then this constraint carries no information and may be discarded.
<a name="340478"></a>
<li>Otherwise, the constraint is of the form <i>T<sub>j</sub> = T<sub>k</sub></i> for <i>k</i><img src="chars/notequal.gif"><i>j</i>. Then all constraints involving <i>T<sub>j</sub></i> are rewritten such that <i>T<sub>j</sub></i> is replaced with <i>T<sub>k</sub></i>, and processing continues with the next type variable.
</ul><a name="346289"></a>
 Then, for each remaining type variable <i>T<sub>j</sub></i>, the constraints <i>T<sub>j</sub> :&gt; U</i> are considered. Given that these constraints are <i>T<sub>j</sub> :&gt; U<sub>1</sub> ... T<sub>j</sub> :&gt; U<sub>k</sub></i>, the type of <i>T<sub>j</sub></i> is inferred as <i>lub(U<sub>1</sub> ... U<sub>k</sub>)</i>, computed as follows:<p>
<a name="340480"></a>
For a type <i>U</i>, we write <i>ST(U)</i> for the set of supertypes of <i>U</i>, and define the erased supertype set of <i>U</i>, <p>
<a name="340481"></a>
<i>EST(U) = { V</i> | <i>W in ST(U) and V =</i> |<i>W</i>|<i> }</i><p>
<a name="340485"></a>
 where |<i>W</i>| is the erasure <a href="typesValues.html#108979">(&#167;4.6)</a> of <i>W</i>.<p>
 <hr>
<a name="345962"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="345967"></a>
 The reason for computing the set of erased supertypes is to deal with situations where a type variable is constrained to be a supertype of several distinct invocations of a generic type declaration, For example, if T<i> :&gt; List&lt;String&gt;</i> and <i>T :&gt; List&lt;Object&gt;</i>, simply intersecting the sets <i>ST(List&lt;String&gt;) = {List&lt;String&gt;, Collection&lt;String&gt;, Object}</i> and <i>ST(List&lt;Object&gt;) = {List&lt;Object&gt;), Collection&lt;Object&gt;, Object}</i> would yield a set <i>{Object}</i>, and we would have lost track of the fact that <i>T</i> can safely be assumed to be a <i>List</i>. <p>
<a name="345994"></a>
In contrast, intersecting <i>EST(List&lt;String&gt;) = {List, Collection, Object}</i> and <i>EST(List&lt;Object&gt;) = {List, Collection, Object} </i>yields <i>{List, Collection, Object}</i>, which we will eventually enable us to infer <i>T = List&lt;?&gt;</i> as described below.<p>
<hr>
<a name="345969"></a>
 <p>
<a name="340486"></a>
The erased candidate set for type parameter <i>T<sub>j</sub></i> , <i>EC</i>, is the intersection of all the sets <i>EST(U)</i> for each <i>U</i> in <i>U<sub>1</sub> .. U<sub>k</sub></i>. The minimal erased candidate set for <i>T<sub>j</sub></i> is
<a name="340490"></a>
<i>MEC = { V </i>|<i> V in EC, and for all <i>W</i><img src="chars/notequal.gif"><i>V</i> in EC, it is not the case that W &lt;: V}</i><p>
<hr>
<a name="386142"></a>
<p>
<b>Discussion</b>
</p>
<a name="346003"></a>
 <p>
<a name="346004"></a>
 Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates. This is what computing <i>MEC</i> accomplishes.<p>
<a name="346025"></a>
In our running example, we had <i>EC = {List, Collection, Object}</i>, and now <i>MEC = {List}</i>.<p>
<a name="346024"></a>
The next step will be to recover actual type arguments for the inferred types.<p>
<hr>
<a name="346006"></a>
 <p>
<a name="340491"></a>
 For any element <i>G</i> of <i>MEC</i> that is a generic type declaration, define the relevant invocations of <i>G</i>, <i>Inv(G)</i> to be:<p>
<a name="340495"></a>
<i>Inv(G) = { V </i>| 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>k</i>, <i>V in ST(Ui), V = G&lt;...&gt;}</i><p>
<a name="346038"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="346039"></a>
 In our running example, the only generic element of <i>MEC</i> is <i>List</i>, and <i>Inv(List) = {List&lt;String&gt;, List&lt;Object&gt;}</i>. We now will seek to find a type argument for <i>List</i> that contains <a href="typesValues.html#113455">(&#167;4.5.1.1)</a> both <i>String</i> and <i>Object</i>.<p>
<a name="346040"></a>
This is done by means of the least containing invocation (<i>lci</i>) operation defined below. The first line defines <i>lci()</i> on a set, such as <i>Inv(List)</i>, as an operation on a list of the elements of the set. The next line defines the operation on such lists, as a pairwise reduction on the elements of the list. The third line is the definition of <i>lci()</i> on pairs of parameterized types, which in turn relies on the notion of least containing type argument (<i>lcta</i>).<p>
<a name="346171"></a>
<i>lcta()</i> is defined for all six possible cases. Then <i>CandidateInvocation(G)</i> defines the most specific invocation of the generic <i>G</i> that is contains all the invocations of <i>G</i> that are known to be supertypes of <i>T<sub>j</sub></i>. This will be our candidate invocation of <i>G</i> in the bound we infer for <i>T<sub>j</sub></i> .<p>
<hr>
<a name="346041"></a>
 <p>
<a name="340496"></a>
and let <i>CandidateInvocation(G) = lci(Inv(G))</i> where <i>lci</i>, the least containing invocation is defined<p>
<a name="340853"></a>
<i>lci(S)</i> = <i>lci(e<sub>1</sub>, ..., e<sub>n</sub>)</i> where <i>e<sub>i</sub></i> in <i>S</i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i><br>
<a name="340854"></a>
<i>lci(e<sub>1</sub>, ..., e<sub>n</sub>) </i>=<i> lci(lci(e<sub>1</sub>, e<sub>2</sub>), e<sub>3</sub>, ..., e<sub>n</sub>)</i><br>
<a name="346115"></a>
<i>lci(G&lt;X<sub>1</sub>, ..., X<sub>n</sub>&gt;, G&lt;Y<sub>1</sub>, ..., Y<sub>n</sub>&gt;) = G&lt;lcta(X<sub>1</sub>, Y<sub>1</sub>),..., lcta(X<sub>n</sub>, Y<sub>n</sub>)&gt;</i><p>
<a name="346116"></a>
where <i>lcta()</i> is the the least containing type argument function defined (assuming U and V are type expressions) as:<p>
<a name="346128"></a>
<i>lcta(U, V)</i> = <i>U</i> if <i>U</i> = <i>V</i>, <i>? extends lub(U, V)</i> otherwise<br>
<a name="346130"></a>
<i>lcta(U, ? extends V)</i> =<i> ? extends lub(U, V)</i><br>
<a name="346132"></a>
<i>lcta(U, ? super V)</i> =<i> ? super glb(U, V)</i><br>
<a name="346134"></a>
<i>lcta(? extends U, ? extends V)</i> =<i> ? extends lub(U, V)</i><br>
<a name="346136"></a>
<i>lcta(? extends U, ? super V)</i> = <i>U</i> if <i>U</i> = <i>V, ? </i>otherwise<br>
<a name="346120"></a>
<i>lcta(? super U, ? super V)</i> =<i> ? super glb(U, V)</i><p>
<a name="352423"></a>
<p>
<a name="352424"></a>
where <i>glb()</i> is as defined in <a href="conversions.html#190795">(&#167;5.1.10)</a>. <p>
<hr>
<a name="340512"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="346173"></a>
 Finally, we define a bound for <i>T<sub>j</sub></i> based on on all the elements of the minimal erased candidate set of its supertypes. If any of these elements are generic, we use the <i>CandidateInvocation()</i> function to recover the type argument information.<p>
 <hr>
<a name="346175"></a>
 <p>
<a name="346172"></a>
Then, define <i>Candidate(W) = CandidateInvocation(W)</i> if <i>W</i> is generic, <i>W</i> otherwise.<p>
<a name="340513"></a>
 Then the inferred type for <i>T<sub>j</sub></i> is
<a name="340517"></a>
<i>lub(U<sub>1</sub> ... U<sub>k</sub>) = Candidate(W<sub>1</sub>) &amp; ... &amp; Candidate(W<sub>r</sub>)</i> where <i>W<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>r</i>, are the elements of <i>MEC</i>. <p>
<a name="340519"></a>
It is possible that the process above yields an infinite type. This is permissible, and Java compilers must recognize such situations and represent them appropriately using cyclic data structures.<p>
<a name="340520"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="346200"></a>
 The possibility of an infinite type stems from the recursive calls to <i>lub()</i>.<p>
<a name="346201"></a>
Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.<p>
<hr>
<a name="346202"></a>
 <p>
<a name="340522"></a>
<a name="15.12.2.8"></a>
<h4>15.12.2.8    Inferring Unresolved Type Arguments</h4>
<a name="340523"></a>
If any of the method's type arguments were not inferred from the types of the actual arguments, they are now inferred as follows.<p>
<ul><a name="340524"></a>
<li>If the method result occurs in a context where it will be subject to assignment conversion <a href="conversions.html#184206">(&#167;5.2)</a> to a type <i>S</i>, then let <i>R</i> be the declared result type of the method, and let <i>R' = R[T<sub>1</sub> = B(T<sub>1</sub>) ... T<sub>n</sub> = B(T<sub>n</sub>)] where B(T<sub>i</sub>)</i> is the type inferred for <i>T<sub>i</sub></i> in the previous section, or <i>T<sub>i</sub></i> if no type was inferred.
</ul><a name="340528"></a>
Then, a set of initial constraints consisting of:<p>
<ul><a name="340529"></a>
<li>the constraint <i>S &gt;&gt; R'</i>, provided <i>R</i> is not <code>void</code>; and
<a name="340530"></a>
<li>additional constraints <i>B<sub>i</sub>[T<sub>1</sub> = B(T<sub>1</sub>) ... T<sub>n</sub> = B(T<sub>n</sub>)] &gt;&gt; T<sub>i</sub></i>, where <i>B<sub>i</sub></i> is the declared bound of <i>T<sub>i</sub></i>,
</ul><a name="340531"></a>
is created and used to infer constraints on the type arguments using the algorithm of section <a href="expressions.html#341287">(&#167;15.12.2.7)</a>. Any equality constraints are resolved, and then, for each remaining constraint of the form <i>T<sub>i</sub> &lt;: U<sub>k</sub></i>, the argument <i>T<sub>i</sub></i> is inferred to be <i>glb(U<sub>1</sub>, ..., U<sub>k</sub>)</i> <a href="conversions.html#190795">(&#167;5.1.10)</a>. <p>
<a name="340535"></a>
Any remaining type variables that have not yet been inferred are then inferred to have type <code>Object</code><p>
<ul><a name="340536"></a>
<li>Otherwise, the unresolved type arguments are inferred by invoking the procedure described in this section under the assumption that the method result was assigned to a variable of type <code>Object</code>.
</ul><a name="370266"></a>
<a name="15.12.2.9"></a>
<h4>15.12.2.9    Examples</h4>
<a name="37720"></a>
<p>In the example program:</p>
<blockquote><pre>public class Doubler {
        static int two() { return two(1); }
        private static int two(int i) { return 2*i; }
}
class Test extends Doubler {
        public static long two(long j) {return j+j; }
        public static void main(String[] args) {
                System.out.println(two(3));
                System.out.println(Doubler.two(3)); // compile-time error
        }
}
</pre></blockquote><a name="37704"></a>
for the method invocation <code>two(1)</code> within class <code>Doubler</code>, there are two accessible methods named <code>two</code>, but only the second one is applicable, and so that is the one invoked at run time. For the method invocation <code>two(3)</code> within class <code>Test</code>, there are two applicable methods, but only the one in class <code>Test</code> is accessible, and so that is the one to be invoked at run time (the argument <code>3</code> is converted to type <code>long</code>). For the method invocation <code>Doubler.two(3)</code>, the class <code>Doubler</code>, not class <code>Test</code>, is searched for methods named <code>two</code>; the only applicable method is not accessible, and so this method invocation causes a compile-time error.<p>
<a name="21942"></a>
<p>Another example is:</p>
<blockquote><pre>class ColoredPoint {
        int x, y;
        byte color;
        void setColor(byte color) { this.color = color; }
}
class Test {
        public static void main(String[] args) {
                ColoredPoint cp = new ColoredPoint();
                byte color = 37;
                cp.setColor(color);
                cp.setColor(37);        // compile-time error
        }
}
</pre></blockquote><a name="21881"></a>
Here, a compile-time error occurs for the second invocation of <code>setColor</code>, because no applicable method can be found at compile time. The type of the literal <code>37</code> is <code>int</code>, and <code>int</code> cannot be converted to <code>byte</code> by method invocation conversion. Assignment conversion, which is used in the initialization of the variable <code>color</code>, performs an implicit conversion of the constant from type <code>int</code> to <code>byte</code>, which is permitted because the value <code>37</code> is small enough to be represented in type <code>byte</code>; but such a conversion is not allowed for method invocation conversion.<p>
<a name="21968"></a>
<p>If the method <code>setColor</code> had, however, been declared to take an <code>int</code> instead of a <code>byte</code>, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from <code>byte</code> to <code>int</code>. However, a narrowing cast would then be required in the body of <code>setColor</code>:</p>
<blockquote><pre>       void setColor(int color) { this.color = (byte)color; }
</pre></blockquote><a name="21711"></a>
<a name="15.12.2.10"></a>
<h4>15.12.2.10    Example: Overloading Ambiguity</h4>
<a name="21712"></a>
Consider the example:<p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }

class Test {
        static void test(ColoredPoint p, Point q) {
                System.out.println("(ColoredPoint, Point)");
        }
        static void test(Point p, ColoredPoint q) {
                System.out.println("(Point, ColoredPoint)");
        }
        public static void main(String[] args) {
                ColoredPoint cp = new ColoredPoint();
                test(cp, cp);                                                                                   // compile-time error
        }
}
</pre></blockquote><a name="21726"></a>
This example produces an error at compile time. The problem is that there are two declarations of<i> test</i> that are applicable and accessible, and neither is more specific than the other. Therefore, the method invocation is ambiguous.<p>
<a name="38010"></a>
<p>If a third definition of <code>test</code> were added:</p>
<blockquote><pre>       static void test(ColoredPoint p, ColoredPoint q) {
                System.out.println("(ColoredPoint, ColoredPoint)");
        }
</pre></blockquote><a name="38011"></a>
then it would be more specific than the other two, and the method invocation would no longer be ambiguous.<p>
<a name="21727"></a>
<a name="15.12.2.11"></a>
<h4>15.12.2.11    Example: Return Type Not Considered</h4>
<a name="21728"></a>
As another example, consider:<p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
        static int test(ColoredPoint p) {
                return p.color;
        }
        static String test(Point p) {
                return "Point";
        }
        public static void main(String[] args) {
                ColoredPoint cp = new ColoredPoint();
                String s = test(cp);                                                                                    // compile-time error
        }
}
</pre></blockquote><a name="21743"></a>
Here the most specific declaration of method <code>test</code> is the one taking a parameter of type <code>ColoredPoint</code>. Because the result type of the method is <code>int</code>, a compile-time error occurs because an <code>int</code> cannot be converted to a <code>String</code> by assignment conversion. This example shows that the result types of methods do not participate in resolving overloaded methods, so that the second <code>test</code> method, which returns a <code>String</code>, is not chosen, even though it has a result type that would allow the example program to compile without error.<p>
<a name="29775"></a>
<a name="15.12.2.12"></a>
<h4>15.12.2.12    Example: Compile-Time Resolution</h4>
<a name="30681"></a>
The most applicable method is chosen at compile time; its descriptor determines what method is actually executed at run time. If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen.<p>
<a name="30687"></a>
<p>So, for example, consider two compilation units, one for class <code>Point</code>:</p>
<blockquote><pre>package points;
public class Point {
        public int x, y;
        public Point(int x, int y) { this.x = x; this.y = y; }
        public String toString() { return toString(""); }
        public String toString(String s) {
                return "(" + x + "," + y + s + ")";
        }
}
</pre></blockquote><a name="30799"></a>
and one for class <code>ColoredPoint</code>:<p>
<blockquote><pre>package points;
public class ColoredPoint extends Point {
        public static final int
                RED = 0, GREEN = 1, BLUE = 2;
        public static String[] COLORS =
                { "red", "green", "blue" };
        public byte color;
        public ColoredPoint(int x, int y, int color) {
                super(x, y); this.color = (byte)color;
        }
        /** Copy all relevant fields of the argument into
                 &#32; &#32;this <code>ColoredPoint</code> object. */
        public void adopt(Point p) { x = p.x; y = p.y; }
        public String toString() {
                String s = "," + COLORS[color];
                return super.toString(s);
        }
}
</pre></blockquote><a name="30815"></a>
Now consider a third compilation unit that uses <code>ColoredPoint</code>:<p>
<blockquote><pre>import points.*;
class Test {
        public static void main(String[] args) {
                ColoredPoint cp =
                        new ColoredPoint(6, 6, ColoredPoint.RED);
                ColoredPoint cp2 =
                        new ColoredPoint(3, 3, ColoredPoint.GREEN);
                cp.adopt(cp2);
                System.out.println("cp: " + cp);
        }
}
</pre></blockquote><a name="30754"></a>
The output is:<p>
<blockquote><pre>cp: (3,3,red)
</pre></blockquote>
<a name="30756"></a>
<p>The application programmer who coded class <code>Test</code> has expected to see the word <code>green</code>, because the actual argument, a <code>ColoredPoint</code>, has a <code>color</code> field, and <code>color</code> would seem to be a "relevant field" (of course, the documentation for the package <code>Points</code> ought to have been much more precise!).</p>
<a name="38120"></a>
<p>Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of <code>adopt</code> has a signature that indicates a method of one parameter, and the parameter is of type <code>Point</code>. This signature becomes part of the binary representation of class <code>Test</code> produced by the compiler and is used by the method invocation at run time.</p>
<a name="38098"></a>
<p>Suppose the programmer reported this software error and the maintainer of the <code>points</code> package decided, after due deliberation, to correct it by adding a method to class <code>ColoredPoint</code>:</p>
<blockquote><pre>
public void adopt(ColoredPoint p) {
        adopt((Point)p); color = p.color;
}
</pre></blockquote>
<a name="239516"></a>
<p>If the application programmer then runs the old binary file for <code>Test</code> with the new binary file for <code>ColoredPoint</code>, the output is still:</p>
cp: (3,3,red)
</pre></blockquote><a name="38138"></a>
because the old binary file for <code>Test</code> still has the descriptor "one parameter, whose type is <code>Point</code>; <code>void</code>" associated with the method call <code>cp.adopt(cp2)</code>. If the source code for <code>Test</code> is recompiled, the compiler will then discover that there are now two applicable <code>adopt</code> methods, and that the signature for the more specific one is "one parameter, whose type is <code>ColoredPoint</code>; <code>void</code>"; running the program will then produce the desired output:<p>
<blockquote><pre>cp: (3,3,green)
</pre></blockquote>
<a name="30865"></a>
<p>With forethought about such problems, the maintainer of the <code>points</code> package could fix the <code>ColoredPoint</code> class to work with both newly compiled and old code, by adding defensive code to the old <code>adopt</code> method for the sake of old code that still invokes it on <code>ColoredPoint</code> arguments:</p>
<blockquote><pre>
public void adopt(Point p) {
        if (p instanceof ColoredPoint)
                color = ((ColoredPoint)p).color;
        x = p.x; y = p.y;
}
</pre></blockquote>
<a name="264481"></a>
<p>Ideally, source code should be recompiled whenever code that it depends on is changed. However, in an environment where different classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See <a href="binaryComp.html#44871">&#167;13</a> for a detailed discussion of binary compatibility and type evolution.</p>
</pre></blockquote><a name="23617"></a>
<a name="15.12.3"></a>
<h3>15.12.3    Compile-Time Step 3: Is the Chosen Method Appropriate?</h3>
<a name="23618"></a>
If there is a most specific method declaration for a method invocation, it is called the <em>compile-time declaration</em> for the method invocation. Three further checks must be made on the compile-time declaration:<p>
<ul><a name="289578"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the &#32;form <em>Identifier</em>, and the method is an instance method, then:
<ul>
<a name="289583"></a>
<li>If the invocation appears within a static context <a href="classes.html#295574">(&#167;8.1.3)</a>, then a compile-time error occurs. (The reason is that a method invocation of this form cannot be used to invoke an instance method in places where <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> is not defined.)
<a name="289594"></a>
<li>Otherwise, let <i>C</i> be the innermost enclosing class of which the method is a member. If the invocation is not directly enclosed by <i>C</i> or an inner class of <i>C</i>, then a compile-time error occurs
</ul>
<a name="21464"></a>
<li>If the method invocation has, before the left parenthesis, a <em>MethodName</em> of the &#32;form <em>TypeName.Identifier</em>, or if the method invocation , before the left parenthesis, has the form <em>TypeName.NonWildTypeArguments Identifier</em>, then the compile-time declaration should be <code>static</code>. If the compile-time declaration for the method invocation is for an instance &#32;method, then a compile-time error occurs. (The reason is that a method invocation of this form does not specify a reference to an object that can serve as <code>this</code> within the instance method.)
<a name="289655"></a>
<li>If the method invocation has, before the left parenthesis, the form <code>super</code>.<i>NonWildTypeArguments<sub>opt</sub> Identifier</i>, then:
<ul>
<a name="289657"></a>
<li>If the method is <code>abstract</code>, a compile-time error occurs
<a name="289632"></a>
<li>If the method invocation occurs in a static context, a compile-time error occurs
</ul>
<a name="289639"></a>
<li>If the method invocation has, before the left parenthesis, the form <i>ClassName</i>.<code>super</code>.<i>NonWildTypeArguments<sub>opt</sub> Identifier</i>, then:
<ul>
<a name="289662"></a>
<li>If the method is <code>abstract</code>, a compile-time error occurs
<a name="289663"></a>
<li>If the method invocation occurs in a static context, a compile-time error occurs
<a name="289672"></a>
<li>Otherwise, let <i>C</i> be the class denoted by <i>ClassName</i>. If the invocation is not directly enclosed by <i>C</i> or an inner class of <i>C</i>, then a compile-time error occurs
</ul>
<a name="289640"></a>
<li>If the compile-time declaration for the method invocation is <code>void</code>, then the method invocation must be a top-level expression, that is, the <em>Expression</em> in an expression statement <a href="statements.html#5984">(&#167;14.8)</a> or in the <em>ForInit</em> or <em>ForU<sub>p</sub>date</em> part of a <code>for</code> statement <a href="statements.html#24588">(&#167;14.14)</a>, or a compile-time error occurs. (The reason is that such a method invocation produces no value and so must be used only in a situation where a value is not needed.)
</ul><a name="38703"></a>
The following compile-time information is then associated with the method invocation for use at run time:<p>
<ul><a name="38709"></a>
<li>The name of the method.
<a name="250715"></a>
<li>The qualifying type of the method invocation <a href="binaryComp.html#44909">(&#167;13.1)</a>.
<a name="38716"></a>
<li>The number of parameters and the types of the parameters, in order.
<a name="38717"></a>
<li>The result type, or <code>void</code>.
<a name="341291"></a>
<li>The invocation mode, computed as follows:
<ul>
<a name="38723"></a>
<li>If the compile-time declaration has the <code>static</code> modifier, then the invocation mode is <code>static</code>.
<a name="43892"></a>
<li>Otherwise, if the compile-time declaration has the <code>private</code> modifier, then the invocation mode is <code>nonvirtual</code>.
<a name="262784"></a>
<li>Otherwise, if the part of the method invocation before the left parenthesis is of the form <code>super</code> <code>.</code> <em>Identifier</em> or of the form <i>ClassName</i>.<code>super</code>.<i>Identifier</i> then the invocation mode is <code>super</code>.
<a name="38796"></a>
<li>Otherwise, if the compile-time declaration is in an interface, then the invocation mode is <code>interface</code>.
<a name="38732"></a>
<li>Otherwise, the invocation mode is <code>virtual</code>.
</ul>
</ul><a name="38220"></a>
If the compile-time declaration for the method invocation is not <code>void</code>, then the type of the method invocation expression is the result type specified in the compile-time declaration.<p>
<a name="45677"></a>
<a name="15.12.4"></a>
<h3>15.12.4    Runtime Evaluation of Method Invocation</h3>
<a name="45678"></a>
At run time, method invocation requires five steps. First, a <em>target reference</em> may be computed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the method to be executed is located. Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code.<p>
<a name="299937"></a>
<a name="15.12.4.1"></a>
<h4>15.12.4.1    Compute Target Reference (If Necessary)</h4>
<a name="38338"></a>
There are several cases to consider, depending on which of the five productions for <em>MethodInvocation</em> <a href="expressions.html#20448">(&#167;15.12)</a> is involved:<p>
<ul><a name="239420"></a>
<li>If the first production for <em>MethodInvocation</em>, which includes a <em>MethodName</em>, is involved, then there are three subcases:
<ul>
<a name="239421"></a>
<li>If the <em>MethodName</em> is a simple name, that is, just an <em>Identifier</em>, then there are two subcases:
<ul>
<a name="38362"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="267467"></a>
<li>Otherwise, let <i>T</i> be the enclosing type declaration of which the method is a member, and let <i>n</i> be an integer such that <i>T</i> is the <i>n</i>th lexically enclosing type declaration <a href="classes.html#295574">(&#167;8.1.3)</a> of the class whose declaration immediately contains the method invocation. Then the target reference is the <i>n</i>th lexically enclosing instance <a href="classes.html#295574">(&#167;8.1.3)</a> of <code>this</code>. It is a compile-time error if the <i>n</i>th lexically enclosing instance <a href="classes.html#295574">(&#167;8.1.3)</a> of <code>this</code> does not exist.
</ul>
<a name="38341"></a>
<li>If the <em>MethodName</em> is a qualified name of the form <em>TypeName</em> <code>.</code> <em>Identifier</em>, then there is no target reference.
<a name="38805"></a>
<li>If the <em>MethodName</em> is a qualified name of the form <em>FieldName</em> <code>.</code> <em>Identifier</em>, then there are two subcases:
<ul>
<a name="38806"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference. The expression <em>FieldName </em>is evaluated, but the result is then discarded.
<a name="38807"></a>
<li>Otherwise, the target reference is the value of the expression <em>FieldName</em>.
</ul>
</ul>
<a name="38815"></a>
<li>If the second production for <em>MethodInvocation</em>, which includes a <em>Primary</em>, is involved, then there are two subcases:
<ul>
<a name="38816"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference. The expression <em>Primary </em>is evaluated, but the result is then discarded.
<a name="38817"></a>
<li>Otherwise, the expression <em>Primary </em>is evaluated and the result is used as the target reference.
</ul>
</ul><ul><a name="38346"></a>
<p>In either case, if the evaluation of the <em>Primary</em> expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
</ul><ul><a name="38347"></a>
<li>If the third production for <em>MethodInvocation</em>, which includes the keyword <code>super</code>, is involved, then the target reference is the value of <code>this</code>.
<a name="251575"></a>
<li>If the fourth production for <i>MethodInvocation</i>, <i>ClassName</i>.<code>super</code>, is involved, then the target reference is the value of <i>ClassName</i>.<code>this</code>.
<a name="385790"></a>
<li>If the fifth production for <i>MethodInvocation</i>, beginning with <i>TypeName.NonWildTypeArguments</i>, is involved, then there is no target reference.
</ul><a name="45449"></a>
<a name="15.12.4.2"></a>
<h4>15.12.4.2    Evaluate Arguments</h4>
<a name="299964"></a>
The process of evaluating of the argument list differs, depending on whether the method being invoked is a fixed arity method or a variable arity method <a href="classes.html#38698">(&#167;8.4.1)</a>. <p>
<a name="299978"></a>
If the method being invoked is a variable arity method <a href="classes.html#38698">(&#167;8.4.1)</a> <i>m</i>, it necessarily has <i>n</i>&gt;0 formal parameters. The final formal parameter of <i>m</i> necessarily has type <i>T[]</i> for some <i>T</i>, and <i>m</i> is necessarily being invoked with <i>k</i><img src="chars/gtequal.gif">0 actual argument expressions.<p>
<a name="299962"></a>
If <i>m</i> is being invoked with <i>k</i><img src="chars/notequal.gif"><i>n</i> actual argument expressions, or, if <i>m</i> is being invoked with <i>k</i>=<i>n</i> actual argument expressions and the type of the <i>k</i>th argument expression is not assignment compatible with <i>T[]</i>, then the argument list <i>(e<sub>1</sub>, ... , e<sub>n-1</sub>, e<sub>n</sub>, ...e<sub>k</sub>)</i> is evaluated as if it were written as <i>(e<sub>1</sub>, ..., e<sub>n-1</sub>, new T[]{e<sub>n</sub>, ..., e<sub>k</sub>})</i>.<p>
<a name="299961"></a>
The argument expressions (possibly rewritten as described above) are now evaluated to yield <i>argument values</i>. Each argument value corresponds to exactly one of the method's <i>n</i> formal parameters. <p>
<a name="299872"></a>
The argument expressions, if any, are evaluated in order, from left to right. If the evaluation of any argument expression completes abruptly, then no part of any argument expression to its right appears to have been evaluated, and the method invocation completes abruptly for the same reason.The result of evaluating the <i>j</i>th argument expression is the <i>j</i>th argument value, for 1<img src="chars/lt_equal.gif"><i>j</i><img src="chars/lt_equal.gif"><i>n</i>. Evaluation then continues, using the argument values, as described below.<p>
<a name="45453"></a>
<a name="15.12.4.3"></a>
<h4>15.12.4.3    Check Accessibility of Type and Method</h4>
<a name="251693"></a>
Let <i>C</i> be the class containing the method invocation, and let <i>T</i> be the qualifying type of the method invocation <a href="binaryComp.html#44909">(&#167;13.1)</a>, and <i>m</i> be the name of the method, as determined at compile time <a href="expressions.html#23617">(&#167;15.12.3)</a>. An implementation of the Java programming language must insure, as part of linkage, that the method <i>m</i> still exists in the type <i>T</i>. If this is not true, then a <code>NoSuchMethodError</code> (which is a subclass of <code>IncompatibleClassChangeError</code>) occurs. If the invocation mode is <code>interface</code>, then the implementation must also check that the target reference type still implements the specified interface. If the target reference type does not still implement the interface, then an <code>IncompatibleClassChangeError</code> occurs.<p>
<a name="251696"></a>
The implementation must also insure, during linkage, that the type <i>T</i> and the method <i>m</i> are accessible. For the type <i>T</i>:<p>
<ul><a name="45547"></a>
<li>If <i>T</i> is in the same package as <i>C</i>, then <i>T</i> is accessible.
<a name="45548"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is <code>public</code>, then <i>T</i> is accessible.
<a name="253445"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is protected, then <i>T</i> is accessible if and only if <i>C</i> is a subclass of <i>T</i>.
</ul><a name="239521"></a>
For the method <i>m</i>:<p>
<ul><a name="45542"></a>
<li>If <i>m</i> is <code>public</code>, then <i>m</i> is accessible. (All members of interfaces are <code>public</code> <a href="interfaces.html#32392">(&#167;9.2)</a>).
<a name="45694"></a>
<li>If <i>m</i> is <code>protected</code>, then <i>m</i> is accessible if and only if either <i>T</i> is in the same package as <i>C</i>, or <i>C</i> is <i>T</i> or a subclass of <i>T</i>.
<a name="45695"></a>
<li>If <i>m</i> has default (package) access, then <i>m</i> is accessible if and only if <i>T</i> is in the same package as <i>C</i>.
<a name="45565"></a>
<li>If <i>m</i> is <code>private</code>, then <i>m</i> is accessible if and only if  <i>C</i> is <i>T</i>, or <i>C</i> encloses <i>T</i>, or <i>T</i> encloses <i>C</i>, or <i>T</i> and <i>C</i> are both enclosed by a third class.
</ul><a name="45566"></a>
If either <i>T</i> or <i>m</i> is not accessible, then an <code>IllegalAccessError</code> occurs <a href="execution.html#44487">(&#167;12.3)</a>.<p>
<a name="45606"></a>
<a name="15.12.4.4"></a>
<h4>15.12.4.4    Locate Method to Invoke</h4>
<a name="38785"></a>
The strategy for method lookup depends on the invocation mode.<p>
<a name="45702"></a>
If the invocation mode is <code>static</code>, no target reference is needed and overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="45395"></a>
Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is <code>null</code>, a <code>NullPointerException</code> is thrown at this point. Otherwise, the target reference is said to refer to a <em>target object</em> and will be used as the value of the keyword <code>this</code> in the invoked method. The other four possibilities for the invocation mode are then considered.<p>
<a name="38856"></a>
If the invocation mode is <code>nonvirtual</code>, overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="38864"></a>
Otherwise, the invocation mode is <code>interface</code>, <code>virtual</code>, or <code>super</code>, and overriding may occur. A <em>dynamic method lookup</em> is used. The dynamic lookup process starts from a class <i>S</i>, determined as follows:<p>
<ul><a name="290412"></a>
<li>If the invocation mode is <code>interface</code> or <code>virtual</code>, then <i>S</i> is initially the actual run-time class <i>R</i> of the target object. This is true even if the target object is an array instance. (Note that for invocation mode <code>interface</code>, <i>R</i> necessarily implements <i>T</i>; for invocation mode <code>virtual</code>, <i>R</i> is necessarily either <i>T</i> or a subclass of <i>T</i>.)
<a name="45403"></a>
<li>If the invocation mode is <code>super</code>, then <i>S</i> is initially the qualifying type <a href="binaryComp.html#44909">(&#167;13.1)</a> of the method invocation.
</ul><a name="39033"></a>
The dynamic method lookup uses the following procedure to search class <i>S</i>, and then the superclasses of class <i>S</i>, as necessary, for method <i>m</i>.<p>
<a name="250473"></a>
Let <i>X</i> be the compile-time type of the target reference of the method invocation.<p>
<ol>
<a name="250480"></a>
<li>If class <i>S</i> contains a declaration for a non-abstract method named <i>m</i> with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time <a href="expressions.html#23617">(&#167;15.12.3)</a>, then:
<ul>
<a name="250485"></a>
<li>If the invocation mode is <code>super</code> or <code>interface</code>, then this is the method to be invoked, and the procedure terminates.
<a name="250487"></a>
<li>If the invocation mode is <code>virtual</code>, and the declaration in <i>S</i> overrides <a href="classes.html#227927">(&#167;8.4.8.1)</a> <i>X.m</i>, then the method declared in <i>S</i> is the method to be invoked, and the procedure terminates.
</ul>
<a name="267561"></a>
<li>Otherwise, if <i>S</i> has a superclass, this same lookup procedure is performed recursively using the direct superclass of <i>S</i> in place of <i>S</i>; the method to be invoked is the result of the recursive invocation of this lookup procedure.
<a name="267569"></a>
</ol>
<p>The above procedure will always find a non-abstract, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled. However, if this is not the case, then various errors may occur. The specification of the behavior of a Java virtual machine under these circumstances is given by <em>The Java Virtual Machine Specification</em>.We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.</p>
<a name="39078"></a>
<a name="15.12.4.5"></a>
<h4>15.12.4.5    Create Frame, Synchronize, Transfer Control</h4>
<a name="39080"></a>
A method <i>m</i> in some class <i>S</i> has been identified as the one to be invoked.<p>
<a name="39084"></a>
Now a new <em>activation frame</em> is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, an <code>StackOverflowError</code> is thrown.<p>
<a name="39085"></a>
The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as <code>this</code>, if there is a target reference. Before each argument value is assigned to its corresponding parameter variable, it is subjected to method invocation conversion <a href="conversions.html#12687">(&#167;5.3)</a>, which includes any required value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>.<p>
<a name="348914"></a>
If the erasure of the type of the method being invoked differs in its signature from the erasure of the type of the compile-time declaration for the method invocation <a href="expressions.html#23617">(&#167;15.12.3)</a>, then if any of the argument values is an object which is not an instance of a subclass or subinterface of the erasure of the corresponding formal parameter type in the compile-time declaration for the method invocation, then a <code>ClassCastException</code> is thrown.<p>
<a name="348946"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="348947"></a>
 As an example of such a situation, consider the declarations:<p>
<blockquote><pre>class C&lt;T&gt; { abstract T id(T x); }
class D extends C&lt;String&gt; { String id(String x) { return x; } }
</pre></blockquote><a name="348948"></a>
Now, given an invocation<p>
<blockquote><pre>C c = new D();
c.id(new Object()); // fails with a ClassCastException
</pre></blockquote><a name="348960"></a>
The erasure of the actual method being invoked, <code.D.id()</code>, differs in its signature from that of the compile-time method declaration, <code>C.id()</code>. The former takes an argument of type <code>String</code> while the latter takes an argument of type <code>Object</code>. The invocation fails with a <code>ClassCastException</code> before the body of the method is executed.<p>
<a name="348987"></a>
Such situations can only arise if the program gives rise to an unchecked warning <a href="conversions.html#190772">(&#167;5.1.9)</a>.<p>
<a name="348991"></a>
Implementations can enforce these semantics by creating <i>bridge methods</i>. In the above example, the following bridge method would be created in class <code>D</code>:<p>
<blockquote><pre>Object id(Object x) { return id((String) x); }
</pre></blockquote><a name="349005"></a>
This is the method that would actually be invoked by the Java virtual machine in response to the call <code>c.id(new Object())</code> shown above, and it will execute the cast and fail, as required.<p>
<hr>
<a name="348949"></a>
 <p>
<a name="42183"></a>
If the method <i>m</i> is a <code>native</code> method but the necessary native, implementation-dependent binary code has not been loaded or otherwise cannot be dynamically linked, then an <code>UnsatisfiedLinkError</code> is thrown.<p>
<a name="41731"></a>
If the method <i>m</i> is not <code>synchronized</code>, control is transferred to the body of the method <i>m</i> to be invoked.<p>
<a name="382410"></a>
If the method <i>m</i> is <code>synchronized</code>, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target must be locked; otherwise the <code>Class</code> object for class <i>S</i>, the class of the method <i>m</i>, must be locked. Control is then transferred to the body of the method <i>m</i> to be invoked. The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a>.<p>
<a name="382779"></a>
<p>
<a name="382776"></a>
<a name="15.12.4.6"></a>
<h4>15.12.4.6    Example: Target Reference and Static Methods</h4>
<a name="39148"></a>
When a target reference is computed and then discarded because the invocation mode is <code>static</code>, the reference is not examined to see whether it is <code>null</code>:<p>
<blockquote><pre>class Test {
        static void mountain() {
                System.out.println("Monadnock");
        }
        static Test favorite(){
                System.out.print("Mount ");
                return null;
        }
        public static void main(String[] args) {
                favorite().mountain();
        }
}
</pre></blockquote><a name="39138"></a>
which prints:<p>
<blockquote><pre>Mount Monadnock
</pre></blockquote><a name="39140"></a>
Here <code>favorite</code> returns <code>null</code>, yet no <code>NullPointerException</code> is thrown.<p>
<a name="23837"></a>
<a name="15.12.4.7"></a>
<h4>15.12.4.7    Example: Evaluation Order</h4>
<a name="23841"></a>
As part of an instance method invocation <a href="expressions.html#20448">(&#167;15.12)</a>, there is an expression that denotes the object to be invoked. This expression appears to be fully evaluated before any part of any argument expression to the method invocation is evaluated.<p>
<a name="23842"></a>
<p>So, for example, in:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                String s = "one";
                if (s.startsWith(s = "two"))
                        System.out.println("oops");
        }
}
</pre></blockquote><a name="272804"></a>
the occurrence of <code>s</code> before "<code>.startsWith</code>" is evaluated first, before the argument expression <code>s="two"</code>. Therefore, a reference to the string <code>"one"</code> is remembered as the target reference before the local variable s is changed to refer to the string <code>"two"</code>. As a result, the <code>startsWith</code> method is invoked for target object <code>"one"</code> with argument <code>"two"</code>, so the result of the invocation is <code>false</code>, as the string <code>"one"</code> does not start with <code>"two"</code>. It follows that the test program does not print "<code>oops</code>".<p>
<a name="239650"></a>
<a name="15.12.4.8"></a>
<h4>15.12.4.8    Example: Overriding</h4>
<a name="239651"></a>
In the example:<p>
<blockquote><pre>class Point {
        final int EDGE = 20;
        int x, y;
        void move(int dx, int dy) {
                x += dx; y += dy;
                if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
                        clear();
        }
        void clear() {
                System.out.println("\tPoint clear");
                x = 0; y = 0;
        }
}
class ColoredPoint extends Point {
        int color;
        void clear() {
                System.out.println("\tColoredPoint clear");
                super.clear();
                color = 0;
        }
}
</pre></blockquote><a name="239673"></a>
the subclass <code>ColoredPoint</code> extends the <code>clear</code> abstraction defined by its superclass <code>Point</code>. It does so by overriding the <code>clear</code> method with its own method, which invokes the <code>clear</code> method of its superclass, using the form <code>super.clear</code>.<p>
<a name="239674"></a>
<p>This method is then invoked whenever the target object for an invocation of <code>clear</code> is a <code>ColoredPoint</code>. Even the method <code>move</code> in <code>Point</code> invokes the <code>clear</code> method of class <code>ColoredPoint</code> when the class of <code>this</code> is <code>ColoredPoint</code>, as shown by the output of this test program:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                Point p = new Point();
                System.out.println("p.move(20,20):");
                p.move(20, 20);
                ColoredPoint cp = new ColoredPoint();
                System.out.println("cp.move(20,20):");
                cp.move(20, 20);
                p = new ColoredPoint();
                System.out.println("p.move(20,20), p colored:");
                p.move(20, 20);
        }
}
</pre></blockquote><a name="239688"></a>
which is:<p>
<blockquote><pre>p.move(20,20):
        Point clear
cp.move(20,20):
        ColoredPoint clear
        Point clear
p.move(20,20), p colored:
        ColoredPoint clear
        Point clear
        </pre></blockquote>
<a name="239749"></a>
<p>Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to <code>clear</code> in the body of <code>Point.move</code> (which is really syntactic shorthand for <code>this.clear</code>) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by <code>this</code>) rather than a method chosen "early" (at compile time, based only on the type of <code>this</code>). This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.</p>
</pre></blockquote><a name="239751"></a>
<a name="15.12.4.9"></a>
<h4>15.12.4.9    Example: Method Invocation using super</h4>
<a name="239647"></a>
An overridden instance method of a superclass may be accessed by using the keyword <code>super</code> to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation.<p>
<a name="39225"></a>
<p>When accessing an instance variable, <code>super</code> means the same as a cast of <code>this</code> <a href="expressions.html#20860">(&#167;15.11.2)</a>, but this equivalence does not hold true for method invocation. This is demonstrated by the example:</p>
<blockquote><pre>class T1 {
        String s() { return "1"; }
}
class T2 extends T1 {
        String s() { return "2"; }
}
class T3 extends T2 {
        String s() { return "3"; }
        void test() {
                System.out.println("s()=\t\t"+s());
                System.out.println("super.s()=\t"+super.s());
                System.out.print("((T2)this).s()=\t");
                System.out.println(((T2)this).s());
                System.out.print("((T1)this).s()=\t");
                System.out.println(((T1)this).s());
        }
}
class Test {
        public static void main(String[] args) {
                T3 t3 = new T3();
                t3.test();
        }
}
</pre></blockquote><a name="42586"></a>
which produces the output:<p>
<blockquote><pre>s()=                   3
super.s()=              2
((T2)this).s()=         3
((T1)this).s()=         3
</pre></blockquote>
<a name="264502"></a>
<p>The casts to types <code>T1</code> and <code>T2</code> do not change the method that is invoked, because the instance method to be invoked is chosen according to the run-time class of the object referred to be <code>this</code>. A cast does not change the class of an object; it only checks that the class is compatible with the specified type.</p>
<a name="239587"></a>
<a name="15.13"></a>
<h2>15.13    Array Access Expressions</h2>
<a name="39327"></a>
An array access expression refers to a variable that is a component of an array.<p>
<blockquote><pre><em>
ArrayAccess:
        ExpressionName </em>[<em> Expression</em> ]<em>
        PrimaryNoNewArray </em>[<em> Expression</em> ]
</pre></blockquote><a name="19392"></a>
An array access expression contains two subexpressions, the <em>array reference expression</em> (before the left bracket) and the <em>index expression</em> (within the brackets). Note that the array reference expression may be a name or any primary expression that is not an array creation expression <a href="expressions.html#46168">(&#167;15.10)</a>.<p>
<a name="22123"></a>
The type of the array reference expression must be an array type (call it <i>T[]</i>, an array whose components are of type <i>T</i>) or a compile-time error results. Then the type of the array access expression is the result of applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to <i>T</i>. <p>
<a name="22103"></a>
The index expression undergoes unary numeric promotion <a href="conversions.html#203523">(&#167;)</a>; the promoted type must be <code>int</code>.<p>
<a name="23960"></a>
The result of an array reference is a variable of type <i>T</i>, namely the variable within the array selected by the value of the index expression. This resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference was obtained from a <code>final</code> variable.<p>
<a name="23958"></a>
<a name="15.13.1"></a>
<h3>15.13.1    Runtime Evaluation of Array Access</h3>
<a name="39346"></a>
An array access expression is evaluated using the following procedure:<p>
<ul><a name="22142"></a>
<li>First, the array reference expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason and the index expression is not evaluated.
<a name="22130"></a>
<li>Otherwise, the index expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
<a name="22098"></a>
<li>Otherwise, if the value of the array reference expression is <code>null</code>, then a <code>NullPointerException</code> &#32;is thrown.
<a name="6936"></a>
<li>Otherwise, the value of the array reference expression indeed refers to an array. If the value of the index expression is less than zero, or greater than or equal to the array's length, then an <code>ArrayIndexOutOfBoundsException</code> is thrown.
<a name="264507"></a>
<li>Otherwise, the result of the array access is the variable of type <i>T</i>, within the array, selected by the value of the index expression. (Note that this resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference expression is a <code>final</code> variable.)
</ul><a name="23902"></a>
<a name="15.13.2"></a>
<h3>15.13.2    Examples: Array Access Evaluation Order</h3>
<a name="23906"></a>
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. For example, in the (admittedly monstrous) expression <code>a[(a=b)[3]]</code>, the expression <code>a</code> is fully evaluated before the expression <code>(a=b)[3]</code>; this means that the original value of <code>a</code> is fetched and remembered while the expression <code>(a=b)[3]</code> is evaluated. This array referenced by the original value of <code>a</code> is then subscripted by a value that is element <code>3</code> of another array (possibly the same array) that was referenced by <code>b</code> and is now also referenced by <code>a</code>.<p>
<a name="23907"></a>
<p>Thus, the example:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int[] a = { 11, 12, 13, 14 };
                int[] b = { 0, 1, 2, 3 };
                System.out.println(a[(a=b)[3]]);
        }
}
</pre></blockquote><a name="23915"></a>
prints:<p>
<blockquote><pre>14
</pre></blockquote><a name="290083"></a>
because the monstrous expression's value is equivalent to <code>a[b[3]]</code> or <code>a[3]</code> or <code>14</code>.<p>
<a name="290084"></a>
<p>If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the example:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int index = 1;
                try {
                        skedaddle()[index=2]++;
                } catch (Exception e) {
                        System.out.println(e + ", index=" + index);
                }
        }
        static int[] skedaddle() throws Exception {
                throw new Exception("Ciao");
        }
}
</pre></blockquote><a name="23931"></a>
prints: <p>
<blockquote><pre>java.lang.Exception: Ciao, index=1
</pre></blockquote><a name="23933"></a>
because the embedded assignment of <code>2</code> to <code>index</code> never occurs.<p>
<a name="23937"></a>
<p>If the array reference expression produces <code>null</code> instead of a reference to an array, then a <code>NullPointerException</code> is thrown at run time, but only after all parts of the array access expression have been evaluated and only if these evaluations completed normally. Thus, the example:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int index = 1;
                try {
                        nada()[index=2]++;
                } catch (Exception e) {
                        System.out.println(e + ", index=" + index);
                }
        }
        static int[] nada() { return null; }
}
</pre></blockquote><a name="23950"></a>
prints:<p>
<blockquote><pre>java.lang.NullPointerException, index=2
</pre></blockquote><a name="23952"></a>
because the embedded assignment of <code>2</code> to <code>index</code> occurs before the check for a null pointer. As a related example, the program:<p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int[] a = null;
                try {
                        int <i>i</i> = a[vamoose()];
                        System.out.println(i);
                } catch (Exception e) {
                        System.out.println(e);
                }
        }
        static int vamoose() throws Exception {
                throw new Exception("Twenty-three skidoo!");
        }
}
</pre></blockquote><a name="36149"></a>
always prints:<p>
<blockquote><pre>java.lang.Exception: Twenty-three skidoo!
</pre></blockquote>
<a name="264512"></a>
<p>A <code>NullPointerException</code> never occurs, because the index expression must be completely evaluated before any part of the indexing operation occurs, and that includes the check as to whether the value of the left-hand operand is <code>null</code>.</p>
</pre></blockquote><a name="36254"></a>
<a name="15.14"></a>
<h2>15.14    Postfix Expressions</h2>
<a name="39432"></a>
Postfix expressions include uses of the postfix <code>++</code> and <code>--</code> operators. Also, as discussed in <a href="expressions.html#23302">&#167;15.8</a>, names are not considered to be primary expressions, but are handled separately in the grammar to avoid certain ambiguities. They become interchangeable only here, at the level of precedence of postfix expressions.<p>
<blockquote><pre><em>
PostfixExpression:
        Primary
        ExpressionName
        PostIncrementExpression
        PostDecrementExpression</em>
</pre></blockquote><a name="39438"></a>
<a name="15.14.1"></a>
<h3>15.14.1    Expression Names</h3>
<a name="292384"></a>
The rules for evaluating expression names are given in <a href="names.html#129350">&#167;6.5.6</a>. <p>
<a name="292383"></a>
<a name="15.14.2"></a>
<h3>15.14.2    Postfix Increment Operator ++</h3>
<blockquote><pre><em>
PostIncrementExpression:
        PostfixExpression </em>++
</pre></blockquote><a name="40093"></a>
A postfix expression followed by a <code>++</code> operator is a postfix increment expression. The result of the postfix expression must be a variable of a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a numeric type, or a compile-time error occurs. The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value.<p>
<a name="249305"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="conversions.html#25363">(&#167;5.1.3)</a> and/or subjected to boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable <em>before </em>the new value is stored.<p>
<a name="249315"></a>
Note that the binary numeric promotion mentioned above may include unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>. If necessary, value set conversion is applied to the sum prior to its being stored in the variable.<p>
<a name="249312"></a>
A variable that is declared <code>final</code> cannot be incremented (unless it is a definitely unassigned (<a href="defAssign.html#25979">&#167;16</a>) blank final variable <a href="typesValues.html#10931">(&#167;4.12.4)</a>), because when an access of such a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix increment operator.<p>
<a name="4987"></a>
<a name="15.14.3"></a>
<h3>15.14.3    Postfix Decrement Operator --</h3>
<blockquote><pre><em>
PostDecrementExpression:
        PostfixExpression </em>--
</pre></blockquote><a name="40094"></a>
A postfix expression followed by a <code>--</code> operator is a postfix decrement expression. The result of the postfix expression must be a variable of a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a numeric type, or a compile-time error occurs. The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value.<p>
<a name="39668"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="conversions.html#25363">(&#167;5.1.3)</a> and/or subjected to boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable <em>before </em>the new value is stored.<p>
<a name="249327"></a>
Note that the binary numeric promotion mentioned above may include unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>. If necessary, value set conversion is applied to the difference prior to its being stored in the variable.<p>
<a name="41352"></a>
A variable that is declared <code>final</code> cannot be decremented (unless it is a definitely unassigned (<a href="defAssign.html#25979">&#167;16</a>) blank final variable <a href="typesValues.html#10931">(&#167;4.12.4)</a>), because when an access of such a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix decrement operator.<p>
<a name="4990"></a>
<a name="15.15"></a>
<h2>15.15    Unary Operators</h2>
<a name="31520"></a>
The <em>unary operators</em> include <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and cast operators. Expressions with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.<p>
<blockquote><pre><em>
UnaryExpression:
        PreIncrementExpression
        PreDecrementExpression
        </em>+<em> UnaryExpression
        </em>-<em> UnaryExpression
        UnaryExpressionNotPlusMinus

PreIncrementExpression:
        </em>++<em> UnaryExpression

PreDecrementExpression:
        </em>--<em> UnaryExpression

UnaryExpressionNotPlusMinus:
        PostfixExpression
        </em>~<em> UnaryExpression
        </em>!<em> UnaryExpression
        CastExpression</em>
</pre></blockquote><a name="29719"></a>
The following productions from <a href="expressions.html#238146">&#167;15.16</a> are repeated here for convenience:<p>
<blockquote><pre><em>
CastExpression:
        </em>(<em> PrimitiveType </em>)<em> UnaryExpression
        </em>(<em> ReferenceType </em>)<em>&#32;UnaryExpressionNotPlusMinus</em>
</pre></blockquote><a name="39547"></a>
<a name="15.15.1"></a>
<h3>15.15.1    Prefix Increment Operator ++</h3>
<a name="5002"></a>
A unary expression preceded by a <code>++</code> operator is a prefix increment expression. The result of the unary expression must be a variable of a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a numeric type, or a compile-time error occurs. The type of the prefix increment expression is the type of the variable. The result of the prefix increment expression is not a variable, but a value.<p>
<a name="39621"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="conversions.html#25363">(&#167;5.1.3)</a> and/or subjected to boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable <em>after </em>the new value is stored.<p>
<a name="249342"></a>
Note that the binary numeric promotion mentioned above may include unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>. If necessary, value set conversion is applied to the sum prior to its being stored in the variable.<p>
<a name="239134"></a>
A variable that is declared <code>final</code> cannot be incremented (unless it is a definitely unassigned (<a href="defAssign.html#25979">&#167;16</a>) blank final variable <a href="typesValues.html#10931">(&#167;4.12.4)</a>), because when an access of such a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix increment operator.<p>
<a name="239136"></a>
<a name="15.15.2"></a>
<h3>15.15.2    Prefix Decrement Operator --</h3>
<a name="5005"></a>
A unary expression preceded by a <code>--</code> operator is a prefix decrement expression. The result of the unary expression must be a variable of a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a numeric type, or a compile-time error occurs. The type of the prefix decrement expression is the type of the variable. The result of the prefix decrement expression is not a variable, but a value.<p>
<a name="39634"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="conversions.html#25363">(&#167;5.1.3)</a> and/or subjected to boxing conversion <a href="conversions.html#190697">(&#167;5.1.7)</a> to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable <em>after </em>the new value is stored.<p>
<a name="249349"></a>
Note that the binary numeric promotion mentioned above may include unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>. If necessary, format conversion is applied to the difference prior to its being stored in the variable.<p>
<a name="41323"></a>
A variable that is declared <code>final</code> cannot be decremented (unless it is a definitely unassigned (<a href="defAssign.html#25979">&#167;16</a>) blank final variable <a href="typesValues.html#10931">(&#167;4.12.4)</a>), because when an access of such a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix decrement operator.<p>
<a name="24924"></a>
<a name="15.15.3"></a>
<h3>15.15.3    Unary Plus Operator +</h3>
<a name="24926"></a>
The type of the operand expression of the unary <code>+</code> operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.html#203523">(&#167;)</a> is performed on the operand. The type of the unary plus expression is the promoted type of the operand. The result of the unary plus expression is not a variable, but a value, even if the result of the operand expression is a variable.<p>
<a name="39701"></a>
At run time, the value of the unary plus expression is the promoted value of the operand.<p>
<a name="236345"></a>
<a name="15.15.4"></a>
<h3>15.15.4    Unary Minus Operator -</h3>
<a name="39711"></a>
The type of the operand expression of the unary <code>-</code> operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.html#203523">(&#167;)</a> is performed on the operand. The type of the unary minus expression is the promoted type of the operand.<p>
<a name="251073"></a>
Note that unary numeric promotion performs value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>. Whatever value set the promoted operand value is drawn from, the unary negation operation is carried out and the result is drawn from that same value set. That result is then subject to further value set conversion.<p>
<a name="249384"></a>
At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand.<p>
<a name="79921"></a>
For integer values, negation is the same as subtraction from zero. The Java programming language uses two's-complement representation for integers, and the range of two's-complement values is not symmetric, so negation of the maximum negative <code>int</code> or <code>long</code> results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values <code>x</code>, <code>-x</code> equals <code>(~x)+1</code>.<p>
<a name="5013"></a>
For floating-point values, negation is not the same as subtraction from zero, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> is <code>+0.0</code>, but <code>-x</code> is <code>-0.0</code>. Unary minus merely inverts the sign of a floating-point number. Special cases of interest:<p>
<ul><a name="5014"></a>
<li>If the operand is NaN, the result is NaN (recall that NaN has no sign).
<a name="5015"></a>
<li>If the operand is an infinity, the result is the infinity of opposite sign.
<a name="5016"></a>
<li>If the operand is a zero, the result is the zero of opposite sign.
</ul><a name="5017"></a>
<a name="15.15.5"></a>
<h3>15.15.5    Bitwise Complement Operator ~</h3>
<a name="39739"></a>
The type of the operand expression of the unary <code>~</code> operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive integral type, or a compile-time error occurs. Unary numeric promotion <a href="conversions.html#203523">(&#167;)</a> is performed on the operand. The type of the unary bitwise complement expression is the promoted type of the operand.<p>
<a name="39743"></a>
At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand; note that, in all cases, <code>~x</code> &#32;equals <code>(-x)-1</code>.<p>
<a name="13350"></a>
<a name="15.15.6"></a>
<h3>15.15.6    Logical Complement Operator !</h3>
<a name="39767"></a>
The type of the operand expression of the unary <code>!</code> operator must be <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs. The type of the unary logical complement expression is <code>boolean</code>.<p>
<a name="39771"></a>
At run time, the operand is subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> if necessary; the value of the unary logical complement expression is <code>true</code> if the (possibly converted) operand value is <code>false</code> and <code>false</code> if the (possibly converted) operand value is <code>true</code>.<p>
<a name="238146"></a>
<a name="15.16"></a>
<h2>15.16    Cast Expressions</h2>
<a name="236464"></a>
A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is <code>boolean</code>; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type.<p>
<blockquote><pre><em>
CastExpression:
        </em>(<em> PrimitiveType Dims<sub><i>opt</i></sub> </em>)<em> UnaryExpression
        </em>(<em> ReferenceType </em>)<em> UnaryExpressionNotPlusMinus</em>
        </pre></blockquote>
        <p>
See <a href="expressions.html#4990">&#167;15.15</a> for a discussion of the distinction between <em>UnaryExpression</em> and <em>UnaryExpressionNotPlusMinus</em>.<p>
<a name="39826"></a>
The type of a cast expression is the result of applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to the type whose name appears within the parentheses. (The parentheses and the type they contain are sometimes called the <em>cast operator</em>.) The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.<p>
<a name="251082"></a>
A cast operator has no effect on the choice of value set <a href="typesValues.html#9208">(&#167;4.2.3)</a> for a value of type <code>float</code> or type <code>double</code>. Consequently, a cast to type <code>float</code> within an expression that is not FP-strict <a href="expressions.html#249198">(&#167;15.4)</a> does not necessarily cause its value to be converted to an element of the float value set, and a cast to type <code>double</code> within an expression that is not FP-strict does not necessarily cause its value to be converted to an element of the double value set.<p>
<a name="386906"></a>
It is a compile-time error if the compile-time type of the operand may never be cast to the type specified by the cast operator according to the rules of casting conversion <a href="conversions.html#20232">(&#167;5.5)</a>. Otherwise, at run-time, the operand value is converted (if necessary) by casting conversion to the type specified by the cast operator.<p>
<a name="386911"></a>
<p>Some casts result in an error at compile time. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time. See for <a href="conversions.html#20232">&#167;5.5</a> details.</p>
<a name="264529"></a>
A <code>ClassCastException</code> is thrown if a cast is found at run time to be impermissible.<p>
<a name="386920"></a>
<p>
<a name="239829"></a>
<a name="15.17"></a>
<h2>15.17    Multiplicative Operators</h2>
<a name="5029"></a>
The operators <code>*</code>, <code>/</code>, and <code>%</code> are called the <em>multiplicative operators</em>. They have the same precedence and are syntactically left-associative (they group left-to-right).<p>
<blockquote><pre><em>
MultiplicativeExpression:
        UnaryExpression
        MultiplicativeExpression</em> *<em> UnaryExpression
        MultiplicativeExpression</em> /<em> UnaryExpression
        MultiplicativeExpression</em> %<em> UnaryExpression</em>
</pre></blockquote><a name="39873"></a>
The type of each of the operands of a multiplicative operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands <a href="conversions.html#170983">(&#167;5.6.2)</a>. The type of a multiplicative expression is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="251088"></a>
Note that binary numeric promotion performs unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>.<p>
<a name="5036"></a>
<a name="15.17.1"></a>
<h3>15.17.1    Multiplication Operator *</h3>
<a name="5037"></a>
The binary <code>*</code> operator performs multiplication, producing the product of its operands. Multiplication is a commutative operation if the operand expressions have no side effects. While integer multiplication is associative when the operands are all of the same type, floating-point multiplication is not associative.<p>
<a name="79991"></a>
If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.<p>
<a name="5039"></a>
The result of a floating-point multiplication is governed by the rules of IEEE 754 arithmetic:<p>
<ul><a name="5040"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5041"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs.
<a name="24701"></a>
<li>Multiplication of an infinity by a zero results in NaN.
<a name="24702"></a>
<li>Multiplication of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="251092"></a>
<li>In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical product is computed. A floating-point value set is then chosen:
<ul>
<a name="251093"></a>
<li>If the multiplication expression is FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251094"></a>
<li>If the type of the multiplication expression is <code>float</code>, then the float value set must be chosen.
<a name="251095"></a>
<li>If the type of the multiplication expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251096"></a>
<li>If the multiplication expression is not FP-strict:
<ul>
<a name="251097"></a>
<li>If the type of the multiplication expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251098"></a>
<li>If the type of the multiplication expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251099"></a>
<p>Next, a value must be chosen from the chosen value set to represent the product. If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the product is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5045"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator <code>*</code> never throws a run-time exception.<p>
<a name="5047"></a>
<a name="15.17.2"></a>
<h3>15.17.2    Division Operator /</h3>
<a name="5048"></a>
The binary <code>/</code> operator performs division, producing the quotient of its operands. The left-hand operand is the dividend and the right-hand operand is the divisor.<p>
<a name="45471"></a>
Integer division rounds toward <code>0</code>. That is, the quotient produced for operands <em>n</em> and <em>d</em> that are integers after binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is an integer value <em>q</em> whose magnitude is as large as possible while satisfying |<i>d</i>&#183;<i>q</i>|<img src="chars/lt_equal.gif">|<i>n</i>|; moreover, <em>q </em>is positive when |<i>n</i>|<img src="chars/gtequal.gif">|<i>d</i>| and <em>n</em> and <em>d</em> have the same sign, but <em>q</em> is negative when |<i>n</i>|<img src="chars/gtequal.gif">|<i>d</i>| and <em>n</em> and <em>d </em>have opposite signs. There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is <code>-1</code>, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is <code>0</code>, then an <code>ArithmeticException</code> is thrown.<p>
<a name="45481"></a>
The result of a floating-point division is determined by the specification of IEEE arithmetic:<p>
<ul><a name="5054"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5055"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
<a name="5056"></a>
<li>Division of an infinity by an infinity results in NaN.
<a name="5057"></a>
<li>Division of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="5058"></a>
<li>Division of a finite value by an infinity results in a signed zero. The sign is determined by the rule stated above.
<a name="236610"></a>
<li>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero. The sign is determined by the rule stated above.
<a name="236611"></a>
<li>Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule stated above.
<a name="251106"></a>
<li>In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical quotient is computed. A floating-point value set is then chosen:
<ul>
<a name="251107"></a>
<li>If the division expression is FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251108"></a>
<li>If the type of the division expression is <code>float</code>, then the float value set must be chosen.
<a name="251109"></a>
<li>If the type of the division expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251110"></a>
<li>If the division expression is not FP-strict:
<ul>
<a name="251111"></a>
<li>If the type of the division expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251112"></a>
<li>If the type of the division expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251113"></a>
<p>Next, a value must be chosen from the chosen value set to represent the quotient. If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the quotient is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5062"></a>
Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator <code>/</code> never throws a run-time exception<p>
<a name="24956"></a>
<a name="15.17.3"></a>
<h3>15.17.3    Remainder Operator %</h3>
<a name="264541"></a>
The binary <code>%</code> operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor.<p>
<a name="264546"></a>
<p>In C and C++, the remainder operator accepts only integral operands, but in the Java programming language, it also accepts floating-point operands.</p>
<a name="264551"></a>
The remainder operation for operands that are integers after binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> produces a result value such that <code>(a/b)*b+(a%b)</code> is equal to <code>a</code>. This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is <code>-1</code> (the remainder is <code>0</code>). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor. If the value of the divisor for an integer remainder operator is <code>0</code>, then an <code>ArithmeticException</code> is thrown.Examples:<p>
<blockquote><pre>5%3 produces 2                 (note that 5/3 produces 1)
5%(-3) produces 2               (note that 5/(-3) produces -1)
(-5)%3 produces -2              (note that (-5)/3 produces -1)
(-5)%(-3) produces -2           (note that (-5)/(-3) produces 1)
</pre></blockquote><a name="249585"></a>
The result of a floating-point remainder operation as computed by the <code>%</code> operator is <em>not</em> the same as that produced by the remainder operation defined by IEEE 754. The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is <em>not</em> analogous to that of the usual integer remainder operator. Instead, the Java programming language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function <code>fmod</code>. The IEEE 754 remainder operation may be computed by the library routine <code>Math.IEEEremainder</code>.<p>
<a name="5068"></a>
The result of a floating-point remainder operation is determined by the rules of IEEE arithmetic:<p>
<ul><a name="5069"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5070"></a>
<li>If the result is not NaN, the sign of the result equals the sign of the dividend.
<a name="5071"></a>
<li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
<a name="5072"></a>
<li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.
<a name="5073"></a>
<li>If the dividend is a zero and the divisor is finite, the result equals the dividend.
<a name="5074"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder <em>r</em> from the division of a dividend <em>n</em> by a divisor <em>d</em> is defined by the mathematical relation <i>r</i>=<i>n</i>-(<i>d</i>&#183;<i>q</i>) where <em>q</em> is an integer that is negative only if <i>n</i>/<i>d</i> is negative and positive only if <i>n</i>/<i>d</i> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <em>n</em> and <em>d</em>.
</ul><a name="264565"></a>
Evaluation of a floating-point remainder operator <code>%</code> never throws a run-time exception, even if the right-hand operand is zero. Overflow, underflow, or loss of precision cannot occur.<p>
<a name="40146"></a>
<p>Examples:</p>
<blockquote><pre>5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0
</pre></blockquote><a name="15746"></a>
<a name="15.18"></a>
<h2>15.18    Additive Operators</h2>
<a name="15749"></a>
The operators <code>+</code> and <code>-</code> are called the <em>additive operators</em>. They have the same precedence and are syntactically left-associative (they group left-to-right).<p>
<blockquote><pre><em>
AdditiveExpression:
        MultiplicativeExpression
        AdditiveExpression</em> + <em>MultiplicativeExpression
        AdditiveExpression</em> - <em>MultiplicativeExpression</em>
</pre></blockquote><a name="39987"></a>
If the type of either operand of a + operator is <code>String</code>, then the operation is string concatenation.<p>
<a name="39998"></a>
Otherwise, the type of each of the operands of the <code>+</code> operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. <p>
<a name="40002"></a>
In every case, the type of each of the operands of the binary <code>-</code> operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. <p>
<a name="39990"></a>
<a name="15.18.1"></a>
<h3>15.18.1    String Concatenation Operator +</h3>
<a name="7894"></a>
If only one operand expression is of type <code>String</code>, then string conversion is performed on the other operand to produce a string at run time. The result is a reference to a <code>String</code> object (newly created, unless the expression is a compile-time constant expression <a href="expressions.html#5313">(&#167;15.28)</a>)that is the concatenation of the two operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string. If an operand of type <code>String</code> is <code>null</code>, then the string "<code>null</code>" is used instead of that operand.<p>
<a name="40220"></a>
<a name="15.18.1.1"></a>
<h4>15.18.1.1    String Conversion</h4>
<a name="40222"></a>
Any type may be converted to type <code>String</code> by <em>string conversion</em>.<p>
<a name="22621"></a>
A value <i>x</i> of primitive type <i>T</i> is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression:<p>
<ul><a name="40316"></a>
<li>If <i>T</i> is <code>boolean</code>, then use <code>new</code> <code>Boolean(</code><i>x</i>).
<a name="40320"></a>
<li>If <i>T</i> is <code>char</code>, then use <code>new</code> <code>Character(</code><i>x</i>).
<a name="40265"></a>
<li>If <i>T</i> is <code>byte</code>, <code>short</code>, or <code>int</code>, then use <code>new</code> <code>Integer(</code><i>x</i>).
<a name="40272"></a>
<li>If <i>T</i> is <code>long</code>, then use <code>new</code> <code>Long(</code><i>x</i>).
<a name="40279"></a>
<li>If <i>T</i> is <code>float</code>, then use <code>new</code> <code>Float(</code><i>x</i>).
<a name="40286"></a>
<li>If <i>T</i> is <code>double</code>, then use <code>new</code> <code>Double(</code><i>x</i>).
</ul><a name="40362"></a>
This reference value is then converted to type <code>String</code> by string conversion.<p>
<a name="22740"></a>
Now only reference values need to be considered. If the reference is <code>null</code>, it is converted to the string "<code>null</code>" (four ASCII characters <code>n</code>, <code>u</code>, <code>l</code>, <code>l</code>). Otherwise, the conversion is performed as if by an invocation of the <code>toString</code> method of the referenced object with no arguments; but if the result of invoking the <code>toString</code> method is <code>null</code>, then the string "<code>null</code>" is used instead. <p>
<a name="290252"></a>
The <code>toString</code> method is defined by the primordial class <code>Object</code>; many classes override it, notably <code>Boolean</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double,</code> and <code>String</code>.<p>
<a name="40226"></a>
<a name="15.18.1.2"></a>
<h4>15.18.1.2    Optimization of String Concatenation</h4>
<a name="40227"></a>
An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate <code>String</code> object. To increase the performance of repeated string concatenation, a Java compiler may use the <code>StringBuffer</code> class or a similar technique to reduce the number of intermediate <code>String</code> objects that are created by evaluation of an expression.<p>
<a name="22668"></a>
For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.<p>
<a name="40423"></a>
<a name="15.18.1.3"></a>
<h4>15.18.1.3    Examples of String Concatenation</h4>
<a name="40221"></a>
The example expression:<p>
<blockquote><pre>"The square root of 2 is " + Math.sqrt(2)
</pre></blockquote><a name="21343"></a>
produces the result:<p>
<blockquote><pre>"The square root of 2 is 1.4142135623730952"
</pre></blockquote>
<a name="21344"></a>
<p>The + operator is syntactically left-associative, no matter whether it is later determined by type analysis to represent string concatenation or addition. In some cases care is required to get the desired result. For example, the expression:</p>
<blockquote><pre>
a + b + c
</pre></blockquote><a name="40518"></a>
is always regarded as meaning:<p>
<blockquote><pre>(a + b) + c
</pre></blockquote><a name="40520"></a>
Therefore the result of the expression:<p>
<blockquote><pre>1 + 2 + " fiddlers"
</pre></blockquote><a name="40522"></a>
is:<p>
<blockquote><pre>"3 fiddlers"
</pre></blockquote><a name="40524"></a>
but the result of:<p>
<blockquote><pre>"fiddlers " + 1 + 2
</pre></blockquote><a name="40526"></a>
is:<p>
<blockquote><pre>"fiddlers 12"
</pre></blockquote>
<a name="238156"></a>
<p>In this jocular little example:</p>
<blockquote><pre>
class Bottles {
        static void printSong(Object stuff, int n) {
                String plural = (n == 1) ? "" : "s";
                loop: while (true) {
                        System.out.println(n + " bottle" + plural
                                + " of " + stuff + " on the wall,");
                        System.out.println(n + " bottle" + plural
                                + " of " + stuff + ";");
                        System.out.println("You take one down "
                                + "and pass it around:");
                        --n;
                        plural = (n == 1) ? "" : "s";
                        if (n == 0)
                                break loop;
                        System.out.println(n + " bottle" + plural
                                + " of " + stuff + " on the wall!");
                        System.out.println();
                }
                System.out.println("No bottles of " +
                                stuff + " on the wall!");
        }
}
</pre></blockquote><a name="386143"></a>
<p>
<a name="40427"></a>
the method <code>printSong</code> will print a version of a children's song. Popular values for stuff include <code>"pop"</code> and <code>"beer"</code>; the most popular value for <code>n</code> is <code>100</code>. Here is the output that results from <code>Bottles.printSong("slime", 3)</code>:<p>
<a name="386144"></a>
<p>
<blockquote><pre>3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!
</pre></blockquote><a name="386145"></a>
<p>
<a name="40459"></a>
<p>In the code, note the careful conditional generation of the singular "<code>bottle</code>" when appropriate rather than the plural "<code>bottles</code>"; note also how the string concatenation operator was used to break the long constant string:</p>
<a name="386147"></a>
<p></p>
<blockquote><pre>"You take one down and pass it around:"
</pre></blockquote>
<a name="264580"></a>
<p>into two pieces to avoid an inconveniently long line in the source code.</p>
</pre></blockquote><a name="386146"></a>
<p>
<a name="13510"></a>
<a name="15.18.2"></a>
<h3>15.18.2    Additive Operators (+ and -) for Numeric Types</h3>
<a name="235182"></a>
The binary <code>+</code> operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The binary <code>-</code> operator performs subtraction, producing the difference of two numeric operands.<p>
<a name="39970"></a>
Binary numeric promotion is performed on the operands <a href="conversions.html#170983">(&#167;5.6.2)</a>. The type of an additive expression on numeric operands is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="251120"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> and unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>.<p>
<a name="39968"></a>
Addition is a commutative operation if the operand expressions have no side effects. Integer addition is associative when the operands are all of the same type, but floating-point addition is not associative.<p>
<a name="13512"></a>
If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.<p>
<a name="13513"></a>
The result of a floating-point addition is determined using the following rules of IEEE arithmetic:<p>
<ul><a name="13514"></a>
<li>If either operand is NaN, the result is NaN.
<a name="13515"></a>
<li>The sum of two infinities of opposite sign is NaN.
<a name="13516"></a>
<li>The sum of two infinities of the same sign is the infinity of that sign.
<a name="13517"></a>
<li>The sum of an infinity and a finite value is equal to the infinite operand.
<a name="13518"></a>
<li>The sum of two zeros of opposite sign is positive zero.
<a name="13519"></a>
<li>The sum of two zeros of the same sign is the zero of that sign.
<a name="13520"></a>
<li>The sum of a zero and a nonzero finite value is equal to the nonzero operand.
<a name="13521"></a>
<li>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
<a name="251124"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the exact mathematical sum is computed. A floating-point value set is then chosen:
<ul>
<a name="251125"></a>
<li>If the addition expression is FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>:
<ul>
<a name="251126"></a>
<li>If the type of the addition expression is <code>float</code>, then the float value set must be chosen.
<a name="251127"></a>
<li>If the type of the addition expression is <code>double</code>, then the double value set must be chosen.
</ul>
<a name="251128"></a>
<li>If the addition expression is not FP-strict:
<ul>
<a name="251129"></a>
<li>If the type of the addition expression is <code>float</code>, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
<a name="251130"></a>
<li>If the type of the addition expression is <code>double</code>, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
</ul>
</ul>
</ul><ul><a name="251131"></a>
<p>Next, a value must be chosen from the chosen value set to represent the sum. If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the sum is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 <a href="typesValues.html#9249">(&#167;4.2.4)</a>.
</ul><a name="13523"></a>
The binary <code>-</code> operator performs subtraction when applied to two operands of numeric type producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend. For both integer and floating-point subtraction, it is always the case that <code>a-b</code> produces the same result as <code>a+(-b)</code>. <p>
<a name="290253"></a>
Note that, for integer values, subtraction from zero is the same as negation. However, for floating-point operands, subtraction from zero is <em>not</em> the same as negation, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> is <code>+0.0</code>, but <code>-x</code> is <code>-0.0</code>. <p>
<a name="13524"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.<p>
<a name="386151"></a>
<p>
<a name="5121"></a>
<a name="15.19"></a>
<h2>15.19    Shift Operators</h2>
<a name="5122"></a>
The <em>shift operators</em> include left shift <code>&lt;&lt;</code>, signed right shift <code>&gt;&gt;</code>, and unsigned right shift <code>&gt;&gt;&gt;</code>; they are syntactically left-associative (they group left-to-right). The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.<p>
<blockquote><pre><em>
ShiftExpression:
        AdditiveExpression
        ShiftExpression </em>&lt;&lt;<em> AdditiveExpression
        ShiftExpression</em> &gt;&gt;<em> AdditiveExpression
        ShiftExpression</em> &gt;&gt;&gt;<em> AdditiveExpression</em>
</pre></blockquote><a name="40554"></a>
The type of each of the operands of a shift operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive integral type, or a compile-time error occurs. Binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is <em>not</em> performed on the operands; rather, unary numeric promotion <a href="conversions.html#203523">(&#167;)</a> is performed on each operand separately. The type of the shift expression is the promoted type of the left-hand operand.<p>
<a name="13680"></a>
If the promoted type of the left-hand operand is <code>int</code>, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="expressions.html#5233">(&#167;15.22.1)</a> with the mask value <code>0x1f</code>. The shift distance actually used is therefore always in the range 0 to 31, inclusive.<p>
<a name="19183"></a>
If the promoted type of the left-hand operand is <code>long</code>, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="expressions.html#5233">(&#167;15.22.1)</a> with the mask value <code>0x3f</code>. The shift distance actually used is therefore always in the range 0 to 63, inclusive.<p>
<a name="19187"></a>
At run time, shift operations are performed on the two's complement integer representation of the value of the left operand.<p>
<a name="19188"></a>
The value of <code>n&lt;&lt;s</code> is <code>n</code> left-shifted <code>s</code> bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power <code>s</code>.<p>
<a name="5140"></a>
The value of <code>n&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with sign-extension. The resulting value is &lfloor;<i>n</i>/2<sup><i>s</i></sup>&rfloor;. For nonnegative values of <code>n</code>, this is equivalent to truncating integer division, as computed by the integer division operator <code>/</code>, by two to the power <code>s</code>.<p>
<a name="40638"></a>
The value of <code>n&gt;&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with zero-extension. If <code>n</code> is positive, then the result is the same as that of <code>n&gt;&gt;s</code>; if <code>n</code> is negative, the result is equal to that of the expression <code>(n&gt;&gt;s)+(2&lt;&lt;~s)</code> if the type of the left-hand operand is <code>int</code>, and to the result of the expression <code>(n&gt;&gt;s)+(2L&lt;&lt;~s)</code> if the type of the left-hand operand is <code>long</code>. The added term <code>(2&lt;&lt;~s)</code> or <code>(2L&lt;&lt;~s)</code> cancels out the propagated sign bit. (Note that, because of the implicit masking of the right-hand operand of a shift operator, <code>~s</code> as a shift distance is equivalent to <code>31-s</code> when shifting an <code>int</code> value and to <code>63-s</code> when shifting a <code>long</code> value.)<p>
<a name="40641"></a>
<a name="15.20"></a>
<h2>15.20    Relational Operators</h2>
<a name="139595"></a>
The <em>relational operators</em> are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, <code>a&lt;b&lt;c</code> parses as <code>(a&lt;b)&lt;c</code>, which is always a compile-time error, because the type of <code>a&lt;b</code> is always <code>boolean</code> and <code>&lt;</code> is not an operator on <code>boolean</code> values.<p>
<blockquote><pre><em>
RelationalExpression:
        ShiftExpression
        RelationalExpression</em> &lt;<em> ShiftExpression
        RelationalExpression</em> &gt;<em> ShiftExpression
        RelationalExpression </em>&lt;=<em> ShiftExpression
        RelationalExpression</em> &gt;=<em> ShiftExpression
        RelationalExpression </em>instanceof<em> ReferenceType</em>
</pre></blockquote><a name="235261"></a>
The type of a relational expression is always <code>boolean</code>.<p>
<a name="153654"></a>
<a name="15.20.1"></a>
<h3>15.20.1    Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;= </h3>
<a name="40647"></a>
The type of each of the operands of a numerical comparison operator must be a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands <a href="conversions.html#170983">(&#167;5.6.2)</a>. If the promoted type of the operands is <code>int</code> or <code>long</code>, then signed integer comparison is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point comparison is performed.<p>
<a name="251144"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> and unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.<p>
<a name="5155"></a>
The result of a floating-point comparison, as determined by the specification of the IEEE 754 standard, is:<p>
<ul><a name="5156"></a>
<li>If either operand is NaN, then the result is <code>false</code>.
<a name="5157"></a>
<li>All values other than NaN are ordered, with negative infinity less than all finite values, and positive infinity greater than all finite values.
<a name="5158"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0&lt;0.0</code> is <code>false</code>, for example, but <code>-0.0&lt;=0.0</code> is <code>true</code>. (Note, however, that the methods <code>Math.min</code> and <code>Math.max</code> treat negative zero as being strictly smaller than positive zero.)
</ul><a name="5159"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5160"></a>
<li>The value produced by the <code>&lt;</code> operator is <code>true</code> if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5161"></a>
<li>The value produced by the <code>&lt;=</code> operator is <code>true</code> if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5162"></a>
<li>The value produced by the <code>&gt;</code> operator is <code>true</code> if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5163"></a>
<li>The value produced by the <code>&gt;=</code> operator is <code>true</code> if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
</ul><a name="80289"></a>
<a name="15.20.2"></a>
<h3>15.20.2    Type Comparison Operator instanceof</h3>
<a name="80291"></a>
The type of a <em>RelationalExpression</em> operand of the <code>instanceof</code> operator must be a reference type or the null type; otherwise, a compile-time error occurs. The <em>ReferenceType</em> mentioned after the <code>instanceof</code> operator must denote a reference type; otherwise, a compile-time error occurs. It is a compile-time error if the <em>ReferenceType</em> mentioned after the <code>instanceof</code> operator does not denote a reifiable type <a href="typesValues.html#112581">(&#167;4.7)</a>.<p>
<a name="240816"></a>
At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <em>RelationalExpression</em> is not <code>null</code> and the reference could be cast <a href="expressions.html#238146">(&#167;15.16)</a> to the <em>ReferenceType</em> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.<p>
<a name="264585"></a>
If a cast of the <em>RelationalExpression</em> to the <em>ReferenceType</em> would be rejected as a compile-time error, then the <code>instanceof</code> relational expression likewise produces a compile-time error. In such a situation, the result of the <code>instanceof</code> expression could never be <code>true</code>.<p>
<a name="238166"></a>
<p>Consider the example program:</p>
<blockquote><pre>class Point { int x, y; }
class Element { int atomicNumber; }
class Test {
        public static void main(String[] args) {
                Point p = new Point();
                Element e = new Element();
                if (e instanceof Point) {       // compile-time error
                        System.out.println("I get your point!");
                        p = (Point)e;           // compile-time error
                }
        }
}
</pre></blockquote><a name="22819"></a>
This example results in two compile-time errors. The cast <code>(Point)e</code> is incorrect because no instance of <code>Element</code> or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of <code>Point</code>. The <code>instanceof</code> expression is incorrect for exactly the same reason. If, on the other hand, the class <code>Point</code> were a subclass of <code>Element</code> (an admittedly strange notion in this example):<p>
<blockquote><pre>class Point extends Element { int x, y; }
</pre></blockquote><a name="291949"></a>
then the cast would be possible, though it would require a run-time check, and the <code>instanceof</code> expression would then be sensible and valid. The cast <code>(Point)e</code> would never raise an exception because it would not be executed if the value of <code>e</code> could not correctly be cast to type <code>Point</code>.<p>
<a name="291957"></a>
<p></p>
<a name="291954"></a>
<a name="15.21"></a>
<h2>15.21    Equality Operators</h2>
<a name="24723"></a>
The equality operators are syntactically left-associative (they group left-to-right), but this fact is essentially never useful; for example, <code>a==b==c</code> parses as <code>(a==b)==c</code>. The result type of <code>a==b</code> is always <code>boolean</code>, and <code>c</code> must therefore be of type <code>boolean</code> or a compile-time error occurs. Thus, <code>a==b==c</code> does <em>not</em> test to see whether <code>a</code>, <code>b</code>, and <code>c</code> are all equal.<p>
<blockquote><pre><em>
EqualityExpression:
        RelationalExpression
        EqualityExpression</em> ==<em> RelationalExpression
        EqualityExpression</em> !=<em> RelationalExpression</em>
</pre></blockquote><a name="5195"></a>
The == (equal to) and the!= (not equal to) operators are analogous to the relational operators except for their lower precedence. Thus, <code>a&lt;b==c&lt;d</code> is <code>true</code> whenever <code>a&lt;b</code> and <code>c&lt;d</code> have the same truth value.<p>
<a name="5196"></a>
The equality operators may be used to compare two operands that are convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to numeric type, or two operands of type <code>boolean</code> or <code>Boolean</code>, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always <code>boolean</code>.<p>
<a name="235280"></a>
In all cases, <code>a!=b</code> produces the same result as <code>!(a==b)</code>. The equality operators are commutative if the operand expressions have no side effects.<p>
<a name="5198"></a>
<a name="15.21.1"></a>
<h3>15.21.1    Numerical Equality Operators ==&#32;and != </h3>
<a name="40803"></a>
If the operands of an equality operator are both of numeric type, or one is of numeric type and the other is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to numeric type, binary numeric promotion is performed on the operands <a href="conversions.html#170983">(&#167;5.6.2)</a>. If the promoted type of the operands is <code>int</code> or <code>long</code>, then an integer equality test is performed; if the promoted type is <code>float</code> or <code>double</code>, then a floating-point equality test is performed.<p>
<a name="251162"></a>
Note that binary numeric promotion performs value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> and unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>. Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.<p>
<a name="5203"></a>
Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard:<p>
<ul><a name="5204"></a>
<li>If either operand is NaN, then the result of <code>==</code> is <code>false</code> but the result of <code>!=</code> is <code>true</code>. Indeed, the test <code>x!=x</code> is true if and only if the value of <code>x</code> is NaN. (The methods <code>Float.isNaN</code> and <code>Double.isNaN</code> may also be used to test whether a value is NaN.)
<a name="54500"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0==0.0</code> is <code>true</code>, for example.
<a name="54501"></a>
<li>Otherwise, two distinct floating-point values are considered unequal by the equality operators. In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
</ul><a name="5207"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5208"></a>
<li>The value produced by the <code>==</code> operator is <code>true</code> if the value of the left-hand operand is equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
<a name="236629"></a>
<li>The value produced by the <code>!=</code> operator is <code>true</code> if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
</ul><a name="54508"></a>
<a name="15.21.2"></a>
<h3>15.21.2    Boolean Equality Operators ==&#32;and != </h3>
<a name="80389"></a>
If the operands of an equality operator are both of type <code>boolean</code>, or if one operand is of type <code>boolean</code> and the other is of type <code>Boolean</code>, then the operation is boolean equality. The boolean equality operators are associative. <p>
<a name="316873"></a>
If one of the operands is of type <code>Boolean</code> it is subjected to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>.<p>
<a name="5214"></a>
The result of <code>==</code> is <code>true</code> if the operands (after any required unboxing conversion) are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>false</code>.<p>
<a name="5215"></a>
The result of <code>!=</code> is <code>false</code> if the operands are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>true</code>. Thus <code>!=</code> behaves the same as <code>^</code> <a href="expressions.html#5242">(&#167;15.22.2)</a> when applied to boolean operands.<p>
<a name="236163"></a>
<a name="15.21.3"></a>
<h3>15.21.3    Reference Equality Operators ==&#32;and !=</h3>
<a name="236164"></a>
If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality.<p>
<a name="80399"></a>
A compile-time error occurs if it is impossible to convert the type of either operand to the type of the other by a casting conversion <a href="conversions.html#20232">(&#167;5.5)</a>. The run-time values of the two operands would necessarily be unequal.<p>
<a name="5225"></a>
At run time, the result of <code>==</code> is <code>true</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>false</code>.<p>
<a name="264595"></a>
The result of <code>!=</code> is <code>false</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>true</code>.<p>
<a name="264600"></a>
<p>While <code>==</code> may be used to compare references of type <code>String</code>, such an equality test determines whether or not the two operands refer to the same <code>String</code> object. The result is <code>false</code> if the operands are distinct <code>String</code> objects, even if they contain the same sequence of characters. The contents of two strings <code>s</code> and <code>t</code> can be tested for equality by the method invocation <code>s.equals(t)</code>. See also <a href="lexical.html#101083">&#167;3.10.5</a>.</p>
<a name="5228"></a>
<a name="15.22"></a>
<h2>15.22    Bitwise and Logical Operators</h2>
<a name="5229"></a>
The <em>bitwise</em> <em>operators</em> and <em>logical operators</em> include the AND operator <code>&amp;</code>, exclusive OR operator <code>^</code>, and inclusive OR operator <code>|</code>. These operators have different precedence, with <code>&amp;</code> having the highest precedence and <code>|</code> the lowest precedence. Each of these operators is syntactically left-associative (each groups left-to-right). Each operator is commutative if the operand expressions have no side effects. Each operator is associative.<p>
<blockquote><pre><em>
AndExpression:
        EqualityExpression
        AndExpression</em> &amp;<em> EqualityExpression

ExclusiveOrExpression:
        AndExpression
        ExclusiveOrExpression</em> ^<em> AndExpression

InclusiveOrExpression:
        ExclusiveOrExpression
        InclusiveOrExpression </em>|<em> ExclusiveOrExpression</em>
</pre></blockquote><a name="40906"></a>
The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type <code>boolean</code>. All other cases result in a compile-time error.<p>
<a name="5233"></a>
<a name="15.22.1"></a>
<h3>15.22.1    Integer Bitwise Operators &amp;, ^, and |</h3>
<a name="5234"></a>
When both operands of an operator <code>&amp;</code>, <code>^</code>, or <code>|</code> are of a type that is convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to a primitive integral type, binary numeric promotion is first performed on the operands <a href="conversions.html#170983">(&#167;5.6.2)</a>. The type of the bitwise operator expression is the promoted type of the operands.<p>
<a name="5238"></a>
For <code>&amp;</code>, the result value is the bitwise AND of the operand values.<p>
<a name="5239"></a>
For <code>^</code>, the result value is the bitwise exclusive OR of the operand values.<p>
<a name="264605"></a>
For <code>|</code>, the result value is the bitwise inclusive OR of the operand values.<p>
<a name="264610"></a>
<p>For example, the result of the expression <code>0xff00</code> <code>&amp;</code> <code>0xf0f0</code> is <code>0xf000</code>. The result of <code>0xff00</code> <code>^</code> <code>0xf0f0</code> is <code>0x0ff0</code>.The result of <code>0xff00</code> <code>|</code> <code>0xf0f0</code> is <code>0xfff0</code>.</p>
<a name="5242"></a>
<a name="15.22.2"></a>
<h3>15.22.2    Boolean Logical Operators &amp;, ^, and |</h3>
<a name="315718"></a>
When both operands of a <code>&amp;</code>, <code>^</code>, or <code>|</code> operator are of type <code>boolean</code> or <code>Boolean</code>, then the type of the bitwise operator expression is <code>boolean</code>. In all cases, the operands are subject to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> as necessary.<p>
<a name="5243"></a>
<p>
<a name="5244"></a>
For <code>&amp;</code>, the result value is <code>true</code> if both operand values are <code>true</code>; otherwise, the result is <code>false</code>.<p>
<a name="5245"></a>
For <code>^</code>, the result value is <code>true</code> if the operand values are different; otherwise, the result is <code>false</code>.<p>
<a name="5246"></a>
For <code>|</code>, the result value is <code>false</code> if both operand values are <code>false</code>; otherwise, the result is <code>true</code>.<p>
<a name="5247"></a>
<a name="15.23"></a>
<h2>15.23    Conditional-And Operator &amp;&amp;</h2>
<a name="5248"></a>
The <code>&amp;&amp;</code> operator is like <code>&amp;</code> <a href="expressions.html#5242">(&#167;15.22.2)</a>, but evaluates its right-hand operand only if the value of its left-hand operand is <code>true</code>. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression <code>((</code><i>a</i>)<code>&amp;&amp;</code>(<i>b</i>))<code>&amp;&amp;</code>(<i>c</i>) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression <code>(</code><i>a</i>)<code>&amp;&amp;</code>((<i>b</i>)<code>&amp;&amp;</code>(<i>c</i>)).<p>
<blockquote><pre><em>
ConditionalAndExpression:
        InclusiveOrExpression
        ConditionalAndExpression</em> &amp;&amp;<em> InclusiveOrExpression</em>
</pre></blockquote><a name="5251"></a>
Each operand of <code>&amp;&amp;</code> must be of type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs. The type of a conditional-and expression is always <code>boolean</code>.<p>
<a name="41086"></a>
At run time, the left-hand operand expression is evaluated first; if the result has type <code>Boolean</code>, it is subjected to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>; if the resulting value is <code>false</code>, the value of the conditional-and expression is <code>false</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>true</code>, then the right-hand expression is evaluated; if the result has type <code>Boolean</code>, it is subjected to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>; the resulting value becomes the value of the conditional-and expression. Thus, <code>&amp;&amp;</code> computes the same result as <code>&amp;</code> on <code>boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.<p>
<a name="54532"></a>
<a name="15.24"></a>
<h2>15.24    Conditional-Or Operator ||</h2>
<a name="41053"></a>
The <code>||</code> operator is like <code>|</code> <a href="expressions.html#5242">(&#167;15.22.2)</a>, but evaluates its right-hand operand only if the value of its left-hand operand is <code>false</code>. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression <code>((</code><i>a</i>)<code>||</code>(<i>b</i>))<code>||</code>(<i>c</i>) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression <code>(</code><i>a</i>)<code>||</code>((<i>b</i>)<code>||</code>(<i>c</i>)).<p>
<blockquote><pre><em>
ConditionalOrExpression:
        ConditionalAndExpression
        ConditionalOrExpression</em> || <em>ConditionalAndExpression</em>
</pre></blockquote><a name="41088"></a>
Each operand of <code>||</code> must be of type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs. The type of a conditional-or expression is always <code>boolean</code>.<p>
<a name="264616"></a>
At run time, the left-hand operand expression is evaluated first; if the result has type <code>Boolean</code>, it is subjected to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>; if the resulting value is <code>true</code>, the value of the conditional-or expression is <code>true</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>false</code>, then the right-hand expression is evaluated; if the result has type <code>Boolean</code>, it is subjected to unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a>; the resulting value becomes the value of the conditional-or expression. <p>
<a name="290289"></a>
<p>Thus, <code>||</code> computes the same result as <code>|</code> on <code>boolean</code> or <code>Boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.</p>
<a name="290293"></a>
<a name="15.25"></a>
<h2>15.25    Conditional Operator ?&#32;:</h2>
<a name="5258"></a>
The conditional operator <code>?&#32;:</code> uses the boolean value of one expression to decide which of two other expressions should be evaluated.<p>
<a name="41113"></a>
The conditional operator is syntactically right-associative (it groups right-to-left), so that <code>a?b:c?d:e?f:g</code> means the same as <code>a?b:(c?d:(e?f:g))</code>.<p>
<blockquote><pre><em>
ConditionalExpression:
        ConditionalOrExpression
        ConditionalOrExpression </em>?<em> Expression </em>: <em>ConditionalExpression</em>
</pre></blockquote><a name="236253"></a>
The conditional operator has three operand expressions; <code>?</code> appears between the first and second expressions, and <code>:</code> appears between the second and third expressions.<p>
<a name="40128"></a>
The first expression must be of type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.<p>
<a name="41144"></a>
Note that it is  a compile-time error for either the second or the third operand expression to be an invocation of a <code>void</code> method. In fact, it is not permitted for a conditional expression to appear in any context where an invocation of a <code>void</code> method could appear <a href="statements.html#5984">(&#167;14.8)</a>.<p>
<a name="236267"></a>
The type of a conditional expression is determined as follows:<p>
<ul><a name="41198"></a>
<li>If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.
<a name="315738"></a>
<li>If one of the second and third operands is of type <code>boolean</code> and the type of the other is of type <code>Boolean</code>, then the type of the conditional expression is <code>boolean</code>.
<a name="315747"></a>
<li>If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
<a name="236254"></a>
<li>Otherwise, if the second and third operands have types that are convertible <a href="conversions.html#190699">(&#167;5.1.8)</a> to numeric types, then there are several cases:
<ul>
<a name="5262"></a>
<li>If one of the operands is of type <code>byte</code> or <code>Byte</code> and the other is of type <code>short</code> or <code>Short</code>, then the type of the conditional expression is <code>short</code>.
<a name="5264"></a>
<li>If one of the operands is of type <i>T</i> where <i>T</i> is <code>byte</code>, <code>short</code>, or <code>char</code>, and the other operand is a constant expression of type <code>int</code> whose value is representable in type <i>T</i>, then the type of the conditional expression is <i>T</i>.
<a name="315750"></a>
<li>    If one of the operands is of type <code>Byte</code> and the other operand is a constant expression of type <code>int</code> whose value is representable in type <code>byte</code>, then the type of the conditional expression is <code>byte</code>.
<a name="315751"></a>
<li>    If one of the operands is of type <code>Short</code> and the other operand is a constant expression of type <code>int</code> whose value is representable in type <code>short</code>, then the type of the conditional expression is <code>short</code>.
<a name="315748"></a>
<li>             If one of the operands is of type; <code>Character</code> and the other operand is a constant expression of type <code>int</code> whose value is representable in type <code>char</code>, then the type of the conditional expression is <code>char.</code>
<a name="249508"></a>
<li>Otherwise, binary numeric promotion <a href="conversions.html#170983">(&#167;5.6.2)</a> is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands. Note that binary numeric promotion performs unboxing conversion <a href="conversions.html#190699">(&#167;5.1.8)</a> and value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a>.
</ul>
<a name="338096"></a>
<li>Otherwise, the second and third operands are of types <i>S1</i> and <i>S2</i> respectively. Let <i>T1</i> be the type that results from applying boxing conversion to <i>S1</i>, and let <i>T2</i> be the type that results from applying boxing conversion to <i>S2</i>. The type of the conditional expression is the result of applying capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a> to <i>lub(T1, T2)</i> <a href="expressions.html#341287">(&#167;15.12.2.7)</a>.
</ul><a name="40134"></a>
At run time, the first operand expression of the conditional expression is evaluated first; if necessary, unboxing conversion is performed on the result; the resulting <code>boolean</code> value is then used to choose either the second or the third operand expression:<p>
<ul><a name="5277"></a>
<li>If the value of the first operand is <code>true</code>, then the second operand expression is chosen.
<a name="5278"></a>
<li>If the value of the first operand is <code>false</code>, then the third operand expression is chosen.
</ul><a name="5279"></a>
The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated above. This conversion may include boxing <a href="conversions.html#190697">(&#167;5.1.7)</a> or unboxing conversion. The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression. <p>
<a name="5281"></a>
<a name="15.26"></a>
<h2>15.26    Assignment Operators</h2>
<a name="5282"></a>
There are 12 <em>assignment operators</em>; all are syntactically right-associative (they group right-to-left). Thus, <code>a=b=c</code> means <code>a=(b=c)</code>, which assigns the value of <code>c</code> to <code>b</code> and then assigns the value of <code>b</code> to <code>a</code>.<p>
<blockquote><pre><em>
AssignmentExpression:
        ConditionalExpression
        Assignment

Assignment:
        LeftHandSide AssignmentOperator AssignmentExpression

LeftHandSide:
        ExpressionName
        FieldAccess
        ArrayAccess

AssignmentOperator: one of</em>
        =&#32;*=&#32;/=&#32;%=&#32;+=&#32;-=&#32;&lt;&lt;=&#32;&gt;&gt;=&#32;&gt;&gt;&gt;=&#32;&amp;=&#32;^=&#32;|=
</pre></blockquote><a name="236643"></a>
The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs. This operand may be a named variable, such as a local variable or a field of the current object or class, or it may be a computed variable, as can result from a field access <a href="expressions.html#41267">(&#167;15.11)</a> or an array access <a href="expressions.html#239587">(&#167;15.13)</a>. The type of the assignment expression is the type of the variable after capture conversion <a href="conversions.html#190795">(&#167;5.1.10)</a>.<p>
<a name="41276"></a>
At run time, the result of the assignment expression is the value of the variable after the assignment has occurred. The result of an assignment expression is not itself a variable.<p>
<a name="322836"></a>
A variable that is declared <code>final</code> cannot be assigned to (unless it is a definitely unassigned (<a href="defAssign.html#25979">&#167;16</a>) blank final variable <a href="typesValues.html#10931">(&#167;4.12.4)</a>), because when an access of such a <code>final</code> variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the first operand of an assignment operator. <p>
<a name="322847"></a>
<a name="15.26.1"></a>
<h3>15.26.1    Simple Assignment Operator =</h3>
<a name="22840"></a>
A compile-time error occurs if the type of the right-hand operand cannot be converted to the type of the variable by assignment conversion <a href="conversions.html#184206">(&#167;5.2)</a>.<p>
<a name="41396"></a>
At run time, the expression is evaluated in one of three ways:<p>
<ul><a name="337939"></a>
<li>If the left-hand operand expression is a field access expression <a href="expressions.html#41267">(&#167;15.11)</a> <i>e.f</i>, possibly enclosed in one or more pairs of parentheses, then:
<ul>
<a name="337987"></a>
<li>First, the expression <i>e</i> is evaluated. If evaluation of <em>e</em> completes abruptly, the assignment expression completes abruptly for the same reason.
<a name="337988"></a>
<li>Next, the right hand operand is evaluated. If evaluation of the right hand expression completes abruptly, the assignment expression completes abruptly for the same reason.
<a name="337989"></a>
<li>Then, if the field denoted by <i>e.f</i> is not <code>static</code> and the result of the evaluation of <i>e</i> above is <code>null</code>, then a <code>NullPointerException</code> is thrown.
<a name="337993"></a>
<li>Otherwise, the variable denoted by <i>e.f</i> is assigned the value of the right hand operand as computed above.
</ul>
<a name="265215"></a>
<li>If the left-hand operand is an array access expression <a href="expressions.html#239587">(&#167;15.13)</a>, possibly enclosed in one or more pairs of parentheses, then:
<ul>
<a name="238214"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="337956"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="337959"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="337962"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="337965"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>ArrayIndexOutOfBoundsException</code> &#32;is thrown.
<a name="337968"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. This component is a variable; call its type <i>SC</i>. Also, let <i>TC</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<a name="337971"></a>
<li>If <i>TC</i> is a primitive type, then <i>SC</i> is necessarily the same as <i>TC</i>. The value of the right-hand operand is converted to the type of the selected array component, is subjected to value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
<a name="337974"></a>
<li>If <i>TC</i> is a reference type, then <i>SC</i> may not be the same as <i>TC</i>, but rather a type that extends or implements <i>TC</i>. Let <i>RC</i> be the class of the object referred to by the value of the right-hand operand at run time.
<p><a name="238306"></a>
The compiler may be able to prove at compile time that the array component will be of type <i>TC</i> exactly (for example, <i>TC</i> might be <code>final</code>). But if the compiler cannot prove at compile time that the array component will be of type <i>TC</i> exactly, then a check must be performed at run time to ensure that the class <i>RC</i> is assignment compatible <a href="conversions.html#184206">(&#167;5.2)</a> with the actual type <i>SC</i> of the array component. This check is similar to a narrowing cast (<a href="conversions.html#20232">&#167;5.5</a>, <a href="expressions.html#238146">&#167;15.16</a>), except that if the check fails, an <code>ArrayStoreException</code> is thrown rather than a <code>ClassCastException</code>. Therefore:<p>
<ul>
<a name="238321"></a>
<li>If class <i>RC</i> is not assignable to type <i>SC</i>, then no assignment occurs and an <code>ArrayStoreException</code> is thrown.
</ul>
<a name="264626"></a>
<li>Otherwise, the reference value of the right-hand operand is stored into the selected array component.
</ul>
<a name="337945"></a>
<li>Otherwise, three steps are required:
<ul>
<a name="337946"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="338021"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238526"></a>
</ul></ul>
<p>Otherwise, the value of the right-hand operand is converted to the type of the left-hand variable, is subjected to value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.The rules for assignment to an array component are illustrated by the following example program:</p>
<blockquote><pre>
class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateSimpleArrayAssignment {
        static Object[] objects = { new Object(), new Object() };
        static Thread[] threads = { new Thread(), new Thread() };
        static Object[] arrayThrow() {
                throw new ArrayReferenceThrow();
        }
        static int indexThrow() { throw new IndexThrow(); }
        static Thread rightThrow() {
                throw new RightHandSideThrow();
        }
        static String name(Object q) {
                String sq = q.getClass().getName();
                int k = sq.lastIndexOf('.');
                return (k &lt; 0) ? sq : sq.substring(k+1);
        }
        static void testFour(Object[] x, int j, Object y) {
                String sx = x == null ? "null" : name(x[0]) + "s";
                String sy = name(y);
                System.out.println();
                try {
                        System.out.print(sx + "[throw]=throw =&gt; ");
                        x[indexThrow()] = rightThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[throw]=" + sy + " =&gt; ");
                        x[indexThrow()] = y;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[" + j + "]=throw =&gt; ");
                        x[j] = rightThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[" + j + "]=" + sy + " =&gt; ");
                        x[j] = y;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
        }
        public static void main(String[] args) {
                try {
                        System.out.print("throw[throw]=throw =&gt; ");
                        arrayThrow()[indexThrow()] = rightThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[throw]=Thread =&gt; ");
                        arrayThrow()[indexThrow()] = new Thread();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]=throw =&gt; ");
                        arrayThrow()[1] = rightThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]=Thread =&gt; ");
                        arrayThrow()[1] = new Thread();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                testFour(null, 1, new StringBuffer());
                testFour(null, 1, new StringBuffer());
                testFour(null, 9, new Thread());
                testFour(null, 9, new Thread());
                testFour(objects, 1, new StringBuffer());
                testFour(objects, 1, new Thread());
                testFour(objects, 9, new StringBuffer());
                testFour(objects, 9, new Thread());
                testFour(threads, 1, new StringBuffer());
                testFour(threads, 1, new Thread());
                testFour(threads, 9, new StringBuffer());
                testFour(threads, 9, new Thread());
        }
}
</pre></blockquote><a name="238532"></a>
This program prints:<p>
<blockquote><pre>throw[throw]=throw =&gt; ArrayReferenceThrow
throw[throw]=Thread =&gt; ArrayReferenceThrow
throw[1]=throw =&gt; ArrayReferenceThrow
throw[1]=Thread =&gt; ArrayReferenceThrow
null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException
null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=StringBuffer =&gt; Okay!
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=Thread =&gt; Okay!
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException
Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=Thread =&gt; ArrayIndexOutOfBoundsException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=StringBuffer =&gt; ArrayStoreException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=Thread =&gt; Okay!
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException
Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=Thread =&gt; ArrayIndexOutOfBoundsException
</pre></blockquote><a name="238840"></a>
The most interesting case of the lot is the one thirteenth from the end:<p>
<blockquote><pre>Threads[1]=StringBuffer =&gt; ArrayStoreException
</pre></blockquote><a name="264631"></a>
which indicates that the attempt to store a reference to a <code>StringBuffer</code> into an array whose components are of type <code>Thread</code> throws an <code>ArrayStoreException</code>. The code is type-correct at compile time: the assignment has a left-hand side of type <code>Object[]</code> and a right-hand side of type <code>Object</code>. At run time, the first actual argument to method <code>testFour</code> is a reference to an instance of "array of <code>Thread</code>" and the third actual argument is a reference to an instance of class <code>StringBuffer</code>.<p>
<a name="5304"></a>
<a name="15.26.2"></a>
<h3>15.26.2    Compound Assignment Operators</h3>
<a name="316970"></a>
A compound assignment expression of the form <i>E1</i> <i>op</i>= <i>E2</i> is equivalent to <i>E1</i> &#32;<code>=</code> &#32;<code>(</code><i>T</i><code>)((</code><i>E1</i>) <i>op</i> <code>(</code><i>E2</i>)), where <i>T</i> is the type of <i>E1</i>, except that <i>E1</i> is evaluated only once.  <p>
<a name="316895"></a>
For example, the following code is correct:<p>
<blockquote><pre><a name="236396"></a>
short x = 3;
x += 4.6;
</pre></blockquote><a name="236398"></a>
and results in <code>x</code> having the value <code>7</code> because it is equivalent to:<p>
<blockquote><pre><a name="236400"></a>
short x = 3;
x = (short)(x + 4.6);
</pre></blockquote><a name="249529"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:<p>
<ul><a name="238396"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="238397"></a>
<li>Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238433"></a>
<li>Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="251178"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.
</ul><a name="238402"></a>
If the left-hand operand expression is an array access expression <a href="expressions.html#239587">(&#167;15.13)</a>, then many steps are required:<p>
<ul><a name="238403"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238404"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238449"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="238450"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>ArrayIndexOutOfBoundsException</code> &#32;is thrown.
<a name="238405"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. (For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.)
<a name="238408"></a>
<li>Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type <i>S</i>. Also, let <i>T</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="238409"></a>
<li>If <i>T</i> is a primitive type, then <i>S</i> is necessarily the same as <i>T</i>.
<ul>
<a name="238472"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="expressions.html#5047">&#167;15.17.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="251182"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the selected array component, subjected to value set conversion <a href="conversions.html#184225">(&#167;5.1.13)</a> to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
</ul>
<a name="238410"></a>
<li>If <i>T</i> is a reference type, then it must be <code>String</code>. Because class <code>String</code> is a <code>final</code> class, <i>S</i> must also be <code>String</code>. Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
<ul>
<a name="238488"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily <code>+=</code>). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
</ul>
</ul>
</ul><a name="264636"></a>
Otherwise, the <code>String</code> result of the binary operation is stored into the array component.<p>
<a name="238860"></a>
<p>The rules for compound assignment to an array component are illustrated by the following example program:</p>
<blockquote><pre>class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateCompoundArrayAssignment {
        static String[] strings = { "Simon", "Garfunkel" };
        static double[] doubles = { Math.E, Math.PI };
        static String[] stringsThrow() {
                throw new ArrayReferenceThrow();
        }
        static double[] doublesThrow() {
                throw new ArrayReferenceThrow();
        }
        static int indexThrow() { throw new IndexThrow(); }
        static String stringThrow() {
                throw new RightHandSideThrow();
        }
        static double doubleThrow() {
                throw new RightHandSideThrow();
        }
        static String name(Object q) {
                String sq = q.getClass().getName();
                int k = sq.lastIndexOf('.');
                return (k &lt; 0) ? sq : sq.substring(k+1);
        }
        static void testEight(String[] x, double[] z, int j) {
                String sx = (x == null) ? "null" : "Strings";
                String sz = (z == null) ? "null" : "doubles";
                System.out.println();
                try {
                        System.out.print(sx + "[throw]+=throw =&gt; ");
                        x[indexThrow()] += stringThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sz + "[throw]+=throw =&gt; ");
                        z[indexThrow()] += doubleThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
                        x[indexThrow()] += "heh";
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sz + "[throw]+=12345 =&gt; ");
                        z[indexThrow()] += 12345;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[" + j + "]+=throw =&gt; ");
                        x[j] += stringThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sz + "[" + j + "]+=throw =&gt; ");
                        z[j] += doubleThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
                        x[j] += "heh";
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
                        z[j] += 12345;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
        }
        public static void main(String[] args) {
                try {
                        System.out.print("throw[throw]+=throw =&gt; ");
                        stringsThrow()[indexThrow()] += stringThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[throw]+=throw =&gt; ");
                        doublesThrow()[indexThrow()] += doubleThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[throw]+=\"heh\" =&gt; ");
                        stringsThrow()[indexThrow()] += "heh";
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[throw]+=12345 =&gt; ");
                        doublesThrow()[indexThrow()] += 12345;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]+=throw =&gt; ");
                        stringsThrow()[1] += stringThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]+=throw =&gt; ");
                        doublesThrow()[1] += doubleThrow();
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]+=\"heh\" =&gt; ");
                        stringsThrow()[1] += "heh";
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                try {
                        System.out.print("throw[1]+=12345 =&gt; ");
                        doublesThrow()[1] += 12345;
                        System.out.println("Okay!");
                } catch (Throwable e) { System.out.println(name(e)); }
                testEight(null, null, 1);
                testEight(null, null, 9);
                testEight(strings, doubles, 1);
                testEight(strings, doubles, 9);
        }
}
</pre></blockquote><a name="238992"></a>
This program prints:<p>
<blockquote><pre>throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+="heh" =&gt; ArrayReferenceThrow
throw[throw]+=12345 =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+="heh" =&gt; ArrayReferenceThrow
throw[1]+=12345 =&gt; ArrayReferenceThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[1]+=throw =&gt; NullPointerException
null[1]+=throw =&gt; NullPointerException
null[1]+="heh" =&gt; NullPointerException
null[1]+=12345 =&gt; NullPointerException
null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[9]+=throw =&gt; NullPointerException
null[9]+=throw =&gt; NullPointerException
null[9]+="heh" =&gt; NullPointerException
null[9]+=12345 =&gt; NullPointerException
Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
Strings[1]+="heh" =&gt; Okay!
doubles[1]+=12345 =&gt; Okay!
Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[9]+=throw =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=throw =&gt; ArrayIndexOutOfBoundsException
Strings[9]+="heh" =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=12345 =&gt; ArrayIndexOutOfBoundsException
</pre></blockquote><a name="239051"></a>
The most interesting cases of the lot are tenth and eleventh from the end:<p>
<blockquote><pre>Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
</pre></blockquote><a name="238861"></a>
They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot. This demonstrates that the evaluation of the right-hand operand indeed occurs after the checks for a null array reference value and an out-of-bounds index value.<p>
<a name="240007"></a>
<p>The following program illustrates the fact that the value of the left-hand side of a compound assignment is saved before the right-hand side is evaluated:</p>
<blockquote><pre>class Test {
        public static void main(String[] args) {
                int k = 1;
                int[] a = { 1 };
                k += (k = 4) * (k + 2);
                a[0] += (a[0] = 4) * (a[0] + 2);
                System.out.println("k==" + k + " and a[0]==" + a[0]);
        }
}
</pre></blockquote><a name="240021"></a>
This program prints:<p>
<blockquote><pre>k==25 and a[0]==25
</pre></blockquote><a name="240027"></a>
The value <code>1</code> of <code>k</code> is saved by the compound assignment operator <code>+=</code> before its right-hand operand <code>(k</code> <code>=</code> <code>4)</code> <code>*</code> <code>(k</code> <code>+</code> <code>2)</code> is evaluated. Evaluation of this right-hand operand then assigns <code>4</code> to <code>k</code>, calculates the value <code>6</code> for <code>k</code> <code>+</code> <code>2</code>, and then multiplies <code>4</code> &#32;by &#32;<code>6</code> to get <code>24</code>. This is added to the saved value <code>1</code> to get <code>25</code>, which is then stored into <code>k</code> by the <code>+=</code> operator. An identical analysis applies to the case that uses <code>a[0]</code>. In short, the statements<p>
<blockquote><pre>k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);
</pre></blockquote><a name="240066"></a>
behave in exactly the same manner as the statements:<p>
<blockquote><pre>k = k + (k = 4) * (k + 2);
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre></blockquote><a name="5308"></a>
<a name="15.27"></a>
<h2>15.27    Expression</h2>
<a name="5309"></a>
An <em>Expression</em> is any assignment expression:<p>
<blockquote><pre><em>
Expression:
        AssignmentExpression</em>
        </pre></blockquote>
<a name="264651"></a>
<p>Unlike C and C++, the Java programming language has no comma operator.</p>
<a name="5313"></a>
<a name="15.28"></a>
<h2>15.28    Constant Expression</h2>
<blockquote><pre><em>
ConstantExpression:
        Expression</em>
</pre></blockquote><a name="5314"></a>
<p>
A compile-time <em>constant expression</em> is an expression denoting a value of primitive type or a <code>String</code> that does not complete abruptly  and is composed using only the following:<p>
<ul><a name="236320"></a>
<li>Literals of primitive type and literals of type <code>String</code> <a href="lexical.html#101083">(&#167;3.10.5)</a>
<a name="236323"></a>
<li>Casts to primitive types and casts to type <code>String</code>
<a name="236324"></a>
<li>The unary operators <code>+</code>, <code>-</code>, <code>~</code>, and <code>! </code>(but not <code>++</code> or <code>--</code>)
<a name="239222"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code>
<a name="239261"></a>
<li>The additive operators <code>+</code> and <code>-</code>
<a name="239263"></a>
<li>The shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>
<a name="239226"></a>
<li>The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;= </code>(but not <code>instanceof</code>)
<a name="239228"></a>
<li>The equality operators <code>==</code> and <code>!=</code>
<a name="239255"></a>
<li>The bitwise and logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code>
<a name="239257"></a>
<li>The conditional-and operator <code>&amp;&amp;</code> and the conditional-or operator <code>||</code>
<a name="236327"></a>
<li>The ternary conditional operator <code>?</code>&#32;<code>:</code>
<a name="292099"></a>
<li>Parenthesized expressions whose contained expression is a constant expression.
<a name="8720"></a>
<li>Simple names that refer to constant variables <a href="typesValues.html#10931">(&#167;4.12.4)</a>.
<a name="239286"></a>
<li>Qualified names of the form <em>TypeName</em> <code>.</code> <em>Identifier</em> that refer to constant variables <a href="typesValues.html#10931">(&#167;4.12.4)</a>.
</ul><a name="5315"></a>
Compile-time constant expressions are used in <code>case</code> labels in <code>switch</code> statements <a href="statements.html#258896">(&#167;14.11)</a> and have a special significance for assignment conversion <a href="conversions.html#184206">(&#167;5.2)</a>. Compile-time constants of type <code>String</code> are always "interned" so as to share unique instances, using the method <code>String.intern.</code><p>
<a name="264656"></a>
A compile-time constant expression is always treated as FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>, even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.<p>
<a name="236407"></a>
<p>Examples of constant expressions:</p>
<blockquote><pre>true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI
"The integer " + Long.MAX_VALUE + " is mighty big."
</pre></blockquote>

<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="statements.html">Prev</a> | <a href="defAssign.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></body></html>

