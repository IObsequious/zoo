grammar Java;
javaSource : compilationUnit ;
compilationUnit : annotationList packageDeclaration? importDeclaration* typeDecls* ;
typeDecls : typeDeclaration | SEMI ;
packageDeclaration : PACKAGE qualifiedIdentifier SEMI ;
importDeclaration : IMPORT STATIC? qualifiedIdentifier DOTSTAR? SEMI ;
typeDeclaration : modifierList ( classTypeDeclaration | interfaceTypeDeclaration | enumTypeDeclaration | annotationTypeDeclaration ) ;
classTypeDeclaration: CLASS IDENT genericTypeParameterList? classExtendsClause? implementsClause? classBody ;
classExtendsClause : EXTENDS type ;
interfaceExtendsClause : EXTENDS typeList ;
implementsClause : IMPLEMENTS typeList ;
genericTypeParameterList : LESS_THAN genericTypeParameter (COMMA genericTypeParameter)* genericTypeListClosing ;
genericTypeListClosing : GREATER_THAN | SHIFT_RIGHT | BIT_SHIFT_RIGHT | EPSILON;
genericTypeParameter : IDENT bound?;
bound : EXTENDS type (AND type)*;
enumTypeDeclaration: ENUM IDENT implementsClause? enumBody ;
enumBody : LCURLY enumScopeDeclarations RCURLY ;
enumScopeDeclarations : enumConstants (COMMA)? enumClassScopeDeclarations? ;
enumClassScopeDeclarations : SEMI classScopeDeclarations*;
enumConstants : enumConstant (COMMA enumConstant)* ;
enumConstant : annotationList IDENT arguments? classBody? ;
interfaceTypeDeclaration: INTERFACE IDENT genericTypeParameterList? interfaceExtendsClause? interfaceBody ;
typeList : type (COMMA type)* ;
classBody : LCURLY classScopeDeclarations* RCURLY ;
interfaceBody : LCURLY interfaceScopeDeclarations* RCURLY ;
classScopeDeclarations : block | STATIC block | modifierList ( genericTypeParameterList? ( type IDENT formalParameterList arrayDeclaratorList? throwsClause? (block | SEMI) | VOID IDENT formalParameterList throwsClause? (block | SEMI) | ident=IDENT formalParameterList throwsClause? block ) | type classFieldDeclaratorList SEMI ) | typeDeclaration | SEMI ;
interfaceScopeDeclarations : modifierList ( genericTypeParameterList? ( type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI | VOID IDENT formalParameterList throwsClause? SEMI ) | type interfaceFieldDeclaratorList SEMI ) | typeDeclaration | SEMI ;
classFieldDeclaratorList : classFieldDeclarator (COMMA classFieldDeclarator)*;
classFieldDeclarator : variableDeclaratorId (ASSIGN variableInitializer)?;
interfaceFieldDeclaratorList : interfaceFieldDeclarator (COMMA interfaceFieldDeclarator)*;
interfaceFieldDeclarator : variableDeclaratorId ASSIGN variableInitializer ;
variableDeclaratorId : IDENT arrayDeclaratorList? ;
variableInitializer : arrayInitializer | expression ;
arrayDeclarator : LBRACK RBRACK ;
arrayDeclaratorList : arrayDeclarator+;
arrayInitializer : LCURLY (variableInitializer (COMMA variableInitializer)* COMMA?)? RCURLY ;
throwsClause : THROWS qualifiedIdentList ;
modifierList : modifier*;
modifier : PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP | localModifier ;
localModifierList : localModifier*;
localModifier : FINAL | annotation ;
type : simpleType | objectType ;
simpleType : primitiveType arrayDeclaratorList?;
objectType : qualifiedTypeIdent arrayDeclaratorList?;
objectTypeSimplified : qualifiedTypeIdentSimplified arrayDeclaratorList?;
qualifiedTypeIdent : typeIdent (DOT typeIdent)*;
qualifiedTypeIdentSimplified : typeIdentSimplified (DOT typeIdentSimplified)*;
typeIdent : IDENT genericTypeArgumentList? ;
typeIdentSimplified : IDENT genericTypeArgumentListSimplified? ;
primitiveType : BOOLEAN | CHAR | BYTE | SHORT | INT | LONG | FLOAT | DOUBLE ;
genericTypeArgumentList : LESS_THAN genericTypeArgument (COMMA genericTypeArgument)* genericTypeListClosing ;
genericTypeArgument : type | QUESTION genericWildcardBoundType?;
genericWildcardBoundType : (EXTENDS | SUPER) type ;
genericTypeArgumentListSimplified : LESS_THAN genericTypeArgumentSimplified (COMMA genericTypeArgumentSimplified)* genericTypeListClosing ;
genericTypeArgumentSimplified : type | QUESTION ;
qualifiedIdentList : qualifiedIdentifier (COMMA qualifiedIdentifier)* ;
formalParameterList : LPAREN ( formalParameterStandardDecl (COMMA formalParameterStandardDecl)* (COMMA formalParameterVarArgDecl)?| formalParameterVarArgDecl | EPSILON) RPAREN ;
formalParameterStandardDecl : localModifierList type variableDeclaratorId ;
formalParameterVarArgDecl : localModifierList type ELLIPSIS variableDeclaratorId ;
qualifiedIdentifier : ( IDENT ) ( DOT ident=IDENT )* ;
annotationList : annotation*;
annotation : AT qualifiedIdentifier annotationInit? ;
annotationInit : LPAREN annotationInitializers RPAREN ;
annotationInitializers : annotationInitializer (COMMA annotationInitializer)*| annotationElementValue ;
annotationInitializer : IDENT ASSIGN annotationElementValue ;
annotationElementValue : annotationElementValueExpression | annotation | annotationElementValueArrayInitializer ;
annotationElementValueExpression : conditionalExpression ;
annotationElementValueArrayInitializer : LCURLY (annotationElementValue (COMMA annotationElementValue)*)? (COMMA)? RCURLY ;
annotationTypeDeclaration: AT INTERFACE IDENT annotationBody ;
annotationBody : LCURLY annotationScopeDeclarations* RCURLY ;
annotationScopeDeclarations : modifierList type ( IDENT LPAREN RPAREN annotationDefaultValue? SEMI | classFieldDeclaratorList SEMI ) | typeDeclaration ;
annotationDefaultValue : DEFAULT annotationElementValue ;
block : LCURLY blockStatement* RCURLY ;
blockStatement : localVariableDeclaration SEMI | typeDeclaration | statement ;
localVariableDeclaration : localModifierList type classFieldDeclaratorList ;
statement : block | ASSERT expr1=expression ( COLON expr2=expression SEMI | SEMI ) | IF parenthesizedExpression ifStat=statement ( ELSE elseStat=statement | EPSILON) | FOR LPAREN ( forInit SEMI forCondition SEMI forUpdater RPAREN statement | localModifierList type IDENT COLON expression RPAREN statement ) | WHILE parenthesizedExpression statement | DO statement WHILE parenthesizedExpression SEMI | TRY block (catches finallyClause? | finallyClause) | SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY | SYNCHRONIZED parenthesizedExpression block | RETURN expression? SEMI | THROW expression SEMI | BREAK IDENT? SEMI | CONTINUE IDENT? SEMI | IDENT COLON statement | expression SEMI | SEMI ;
catches : catchClause+;
catchClause : CATCH LPAREN formalParameterStandardDecl RPAREN block ;
finallyClause : FINALLY block ;
switchBlockLabels : switchCaseLabels switchDefaultLabel? switchCaseLabels ;
switchCaseLabels : switchCaseLabel* ;
switchCaseLabel : CASE expression COLON blockStatement* ;
switchDefaultLabel : DEFAULT COLON blockStatement* ;
forInit : localVariableDeclaration | expressionList | EPSILON ;
forCondition : expression?;
forUpdater : expressionList?;
parenthesizedExpression : LPAREN expression RPAREN ;
expressionList : expression (COMMA expression)* ;
expression : assignmentExpression ;
assignmentExpression : conditionalExpression ( ( ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | BIT_SHIFT_RIGHT_ASSIGN ) assignmentExpression)? ;
conditionalExpression : logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression : logicalAndExpression (LOGICAL_OR logicalAndExpression)* ;
logicalAndExpression : inclusiveOrExpression (LOGICAL_AND inclusiveOrExpression)* ;
inclusiveOrExpression : exclusiveOrExpression (OR exclusiveOrExpression)* ;
exclusiveOrExpression : andExpression (XOR andExpression)* ;
andExpression : equalityExpression (AND equalityExpression)* ;
equalityExpression : instanceOfExpression ( ( EQUAL | NOT_EQUAL ) instanceOfExpression )* ;
instanceOfExpression : relationalExpression (INSTANCEOF type)? ;
relationalExpression : shiftExpression ( ( LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN ) shiftExpression )* ;
shiftExpression : additiveExpression ( ( BIT_SHIFT_RIGHT | SHIFT_RIGHT | SHIFT_LEFT ) additiveExpression )* ;
additiveExpression : multiplicativeExpression ( ( PLUS | MINUS ) multiplicativeExpression )* ;
multiplicativeExpression : unaryExpression ( ( STAR | DIV | MOD ) unaryExpression )* ;
unaryExpression : PLUS unaryExpression | MINUS unaryExpression | INC postfixedExpression | DEC postfixedExpression | unaryExpressionNotPlusMinus ;
unaryExpressionNotPlusMinus : NOT unaryExpression | LOGICAL_NOT unaryExpression | LPAREN type RPAREN unaryExpression | postfixedExpression ;
postfixedExpression : ( primaryExpression ) ( outerDot=DOT ( ( genericTypeArgumentListSimplified? IDENT ) ( arguments )? | THIS | Super=SUPER arguments | ( SUPER innerDot=DOT IDENT ) ( arguments )? | innerNewExpression ) | LBRACK expression RBRACK )* ( INC | DEC )? ;
primaryExpression : parenthesizedExpression | literal | newExpression | qualifiedIdentExpression | genericTypeArgumentListSimplified ( SUPER ( arguments | DOT IDENT arguments ) | IDENT arguments | THIS arguments ) | ( THIS ) ( arguments )? | SUPER arguments | ( SUPER DOT IDENT ) ( arguments | EPSILON ) | ( primitiveType ) ( arrayDeclarator )* DOT CLASS | VOID DOT CLASS ;
qualifiedIdentExpression : ( qualifiedIdentifier ) ( ( arrayDeclarator )+ ( DOT CLASS ) | arguments | outerDot=DOT ( CLASS | genericTypeArgumentListSimplified ( Super=SUPER arguments | SUPER innerDot=DOT IDENT arguments | IDENT arguments ) | THIS | Super=SUPER arguments | innerNewExpression ) )? ;
newExpression : NEW ( primitiveType newArrayConstruction | genericTypeArgumentListSimplified? qualifiedTypeIdentSimplified ( newArrayConstruction | arguments classBody?) ) ;
innerNewExpression : NEW genericTypeArgumentListSimplified? IDENT arguments classBody?;
newArrayConstruction : arrayDeclaratorList arrayInitializer | LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList? ;
arguments : LPAREN expressionList? RPAREN ;
literal : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | FLOATING_POINT_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | TRUE | FALSE | NULL ;
